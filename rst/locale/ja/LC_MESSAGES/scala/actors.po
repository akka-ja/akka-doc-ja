# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kazuki Negoro <negokaz@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/actors.rst:5
msgid "Actors"
msgstr "アクター"

#: ../../scala/actors.rst:8
msgid ""
"The `Actor Model`_ provides a higher level of abstraction for writing "
"concurrent and distributed systems. It alleviates the developer from having "
"to deal with explicit locking and thread management, making it easier to "
"write correct concurrent and parallel systems. Actors were defined in the "
"1973 paper by Carl Hewitt but have been popularized by the Erlang language, "
"and used for example at Ericsson with great success to build highly "
"concurrent and reliable telecom systems."
msgstr ""
"`アクターモデル`は並行分散システムを作るための高度な抽象を提供します。アクターモデルを用いることで開発者は明示的なロックやスレッドの管理を行う労力を軽減した上で信頼性のある並行並列なシステムを作ることができます。アクターは"
" Cal Herwitt が1973年に論文として発表したものですが、Erlangによって世に広められ、この成功例として Ericsson "
"社による高い並行性と信頼性を持つ電気通信システムの構築が挙げられます。"

#: ../../scala/actors.rst:16
msgid ""
"The API of Akka’s Actors is similar to Scala Actors which has borrowed some "
"of its syntax from Erlang."
msgstr "Akka のアクターは Erlang からシンタックスを拝借した Scala のアクターと似ています。"

#: ../../scala/actors.rst:23
msgid "Creating Actors"
msgstr "アクターの生成"

#: ../../scala/actors.rst:27
msgid ""
"Since Akka enforces parental supervision every actor is supervised and "
"(potentially) the supervisor of its children, it is advisable that you "
"familiarize yourself with :ref:`actor-systems` and :ref:`supervision` and it"
" may also help to read :ref:`addressing`."
msgstr ""
"Akka では全てのアクターが親となるアクターに監視され、同時に子供のアクターの supervisor "
"になる(可能性がある)という方式をとっています。この方式については :ref:`actor-systems` や :ref:`supervision` "
"あるいは :ref:`addressing` といった記事を参考に読んでみるとよいでしょう。"

#: ../../scala/actors.rst:33
msgid "Defining an Actor class"
msgstr "アクターのクラスを定義する"

#: ../../scala/actors.rst:35
msgid ""
"Actors are implemented by extending the :class:`Actor` base trait and "
"implementing the :meth:`receive` method. The :meth:`receive` method should "
"define a series of case statements (which has the type "
"``PartialFunction[Any, Unit]``) that defines which messages your Actor can "
"handle, using standard Scala pattern matching, along with the implementation"
" of how the messages should be processed."
msgstr ""
"アクターは :class:`Actor` "
"という基本traitを拡張することで実装することができます。また、ここで:meth:`receive`というメソッドを実装する必要があります。:meth:`receive`というメソッドはcase文の塊で(この型は`PartialFunction[Any,"
" "
"Unit]``です)、Scalaのパターンマッチングを使ってアクターがどのようなメッセージを処理できるかということとそのメッセージがどのように処理されるかということを定義します。"

#: ../../scala/actors.rst:41 ../../scala/actors.rst:532
msgid "Here is an example:"
msgstr "以下はこのサンプルコードです。"

#: ../../scala/actors.rst:46
msgid ""
"Please note that the Akka Actor ``receive`` message loop is exhaustive, "
"which is different compared to Erlang and the late Scala Actors. This means "
"that you need to provide a pattern match for all messages that it can accept"
" and if you want to be able to handle unknown messages then you need to have"
" a default case as in the example above. Otherwise an "
"``akka.actor.UnhandledMessage(message, sender, recipient)`` will be "
"published to the ``ActorSystem``'s ``EventStream``."
msgstr ""
"Akkaのアクターの``receive``メッセージループは網羅的であるということに注意してください。これはErlangやScala言語組み込みのアクターとは異なっています。つまり受け取ることのできる全てのメッセージについてのパターンマッチを書く必要があり、未知のメッセージを処理したい場合はデフォルトのcaseを書かなければいけません。これを行わなかった場合は"
" ``ActorSystem``の``EventStream``に`akka.actor.UnhandledMessage(message, "
"sender, recipient)``が発行されます。"

#: ../../scala/actors.rst:54
msgid ""
"Note further that the return type of the behavior defined above is ``Unit``;"
" if the actor shall reply to the received message then this must be done "
"explicitly as explained below."
msgstr ""
"また、振る舞いの戻り値の型が``Unit``であることにも注意してください。アクターが受け取ったメッセージに対して応答を返す場合、後で説明するようにこれを明示的に行う必要があります。"

#: ../../scala/actors.rst:58
msgid ""
"The result of the :meth:`receive` method is a partial function object, which"
" is stored within the actor as its “initial behavior”, see "
"`Become/Unbecome`_ for further information on changing the behavior of an "
"actor after its construction."
msgstr ""
":meth:`receive`メソッドの結果は部分関数であり、アクターの\"初期の振る舞い\"とみなされます。アクターが生成された後でどのように振る舞いを変えるかということについての詳しい情報は`Become/Unbecome`_を参照してください。"

#: ../../scala/actors.rst:64
msgid "Props"
msgstr "Props"

#: ../../scala/actors.rst:66
msgid ""
":class:`Props` is a configuration class to specify options for the creation "
"of actors, think of it as an immutable and thus freely shareable recipe for "
"creating an actor including associated deployment information (e.g. which "
"dispatcher to use, see more below). Here are some examples of how to create "
"a :class:`Props` instance."
msgstr ""
":class:`Propsはアクターを生成するときのオプションを指定するための設定クラスです。このクラスのインスタンスは不変なので気軽に共有することができるアクターを生成するためのレシピと考えることができます。また、このレシピにはデプロイに関係した情報(例えばどのdispatcherを使うかとかいったもの)も含めることができます。"

#: ../../scala/actors.rst:74
msgid ""
"The second variant shows how to pass constructor arguments to the "
":class:`Actor` being created, but it should only be used outside of actors "
"as explained below."
msgstr ""
"二つ目のやり方は生成する:class:`Actor`にどのように引数を渡すかということを例示していますが、後で説明するように、アクターの外側のみで用いるべきやり方です。"

#: ../../scala/actors.rst:78
msgid ""
"The last line shows a possibility to pass constructor arguments regardless "
"of the context it is being used in. The presence of a matching constructor "
"is verified during construction of the :class:`Props` object, resulting in "
"an :class:`IllegalArgumentException` if no or multiple matching constructors"
" are found."
msgstr ""
"最後のやり方はアクターのコンストラクタに引数を渡す場合にどのようなコンテクストでも使うことができるやり方です。Propsオブジェクトの中でどのコンストラクタを用いるべきかということを調べて、適当なコンストラクタが見つからなかった場合や複数のコンストラクタにマッチしてしまった場合には:class:`IllegalArgumentException`"
" となってしまいます。"

#: ../../scala/actors.rst:86
msgid ""
"The recommended approach to create the actor :class:`Props` is not supported"
" for cases when the actor constructor takes value classes as arguments."
msgstr ""
"アクターのコンストラクタが引数として値クラスを受け取る場合、アクターの:class:`Props`を作るための推奨される手法はサポートされていません。"

#: ../../scala/actors.rst:90
msgid "Dangerous Variants"
msgstr "危険な方法"

#: ../../scala/actors.rst:94
msgid ""
"This method is not recommended to be used within another actor because it "
"encourages to close over the enclosing scope, resulting in non-serializable "
":class:`Props` and possibly race conditions (breaking the actor "
"encapsulation). We will provide a macro-based solution in a future release "
"which allows similar syntax without the headaches, at which point this "
"variant will be properly deprecated. On the other hand using this variant in"
" a :class:`Props` factory in the actor’s companion object as documented "
"under “Recommended Practices” below is completely fine."
msgstr ""
"このメソッドはアクターの中で使わないほうがいいです。このメソッドによって呼び出し元のアクターのスコープをリークしてしまい、:class:`Props`が永続化不可になってしまい競合状態(アクターのカプセル化が壊されるということ)を引き起こす可能性があります。将来的にはマクロを使って同じようなシンタックスを使っても問題が起きないようにする予定ですが、現在のところこの方式は非推奨としたほうがいいでしょう。一方で、\"推奨される手法\"のところに書いてあるアクターのコンパニオンオブジェクトにある:class:`Props`のファクトリを使うというやり方は特に問題がありません。"

#: ../../scala/actors.rst:103
msgid ""
"There were two use-cases for these methods: passing constructor arguments to"
" the actor—which is solved by the newly introduced :meth:`Props.apply(clazz,"
" args)` method above or the recommended practice below—and creating actors "
"“on the spot” as anonymous classes. The latter should be solved by making "
"these actors named classes instead (if they are not declared within a top-"
"level ``object`` then the enclosing instance’s ``this`` reference needs to "
"be passed as the first argument)."
msgstr ""
"このメソッドを使うユースケースは二つあります。一つはアクターのコンストラクタに引数を渡したい場合ですが、これは新しくできた:meth:`Props.apply(clazz,"
" "
"args)`を上に書いてあるとおりに使うか下に書いてあるような推奨される手法を使うことで解決できます。もう一つは\"その場で\"無名のアクターを作る場合ですが、これはそのようなアクターにちゃんと名前を付けてあげることで解決できます。(アクターがトップレベルの``object``として宣言されていない場合、それに紐づくインスタンスの\"this\"の参照がクラスの最初の引数に渡されてしまいます)"

#: ../../scala/actors.rst:113
msgid ""
"Declaring one actor within another is very dangerous and breaks actor "
"encapsulation. Never pass an actor’s ``this`` reference into :class:`Props`!"
msgstr ""
"あるアクターを別のアクターの中で宣言することは非常に危険でアクターのカプセル化を破壊してしまいます。アクターの\"this\"への参照を:class:`Props`に渡してしまわないように注意してください。"

#: ../../scala/actors.rst:117
msgid "Edge cases"
msgstr "エッジケース"

#: ../../scala/actors.rst:118
msgid "There are two edge cases in actor creation with :class:`Props`:"
msgstr ":class:`Props`を使ったアクターの生成には二つのエッジケースがあります。"

#: ../../scala/actors.rst:120
msgid "An actor with :class:`AnyVal` arguments."
msgstr "引数に:class:`AnyVal`を受け取るアクター"

#: ../../scala/actors.rst:125
msgid "An actor with default constructor values."
msgstr "デフォルトのコンストラクタ引数を持つアクター"

#: ../../scala/actors.rst:129
msgid ""
"In both cases an :class:`IllegalArgumentException` will be thrown stating no"
" matching constructor could be found."
msgstr ""
"どちらのケースもコンストラクターを見つけられない状態になってしまって :class:`IllegalArgumentException` "
"がスローされます。"

#: ../../scala/actors.rst:132
msgid ""
"The next section explains the recommended ways to create :class:`Actor` "
"props in a way, which simultaneously safe-guards against these edge cases."
msgstr ""
"次のセクションでは:class:`Actor`のpropを作るための推奨される手法を説明します。同時にこの手法はこれらのエッジケースに対する回避策になります。"

#: ../../scala/actors.rst:136
msgid "Recommended Practices"
msgstr "推奨される手法"

#: ../../scala/actors.rst:138
msgid ""
"It is a good idea to provide factory methods on the companion object of each"
" :class:`Actor` which help keeping the creation of suitable :class:`Props` "
"as close to the actor definition as possible. This also avoids the pitfalls "
"associated with using the ``Props.apply(...)`` method which takes a by-name "
"argument, since within a companion object the given code block will not "
"retain a reference to its enclosing scope:"
msgstr ""
"全ての:class:`Actor`のコンパニオンオブジェクトの中で:class:`Props`の生成を適切に行うことを補助するようなファクトリメソッドを提供するのは良いアイディアです"
"。コンパニオンオブジェクトの中のコードブロックはcall-by-"
"nameなメソッド引数の中にリークしないので、こうしたファクトリメソッドを使えば``Props.apply(...)``を使うことによる落とし穴に嵌ることを避けることができます。"

#: ../../scala/actors.rst:147
msgid ""
"Another good practice is to declare what messages an Actor can receive in "
"the companion object of the Actor, which makes easier to know what it can "
"receive:"
msgstr ""
"もう一つの良い手法として、コンパニオンオブジェクトの中でそのアクターが受け取ることができるメッセージを宣言するというものがあります。このようにしておくと、アクターがどのようなメッセージを受け取ることができるのかがわかりやすくなります。"

#: ../../scala/actors.rst:154
msgid "Creating Actors with Props"
msgstr "Propsを使ったアクターの生成"

#: ../../scala/actors.rst:156
msgid ""
"Actors are created by passing a :class:`Props` instance into the "
":meth:`actorOf` factory method which is available on :class:`ActorSystem` "
"and :class:`ActorContext`."
msgstr ""
"アクターは:class:`Props`のインスタンスを:class:`ActorSystem`や:class:`ActorContext`が持っている:meth:`actorOf`というファクトリメソッドに渡すことで生成できます。"

#: ../../scala/actors.rst:162
msgid ""
"Using the :class:`ActorSystem` will create top-level actors, supervised by "
"the actor system’s provided guardian actor, while using an actor’s context "
"will create a child actor."
msgstr ""
":class:`ActorSystem`を使うとトップレベルのアクターを生成できます。トップレベルのアクターはアクターシステムが提供しているガーディアンアクターによって監視されます。一方でコンテクストから生成したアクターはそのアクターの子アクターになります。"

#: ../../scala/actors.rst:169
msgid ""
"It is recommended to create a hierarchy of children, grand-children and so "
"on such that it fits the logical failure-handling structure of the "
"application, see :ref:`actor-systems`."
msgstr ""
"子供から孫といった階層を作るようにしてください。そのようにすることでアプリケーションの論理的なエラー処理の構造を作ることができます。詳しくは:ref"
":`actor-systems`を参照してください。"

#: ../../scala/actors.rst:173
msgid ""
"The call to :meth:`actorOf` returns an instance of :class:`ActorRef`. This "
"is a handle to the actor instance and the only way to interact with it. The "
":class:`ActorRef` is immutable and has a one to one relationship with the "
"Actor it represents. The :class:`ActorRef` is also serializable and network-"
"aware. This means that you can serialize it, send it over the wire and use "
"it on a remote host and it will still be representing the same Actor on the "
"original node, across the network."
msgstr ""
":meth:`actorOf`を呼ぶことで:class:`ActorRef`のインスタンスを得ることができます。:class:`ActorRef`はアクターのインスタンスとつながっていて、アクターと対話するための唯一の手段となります。:class:`ActorRef`は不変でそれが表現しているアクターと一対一の関係を持っています。:class:`ActorRef`は永続化可能なのでネットワークを介することができます。つまり、シリアライズしたインスタンスをリモートのホストに送信した場合、元のノードのアクターをネットワークを超えて表現することができます。"

#: ../../scala/actors.rst:181
msgid ""
"The name parameter is optional, but you should preferably name your actors, "
"since that is used in log messages and for identifying actors. The name must"
" not be empty or start with ``$``, but it may contain URL encoded characters"
" (eg. ``%20`` for a blank space).  If the given name is already in use by "
"another child to the same parent an :class:`InvalidActorNameException` is "
"thrown."
msgstr ""
"nameパラメータはオプションですがアクターには名前を与えた方がよいでしょう。なぜなら、アクターの名前はログメッセージでアクターを識別するために用いるからです。アクターの名前は空文字や\"$\"から始まる文字列は許可されていませんが、そうした名前がURLにエンコードされた文字には含まれることがあります。(例えば、\"%20\"は空白文字です。)もじ与えられた名前が既に同じ親を持つ他の子アクターが利用していた場合、:class:`InvalidActorNameException`がスローされます。"

#: ../../scala/actors.rst:187
msgid "Actors are automatically started asynchronously when created."
msgstr "アクターは生成されたら非同期に自動的に開始されます。"

#: ../../scala/actors.rst:190
msgid "Value classes as constructor arguments"
msgstr "コンストラクタ引数の値クラス"

#: ../../scala/actors.rst:192
msgid ""
"The recommended way to instantiate actor props uses reflection at runtime to"
" determine the correct actor constructor to be invoked and due to technical "
"limitations is not supported when said constructor takes arguments that are "
"value classes. In these cases you should either unpack the arguments or "
"create the props by calling the constructor manually:"
msgstr ""
"アクターのpropsのインスタンスを得るための推奨される方法ではアクターのどのコンストラクタを呼ぶのが正しいのかを調べるためにリフレクションを使っています。この技術的な制限のため、値クラスを引き数として受け取るコンストラクタの利用はサポートされていません。こういったケースでは値クラスの中の値をあらかじめ取り出しておくかコンストラクタを直接呼び出すようなpropsを作る必要があります。"

#: ../../scala/actors.rst:202
msgid "Dependency Injection"
msgstr "依存性の注入"

#: ../../scala/actors.rst:204
msgid ""
"If your Actor has a constructor that takes parameters then those need to be "
"part of the :class:`Props` as well, as described `above`__. But there are "
"cases when a factory method must be used, for example when the actual "
"constructor arguments are determined by a dependency injection framework."
msgstr ""
"アクターがコンストラクタで引数を受け取る場合、`すでに述べたように`__それは:class:`Props`の生成の中で利用する必要があります。しかし、ファクトリメソッドを用意していたとしても直接コンストラクタを使うケースがあります。例えば依存性の注入を行うフレームワークがコンストラクタの引数を調べる場合です。"

#: ../../scala/actors.rst:217
msgid ""
"You might be tempted at times to offer an :class:`IndirectActorProducer` "
"which always returns the same instance, e.g. by using a ``lazy val``. This "
"is not supported, as it goes against the meaning of an actor restart, which "
"is described here: :ref:`supervision-restart`."
msgstr ""
":class:`IndirectActorProducer`が必要な時に``lazy "
"val``などを使って常に同じインスタンスを得たいと思うかもしれません。しかし、同じアクターのインスタンスを使いまわすということはは:ref"
":`supervision-restart`で述べてるようなアクターの再起動といった概念と衝突するためサポートされていません。"

#: ../../scala/actors.rst:222
msgid ""
"When using a dependency injection framework, actor beans *MUST NOT* have "
"singleton scope."
msgstr "依存性の注入を行うフレームワークを使う場合、アクターのbeanはシングルトンスコープであることは*許可されません*。"

#: ../../scala/actors.rst:225
msgid ""
"Techniques for dependency injection and integration with dependency "
"injection frameworks are described in more depth in the `Using Akka with "
"Dependency Injection <http://letitcrash.com/post/55958814293/akka-"
"dependency-injection>`_ guideline and the `Akka Java Spring "
"<http://www.lightbend.com/activator/template/akka-java-spring>`_ tutorial in"
" Lightbend Activator."
msgstr ""
"依存性の注入のためのテクニックや依存性注入を行うフレームワークとの統合については`Using Akka with Dependency "
"Injection  <http://letitcrash.com/post/55958814293/akka-dependency-"
"injection>`_ guidelineやLightbend Activatorの中の`Akka Java Spring "
"<http://www.lightbend.com/activator/template/akka-java-spring>`_ "
"tutorialにより詳しい情報があります。"

#: ../../scala/actors.rst:232
msgid "The Inbox"
msgstr "Inbox"

#: ../../scala/actors.rst:234
msgid ""
"When writing code outside of actors which shall communicate with actors, the"
" ``ask`` pattern can be a solution (see below), but there are two things it "
"cannot do: receiving multiple replies (e.g. by subscribing an "
":class:`ActorRef` to a notification service) and watching other actors’ "
"lifecycle. For these purposes there is the :class:`Inbox` class:"
msgstr ""
"アクターの外側のコードからアクターと通信をする場合、``ask``パターン(後で出てきます)を使うのが一つの方法ですが、それを使えない場合が二つあります。一つは複数のメッセージを受け取るような場合(例えば通知サービスとして実装されている:class:`ActorRef`を購読する場合)で、もう一つはActorのライフサイクルをwatchしている場合です。こういった場合のために:class:`Inbox`というクラスが用意されています。"

#: ../../scala/actors.rst:242
msgid ""
"There is an implicit conversion from inbox to actor reference which means "
"that in this example the sender reference will be that of the actor hidden "
"away within the inbox. This allows the reply to be received on the last "
"line. Watching an actor is quite simple as well:"
msgstr ""
"このコードでは:class:`Inbox`から:class:`Inbox`への暗黙的な変換が行われています。つまりこの例ではsenderへの参照は暗黙的に:class:`Inbox`に対するものになります。このようにすることで最後の行に書かれているようなやり方で応答を受け取ることができます。アクターをwatchする方法も簡単です。"

#: ../../scala/actors.rst:250
msgid "Actor API"
msgstr "Actor API"

#: ../../scala/actors.rst:252
msgid ""
"The :class:`Actor` trait defines only one abstract method, the above "
"mentioned :meth:`receive`, which implements the behavior of the actor."
msgstr ""
":class:`Actor` "
"traitには、抽象メソッドが一つしか定義されていません。それはすでに述べた:meth:`receive`メソッドで、アクターの振る舞いを実装するメソッドです。"

#: ../../scala/actors.rst:255
msgid ""
"If the current actor behavior does not match a received message, "
":meth:`unhandled` is called, which by default publishes an "
"``akka.actor.UnhandledMessage(message, sender, recipient)`` on the actor "
"system’s event stream (set configuration item ``akka.actor.debug.unhandled``"
" to ``on`` to have them converted into actual Debug messages)."
msgstr ""
"現在のアクターの振る舞いが受け取ったメッセージを処理できない場合、:meth:`unhandled`が呼ばれ、そのデフォルトの実装では``akka.actor.UnhandledMessage(message,"
" sender, "
"recipient)``をアクターシステムのイベントストリームに発行します(これは``akka.actor.debug.unhandled``という設定を``on``にすることで実際のデバッグのメッセージに変換されます)。"

#: ../../scala/actors.rst:262
msgid "In addition, it offers:"
msgstr ":class:`Actor` traitには他にも以下のようなメソッドがあります。"

#: ../../scala/actors.rst:264
msgid ":obj:`self` reference to the :class:`ActorRef` of the actor"
msgstr ":obj:`self` このアクター自身の:class:`ActorRef`への参照"

#: ../../scala/actors.rst:266
msgid ""
":obj:`sender` reference sender Actor of the last received message, typically"
" used as described in :ref:`Actor.Reply`"
msgstr ""
":obj:`sender` "
"最後に受け取ったメッセージの送信者となるActorへの参照。通常:ref:`Actor.Reply`で述べているような用途で使います。"

#: ../../scala/actors.rst:268
msgid ""
":obj:`supervisorStrategy` user overridable definition the strategy to use "
"for supervising child actors"
msgstr ":obj:`supervisorStrategy` ユーザがオーバーライド可能な子アクターをどう監視するかというストラテジーの定義"

#: ../../scala/actors.rst:270
msgid ""
"This strategy is typically declared inside the actor in order to have access"
" to the actor’s internal state within the decider function: since failure is"
" communicated as a message sent to the supervisor and processed like other "
"messages (albeit outside of the normal behavior), all values and variables "
"within the actor are available, as is the ``sender`` reference (which will "
"be the immediate child reporting the failure; if the original failure "
"occurred within a distant descendant it is still reported one level up at a "
"time)."
msgstr ""
"このストラテジーは戦略を決めるための関数の中でアクターの内部状態にアクセスするため、通常アクターの中で宣言します。障害は supervisor "
"にメッセージとして通知され、他のメッセージと同じように処理されます。(通常の振る舞いの外側に置かれるものの)この関数の中ではアクター内部の全ての値や変数、\"sender\"への参照を利用することができます。(これは直接の子アクターが報告した障害の情報に含まれます。元となる障害が孫以上の子孫の場合でも障害が起きた階層の"
" sender が報告されます。)"

#: ../../scala/actors.rst:279
msgid ""
":obj:`context` exposes contextual information for the actor and the current "
"message, such as:"
msgstr ":obj:`context` アクターや現在のメッセージに関するコンテクスト情報を参照できます。これには以下のようなものがあります。"

#: ../../scala/actors.rst:281
msgid "factory methods to create child actors (:meth:`actorOf`)"
msgstr "子アクターを作るためのファクトリメソッド(:meth:`actorOf`)"

#: ../../scala/actors.rst:282
msgid "system that the actor belongs to"
msgstr "アクターが所属しているシステム"

#: ../../scala/actors.rst:283
msgid "parent supervisor"
msgstr "supervisorである親アクター"

#: ../../scala/actors.rst:284
msgid "supervised children"
msgstr "監視している子アクター"

#: ../../scala/actors.rst:285
msgid "lifecycle monitoring"
msgstr "ライフサイクルの監視"

#: ../../scala/actors.rst:286
msgid "hotswap behavior stack as described in :ref:`Actor.HotSwap`"
msgstr ":ref:`Actor.Hotswap`に書かれている動的に置き換え可能な振る舞いのスタック"

#: ../../scala/actors.rst:288
msgid ""
"You can import the members in the :obj:`context` to avoid prefixing access "
"with ``context.``"
msgstr ""
":obj:`context`のメンバーをimportすることで\"context\"というプレフィックスなしにそのメンバにアクセスすることができます。"

#: ../../scala/actors.rst:292
msgid ""
"The remaining visible methods are user-overridable life-cycle hooks which "
"are described in the following:"
msgstr ""
"ここまででまだ残っているアクセス可能なメソッドはユーザがオーバーライドすることで以下の述べるアクターのライフサイクルにフックすることができるメソッドです。"

#: ../../scala/actors.rst:297
msgid ""
"The implementations shown above are the defaults provided by the "
":class:`Actor` trait."
msgstr "ここまでに紹介した実装は:class:`Actor` traitを使うことでデフォルトで利用できます。"

#: ../../scala/actors.rst:303
msgid "Actor Lifecycle"
msgstr "アクターのライフサクル"

#: ../../scala/actors.rst:309
msgid ""
"A path in an actor system represents a \"place\" which might be occupied by "
"a living actor. Initially (apart from system initialized actors) a path is "
"empty. When ``actorOf()`` is called it assigns an *incarnation* of the actor"
" described by the passed ``Props`` to the given path. An actor incarnation "
"is identified by the path *and a UID*. A restart only swaps the ``Actor`` "
"instance defined by the ``Props`` but the incarnation and hence the UID "
"remains the same."
msgstr ""
"アクターシステムにおけるパスは生存しているアクターによって占有されている\"場所\"を表現しています。始めは(システムによって初期化されたアクターを除き)パスは空になっています。"
" ``actorOf()`` を呼びだすと ``Prop`` "
"で表現されたアクターの*インカーネーション*が与えられたパスに生成されます。アクターのインカーネーションはパスと *UID* "
"によって識別されます。再起動が行われたときには ``Actor`` のインスタンスは置き換えられますが、インカーネーションの方は置き換えられないので "
"UID は同じものになります。"

#: ../../scala/actors.rst:317
msgid ""
"The lifecycle of an incarnation ends when the actor is stopped. At that "
"point the appropriate lifecycle events are called and watching actors are "
"notified of the termination. After the incarnation is stopped, the path can "
"be reused again by creating an actor with ``actorOf()``. In this case the "
"name of the new incarnation will be the same as the previous one but the "
"UIDs will differ. An actor can be stopped by the actor itself, another actor"
" or the ``ActorSystem`` (see :ref:`stopping-actors-scala`)."
msgstr ""
"アクターのインカーネーションのライフサイクルはアクターが停止した時に終わります。この時、これに対応したライフサイクルの終了イベントが呼ばれ、これを "
"watch しているアクターに停止が通知されます。インカーネーションが停止したのち、インカーネーションのパスは再び ``actorOf()`` "
"を使って再利用することができるようになります。この場合新しいインカーネーションの名前は前のものと同じですがUIDは別のものになります。アクターは自分自身や他のアクター、あるいは``ActorSystem``によって停止されることがあります。(:ref"
":`stopping-actors-scala`を参照)"

#: ../../scala/actors.rst:327
msgid ""
"It is important to note that Actors do not stop automatically when no longer"
" referenced, every Actor that is created must also explicitly be destroyed. "
"The only simplification is that stopping a parent Actor will also "
"recursively stop all the child Actors that this parent has created."
msgstr ""
"アクターは参照されなくなったとしても自動的に停止することはないという点は重要です。生成された全てのアクターは明示的に破棄する必要があります。ただし親のアクターを停止する場合、そのアクターが生成した全ての子供のアクターも停止されるのでこの点は単純です。"

#: ../../scala/actors.rst:332
msgid ""
"An ``ActorRef`` always represents an incarnation (path and UID) not just a "
"given path. Therefore if an actor is stopped and a new one with the same "
"name is created an ``ActorRef`` of the old incarnation will not point to the"
" new one."
msgstr ""
"``ActorRef``はただ単に与えられたパスを表現しているのではなくいつでもインカーネーション(パスとUID)を表現しています。つまりアクターを停止して同じ名前のアクターを生成した場合、新しく生成した``ActorRef``は古いインカーネーションでなく新しいインカーネーションを指しています。"

#: ../../scala/actors.rst:337
msgid ""
"``ActorSelection`` on the other hand points to the path (or multiple paths "
"if wildcards are used) and is completely oblivious to which incarnation is "
"currently occupying it. ``ActorSelection`` cannot be watched for this "
"reason. It is possible to resolve the current incarnation's ``ActorRef`` "
"living under the path by sending an ``Identify`` message to the "
"``ActorSelection`` which will be replied to with an ``ActorIdentity`` "
"containing the correct reference (see :ref:`actorSelection-scala`). This can"
" also be done with the ``resolveOne`` method of the :class:`ActorSelection`,"
" which returns a ``Future`` of the matching :class:`ActorRef`."
msgstr ""
"一方で ``ActorSelection`` "
"はパスを示していて(ワイルドカードを使った場合は複数のパスを指します。)、現在そのパスを持っているのがどのインカーネーションなのかを完全に識別することができます。このため"
" ``ActorSelection`` を watch することはできません。パスに存在するインカーネーションを watch "
"するためには、``ActorSelection`` に対して ``Identity`` メッセージを送信し ``ActorSelection`` "
"から応答として ``ActorIdentity`` を受け取り、その中に含まれる正しい参照(:ref:`actorSelection-"
"scala`を参照)を使って現在のインカーネーションの ``ActorRef`` を解決します。 ``ActorSelection`` が持つ "
"``resolveOne`` を使うとパスにマッチした ``ActorRef`` の ``Future`` が戻されるので同じようなことができます。"

#: ../../scala/actors.rst:350
msgid "Lifecycle Monitoring aka DeathWatch"
msgstr "ライフサイクルの監視、DeathWatch"

#: ../../scala/actors.rst:352
msgid ""
"In order to be notified when another actor terminates (i.e. stops "
"permanently, not temporary failure and restart), an actor may register "
"itself for reception of the :class:`Terminated` message dispatched by the "
"other actor upon termination (see `Stopping Actors`_). This service is "
"provided by the :class:`DeathWatch` component of the actor system."
msgstr ""
"他のアクターの停止を知るために(例えば、永久に停止された場合や一時的ではない障害によって再起動された場合など)、アクターは他のアクターが停止時に発する "
":class:`Terminated` メッセージを受け取るようにすることができます。(`Stopping "
"Actors`_も参照のこと)この機能はアクターシステムの :class:`DeathWatch` というコンポーネントによって提供されています。"

#: ../../scala/actors.rst:358
msgid "Registering a monitor is easy:"
msgstr "モニターを登録するのは簡単です。"

#: ../../scala/actors.rst:362
msgid ""
"It should be noted that the :class:`Terminated` message is generated "
"independent of the order in which registration and termination occur. In "
"particular, the watching actor will receive a :class:`Terminated` message "
"even if the watched actor has already been terminated at the time of "
"registration."
msgstr ""
":class:`Terminated` "
"メッセージは登録や停止がどのような順番で起きたかとは独立して生成されることに注意してください。典型的な例として、監視を行うアクターは例え監視の登録を行った時点ですでに監視対象のアクターが停止されていたとしても"
" :class:`Treminated` メッセージを受け取ることになります。"

#: ../../scala/actors.rst:367
msgid ""
"Registering multiple times does not necessarily lead to multiple messages "
"being generated, but there is no guarantee that only exactly one such "
"message is received: if termination of the watched actor has generated and "
"queued the message, and another registration is done before this message has"
" been processed, then a second message will be queued, because registering "
"for monitoring of an already terminated actor leads to the immediate "
"generation of the :class:`Terminated` message."
msgstr ""
"監視の登録を複数回行うことが必ずしも複数のメッセージを作ることになるわけではありませんが、こうしたメッセージを正確に一度受け取ることができる保障はありません。監視対象のアクターの停止メッセージが作られてキューに入ってから、このメッセージが処理される前に他のところで登録が行われたら、二つ目のメッセージがキューに入ります。何故なら既に停止したアクターの監視を登録すると、直ちに:"
" class:`Terminated` が生成されるためです。"

#: ../../scala/actors.rst:375
msgid ""
"It is also possible to deregister from watching another actor’s liveliness "
"using ``context.unwatch(target)``. This works even if the "
":class:`Terminated` message has already been enqueued in the mailbox; after "
"calling :meth:`unwatch` no :class:`Terminated` message for that actor will "
"be processed anymore."
msgstr ""
"同じようなことが他のアクターの生存監視を ``context.unwatch(target)`` を使ってやめた場合にも起こりえます。これは例え "
":class:`Terminated` "
"メッセージがメールボックスに入っていたとしても、:meth:`unwatch`の呼び出しの後には監視を停止したアクターの "
":class:`Terminated` メッセージは処理されないためです。"

#: ../../scala/actors.rst:383
msgid "Start Hook"
msgstr "Start Hook"

#: ../../scala/actors.rst:385
msgid ""
"Right after starting the actor, its :meth:`preStart` method is invoked."
msgstr "アクターが正しく起動すると、 :meth:`preStart` というメソッドが呼び出されます。"

#: ../../scala/actors.rst:389
msgid ""
"This method is called when the actor is first created. During restarts it is"
" called by the default implementation of :meth:`postRestart`, which means "
"that by overriding that method you can choose whether the initialization "
"code in this method is called only exactly once for this actor or for every "
"restart. Initialization code which is part of the actor’s constructor will "
"always be called when an instance of the actor class is created, which "
"happens at every restart."
msgstr ""
"このメソッドはアクタがーが初めに生成されたときに呼び出されます。アクターが再起動したときには :meth:`postRestart` "
"のデフォルトの実装がこのメソッドの呼び出しを行いますが、このメソッドをオーバーライドすることによって初期化のコードを一度だけ呼び出されるようにするのか、再起動のたびに呼び出されるようにするのかを選択することができます。アクターのコンストラクタの中の初期化コードはアクターが生成された時や再起動したときに常に呼び出されます。"

#: ../../scala/actors.rst:400
msgid "Restart Hooks"
msgstr "Restart Hook"

#: ../../scala/actors.rst:402
msgid ""
"All actors are supervised, i.e. linked to another actor with a fault "
"handling strategy. Actors may be restarted in case an exception is thrown "
"while processing a message (see :ref:`supervision`). This restart involves "
"the hooks mentioned above:"
msgstr ""
"全てのアクターは、例えば他のアクターによるエラー処理のストラテジーに紐づくことによって監視されています。アクターがメッセージを処理しているときに例外をスローした場合は再起動が行われます。(:ref:`supervision`"
" を参照)この再起動は上記に挙げたフック処理のトリガになります。"

#: ../../scala/actors.rst:407
msgid ""
"The old actor is informed by calling :meth:`preRestart` with the exception "
"which caused the restart and the message which triggered that exception; the"
" latter may be ``None`` if the restart was not caused by processing a "
"message, e.g. when a supervisor does not trap the exception and is restarted"
" in turn by its supervisor, or if an actor is restarted due to a sibling’s "
"failure. If the message is available, then that message’s sender is also "
"accessible in the usual way (i.e. by calling ``sender``)."
msgstr ""
"古いアクターには :meth:`preRestart` "
"の中で再起動の原因となった例外と例外を引き起こしたメッセージが通知されます。後者のメッセージは、例えばsupervisorが例外を補足せずにそれより上位のsupervisorに再起動された場合やアクターが兄弟関係にあるアクターの障害によって再起動された場合など、再起動の原因となったのがメッセージの処理ではない場合には"
"　``None`` "
"が受け渡されます。メッセージが受け渡された場合には、メッセージのsenderもいつもと同じやり方で取得することができます。(これは、``sender``の呼び出しを行うことでできます)"

#: ../../scala/actors.rst:415
msgid ""
"This method is the best place for cleaning up, preparing hand-over to the "
"fresh actor instance, etc.  By default it stops all children and calls "
":meth:`postStop`."
msgstr ""
"このメソッドは新しいアクターのインスタンスなどへの引き継ぎのためにクリーンアップを行うのにもっともよい場所です。デフォルトの実装では全ての子アクターを停止して"
" :meth:`postStop` を呼び出すようになっています。"

#: ../../scala/actors.rst:419
msgid ""
"The initial factory from the ``actorOf`` call is used to produce the fresh "
"instance."
msgstr "新しいインスタンスを生成するために :meth:`actorOf` の呼び出し時から引き継いだ初期化のファクトリを利用します。"

#: ../../scala/actors.rst:422
msgid ""
"The new actor’s :meth:`postRestart` method is invoked with the exception "
"which caused the restart. By default the :meth:`preStart` is called, just as"
" in the normal start-up case."
msgstr ""
"新しく生成したアクターの :meth:`postRestart` に再起動の原因となった例外を受け渡して呼び出します。デフォルトの実装では "
":meth:`preStart` の呼び出しを行って通常のアクターの開始と同じように振る舞います。"

#: ../../scala/actors.rst:426
msgid ""
"An actor restart replaces only the actual actor object; the contents of the "
"mailbox is unaffected by the restart, so processing of messages will resume "
"after the :meth:`postRestart` hook returns. The message that triggered the "
"exception will not be received again. Any message sent to an actor while it "
"is being restarted will be queued to its mailbox as usual."
msgstr ""
"アクターの再起動では実際のアクターのオブジェクトが入れ替わるだけです。再起動がメールボックの内容に影響を及ぼすことはないので、メッセージの処理は "
":metho:`postRestart` "
"の処理が終わった後に再開されます。例外の原因となったメッセージを再び受け取ることはありません。再起動中にアクターが受け取ったメッセージは通常メールボックスには入りません。"

#: ../../scala/actors.rst:435
msgid ""
"Be aware that the ordering of failure notifications relative to user "
"messages is not deterministic. In particular, a parent might restart its "
"child before it has processed the last messages sent by the child before the"
" failure. See :ref:`message-ordering` for details."
msgstr ""
"障害の通知とユーザのメッセージの相対的な順番が決定的ではないことに注意してください。特に、親のアクターによって子アクターが障害が起きる前に受け取った最後のメッセージを処理する前に再起動してしまうことがあります。詳細については"
" :ref:`message-ordering` を参照してください。"

#: ../../scala/actors.rst:443
msgid "Stop Hook"
msgstr "Stop Hook"

#: ../../scala/actors.rst:445
msgid ""
"After stopping an actor, its :meth:`postStop` hook is called, which may be "
"used e.g. for deregistering this actor from other services. This hook is "
"guaranteed to run after message queuing has been disabled for this actor, "
"i.e. messages sent to a stopped actor will be redirected to the "
":obj:`deadLetters` of the :obj:`ActorSystem`."
msgstr ""
"アクターが停止した後には、そのアクターの :meth:`postStop` "
"フックが呼び出されるので、これを使って他のサービスからこのアクターを登録解除するといった処理を行うようにします。ここのフックはこのアクターに対するメッセージのキューイングが利用できなくなってから呼び出されることが保障されています。停止されたアクターに送信したメッセージは"
" :obj:`ActorSystem` の :obj:`deadLetters` にリダイレクトされるようになります。"

#: ../../scala/actors.rst:454
msgid "Identifying Actors via Actor Selection"
msgstr "Actor Selectionを使ったアクターの識別"

#: ../../scala/actors.rst:456
msgid ""
"As described in :ref:`addressing`, each actor has a unique logical path, "
"which is obtained by following the chain of actors from child to parent "
"until reaching the root of the actor system, and it has a physical path, "
"which may differ if the supervision chain includes any remote supervisors. "
"These paths are used by the system to look up actors, e.g. when a remote "
"message is received and the recipient is searched, but they are also useful "
"more directly: actors may look up other actors by specifying absolute or "
"relative paths—logical or physical—and receive back an "
":class:`ActorSelection` with the result:"
msgstr ""
":ref:`addressing` "
"で述べたように、アクターはそれぞれ一意な論理パスを持っていて、子供から親を辿ってアクターシステムのルートにまで遡ることができることができます。また、アクターは物理的なパスも持っていますが、監視のチェーンの中にリモートのsupervisorが存在する場合には論理的なパスと異なることがあります。これらのパスはリモートからメッセージを受け取った時に受信者を検索するのに利用されたりしますが、もっと直接的な利点があります。アクターは絶対パスもしくは相対パスを"
"--これらは論理的なものと物理的なものがあります--を使ってほかのアクターを検索し :class:`ActorSelection` "
"を使ってその結果を受け取ることができます。"

#: ../../scala/actors.rst:470
msgid ""
"It is always preferable to communicate with other Actors using their "
"ActorRef instead of relying upon ActorSelection. Exceptions are"
msgstr "通常、アクターの通信はActorSelectionに頼らずにActorRefを使う方が望ましいです。ただし、次の場合は例外です。"

#: ../../scala/actors.rst:473
msgid ""
"sending messages using the :ref:`at-least-once-delivery-scala` facility"
msgstr "メッセージを送信するのに :ref:`at-least-once-delivery-scala` の手法を用いる場合"

#: ../../scala/actors.rst:474
msgid "initiating first contact with a remote system"
msgstr "リモートシステムとの始めの通信を行う場合"

#: ../../scala/actors.rst:476
msgid ""
"In all other cases ActorRefs can be provided during Actor creation or "
"initialization, passing them from parent to child or introducing Actors by "
"sending their ActorRefs to other Actors within messages."
msgstr ""
"上記以外のケースでは、親から子にActorRefを渡したり、ActorRefへの参照を含メッセージを他のアクターに送信するなど、アクターの生成時や初期化時にActorRefを受け渡す方法があります。"

#: ../../scala/actors.rst:480
msgid ""
"The supplied path is parsed as a :class:`java.net.URI`, which basically "
"means that it is split on ``/`` into path elements. If the path starts with "
"``/``, it is absolute and the look-up starts at the root guardian (which is "
"the parent of ``\"/user\"``); otherwise it starts at the current actor. If a"
" path element equals ``..``, the look-up will take a step “up” towards the "
"supervisor of the currently traversed actor, otherwise it will step “down” "
"to the named child. It should be noted that the ``..`` in actor paths here "
"always means the logical structure, i.e. the supervisor."
msgstr ""
"与えられたパスは :class:`java.net.URI` に解決されます。つまり基本的にパスは\"/\"で区切られたパスの要素からなります。パスが "
"`\"/\"` から始まる場合はルートガーディアンから辿ることのできる絶対パスになります。(ルートガーディアンは　`\"/user\"` の親です。) "
"それ以外の場合は現在のアクターから辿るパスになります。パスの要素が ``..`` "
"となっている場合はその前のパスで解決されたアクターのsupervisorのパスへと\"戻り\"、そこからその子アクターを\"辿り\"ます。 ``..``"
" というアクターのパスが表現しているのがいつも論理的な構造でsupervisorを表しているということには注意が必要です。"

#: ../../scala/actors.rst:489
msgid ""
"The path elements of an actor selection may contain wildcard patterns "
"allowing for broadcasting of messages to that section:"
msgstr "アクターを選択するするパス要素には選択されたアクターにメッセージをブロードキャストするためにワイルドカードを指定することができます。"

#: ../../scala/actors.rst:494
msgid ""
"Messages can be sent via the :class:`ActorSelection` and the path of the "
":class:`ActorSelection` is looked up when delivering each message. If the "
"selection does not match any actors the message will be dropped."
msgstr ""
"メッセージは :class:`ActorSelection` を使っても送ることができます。 :class:`ActorSelection` "
"のパスは配信するメッセージごとに探索が行われます。 アクターを探索結果として得られなかった場合はメッセージは破棄されます。"

#: ../../scala/actors.rst:498
msgid ""
"To acquire an :class:`ActorRef` for an :class:`ActorSelection` you need to "
"send a message to the selection and use the ``sender()`` reference of the "
"reply from the actor. There is a built-in ``Identify`` message that all "
"Actors will understand and automatically reply to with a ``ActorIdentity`` "
"message containing the :class:`ActorRef`. This message is handled specially "
"by the actors which are traversed in the sense that if a concrete name "
"lookup fails (i.e. a non-wildcard path element does not correspond to a live"
" actor) then a negative result is generated. Please note that this does not "
"mean that delivery of that reply is guaranteed, it still is a normal "
"message."
msgstr ""
":class:`ActorSelection` に対応する :class:`ActorRef` "
"を取得するためには、selectionに対してメッセージを送信し、　アクターから応答を受け取るために ``sender()`` "
"の参照を利用してください。全てのアクターは組み込みの ``Identify`` というメッセージを理解して、 :class:`ActorRef` "
"への参照を含む ``ActorIdentity`` "
"というメッセージを自動的に応答として返します。このメッセージはアクターによって特別な処理が行われ、具体的な名前による探索が失敗した場合(例えば、ワイルドカードではないパス要素が生存しているアクターと対応していなかった場合)には、偽の結果が生成されます。このことは応答メッセージの到達が保障されていることを意味していないことに注意してください。応答も通常のメッセージです。"

#: ../../scala/actors.rst:510
msgid ""
"You can also acquire an :class:`ActorRef` for an :class:`ActorSelection` "
"with the ``resolveOne`` method of the :class:`ActorSelection`. It returns a "
"``Future`` of the matching :class:`ActorRef` if such an actor exists. It is "
"completed with failure [[akka.actor.ActorNotFound]] if no such actor exists "
"or the identification didn't complete within the supplied `timeout`."
msgstr ""
":clas:`ActorSelection` の ``resolveOne`` というメソッドを使うことによっても "
":class:`ActorSelection` に対応する :class:`ActorRef` "
"を取得することができます。このメソッドは指定したアクターが存在した場合に該当する :class:`ActorRef` を ``Future`` "
"として返します。指定したアクターが存在しない場合や ``timeout`` で指定した時間内に解決が完了しなかった場合には "
"[[akka.actor.ActorNotFound]]が失敗として戻されます。"

#: ../../scala/actors.rst:516
msgid ""
"Remote actor addresses may also be looked up, if :ref:`remoting <remoting-"
"scala>` is enabled:"
msgstr ":ref:`remoting<remoting-scala>` が有効な場合、リモートのアクターのアドレスも探索することができます。"

#: ../../scala/actors.rst:520
msgid ""
"An example demonstrating actor look-up is given in :ref:`remote-sample-"
"scala`."
msgstr "アクターの探索のサンプルデモは :ref:`remote-sample-scala` にあります。"

#: ../../scala/actors.rst:523
msgid "Messages and immutability"
msgstr "メッセージと不変性"

#: ../../scala/actors.rst:525
msgid ""
"**IMPORTANT**: Messages can be any kind of object but have to be immutable. "
"Scala can’t enforce immutability (yet) so this has to be by convention. "
"Primitives like String, Int, Boolean are always immutable. Apart from these "
"the recommended approach is to use Scala case classes which are immutable "
"(if you don’t explicitly expose the state) and works great with pattern "
"matching at the receiver side."
msgstr ""
"**重要** : "
"メッセージはどんな種類のオブジェクトでも構いませんが、不変である必要があります。Scalaは不変性を(今のところ)強制できないのでこれは習慣にする必要があります。StringやInt、Booleanといったプリミティブは常に不変です。これら以外でScalaで推奨される手法は(明示的に状態を公開しない限りにおいては)不変なcase"
" classを使うことです。case classを使うとメッセージの受信側でパターンマッチを使えるので大変便利です。"

#: ../../scala/actors.rst:543
msgid "Send messages"
msgstr "メッセージの送信"

#: ../../scala/actors.rst:545
msgid "Messages are sent to an Actor through one of the following methods."
msgstr "メッセージはアクターの以下に挙げるメソッドのいずれかを使って送信することができます。"

#: ../../scala/actors.rst:547
msgid ""
"``!`` means “fire-and-forget”, e.g. send a message asynchronously and return"
" immediately. Also known as ``tell``."
msgstr ""
"``!`` は\"fire-and-forget\"を意味します。つまり、メッセージを非同期に送信し、直ちに制御を戻すことができます。 ``tell``"
" という別名もあります。"

#: ../../scala/actors.rst:549
msgid ""
"``?`` sends a message asynchronously and returns a :class:`Future` "
"representing a possible reply. Also known as ``ask``."
msgstr ""
"``?`` はメッセージを非同期に送信し、利用可能な戻り値を表現した :class:`Future` を返します。 ``ask`` "
"という別名もあります。"

#: ../../scala/actors.rst:552
msgid "Message ordering is guaranteed on a per-sender basis."
msgstr "メッセージの順序は基本的に送信者ごとに保障されます。"

#: ../../scala/actors.rst:556
msgid ""
"There are performance implications of using ``ask`` since something needs to"
" keep track of when it times out, there needs to be something that bridges a"
" ``Promise`` into an ``ActorRef`` and it also needs to be reachable through "
"remoting. So always prefer ``tell`` for performance, and only ``ask`` if you"
" must."
msgstr ""
"``timeout`` を追跡しなければならないため、``ask`` を使う場合にはパフォーマンス上の影響があります。 ``Promise`` と "
"``ActorRef`` "
"を連携させるためにいくつかのことをやらなければならないし、それがリモートであっても到達可能にする必要があります。パフォーマンスのためには常に "
"``tell`` を使うことが望ましく、 ``ask`` を使うのは本当に必要な時だけにすべきです。"

#: ../../scala/actors.rst:564
msgid "Tell: Fire-forget"
msgstr "Tell: Fire-forget"

#: ../../scala/actors.rst:566
msgid ""
"This is the preferred way of sending messages. No blocking waiting for a "
"message. This gives the best concurrency and scalability characteristics."
msgstr ""
"メッセージを送る場合、こちらの方が好ましい手段です。メッセージを待つようなブロッキングがありません。この手段を用いることで並列性最大限に生かし、スケーラビリティを得ることができます。"

#: ../../scala/actors.rst:571
msgid ""
"If invoked from within an Actor, then the sending actor reference will be "
"implicitly passed along with the message and available to the receiving "
"Actor in its ``sender(): ActorRef`` member method. The target actor can use "
"this to reply to the original sender, by using ``sender() ! replyMsg``."
msgstr ""
"Actorの中で呼びだした場合、送信側のアクターの参照が暗黙的にメッセージと一緒に受け渡され、受信側のアクターが "
"``sender():ActorRef`` というメンバーメソッドを使ってこれを利用できます。メッセージを受け取ったアクターはこれを使って、 "
"``sender() ! replyMsg`` という形で元の送信者に応答を返すことができます。"

#: ../../scala/actors.rst:576
msgid ""
"If invoked from an instance that is **not** an Actor the sender will be "
":obj:`deadLetters` actor reference by default."
msgstr ""
"アクター **ではない** インスタンスから呼び出した場合、デフォルトでは送信者は :obj:`deadLetters` のアクターの参照になります。"

#: ../../scala/actors.rst:582
msgid "Ask: Send-And-Receive-Future"
msgstr "Ask: Send-And-Receive-Future"

#: ../../scala/actors.rst:584
msgid ""
"The ``ask`` pattern involves actors as well as futures, hence it is offered "
"as a use pattern rather than a method on :class:`ActorRef`:"
msgstr ""
"``ask`` パターンはアクターだけではなくfutureも含むパターンです。よって :class:`ActorRef` "
"のメソッドとしてではなくパターンとして使う形で提供されています。"

#: ../../scala/actors.rst:589
msgid ""
"This example demonstrates ``ask`` together with the ``pipeTo`` pattern on "
"futures, because this is likely to be a common combination. Please note that"
" all of the above is completely non-blocking and asynchronous: ``ask`` "
"produces a :class:`Future`, three of which are composed into a new future "
"using the for-comprehension and then ``pipeTo`` installs an "
"``onComplete``-handler on the future to affect the submission of the "
"aggregated :class:`Result` to another actor."
msgstr ""
"一般的によく使う組み合わせなので、このサンプルコードでは ``ask`` と ``pipeTo`` "
"というパターンを一緒に使っています。上記のコードは全てノンブロッキングで非同期だということに注目してください。 ``ask`` は "
":class:``Future``` "
"を作りますが、for内包表記を使って3つのFutureを組み合わせて別の新しいFutureに合成しています。``pipeTo``　はFutureに "
"``onComplete`` ハンドラを作って :class:`Result` に集約された結果を他のアクターに受け渡します。"

#: ../../scala/actors.rst:597
msgid ""
"Using ``ask`` will send a message to the receiving Actor as with ``tell``, "
"and the receiving actor must reply with ``sender() ! reply`` in order to "
"complete the returned :class:`Future` with a value. The ``ask`` operation "
"involves creating an internal actor for handling this reply, which needs to "
"have a timeout after which it is destroyed in order not to leak resources; "
"see more below."
msgstr ""
"``ask`` を使うとメッセージは ``tell`` を使って受信側のアクターに送信され、 受信側のアクターは :class:`Future` "
"として値を返すために ``sender() ! reply`` を使って応答を返さなければいけません。 ``ask`` "
"を実行すると応答を処理するための内部的なアクターが生成されますが、資源がリークさせないように一定時間を経過したらそれが破棄されるようタイムアウトを設ける必要があります。以下の詳細をご覧ください。"

#: ../../scala/actors.rst:605
msgid ""
"To complete the future with an exception you need send a Failure message to "
"the sender. This is *not done automatically* when an actor throws an "
"exception while processing a message."
msgstr ""
"Futureで例外が発生した場合、送信者に障害のメッセージを送信する必要があります。これはアクターがメッセージを処理するときに例外をスローしたとしても "
"*自動的行われることはありません。* "

#: ../../scala/actors.rst:610
msgid ""
"If the actor does not complete the future, it will expire after the timeout "
"period, completing it with an :class:`AskTimeoutException`.  The timeout is "
"taken from one of the following locations in order of precedence:"
msgstr ""
"アクターがFutureの処理を完了しなかった場合、タイムアウト経過後に :class:`AskTimeoutException` "
"を返して有効期限切れになります。タイムアウトは次のような優先順位で取得されます。"

#: ../../scala/actors.rst:614
msgid "explicitly given timeout as in:"
msgstr "次のように明示的に与えられた場合"

#: ../../scala/actors.rst:618
msgid "implicit argument of type :class:`akka.util.Timeout`, e.g."
msgstr ":class:`akka.util.Timeout` 型の暗黙的引数"

#: ../../scala/actors.rst:622
msgid ""
"See :ref:`futures-scala` for more information on how to await or query a "
"future."
msgstr ""
"Futureの結果をどのように待つかといったことやFutureに対する操作については :ref:`future-scala` を参照してください。"

#: ../../scala/actors.rst:625
msgid ""
"The ``onComplete``, ``onSuccess``, or ``onFailure`` methods of the "
"``Future`` can be used to register a callback to get a notification when the"
" Future completes, giving you a way to avoid blocking."
msgstr ""
"``onComplete`` や ``onSuccess`` 、 ``onFailure`` といった ``Future`` "
"のメソッドはFutureの処理が完了した時にブロックすることなく通知を受け取るためのコールバックとして利用することができます。"

#: ../../scala/actors.rst:631
msgid ""
"When using future callbacks, such as ``onComplete``, ``onSuccess``, and "
"``onFailure``, inside actors you need to carefully avoid closing over the "
"containing actor’s reference, i.e. do not call methods or access mutable "
"state on the enclosing actor from within the callback. This would break the "
"actor encapsulation and may introduce synchronization bugs and race "
"conditions because the callback will be scheduled concurrently to the "
"enclosing actor. Unfortunately there is not yet a way to detect these "
"illegal accesses at compile time. See also: :ref:`jmm-shared-state`"
msgstr ""
"``onComplete`` や ``onSuccess`` 、 ``onFailure`` "
"といったFutureのコールバックを使う場合、アクターの中ではアクターの参照をリークしてしまわないように注意する必要があります。例えば、コールバックの中で外側のアクターのメソッドを呼び出したりアクターの状態にアクセスしてはいけません。コールバックは外側のアクターに対して並行に実行されるので、これらはアクターのカプセル化を破壊し、同期関連のバグやレースコンディションを引き起こします。残念なことに今のところこれらの不正なアクセスをコンパイル時に検知する方法がありません。"
" :ref:`jmm-shared-state` も参照してください。"

#: ../../scala/actors.rst:641
msgid "Forward message"
msgstr "メッセージの転送"

#: ../../scala/actors.rst:643
msgid ""
"You can forward a message from one actor to another. This means that the "
"original sender address/reference is maintained even though the message is "
"going through a 'mediator'. This can be useful when writing actors that work"
" as routers, load-balancers, replicators etc."
msgstr ""
"あるアクターが別のアクターへメッセージを転送することができます。これはメッセージが'仲介者'を経由した後でも元の送信者のアドレスや参照が維持されるということです。これはアクターをルーターやロードバランサ、レプリケイターといった用途で使う場合、便利です。"

#: ../../scala/actors.rst:651
msgid "Receive messages"
msgstr "メッセージの受信"

#: ../../scala/actors.rst:653
msgid "An Actor has to implement the ``receive`` method to receive messages:"
msgstr "アクターはメッセージを受信するために ``receive`` というメソッドを実装する必要があります。"

#: ../../scala/actors.rst:657
msgid ""
"This method returns a ``PartialFunction``, e.g. a ‘match/case’ clause in "
"which the message can be matched against the different case clauses using "
"Scala pattern matching. Here is an example:"
msgstr ""
"このメソッドの戻り値は ``PartialFunction`` "
"になっていて、その中でメッセージはScalaのパターンマッチを使って'match/case'句の中のそれぞれ異なるmatch句にmatchさせることができます。"

#: ../../scala/actors.rst:668
msgid "Reply to messages"
msgstr "メッセージへの応答"

#: ../../scala/actors.rst:670
msgid ""
"If you want to have a handle for replying to a message, you can use "
"``sender()``, which gives you an ActorRef. You can reply by sending to that "
"ActorRef with ``sender() ! replyMsg``. You can also store the ActorRef for "
"replying later, or passing on to other actors. If there is no sender (a "
"message was sent without an actor or future context) then the sender "
"defaults to a 'dead-letter' actor ref."
msgstr ""
"メッセージに応答を返した場合、 ``sender()`` というメソッドを使ってActorRefを取得することができます。そのActorRefに対して "
"``sender() ! replyMsg`` "
"という形で応答を返すことができます。後で応答を返すためにActorRefを保存しておいたり、他のアクターに受け渡すこともできます。送信者がいない場合(アクターの外からメッセージを送信した場合やFutureのコンテクストの中)、デフォルトの送信者は"
" 'dead-letter' のアクターの参照になります。"

#: ../../scala/actors.rst:684
msgid "Receive timeout"
msgstr "受信タイムアウト"

#: ../../scala/actors.rst:686
msgid ""
"The `ActorContext` :meth:`setReceiveTimeout` defines the inactivity timeout "
"after which the sending of a `ReceiveTimeout` message is triggered. When "
"specified, the receive function should be able to handle an "
"`akka.actor.ReceiveTimeout` message. 1 millisecond is the minimum supported "
"timeout."
msgstr ""
"`ActorContext`:meth:`setReceiveTimeout` は非アクティブ時のタイムアウトを定義し、その時間を経過すると "
"`ReceiveTimeout` が送信されるトリガになります。このタイムアウトが設定されている時、 receive 関数は "
"`akka.actor.ReceiveTimeout` を処理することができなければいけません。このタイムアウトの最小値は1ミリ秒です。"

#: ../../scala/actors.rst:691
msgid ""
"Please note that the receive timeout might fire and enqueue the "
"`ReceiveTimeout` message right after another message was enqueued; hence it "
"is **not guaranteed** that upon reception of the receive timeout there must "
"have been an idle period beforehand as configured via this method."
msgstr ""
"受信タイムアウトが発生してから `ReceiveTimeout` "
"メッセージが他の既にキューに入っているメッセージの後に追加されることに注意してください。つまり、あらかじめメソッドを通じて設定した待ち時間ちょうどに受信タイムアウトのメッセージを受け取られることは**保障されていません**。"

#: ../../scala/actors.rst:695
msgid ""
"Once set, the receive timeout stays in effect (i.e. continues firing "
"repeatedly after inactivity periods). Pass in `Duration.Undefined` to switch"
" off this feature."
msgstr ""
"受信タイムアウトは一度設定すると効果として残り続けます。(つまり、非アクティブ時間を経過するごとに継続的にメッセージが送信されます。) "
"`Duration.Undefined` を設定することでこの機能を閉じることができます。"

#: ../../scala/actors.rst:700
msgid ""
"Messages marked with ``NotInfluenceReceiveTimeout`` will not reset the "
"timer. This can be useful when ``ReceiveTimeout`` should be fired by "
"external inactivity but not influenced by internal activity, e.g. scheduled "
"tick messages."
msgstr ""
"``NotInfluenceReceiveTimeout`` をmix-"
"inしたメッセージはタイマーのリセットを行いません。外部に対して非アクティブだった場合に ``ReceiveTimeout`` "
"を起こしたいが、内部の活動からは影響を受けたくない場合にこれが役に立つことがあります。例えば、スケジューラの定期的なメッセージ等です。"

#: ../../scala/actors.rst:707
msgid "Stopping actors"
msgstr "アクターの停止"

#: ../../scala/actors.rst:709
msgid ""
"Actors are stopped by invoking the :meth:`stop` method of a "
"``ActorRefFactory``, i.e. ``ActorContext`` or ``ActorSystem``. Typically the"
" context is used for stopping the actor itself or child actors and the "
"system for stopping top level actors. The actual termination of the actor is"
" performed asynchronously, i.e. :meth:`stop` may return before the actor is "
"stopped."
msgstr ""
"アクターは ``ActorContext``や ``ActorSystem`` 等の``ActorRefFactory`` が持つ "
":meth:`stop` "
"というメソッドを呼び出すことで停止できます。通常はコンテクストでは自分自身や自分の子供のアクターを停止し、アクターシステムではトップレベルのアクターを停止します。実際にアクターが終了するのは非同期に行われ、"
" :meth:`stop` メソッドはアクターが停止する前に制御を戻します。"

#: ../../scala/actors.rst:717
msgid ""
"Processing of the current message, if any, will continue before the actor is"
" stopped, but additional messages in the mailbox will not be processed. By "
"default these messages are sent to the :obj:`deadLetters` of the "
":obj:`ActorSystem`, but that depends on the mailbox implementation."
msgstr ""
"アクターを停止する前に処理しようとしていたメッセージがあれば、それは処理されますが、その後にメールボックスに入ってきたメッセージは処理されません。デフォルトではこれらのメッセージは"
" :obj:`ActorSystem` の :obj:`deadLetters` に送られますが、これはメールボックスの実装に依存します。"

#: ../../scala/actors.rst:722
msgid ""
"Termination of an actor proceeds in two steps: first the actor suspends its "
"mailbox processing and sends a stop command to all its children, then it "
"keeps processing the internal termination notifications from its children "
"until the last one is gone, finally terminating itself (invoking "
":meth:`postStop`, dumping mailbox, publishing :class:`Terminated` on the "
":ref:`DeathWatch <deathwatch-scala>`, telling its supervisor). This "
"procedure ensures that actor system sub-trees terminate in an orderly "
"fashion, propagating the stop command to the leaves and collecting their "
"confirmation back to the stopped supervisor. If one of the actors does not "
"respond (i.e. processing a message for extended periods of time and "
"therefore not receiving the stop command), this whole process will be stuck."
msgstr ""
"アクターの停止には二つのステップがあります。まず、アクターは自分のメールボックスの処理を中止して自分の子アクターに停止コマンドを送信します。それから最後のものがなくなるまで内部の終了通知の処理を続け、最終的に自分自身を停止します。("
" :meth:`postStop` を呼び出し、メールボックスをダンプしてから :ref:`DeathWatch` しながら "
":class:`Terminated` "
"メッセージを発行します。)この手順はアクターシステムのサブツリーを秩序のある方法で停止し、停止コマンドを葉に伝播させてから確認応答を停止したアクターのスーパーバイザーに返していきます。もしいずれかのアクターが応答しなかった場合(例えば、メッセージを長時間処理していて停止コマンドを受信できない場合)、この全体の処理が止まってしまいます。"

#: ../../scala/actors.rst:734
msgid ""
"Upon :meth:`ActorSystem.terminate()`, the system guardian actors will be "
"stopped, and the aforementioned process will ensure proper termination of "
"the whole system."
msgstr ""
":meth:`ActorSystem.terminate()` "
"を呼びだすと、システムガーディアンアクターが停止され、前述の処理によってシステム全体が正しく停止されます。"

#: ../../scala/actors.rst:738
msgid ""
"The :meth:`postStop()` hook is invoked after an actor is fully stopped. This"
" enables cleaning up of resources:"
msgstr ""
":meth:`postStop()` フックは、アクターが完全に停止した後に呼び出されます。これにより、リソースのクリーンアップが可能になります。"

#: ../../scala/actors.rst:746
msgid ""
"Since stopping an actor is asynchronous, you cannot immediately reuse the "
"name of the child you just stopped; this will result in an "
":class:`InvalidActorNameException`. Instead, :meth:`watch()` the terminating"
" actor and create its replacement in response to the :class:`Terminated` "
"message which will eventually arrive."
msgstr ""
"アクターの停止は非同期であるため、停止した子の名前をすぐに再利用することはできません。これは "
":class:`InvalidActorNameException` になります。代わりに、停止しようとしているアクターを "
":meth:`watch()` し、最終的に到着する :class:`Terminated` メッセージに反応して置換を行います。"

#: ../../scala/actors.rst:755
msgid "PoisonPill"
msgstr "毒薬"

#: ../../scala/actors.rst:757
msgid ""
"You can also send an actor the ``akka.actor.PoisonPill`` message, which will"
" stop the actor when the message is processed. ``PoisonPill`` is enqueued as"
" ordinary messages and will be handled after messages that were already "
"queued in the mailbox."
msgstr ""
"アクターに ``akka.actor.PoisonPill`` メッセージを送ることもできます。このメッセージが処理されると、アクターは停止します。 "
"``PoisonPill`` は通常のメッセージとしてエンキューされ、すでにメールボックスにキューイングされているメッセージの後に処理されます。"

#: ../../scala/actors.rst:763
msgid "Graceful Stop"
msgstr "グレースフルな停止"

#: ../../scala/actors.rst:765
msgid ""
":meth:`gracefulStop` is useful if you need to wait for termination or "
"compose ordered termination of several actors:"
msgstr ""
":meth:`gracefulStop` は、終了を待つ必要がある場合や、いくつかのアクタの順序付けられた終了を構成する必要がある場合に便利です。"

#: ../../scala/actors.rst:772
msgid ""
"When ``gracefulStop()`` returns successfully, the actor’s ``postStop()`` "
"hook will have been executed: there exists a happens-before edge between the"
" end of ``postStop()`` and the return of ``gracefulStop()``."
msgstr ""
"``gracefulStop()`` が正常に返されると、アクターの ``postStop()`` フックが実行されます: ``postStop()``"
" の終了と ``gracefulStop()`` の完了の間には順次呼び出しの隙間があります。"

#: ../../scala/actors.rst:776
msgid ""
"In the above example a custom ``Manager.Shutdown`` message is sent to the "
"target actor to initiate the process of stopping the actor. You can use "
"``PoisonPill`` for this, but then you have limited possibilities to perform "
"interactions with other actors before stopping the target actor. Simple "
"cleanup tasks can be handled in ``postStop``."
msgstr ""
"上記の例では、カスタムの ``Manager.Shutdown`` "
"メッセージがターゲットのアクターに送信され、アクターを停止するプロセスが開始されます。 これを実現するのに  ``PoisonPill`` "
"を使うこともできますが、ターゲットのアクターを停止する前に他のアクターとのやり取りを行う可能性がわずかながらあります。 単純なクリーンアップのタスクは "
"``postStop`` で処理できます。"

#: ../../scala/actors.rst:783
msgid ""
"Keep in mind that an actor stopping and its name being deregistered are "
"separate events which happen asynchronously from each other. Therefore it "
"may be that you will find the name still in use after ``gracefulStop()`` "
"returned. In order to guarantee proper deregistration, only reuse names from"
" within a supervisor you control and only in response to a "
":class:`Terminated` message, i.e. not for top-level actors."
msgstr ""
"アクターが停止することと、その名前の登録が抹消されることは、お互いに非同期で起こる別々のイベントであることに注意してください。したがって、  "
"``gracefulStop()`` が返された後でも、まだ名前が使用中なのを見ることがあるかもしれません。 "
"適切に登録の解除を保証するには、あなたが管理するスーパーバイザ内から名前を再利用するだけで、class:`Terminated` "
"メッセージに反応するだけで、つまりトップレベルのアクターではありません。"

#: ../../scala/actors.rst:793
msgid "Become/Unbecome"
msgstr "Become/Unbecome"

#: ../../scala/actors.rst:796
msgid "Upgrade"
msgstr "更新"

#: ../../scala/actors.rst:798
msgid ""
"Akka supports hotswapping the Actor’s message loop (e.g. its implementation)"
" at runtime: invoke the ``context.become`` method from within the Actor. "
":meth:`become` takes a ``PartialFunction[Any, Unit]`` that implements the "
"new message handler. The hotswapped code is kept in a Stack which can be "
"pushed and popped."
msgstr ""
"Akkaは、実行時にアクターのメッセージループ(例：その実装)をホットスワップすることをサポートしています。これを行うためには、アクターの中から `` "
"context.become`` メソッドを呼び出します。 ：meth： `become` は、新しいメッセージハンドラの実装となる ` "
"`PartialFunction [Any、Unit]` ` を受け取ります。 "
"ホットスワップされたコードはスタックに保持され、プッシュしたりポップしたりすることができます。"

#: ../../scala/actors.rst:806
msgid ""
"Please note that the actor will revert to its original behavior when "
"restarted by its Supervisor."
msgstr "Supervisorによってアクターが再起動されたときには元の振る舞いに戻ってしまうことに注意してください。"

#: ../../scala/actors.rst:808
msgid "To hotswap the Actor behavior using ``become``:"
msgstr "アクターの振る舞いをホットスワップするためには ``become`` を使用します。"

#: ../../scala/actors.rst:812
msgid ""
"This variant of the :meth:`become` method is useful for many different "
"things, such as to implement a Finite State Machine (FSM, for an example see"
" `Dining Hakkers`_). It will replace the current behavior (i.e. the top of "
"the behavior stack), which means that you do not use :meth:`unbecome`, "
"instead always the next behavior is explicitly installed."
msgstr ""
"：meth： `become`メソッドの変種は便利で例えば有限状態マシン (FSM、この例は、`Dining Hakkers`を参照してください_) "
"を実装するなど、さまざまな目的に役立ちます。 有限状態マシンは現在の動作(つまり動作スタックの先頭)を置き換えます。つまり、：meth： "
"`unbecome` を使わなくても、常に次の動作が明示的に決まります。"

#: ../../scala/actors.rst:820
msgid ""
"The other way of using :meth:`become` does not replace but add to the top of"
" the behavior stack. In this case care must be taken to ensure that the "
"number of “pop” operations (i.e. :meth:`unbecome`) matches the number of "
"“push” ones in the long run, otherwise this amounts to a memory leak (which "
"is why this behavior is not the default)."
msgstr ""
"：meth： `become` のもう一つの使い方として、動作スタックの先頭を置き換えずにスタックの先頭に追加するというものがあります。 "
"この場合、「ポップ」操作の数(すなわち ：meth： "
"`unbecome`)が長期的に「プッシュ」の数に一致するように注意する必要があります。そうでなければ、メモリリークが発生します(この動作はデフォルトではないのはこれが理由です)。"

#: ../../scala/actors.rst:829
msgid ""
"Encoding Scala Actors nested receives without accidentally leaking memory"
msgstr "Scalaのアクターは、メモリを誤ってリークすることなくネストされた受信を行います。"

#: ../../scala/actors.rst:831
msgid ""
"See this `Unnested receive example <@github@/akka-"
"docs/rst/scala/code/docs/actor/UnnestedReceives.scala>`_."
msgstr ""
"以下の `ネスとしない受信の例 <@github@/akka-"
"docs/rst/scala/code/docs/actor/UnnestedReceives.scala>` を参照してください。"

#: ../../scala/actors.rst:836
msgid "Stash"
msgstr "Stash"

#: ../../scala/actors.rst:838
msgid ""
"The `Stash` trait enables an actor to temporarily stash away messages that "
"can not or should not be handled using the actor's current behavior. Upon "
"changing the actor's message handler, i.e., right before invoking "
"``context.become`` or ``context.unbecome``, all stashed messages can be "
"\"unstashed\", thereby prepending them to the actor's mailbox. This way, the"
" stashed messages can be processed in the same order as they have been "
"received originally."
msgstr ""
"``stash()`` を呼び出すと、現在のメッセージ（アクターが最後に受け取ったメッセージ）がアクターの隠しに追加されます。 "
"これは通常、アクターのメッセージハンドラーでデフォルトのケースを処理して、他のケースでは処理されないメッセージを隠すときに呼び出されます。 "
"同じメッセージを2回隠すのは不正です。 これを行うと、 `` IllegalStateException``がスローされます。 "
"stashはまた境界がついているかもしれません。その場合、 `` stash（） ``を呼び出すと容量違反につながり、結果として `` "
"StashOverflowException``が発生します。 stashの容量はメールボックスの設定の \"stash-capacity\"設定（ "
"`` Int``）を使って設定できます。"

#: ../../scala/actors.rst:848
msgid ""
"The trait ``Stash`` extends the marker trait "
"``RequiresMessageQueue[DequeBasedMessageQueueSemantics]`` which requests the"
" system to automatically choose a deque based mailbox implementation for the"
" actor. If you want more control over the mailbox, see the documentation on "
"mailboxes: :ref:`mailboxes-scala`."
msgstr ""
"`` Stash``は、 `` RequiresMessageQueue [DequeBasedMessageQueueSemantics] `` "
"というマーカートレイトを拡張しています。このマーカートレイトは、システムにアクターにキューベースのメールボックス実装を自動的に選択するように要求します。"
" メールボックスをより詳細に制御したい場合は、メールボックス  :ref:`mailboxes-scala` のドキュメントを参照してください。"

#: ../../scala/actors.rst:854
msgid "Here is an example of the ``Stash`` in action:"
msgstr "以下は実際に ``Stash`` を使った例です。"

#: ../../scala/actors.rst:858
msgid ""
"Invoking ``stash()`` adds the current message (the message that the actor "
"received last) to the actor's stash. It is typically invoked when handling "
"the default case in the actor's message handler to stash messages that "
"aren't handled by the other cases. It is illegal to stash the same message "
"twice; to do so results in an ``IllegalStateException`` being thrown. The "
"stash may also be bounded in which case invoking ``stash()`` may lead to a "
"capacity violation, which results in a ``StashOverflowException``. The "
"capacity of the stash can be configured using the ``stash-capacity`` setting"
" (an ``Int``) of the mailbox's configuration."
msgstr ""
"``stash()`` を呼び出すと、現在のメッセージ(アクターが最後に受け取ったメッセージ)をアクターの隠れた場所に追加します。 "
"これは通常、アクターのメッセージハンドラーでデフォルトのケースを処理するときに、他のケースで処理しないメッセージを蓄えておきたいときに呼び出します。 "
"同じメッセージを2回蓄えるのは不正です。 これを行うと、 ``IllegalStateException``      がスローされます。 "
"stashは容量を持っているので、 ``stash()``を呼び出したときに容量違反になることがあり、その場合  `` "
"StashOverflowException`` が発生します。 stashの容量はメールボックスの設定の \"stash-capacity\" "
"という項目(`` Int`` を指定します)を使って設定できます。"

#: ../../scala/actors.rst:869
msgid ""
"Invoking ``unstashAll()`` enqueues messages from the stash to the actor's "
"mailbox until the capacity of the mailbox (if any) has been reached (note "
"that messages from the stash are prepended to the mailbox). In case a "
"bounded mailbox overflows, a ``MessageQueueAppendFailedException`` is "
"thrown. The stash is guaranteed to be empty after calling ``unstashAll()``."
msgstr ""
"``unstashAll()`` "
"を呼び出すと、メールボックス(もしあれば)の容量に達するまで、stashからのメッセージをアクターのメールボックスに追加します(stashからのメッセージはメールボックスに前から追加されます)。"
" 容量を持つメールボックスがオーバーフローした場合、 ``MessageQueueAppendFailedException`` がスローされます。 "
"stashは、 `unstashAll()`` を呼び出した後は空であることが保証されています。"

#: ../../scala/actors.rst:876
msgid ""
"The stash is backed by a ``scala.collection.immutable.Vector``. As a result,"
" even a very large number of messages may be stashed without a major impact "
"on performance."
msgstr ""
"stashは ``scala.collection.immutable.Vector`` を使っています。 "
"そのため、非常に多数のメッセージを蓄えていたとしてもパフォーマンスに大きな影響を与えません。"

#: ../../scala/actors.rst:882
msgid ""
"Note that the ``Stash`` trait must be mixed into (a subclass of) the "
"``Actor`` trait before any trait/class that overrides the ``preRestart`` "
"callback. This means it's not possible to write ``Actor with MyActor with "
"Stash`` if ``MyActor`` overrides ``preRestart``."
msgstr ""
"``Stash`` トレイトは、 ``preRestart`` コールバックをオーバーライドするトレイト/クラスの前に ``Actor`` "
"トレイト(もしくはそのサブクラス)にミックスインしなければならないことに注意してください。 これは、 ``MyActor`` が "
"``preRestart`` をオーバーライドしている場合に、 ``Actor with MyActor with Stash`` "
"という書き方ができないということです。"

#: ../../scala/actors.rst:887
msgid ""
"Note that the stash is part of the ephemeral actor state, unlike the "
"mailbox. Therefore, it should be managed like other parts of the actor's "
"state which have the same property. The :class:`Stash` trait’s "
"implementation of :meth:`preRestart` will call ``unstashAll()``, which is "
"usually the desired behavior."
msgstr ""
"stashは、メールボックスとは異なり、一時的なアクター状態の一部であることに注意してください。 "
"したがって、同じような特性を持つその他のアクターの状態と同様に管理する必要があります。 ：class： `Stash` "
"トレイトの:meth:`preRestart` の実装は、 ``unstashAll()`` を呼び出します。これは、通常、望ましい動作です。"

#: ../../scala/actors.rst:895
msgid ""
"If you want to enforce that your actor can only work with an unbounded "
"stash, then you should use the ``UnboundedStash`` trait instead."
msgstr "アクターが容量の境界がないstashを使うようにしたい場合は、代わりに ``UnboundedStash`` を使います。"

#: ../../scala/actors.rst:902
msgid "Killing an Actor"
msgstr "アクターの強制停止"

#: ../../scala/actors.rst:904
msgid ""
"You can kill an actor by sending a ``Kill`` message. This will cause the "
"actor to throw a :class:`ActorKilledException`, triggering a failure. The "
"actor will suspend operation and its supervisor will be asked how to handle "
"the failure, which may mean resuming the actor, restarting it or terminating"
" it completely. See :ref:`supervision-directives` for more information."
msgstr ""
"``Kill`` メッセージを送ることによってアクターを強制停止することができます。 このメッセージを受け取ると、アクターは "
":class:`ActorKilledException` をスローし、失敗をトリガーします。 "
"アクターは操作を中断し、スーパーバイザーに失敗を処理する方法を尋ねます。 "
"これはアクターがレジュームされたり、再起動されたり、完全に停止させられたりすることを意味します。 詳細は、:ref:`supervision-"
"directives` を参照してください。"

#: ../../scala/actors.rst:910
msgid "Use ``Kill`` like this:"
msgstr "`Kill`` メッセージは以下の様に使用します。"

#: ../../scala/actors.rst:919
msgid "Actors and exceptions"
msgstr "アクターと例外"

#: ../../scala/actors.rst:921
msgid ""
"It can happen that while a message is being processed by an actor, that some"
" kind of exception is thrown, e.g. a database exception."
msgstr "アクターがメッセージを処理している間に、データベース例外のような例外が発生することがあります。"

#: ../../scala/actors.rst:925
msgid "What happens to the Message"
msgstr "メッセージへの影響"

#: ../../scala/actors.rst:927
msgid ""
"If an exception is thrown while a message is being processed (i.e. taken out"
" of its mailbox and handed over to the current behavior), then this message "
"will be lost. It is important to understand that it is not put back on the "
"mailbox. So if you want to retry processing of a message, you need to deal "
"with it yourself by catching the exception and retry your flow. Make sure "
"that you put a bound on the number of retries since you don't want a system "
"to livelock (so consuming a lot of cpu cycles without making progress). "
"Another possibility would be to have a look at the :ref:`PeekMailbox pattern"
" <mailbox-acking>`."
msgstr ""
"メッセージの処理中に例外がスローされた場合(つまり、メールボックスから取り出され、現在の動作に引き渡されていた場合)、このメッセージは失われます。それがメールボックスに戻されないということを理解しておくことが重要です。したがって、メッセージの処理を再試行したい場合は、例外をキャッチして自分で処理し、フローを再試行する必要があります。システムがライブロックしないようにするため、再試行回数に制限を書けるようにしてください(処理を行わないのにCPUサイクルを多く消費してしまいまう)。"
" :ref:`PeekMailbox pattern <mailbox-acking>` を用いるという手もあります。"

#: ../../scala/actors.rst:937
msgid "What happens to the mailbox"
msgstr "メールボックスへの影響"

#: ../../scala/actors.rst:939
msgid ""
"If an exception is thrown while a message is being processed, nothing "
"happens to the mailbox. If the actor is restarted, the same mailbox will be "
"there. So all messages on that mailbox will be there as well."
msgstr ""
"メッセージの処理中に例外がスローされても、メールボックスには何の影響もありません。アクターが再起動すると、同じメールボックスが利用されます。メールボックスの中のすべてのメッセージもそこにあります。"

#: ../../scala/actors.rst:944
msgid "What happens to the actor"
msgstr "アクターへの影響"

#: ../../scala/actors.rst:946
msgid ""
"If code within an actor throws an exception, that actor is suspended and the"
" supervision process is started (see :ref:`supervision`). Depending on the "
"supervisor’s decision the actor is resumed (as if nothing happened), "
"restarted (wiping out its internal state and starting from scratch) or "
"terminated."
msgstr ""
"アクター内のコードが例外をスローすると、そのアクターは中断され、スーパーバイザーの処理が開始します(：ref： `supervision` "
"を参照してください)。アクターはスーパーバイザーの決定に従って、(何も起きなかったのと同じように)レジュームしたり、再起動したり(内部状態を一掃してゼロから開始します)、停止したりします。"

#: ../../scala/actors.rst:953
msgid "Extending Actors using PartialFunction chaining"
msgstr "PartialFunction を連鎖してアクターを拡張する"

#: ../../scala/actors.rst:955
msgid ""
"Sometimes it can be useful to share common behavior among a few actors, or "
"compose one actor's behavior from multiple smaller functions. This is "
"possible because an actor's :meth:`receive` method returns an "
"``Actor.Receive``, which is a type alias for ``PartialFunction[Any,Unit]``, "
"and partial functions can be chained together using the "
"``PartialFunction#orElse`` method. You can chain as many functions as you "
"need, however you should keep in mind that \"first match\" wins - which may "
"be important when combining functions that both can handle the same type of "
"message."
msgstr ""
"いくつかのアクター間で共通の振る舞いを共有したり、複数の小さな関数から1つのアクターの振る舞いを合成することが有用なことがあります。アクターの "
"：meth： `receive` メソッドの戻り値である ` `Actor.Receive`` は ` `PartialFunction "
"[Any、Unit]` ` の型エイリアスであり、部分関数は ``PartialFunction#orElse`` "
"メソッドを使って合成できるので、これは可能です。必要なだけ多くの関数を連鎖させることができますが、同じ型のメッセージ処理できる関数を合成する際に重要な "
"\"first-match\" wins という法則に注意してください。"

#: ../../scala/actors.rst:960
msgid ""
"For example, imagine you have a set of actors which are either ``Producers``"
" or ``Consumers``, yet sometimes it makes sense to have an actor share both "
"behaviors. This can be easily achieved without having to duplicate code by "
"extracting the behaviors to traits and implementing the actor's "
":meth:`receive` as combination of these partial functions."
msgstr ""
"たとえば、 ``Producers`` と ``Consumers`` "
"のどちらかのアクターのセットがあるときに、一つのアクターに両方の動作を共有させることが理にかなっていることがあります。これは、振る舞いトレイトに切り出して、その部分関数の組み合わせとしてアクターの"
" ：meth：`receive` を実装することによって、コードを重複させる必要なしに、容易に達成することができます。"

#: ../../scala/actors.rst:966
msgid ""
"Instead of inheritance the same pattern can be applied via composition - one"
" would simply compose the receive method using partial functions from "
"delegates."
msgstr ""
"継承の代わりに、合成を使うことで同じパターンを適用することもできます。 この場合、デリゲートの部分関数を使って単純に receive 関数を合成します。"

#: ../../scala/actors.rst:969
msgid "Initialization patterns"
msgstr "初期化のパターン"

#: ../../scala/actors.rst:971
msgid ""
"The rich lifecycle hooks of Actors provide a useful toolkit to implement "
"various initialization patterns. During the lifetime of an ``ActorRef``, an "
"actor can potentially go through several restarts, where the old instance is"
" replaced by a fresh one, invisibly to the outside observer who only sees "
"the ``ActorRef``."
msgstr ""
"アクターには沢山のライフサイクルフックがあり、さまざまな初期化パターンを実装するための便利なツールキットを提供します。 ``ActorRef`` "
"の存続期間中、アクターはいくつかの再始動を行っている可能性があります。古いインスタンスは新しいものに置き換えられ、 `` "
"ActorRef``だけを見る外部の観察者にはわかりません。"

#: ../../scala/actors.rst:975
msgid ""
"One may think about the new instances as \"incarnations\". Initialization "
"might be necessary for every incarnation of an actor, but sometimes one "
"needs initialization to happen only at the birth of the first instance when "
"the ``ActorRef`` is created. The following sections provide patterns for "
"different initialization needs."
msgstr ""
"新しいインスタンスは「インカネーション」だと思う人もいるかもしれません。初期化はアクターのすべてのインカーネーションに対して必要であることもありますが、場合によっては、"
" ``ActorRef`` "
"が作成されたときの最初のインスタンスの誕生時にのみ初期化を行う必要があることもあります。次のセクションでは、異なる初期化の必要に応じたパターンを紹介します。"

#: ../../scala/actors.rst:980
msgid "Initialization via constructor"
msgstr "コンストラクタを使った初期化"

#: ../../scala/actors.rst:982
msgid ""
"Using the constructor for initialization has various benefits. First of all,"
" it makes it possible to use ``val`` fields to store any state that does not"
" change during the life of the actor instance, making the implementation of "
"the actor more robust. The constructor is invoked for every incarnation of "
"the actor, therefore the internals of the actor can always assume that "
"proper initialization happened. This is also the drawback of this approach, "
"as there are cases when one would like to avoid reinitializing internals on "
"restart. For example, it is often useful to preserve child actors across "
"restarts. The following section provides a pattern for this case."
msgstr ""
"コンストラクタを使った初期化には様々な利点があります。まず第一に、アクターインスタンスの存続期間中に変化しない状態を格納するために "
"``val``フィールドを使用することができるようになり、アクターの実装がより堅牢になります。コンストラクタはアクターのインカネーションごとに呼び出されるため、アクタの内部は常に適切な初期化が行われたとみなすことができます。しかし、この方法の欠点でもあります。再起動時に内部の再初期化を避けたい場合があるためです。たとえば、再起動をまたいで子アクターを保持すると便利なことがあります。次のセクションでは、このケースのパターンを示します。"

#: ../../scala/actors.rst:990
msgid "Initialization via preStart"
msgstr "preStart による初期化"

#: ../../scala/actors.rst:992
msgid ""
"The method ``preStart()`` of an actor is only called once directly during "
"the initialization of the first instance, that is, at creation of its "
"``ActorRef``. In the case of restarts, ``preStart()`` is called from "
"``postRestart()``, therefore if not overridden, ``preStart()`` is called on "
"every incarnation. However, by overriding ``postRestart()`` one can disable "
"this behavior, and ensure that there is only one call to ``preStart()``."
msgstr ""
"アクターの ``preStart()`` メソッドは、最初のインスタンスの初期化中、つまり  ``ActorRef`` "
"の作成時に一度だけ直接的に呼び出されます。再起動の場合、 `` preStart()``は `` "
"postRestart()``から呼び出されるため、オーバーライドしないと、すべてのインカネーションで "
"``preStart()``が呼び出されます。しかし、 ``postRestart()``をオーバーライドすることで、この動作を無効にし、 "
"``preStart()``への呼び出しが1つしかないことを保証することができます。"

#: ../../scala/actors.rst:997
msgid ""
"One useful usage of this pattern is to disable creation of new ``ActorRefs``"
" for children during restarts. This can be achieved by overriding "
"``preRestart()``:"
msgstr ""
"このパターンの便利な使い方の1つは、再起動時に子プロセスの新しい ``ActorRefs`` の作成を無効にすることです。これは "
"``preRestart()`` をオーバーライドすることで実現できます："

#: ../../scala/actors.rst:1002
msgid ""
"Please note, that the child actors are *still restarted*, but no new "
"``ActorRef`` is created. One can recursively apply the same principles for "
"the children, ensuring that their ``preStart()`` method is called only at "
"the creation of their refs."
msgstr ""
"子アクターはまだ *再起動しています* が、新しい "
"``ActorRef``は作成されないということに注目してください。子アクターに同じ原則を再帰的に適用して、 "
"``preStart()``メソッドがrefの作成時にのみ呼び出されるようにすることができます。"

#: ../../scala/actors.rst:1006
msgid "For more information see :ref:`supervision-restart`."
msgstr "さらに詳しい情報は :ref:`supervision-restart` を参照してください。"

#: ../../scala/actors.rst:1009
msgid "Initialization via message passing"
msgstr "メッセージパッシングによる初期化"

#: ../../scala/actors.rst:1011
msgid ""
"There are cases when it is impossible to pass all the information needed for"
" actor initialization in the constructor, for example in the presence of "
"circular dependencies. In this case the actor should listen for an "
"initialization message, and use ``become()`` or a finite state-machine state"
" transition to encode the initialized and uninitialized states of the actor."
msgstr ""
"たとえば、循環依存が存在する場合など、アクターの初期化に必要なすべての情報をコンストラクタに渡すことが不可能な場合があります。この場合、アクターは初期化メッセージをリッスンし、アクターの初期化後の状態と初期化前の状態をエンコードするために"
" ``become()`` または有限ステートマシン状態による遷移を使用する必要があります。"

#: ../../scala/actors.rst:1018
msgid ""
"If the actor may receive messages before it has been initialized, a useful "
"tool can be the ``Stash`` to save messages until the initialization "
"finishes, and replaying them after the actor became initialized."
msgstr ""
"アクターが初期化される前にメッセージを受けとる場合、初期化が完了するまでメッセージを保存し、アクターが初期化された後にメッセージを再生する "
"``Stash`` という便利なツールがあります。"

#: ../../scala/actors.rst:1023
msgid ""
"This pattern should be used with care, and applied only when none of the "
"patterns above are applicable. One of the potential issues is that messages "
"might be lost when sent to remote actors. Also, publishing an ``ActorRef`` "
"in an uninitialized state might lead to the condition that it receives a "
"user message before the initialization has been done."
msgstr ""
"このパターンは慎重に使用し、上記のパターンのいずれも該当しない場合にのみ適用してください。潜在的な問題の1つは、メッセージがリモートアクターに送信されると失われる可能性があることです。また、"
" ``ActorRef`` を初期化されていない状態で公開すると、初期化が完了する前にユーザメッセージを受け取るという条件につながる可能性があります。"
