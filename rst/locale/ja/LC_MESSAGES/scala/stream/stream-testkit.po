# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/stream/stream-testkit.rst:5
msgid "Testing streams"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:7
msgid ""
"Verifying behaviour of Akka Stream sources, flows and sinks can be done "
"using various code patterns and libraries. Here we will discuss testing "
"these elements using:"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:11
msgid "simple sources, sinks and flows;"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:12
msgid ""
"sources and sinks in combination with :class:`TestProbe` from the :mod"
":`akka-testkit` module;"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:13
msgid ""
"sources and sinks specifically crafted for writing tests from the :mod"
":`akka-stream-testkit` module."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:15
msgid ""
"It is important to keep your data processing pipeline as separate sources, "
"flows and sinks. This makes them easily testable by wiring them up to other "
"sources or sinks, or some test harnesses that :mod:`akka-testkit` or :mod"
":`akka-stream-testkit` provide."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:21
msgid "Built in sources, sinks and combinators"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:23
msgid ""
"Testing a custom sink can be as simple as attaching a source that emits "
"elements from a predefined collection, running a constructed test flow and "
"asserting on the results that sink produced. Here is an example of a test "
"for a sink:"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:30
msgid ""
"The same strategy can be applied for sources as well. In the next example we"
" have a source that produces an infinite stream of elements. Such source can"
" be tested by asserting that first arbitrary number of elements hold some "
"condition. Here the ``take`` combinator and ``Sink.seq`` are very useful."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:37
msgid ""
"When testing a flow we need to attach a source and a sink. As both stream "
"ends are under our control, we can choose sources that tests various edge "
"cases of the flow and sinks that ease assertions."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:44
msgid "TestKit"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:46
msgid ""
"Akka Stream offers integration with Actors out of the box. This support can "
"be used for writing stream tests that use familiar :class:`TestProbe` from "
"the :mod:`akka-testkit` API."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:50
msgid ""
"One of the more straightforward tests would be to materialize stream to a "
":class:`Future` and then use ``pipe`` pattern to pipe the result of that "
"future to the probe."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:56
msgid ""
"Instead of materializing to a future, we can use a :class:`Sink.actorRef` "
"that sends all incoming elements to the given :class:`ActorRef`. Now we can "
"use assertion methods on :class:`TestProbe` and expect elements one by one "
"as they arrive. We can also assert stream completion by expecting for "
"``onCompleteMessage`` which was given to :class:`Sink.actorRef`."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:64
msgid ""
"Similarly to :class:`Sink.actorRef` that provides control over received "
"elements, we can use :class:`Source.actorRef` and have full control over "
"elements to be sent."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:71
msgid "Streams TestKit"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:73
msgid ""
"You may have noticed various code patterns that emerge when testing stream "
"pipelines. Akka Stream has a separate :mod:`akka-stream-testkit` module that"
" provides tools specifically for writing stream tests. This module comes "
"with two main components that are :class:`TestSource` and :class:`TestSink` "
"which provide sources and sinks that materialize to probes that allow fluent"
" API."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:81
msgid ""
"Be sure to add the module :mod:`akka-stream-testkit` to your dependencies."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:83
msgid ""
"A sink returned by ``TestSink.probe`` allows manual control over demand and "
"assertions over elements coming downstream."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:88
msgid ""
"A source returned by ``TestSource.probe`` can be used for asserting demand "
"or controlling when stream is completed or ended with an error."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:93
msgid ""
"You can also inject exceptions and test sink behaviour on error conditions."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:97
msgid ""
"Test source and sink can be used together in combination when testing flows."
msgstr ""

#: ../../scala/stream/stream-testkit.rst:103
msgid "Fuzzing Mode"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:105
msgid ""
"For testing, it is possible to enable a special stream execution mode that "
"exercises concurrent execution paths more aggressively (at the cost of "
"reduced performance) and therefore helps exposing race conditions in tests. "
"To enable this setting add the following line to your configuration:"
msgstr ""

#: ../../scala/stream/stream-testkit.rst:116
msgid ""
"Never use this setting in production or benchmarks. This is a testing tool "
"to provide more coverage of your code during tests, but it reduces the "
"throughput of streams. A warning message will be logged if you have this "
"setting enabled."
msgstr ""
