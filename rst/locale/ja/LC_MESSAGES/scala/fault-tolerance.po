# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kazuki Negoro <negokaz@gmail.com>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/fault-tolerance.rst:4
msgid "Fault Tolerance"
msgstr "耐障害性"

#: ../../scala/fault-tolerance.rst:6
msgid ""
"As explained in :ref:`actor-systems` each actor is the supervisor of its "
"children, and as such each actor defines fault handling supervisor strategy."
" This strategy cannot be changed afterwards as it is an integral part of the"
" actor system’s structure."
msgstr ""
":ref:`actor-systems` "
"で説明した通り、各アクターは自身の子供のスーパーバイザであり、障害をハンドリングするためのスーパーバイザ戦略を定義しています。この戦略はアクターシステムに不可欠な部品であるため後から変更することはできません。"

#: ../../scala/fault-tolerance.rst:12
msgid "Fault Handling in Practice"
msgstr "障害ハンドリングの実践"

#: ../../scala/fault-tolerance.rst:14
msgid ""
"First, let us look at a sample that illustrates one way to handle data store"
" errors, which is a typical source of failure in real world applications. Of"
" course it depends on the actual application what is possible to do when the"
" data store is unavailable, but in this sample we use a best effort re-"
"connect approach."
msgstr ""
"まず、実際のアプリケーションでの典型的な障害原因であるデータストアのエラーを処理する方法の 1 つを示すサンプルを見てみましょう。 "
"もちろん、データストアが利用できないときに何ができるかは実際のアプリケーションに依存しますが、このサンプルでは、ベストエフォートの再接続アプローチを用います。"

#: ../../scala/fault-tolerance.rst:19
msgid ""
"Read the following source code. The inlined comments explain the different "
"pieces of the fault handling and why they are added. It is also highly "
"recommended to run this sample as it is easy to follow the log output to "
"understand what is happening at runtime."
msgstr ""
"次のソースコードを読んでください。 インラインコメントはさまざまな障害ハンドリングと、なぜそれらが追加されたのかを説明します。 "
"実行時に何が起こっているかを理解するためにはログの出力を追うのが簡単なので、このサンプルを実行することを強くお勧めします。"

#: ../../scala/fault-tolerance.rst:28
msgid "Creating a Supervisor Strategy"
msgstr "スーパーバイザー戦略を作成する"

#: ../../scala/fault-tolerance.rst:30
msgid ""
"The following sections explain the fault handling mechanism and alternatives"
" in more depth."
msgstr "以下のセクションでは、障害ハンドリングのメカニズムとその代替方法について詳しく説明します。"

#: ../../scala/fault-tolerance.rst:33
msgid "For the sake of demonstration let us consider the following strategy:"
msgstr "デモンストレーションのために、次の戦略を考えてみましょう。"

#: ../../scala/fault-tolerance.rst:38
msgid ""
"I have chosen a few well-known exception types in order to demonstrate the "
"application of the fault handling directives described in "
":ref:`supervision`. First off, it is a one-for-one strategy, meaning that "
"each child is treated separately (an all-for-one strategy works very "
"similarly, the only difference is that any decision is applied to all "
"children of the supervisor, not only the failing one). There are limits set "
"on the restart frequency, namely maximum 10 restarts per minute; each of "
"these settings could be left out, which means that the respective limit does"
" not apply, leaving the possibility to specify an absolute upper limit on "
"the restarts or to make the restarts work infinitely. The child actor is "
"stopped if the limit is exceeded."
msgstr ""
"私は、 ref:`supervision` "
"に記述されている障害ハンドリングのディレクティブの適用をデモするために、いくつかのよく知られた例外タイプを選びました。 まず、one-for-one "
"戦略については、それぞれの子が別々に扱われることを意味します (all-for-one "
"戦略は非常によく似ていますが、唯一の違いは障害が起きたものだけでなく、スーパーバイザーのすべての子に適用されるということです) 。 "
"再起動の頻度には上限が設定されています。つまり、1 分あたり最大 10 回再起動します。 "
"これらの設定は省略することができます。その場合はそれぞれの制限が適用されず、再起動時に上限の絶対値を指定するか、再起動を無期限に実行させることができます。上限を超えると、子アクターは停止します。"

#: ../../scala/fault-tolerance.rst:49
msgid ""
"The match statement which forms the bulk of the body is of type ``Decider``,"
" which is a ``PartialFunction[Throwable, Directive]``. This is the piece "
"which maps child failure types to their corresponding directives."
msgstr ""
"本体の大部分を形成する match 文は ``Decider`` 型で、 ``PartialFunction[Throwable, "
"Directive]`` です。これは、子の障害のタイプから対応するディレクティブにマッピングする部分です。"

#: ../../scala/fault-tolerance.rst:55
msgid ""
"If the strategy is declared inside the supervising actor (as opposed to "
"within a companion object) its decider has access to all internal state of "
"the actor in a thread-safe fashion, including obtaining a reference to the "
"currently failed child (available as the ``sender`` of the failure message)."
msgstr ""
"戦略がスーパーバイザーのアクターの内部で宣言されている場合 (コンパニオンオブジェクト内ではなく) 、その決定者は、今障害が起きた子の参照を "
"(障害メッセージの ``sender`` から) 取得することができ、スレッドセーフな方法でアクターの内部状態にアクセスすることもできます 。"

#: ../../scala/fault-tolerance.rst:61
msgid "Default Supervisor Strategy"
msgstr "デフォルトのスーパーバイザー戦略"

#: ../../scala/fault-tolerance.rst:63
msgid ""
"``Escalate`` is used if the defined strategy doesn't cover the exception "
"that was thrown."
msgstr "``Escalate`` は定義された戦略がスローされた例外を処理しない場合に使われます。"

#: ../../scala/fault-tolerance.rst:65
msgid ""
"When the supervisor strategy is not defined for an actor the following "
"exceptions are handled by default:"
msgstr "スーパーバイザー戦略がアクターに対して定義されていない場合、デフォルトで次の例外が処理されます。"

#: ../../scala/fault-tolerance.rst:68
msgid "``ActorInitializationException`` will stop the failing child actor"
msgstr "``ActorInitializationException`` は障害の起きた子アクターを停止します"

#: ../../scala/fault-tolerance.rst:69
msgid "``ActorKilledException`` will stop the failing child actor"
msgstr "``ActorKilledException`` は障害の起きた子アクターを停止します"

#: ../../scala/fault-tolerance.rst:70
msgid "``Exception`` will restart the failing child actor"
msgstr "``Exception`` は障害の起きた子アクターを再起動します"

#: ../../scala/fault-tolerance.rst:71
msgid "Other types of ``Throwable`` will be escalated to parent actor"
msgstr "他の型の ``Throwable`` は親のアクターにエスカレーションされます"

#: ../../scala/fault-tolerance.rst:73
msgid ""
"If the exception escalate all the way up to the root guardian it will handle"
" it in the same way as the default strategy defined above."
msgstr "例外がルートガーディアンにまでエスカレーションされると、上記で定義されたデフォルトの戦略と同じ方法で処理されます。"

#: ../../scala/fault-tolerance.rst:76
msgid "You can combine your own strategy with the default strategy:"
msgstr "独自の戦略とデフォルトの戦略を組み合わせることもできます。"

#: ../../scala/fault-tolerance.rst:82
msgid "Stopping Supervisor Strategy"
msgstr "停止のスーパーバイザー戦略"

#: ../../scala/fault-tolerance.rst:84
msgid ""
"Closer to the Erlang way is the strategy to just stop children when they "
"fail and then take corrective action in the supervisor when DeathWatch "
"signals the loss of the child. This strategy is also provided pre-packaged "
"as :obj:`SupervisorStrategy.stoppingStrategy` with an accompanying "
":class:`StoppingSupervisorStrategy` configurator to be used when you want "
"the ``\"/user\"`` guardian to apply it."
msgstr ""
"Erlang に似た方法として、障害が起きた子を停止し、DeathWatch "
"が子の損失を知らせたときにスーパーバイザーで是正措置をとるという戦略があります。この戦略は、 ``''/user''`` "
"ガーディアンで適用したいときのために obj:` SupervisorStrategy.stoppingStrategy` として "
":class:`StoppingSupervisorStrategy` コンフィグレーターと一緒にあらかじめパッケージされて提供されています。"

#: ../../scala/fault-tolerance.rst:92
msgid "Logging of Actor Failures"
msgstr "アクターの障害をロギングする"

#: ../../scala/fault-tolerance.rst:94
msgid ""
"By default the ``SupervisorStrategy`` logs failures unless they are "
"escalated. Escalated failures are supposed to be handled, and potentially "
"logged, at a level higher in the hierarchy."
msgstr ""
"デフォルトでは、 ``SupervisorStrategy`` はエスカレーションされない限り障害を記録します。 "
"エスカレーションされた障害は、階層内の上位レベルで処理され、潜在的にログに記録されることになっています。"

#: ../../scala/fault-tolerance.rst:98
msgid ""
"You can mute the default logging of a ``SupervisorStrategy`` by setting "
"``loggingEnabled`` to ``false`` when instantiating it. Customized logging "
"can be done inside the ``Decider``. Note that the reference to the currently"
" failed child is available as the ``sender`` when the ``SupervisorStrategy``"
" is declared inside the supervising actor."
msgstr ""
"``SupervisorStrategy`` のデフォルトのログをミュートするには、インスタンス化するときに  `` loggingEnabled`` "
"を`` false``に設定します。 カスタマイズされたロギングは ``Decider`` の中で行うことができます。 障害が起きた子への参照は、 "
"``SupervisorStrategy`` がスーパーバイザーアクターの内部で宣言されたときに ``sender`` "
"として利用できることを知っておいてください。"

#: ../../scala/fault-tolerance.rst:104
msgid ""
"You may also customize the logging in your own ``SupervisorStrategy`` "
"implementation by overriding the ``logFailure`` method."
msgstr ""
"独自の ``SupervisorStrategy`` 実装で ``logFailure`` "
"メソッドをオーバーライドすることで、ログをカスタマイズすることもできます。"

#: ../../scala/fault-tolerance.rst:108
msgid "Supervision of Top-Level Actors"
msgstr "トップレベルアクターのスーパービジョン"

#: ../../scala/fault-tolerance.rst:110
msgid ""
"Toplevel actors means those which are created using ``system.actorOf()``, "
"and they are children of the :ref:`User Guardian <user-guardian>`. There are"
" no special rules applied in this case, the guardian simply applies the "
"configured strategy."
msgstr ""
"トップレベルアクターは、 ``system.actorOf()`` を使って作成されたアクターを意味し、 :ref:`User Guardian "
"<user-guardian>` の子です。 この場合、特別なルールは適用されません。ガーディアンは構成済みの戦略を適用するだけです。"

#: ../../scala/fault-tolerance.rst:116
msgid "Test Application"
msgstr "アプリケーションをテストする"

#: ../../scala/fault-tolerance.rst:118
msgid ""
"The following section shows the effects of the different directives in "
"practice, where a test setup is needed. First off, we need a suitable "
"supervisor:"
msgstr ""
"次のセクションでは、異なるディレクティブの効果を実際に示しますが、そのためにはテストのセットアップが必要です。 まず、適切なスーパーバイザーが必要です。"

#: ../../scala/fault-tolerance.rst:124
msgid ""
"This supervisor will be used to create a child, with which we can "
"experiment:"
msgstr "このスーパーバイザーは子を作るために使用され、それを実験することができます:"

#: ../../scala/fault-tolerance.rst:129
msgid ""
"The test is easier by using the utilities described in :ref:`akka-testkit`."
msgstr "テストは、 :ref:`akka-testkit` で説明されているユーティリティを使うと簡単にできます。"

#: ../../scala/fault-tolerance.rst:134
msgid "Let us create actors:"
msgstr "アクターを作成してみましょう:"

#: ../../scala/fault-tolerance.rst:139
msgid ""
"The first test shall demonstrate the ``Resume`` directive, so we try it out "
"by setting some non-initial state in the actor and have it fail:"
msgstr "最初のテストでは ``Resume`` ディレクティブをデモするために、アクターの非初期状態をいくつか設定して障害を起こしてみましょう。"

#: ../../scala/fault-tolerance.rst:145
msgid ""
"As you can see the value 42 survives the fault handling directive. Now, if "
"we change the failure to a more serious ``NullPointerException``, that will "
"no longer be the case:"
msgstr ""
"ご覧のように、42 という値が障害ハンドリングのディレクティブに残っています。より深刻な ``NullPointerException`` "
"に障害を変更すると、もはやそれはなくなります。"

#: ../../scala/fault-tolerance.rst:152
msgid ""
"And finally in case of the fatal ``IllegalArgumentException`` the child will"
" be terminated by the supervisor:"
msgstr "最後に、致命的な `` IllegalArgumentException``の場合、子プロセスはスーパーバイザによって終了されます："

#: ../../scala/fault-tolerance.rst:158
msgid ""
"Up to now the supervisor was completely unaffected by the child’s failure, "
"because the directives set did handle it. In case of an ``Exception``, this "
"is not true anymore and the supervisor escalates the failure."
msgstr ""
"今のところ監督者は、子供の失敗によって全く影響を受けませんでした。 「例外」の場合、これはもはや真実ではなく、監督者は失敗をエスカレートする。"

#: ../../scala/fault-tolerance.rst:165
msgid ""
"The supervisor itself is supervised by the top-level actor provided by the "
":class:`ActorSystem`, which has the default policy to restart in case of all"
" ``Exception`` cases (with the notable exceptions of "
"``ActorInitializationException`` and ``ActorKilledException``). Since the "
"default directive in case of a restart is to kill all children, we expected "
"our poor child not to survive this failure."
msgstr ""
"スーパーバイザ自体は：class： `ActorSystem`によって提供されるトップレベルのアクタによって監督されます。これは、すべての` "
"`Exception``ケース（例外的に` `ActorInitializationException``の例外があります。 `` "
"ActorKilledException``）。 "
"再起動の場合のデフォルトの指示はすべての子を殺すことであるため、私たちは貧しい子供がこの失敗から生き残らないことを期待しました。"

#: ../../scala/fault-tolerance.rst:172
msgid ""
"In case this is not desired (which depends on the use case), we need to use "
"a different supervisor which overrides this behavior."
msgstr "これが望ましくない場合（ユースケースに依存します）、この動作を無効にする別のスーパーバイザーを使用する必要があります。"

#: ../../scala/fault-tolerance.rst:178
msgid ""
"With this parent, the child survives the escalated restart, as demonstrated "
"in the last test:"
msgstr "この親を使用すると、最後のテストで示されているように、エスカレートされた再起動が生き残ります。"
