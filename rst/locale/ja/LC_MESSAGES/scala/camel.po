# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-03 22:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../scala/camel.rst:6
msgid "Camel"
msgstr ""

#: ../../scala/camel.rst:9
msgid "Introduction"
msgstr ""

#: ../../scala/camel.rst:11
msgid ""
"The akka-camel module allows Untyped Actors to receive and send messages "
"over a great variety of protocols and APIs. In addition to the native "
"Scala and Java actor API, actors can now exchange messages with other "
"systems over large number of protocols and APIs such as HTTP, SOAP, TCP, "
"FTP, SMTP or JMS, to mention a few. At the moment, approximately 80 "
"protocols and APIs are supported."
msgstr ""

#: ../../scala/camel.rst:18
msgid "Apache Camel"
msgstr ""

#: ../../scala/camel.rst:19
msgid ""
"The akka-camel module is based on `Apache Camel`_, a powerful and light-"
"weight integration framework for the JVM. For an introduction to Apache "
"Camel you may want to read this `Apache Camel article`_. Camel comes with"
" a large number of `components`_ that provide bindings to different "
"protocols and APIs. The `camel-extra`_ project provides further "
"components."
msgstr ""

#: ../../scala/camel.rst:31
msgid "Consumer"
msgstr ""

#: ../../scala/camel.rst:32
msgid ""
"Usage of Camel's integration components in Akka is essentially a one-"
"liner. Here's an example."
msgstr ""

#: ../../scala/camel.rst:37
msgid ""
"The above example exposes an actor over a TCP endpoint via Apache Camel's"
" `Mina component`_. The actor implements the endpointUri method to define"
" an endpoint from which it can receive messages. After starting the "
"actor, TCP clients can immediately send messages to and receive responses"
" from that actor. If the message exchange should go over HTTP (via "
"Camel's `Jetty component`_), only the actor's endpointUri method must be "
"changed."
msgstr ""

#: ../../scala/camel.rst:50
msgid "Producer"
msgstr ""

#: ../../scala/camel.rst:51
msgid ""
"Actors can also trigger message exchanges with external systems i.e. "
"produce to Camel endpoints."
msgstr ""

#: ../../scala/camel.rst:57
msgid ""
"In the above example, any message sent to this actor will be sent to the "
"JMS queue ``orders``. Producer actors may choose from the same set of "
"Camel components as Consumer actors do."
msgstr ""

#: ../../scala/camel.rst:62
msgid "CamelMessage"
msgstr ""

#: ../../scala/camel.rst:63
msgid ""
"The number of Camel components is constantly increasing. The akka-camel "
"module can support these in a plug-and-play manner. Just add them to your"
" application's classpath, define a component-specific endpoint URI and "
"use it to exchange messages over the component-specific protocols or "
"APIs. This is possible because Camel components bind protocol-specific "
"message formats to a Camel-specific `normalized message format`__. The "
"normalized message format hides protocol-specific details from Akka and "
"makes it therefore very easy to support a large number of protocols "
"through a uniform Camel component interface. The akka-camel module "
"further converts mutable Camel messages into immutable representations "
"which are used by Consumer and Producer actors for pattern matching, "
"transformation, serialization or storage. In the above example of the "
"Orders Producer, the XML message is put in the body of a newly created "
"Camel Message with an empty set of headers. You can also create a "
"CamelMessage yourself with the appropriate body and headers as you see "
"fit."
msgstr ""

#: ../../scala/camel.rst:80
msgid "CamelExtension"
msgstr ""

#: ../../scala/camel.rst:81
msgid ""
"The akka-camel module is implemented as an Akka Extension, the "
"``CamelExtension`` object. Extensions will only be loaded once per "
"``ActorSystem``, which will be managed by Akka. The ``CamelExtension`` "
"object provides access to the `Camel`_ trait. The `Camel`_ trait in turn "
"provides access to two important Apache Camel objects, the "
"`CamelContext`_ and the `ProducerTemplate`_. Below you can see how you "
"can get access to these Apache Camel objects."
msgstr ""

#: ../../scala/camel.rst:89
msgid ""
"One ``CamelExtension`` is only loaded once for every one ``ActorSystem``,"
" which makes it safe to call the ``CamelExtension`` at any point in your "
"code to get to the Apache Camel objects associated with it. There is one "
"`CamelContext`_ and one `ProducerTemplate`_ for every one ``ActorSystem``"
" that uses a ``CamelExtension``. By Default, a new `CamelContext`_ is "
"created when the ``CamelExtension`` starts. If you want to inject your "
"own context instead, you can extend the `ContextProvider`_ trait and add "
"the FQCN of your implementation in the config, as the value of the "
"\"akka.camel.context-provider\". This interface define a single method "
"``getContext`` used to load the `CamelContext`_."
msgstr ""

#: ../../scala/camel.rst:97
msgid ""
"Below an example on how to add the ActiveMQ component to the "
"`CamelContext`_, which is required when you would like to use the "
"ActiveMQ component."
msgstr ""

#: ../../scala/camel.rst:101
msgid ""
"The `CamelContext`_ joins the lifecycle of the ``ActorSystem`` and "
"``CamelExtension`` it is associated with; the `CamelContext`_ is started "
"when the ``CamelExtension`` is created, and it is shut down when the "
"associated ``ActorSystem`` is shut down. The same is true for the "
"`ProducerTemplate`_."
msgstr ""

#: ../../scala/camel.rst:104
msgid ""
"The ``CamelExtension`` is used by both `Producer` and `Consumer` actors "
"to interact with Apache Camel internally. You can access the "
"``CamelExtension`` inside a `Producer` or a `Consumer` using the "
"``camel`` definition, or get straight at the `CamelContext` using the "
"``camelContext`` definition. Actors are created and started "
"asynchronously. When a `Consumer` actor is created, the `Consumer` is "
"published at its Camel endpoint (more precisely, the route is added to "
"the `CamelContext`_ from the `Endpoint`_ to the actor). When a `Producer`"
" actor is created, a `SendProcessor`_ and `Endpoint`_ are created so that"
" the Producer can send messages to it. Publication is done "
"asynchronously; setting up an endpoint may still be in progress after you"
" have requested the actor to be created. Some Camel components can take a"
" while to startup, and in some cases you might want to know when the "
"endpoints are activated and ready to be used. The `Camel`_ trait allows "
"you to find out when the endpoint is activated or deactivated."
msgstr ""

#: ../../scala/camel.rst:114
msgid ""
"The above code shows that you can get a ``Future`` to the activation of "
"the route from the endpoint to the actor, or you can wait in a blocking "
"fashion on the activation of the route. An ``ActivationTimeoutException``"
" is thrown if the endpoint could not be activated within the specified "
"timeout. Deactivation works in a similar fashion:"
msgstr ""

#: ../../scala/camel.rst:119
msgid ""
"Deactivation of a Consumer or a Producer actor happens when the actor is "
"terminated. For a Consumer, the route to the actor is stopped. For a "
"Producer, the `SendProcessor`_ is stopped. A "
"``DeActivationTimeoutException`` is thrown if the associated camel "
"objects could not be deactivated within the specified timeout."
msgstr ""

#: ../../scala/camel.rst:129
msgid "Consumer Actors"
msgstr ""

#: ../../scala/camel.rst:131
msgid ""
"For objects to receive messages, they must mixin the `Consumer`_ trait. "
"For example, the following actor class (Consumer1) implements the "
"endpointUri method, which is declared in the Consumer trait, in order to "
"receive messages from the ``file:data/input/actor`` Camel endpoint."
msgstr ""

#: ../../scala/camel.rst:140
msgid ""
"Whenever a file is put into the data/input/actor directory, its content "
"is picked up by the Camel `file component`_ and sent as message to the "
"actor. Messages consumed by actors from Camel endpoints are of type "
"`CamelMessage`_. These are immutable representations of Camel messages."
msgstr ""

#: ../../scala/camel.rst:149
msgid ""
"Here's another example that sets the endpointUri to "
"``jetty:http://localhost:8877/camel/default``. It causes Camel's `Jetty "
"component`_ to start an embedded `Jetty`_ server, accepting HTTP "
"connections from localhost on port 8877."
msgstr ""

#: ../../scala/camel.rst:159
msgid ""
"After starting the actor, clients can send messages to that actor by "
"POSTing to ``http://localhost:8877/camel/default``. The actor sends a "
"response by using the sender `!` method. For returning a message body and"
" headers to the HTTP client the response type should be `CamelMessage`_. "
"For any other response type, a new CamelMessage object is created by "
"akka-camel with the actor response as message body."
msgstr ""

#: ../../scala/camel.rst:171
msgid "Delivery acknowledgements"
msgstr ""

#: ../../scala/camel.rst:173
msgid ""
"With in-out message exchanges, clients usually know that a message "
"exchange is done when they receive a reply from a consumer actor. The "
"reply message can be a CamelMessage (or any object which is then "
"internally converted to a CamelMessage) on success, and a Failure message"
" on failure."
msgstr ""

#: ../../scala/camel.rst:178
msgid ""
"With in-only message exchanges, by default, an exchange is done when a "
"message is added to the consumer actor's mailbox. Any failure or "
"exception that occurs during processing of that message by the consumer "
"actor cannot be reported back to the endpoint in this case. To allow "
"consumer actors to positively or negatively acknowledge the receipt of a "
"message from an in-only message exchange, they need to override the "
"``autoAck`` method to return false. In this case, consumer actors must "
"reply either with a special akka.camel.Ack message (positive "
"acknowledgement) or a akka.actor.Status.Failure (negative "
"acknowledgement)."
msgstr ""

#: ../../scala/camel.rst:193
msgid "Consumer timeout"
msgstr ""

#: ../../scala/camel.rst:195
msgid ""
"Camel Exchanges (and their corresponding endpoints) that support two-way "
"communications need to wait for a response from an actor before returning"
" it to the initiating client. For some endpoint types, timeout values can"
" be defined in an endpoint-specific way which is described in the "
"documentation of the individual `Camel components`_. Another option is to"
" configure timeouts on the level of consumer actors."
msgstr ""

#: ../../scala/camel.rst:203
msgid ""
"Two-way communications between a Camel endpoint and an actor are "
"initiated by sending the request message to the actor with the `ask`_ "
"pattern and the actor replies to the endpoint when the response is ready."
" The ask request to the actor can timeout, which will result in the "
"`Exchange`_ failing with a TimeoutException set on the failure of the "
"`Exchange`_. The timeout on the consumer actor can be overridden with the"
" ``replyTimeout``, as shown below."
msgstr ""

#: ../../scala/camel.rst:214
msgid "Producer Actors"
msgstr ""

#: ../../scala/camel.rst:216
msgid ""
"For sending messages to Camel endpoints, actors need to mixin the "
"`Producer`_ trait and implement the endpointUri method."
msgstr ""

#: ../../scala/camel.rst:220
msgid ""
"Producer1 inherits a default implementation of the receive method from "
"the Producer trait. To customize a producer actor's default behavior you "
"must override the `Producer`_.transformResponse and "
"`Producer`_.transformOutgoingMessage methods. This is explained later in "
"more detail. Producer Actors cannot override the default "
"`Producer`_.receive method."
msgstr ""

#: ../../scala/camel.rst:225
msgid ""
"Any message sent to a `Producer`_ actor will be sent to the associated "
"Camel endpoint, in the above example to ``http://localhost:8080/news``. "
"The `Producer`_ always sends messages asynchronously. Response messages "
"(if supported by the configured endpoint) will, by default, be returned "
"to the original sender. The following example uses the ask pattern to "
"send a message to a Producer actor and waits for a response."
msgstr ""

#: ../../scala/camel.rst:234
msgid ""
"The future contains the response CamelMessage, or an "
"``AkkaCamelException`` when an error occurred, which contains the headers"
" of the response."
msgstr ""

#: ../../scala/camel.rst:239
msgid "Custom Processing"
msgstr ""

#: ../../scala/camel.rst:241
msgid ""
"Instead of replying to the initial sender, producer actors can implement "
"custom response processing by overriding the routeResponse method. In the"
" following example, the response message is forwarded to a target actor "
"instead of being replied to the original sender."
msgstr ""

#: ../../scala/camel.rst:248
msgid ""
"Before producing messages to endpoints, producer actors can pre-process "
"them by overriding the `Producer`_.transformOutgoingMessage method."
msgstr ""

#: ../../scala/camel.rst:254
msgid "Producer configuration options"
msgstr ""

#: ../../scala/camel.rst:256
msgid ""
"The interaction of producer actors with Camel endpoints can be configured"
" to be one-way or two-way (by initiating in-only or in-out message "
"exchanges, respectively). By default, the producer initiates an in-out "
"message exchange with the endpoint. For initiating an in-only exchange, "
"producer actors have to override the oneway method to return true."
msgstr ""

#: ../../scala/camel.rst:264
msgid "Message correlation"
msgstr ""

#: ../../scala/camel.rst:266
msgid ""
"To correlate request with response messages, applications can set the "
"`Message.MessageExchangeId` message header."
msgstr ""

#: ../../scala/camel.rst:272
msgid "ProducerTemplate"
msgstr ""

#: ../../scala/camel.rst:274
msgid ""
"The `Producer`_ trait is a very convenient way for actors to produce "
"messages to Camel endpoints. Actors may also use a Camel "
"`ProducerTemplate`_ for producing messages to endpoints."
msgstr ""

#: ../../scala/camel.rst:280
msgid ""
"For initiating a two-way message exchange, one of the "
"``ProducerTemplate.request*`` methods must be used."
msgstr ""

#: ../../scala/camel.rst:291
msgid "Asynchronous routing"
msgstr ""

#: ../../scala/camel.rst:293
msgid ""
"In-out message exchanges between endpoints and actors are designed to be "
"asynchronous. This is the case for both, consumer and producer actors."
msgstr ""

#: ../../scala/camel.rst:297
msgid ""
"A consumer endpoint sends request messages to its consumer actor using "
"the ``!`` (tell) operator and the actor returns responses with ``sender "
"!`` once they are ready."
msgstr ""

#: ../../scala/camel.rst:301
msgid ""
"A producer actor sends request messages to its endpoint using Camel's "
"asynchronous routing engine. Asynchronous responses are wrapped and added"
" to the producer actor's mailbox for later processing. By default, "
"response messages are returned to the initial sender but this can be "
"overridden by Producer implementations (see also description of the "
"``routeResponse`` method in :ref:`camel-custom-processing-scala`)."
msgstr ""

#: ../../scala/camel.rst:308
msgid ""
"However, asynchronous two-way message exchanges, without allocating a "
"thread for the full duration of exchange, cannot be generically supported"
" by Camel's asynchronous routing engine alone. This must be supported by "
"the individual `Camel components`_ (from which endpoints are created) as "
"well. They must be able to suspend any work started for request "
"processing (thereby freeing threads to do other work) and resume "
"processing when the response is ready. This is currently the case for a "
"`subset of components`_ such as the `Jetty component`_. All other Camel "
"components can still be used, of course, but they will cause allocation "
"of a thread for the duration of an in-out message exchange. There's also "
":ref:`camel-examples` that implements both, an asynchronous consumer and "
"an asynchronous producer, with the jetty component."
msgstr ""

#: ../../scala/camel.rst:320
msgid ""
"If the used Camel component is blocking it might be necessary to use a "
"separate :ref:`dispatcher <dispatchers-scala>` for the producer. The "
"Camel processor is invoked by a child actor of the producer and the "
"dispatcher can be defined in the deployment section of the configuration."
" For example, if your producer actor has path "
"``/user/integration/output`` the dispatcher of the child actor can be "
"defined with::"
msgstr ""

#: ../../scala/camel.rst:338
msgid "Custom Camel routes"
msgstr ""

#: ../../scala/camel.rst:340
msgid ""
"In all the examples so far, routes to consumer actors have been "
"automatically constructed by akka-camel, when the actor was started. "
"Although the default route construction templates, used by akka-camel "
"internally, are sufficient for most use cases, some applications may "
"require more specialized routes to actors. The akka-camel module provides"
" two mechanisms for customizing routes to actors, which will be explained"
" in this section. These are:"
msgstr ""

#: ../../scala/camel.rst:347
msgid ""
"Usage of :ref:`camel-components` to access actors. Any Camel route can "
"use these components to access Akka actors."
msgstr ""

#: ../../scala/camel.rst:350
msgid ""
":ref:`camel-intercepting-route-construction` to actors. This option gives"
" you the ability to change routes that have already been added to Camel. "
"Consumer actors have a hook into the route definition process which can "
"be used to change the route."
msgstr ""

#: ../../scala/camel.rst:358
msgid "Akka Camel components"
msgstr ""

#: ../../scala/camel.rst:360
msgid ""
"Akka actors can be accessed from Camel routes using the `actor`_ Camel "
"component. This component can be used to access any Akka actor (not only "
"consumer actors) from Camel routes, as described in the following "
"sections."
msgstr ""

#: ../../scala/camel.rst:368
msgid "Access to actors"
msgstr ""

#: ../../scala/camel.rst:370
msgid ""
"To access actors from custom Camel routes, the `actor`_ Camel component "
"should be used. It fully supports Camel's `asynchronous routing engine`_."
msgstr ""

#: ../../scala/camel.rst:377
msgid "This component accepts the following endpoint URI format:"
msgstr ""

#: ../../scala/camel.rst:379
msgid "``[<actor-path>]?<options>``"
msgstr ""

#: ../../scala/camel.rst:381
msgid ""
"where ``<actor-path>`` is the ``ActorPath`` to the actor. The "
"``<options>`` are name-value pairs separated by ``&`` (i.e. "
"``name1=value1&name2=value2&...``)."
msgstr ""

#: ../../scala/camel.rst:386
msgid "URI options"
msgstr ""

#: ../../scala/camel.rst:388
msgid "The following URI options are supported:"
msgstr ""

#: ../../scala/camel.rst:393
msgid "Name"
msgstr ""

#: ../../scala/camel.rst:393
msgid "Type"
msgstr ""

#: ../../scala/camel.rst:393
msgid "Default"
msgstr ""

#: ../../scala/camel.rst:393
msgid "Description"
msgstr ""

#: ../../scala/camel.rst:395
msgid "replyTimeout"
msgstr ""

#: ../../scala/camel.rst:395
msgid "Duration"
msgstr ""

#: ../../scala/camel.rst:395
msgid "false"
msgstr ""

#: ../../scala/camel.rst:395
msgid ""
"The reply timeout, specified in the same way that you use the duration in"
" akka, for instance ``10 seconds`` except that in the url it is handy to "
"use a + between the amount and the unit, like for example ``200+millis``"
msgstr ""

#: ../../scala/camel.rst:402
msgid "See also :ref:`camel-timeout`."
msgstr ""

#: ../../scala/camel.rst:404
msgid "autoAck"
msgstr ""

#: ../../scala/camel.rst:404
msgid "Boolean"
msgstr ""

#: ../../scala/camel.rst:404
msgid "true"
msgstr ""

#: ../../scala/camel.rst:404
msgid ""
"If set to true, in-only message exchanges are auto-acknowledged when the "
"message is added to the actor's mailbox. If set to false, actors must "
"acknowledge the receipt of the message."
msgstr ""

#: ../../scala/camel.rst:410
msgid "See also :ref:`camel-acknowledgements`."
msgstr ""

#: ../../scala/camel.rst:413
msgid "Here's an actor endpoint URI example containing an actor path::"
msgstr ""

#: ../../scala/camel.rst:417
msgid ""
"In the following example, a custom route to an actor is created, using "
"the actor's path. the Akka camel package contains an implicit "
"``toActorRouteDefinition`` that allows for a route to reference an "
"``ActorRef`` directly as shown in the below example, The route starts "
"from a `Jetty`_ endpoint and ends at the target actor."
msgstr ""

#: ../../scala/camel.rst:424
msgid ""
"When a message is received on the jetty endpoint, it is routed to the "
"Responder actor, which in return replies back to the client of the HTTP "
"request."
msgstr ""

#: ../../scala/camel.rst:431
msgid "Intercepting route construction"
msgstr ""

#: ../../scala/camel.rst:433
msgid ""
"The previous section, :ref:`camel-components`, explained how to setup a "
"route to an actor manually. It was the application's responsibility to "
"define the route and add it to the current CamelContext. This section "
"explains a more convenient way to define custom routes: akka-camel is "
"still setting up the routes to consumer actors (and adds these routes to "
"the current CamelContext) but applications can define extensions to these"
" routes. Extensions can be defined with Camel's `Java DSL`_ or `Scala "
"DSL`_. For example, an extension could be a custom error handler that "
"redelivers messages from an endpoint to an actor's bounded mailbox when "
"the mailbox was full."
msgstr ""

#: ../../scala/camel.rst:442
msgid ""
"The following examples demonstrate how to extend a route to a consumer "
"actor for handling exceptions thrown by that actor."
msgstr ""

#: ../../scala/camel.rst:447
msgid ""
"The above ErrorThrowingConsumer sends the Failure back to the sender in "
"preRestart because the Exception that is thrown in the actor would "
"otherwise just crash the actor, by default the actor would be restarted, "
"and the response would never reach the client of the Consumer."
msgstr ""

#: ../../scala/camel.rst:451
msgid ""
"The akka-camel module creates a RouteDefinition instance by calling "
"from(endpointUri) on a Camel RouteBuilder (where endpointUri is the "
"endpoint URI of the consumer actor) and passes that instance as argument "
"to the route definition handler \\*). The route definition handler then "
"extends the route and returns a ProcessorDefinition (in the above "
"example, the ProcessorDefinition returned by the end method. See the "
"`org.apache.camel.model`__ package for details). After executing the "
"route definition handler, akka-camel finally calls a to(targetActorUri) "
"on the returned ProcessorDefinition to complete the route to the consumer"
" actor (where targetActorUri is the actor component URI as described in "
":ref:`access-to-actors`). If the actor cannot be found, a "
"`ActorNotRegisteredException` is thrown."
msgstr ""

#: ../../scala/camel.rst:462
msgid ""
"\\*) Before passing the RouteDefinition instance to the route definition "
"handler, akka-camel may make some further modifications to it."
msgstr ""

#: ../../scala/camel.rst:470
msgid "Examples"
msgstr ""

#: ../../scala/camel.rst:472
msgid ""
"The `Lightbend Activator <http://www.lightbend.com/platform/getstarted>`_"
" tutorial named `Akka Camel Samples with Scala "
"<http://www.lightbend.com/activator/template/akka-sample-camel-scala>`_ "
"contains 3 samples:"
msgstr ""

#: ../../scala/camel.rst:476
msgid ""
"Asynchronous routing and transformation - This example demonstrates how "
"to implement consumer and producer actors that support :ref:`camel-"
"asynchronous-routing` with their Camel endpoints."
msgstr ""

#: ../../scala/camel.rst:479
msgid ""
"Custom Camel route - Demonstrates the combined usage of a ``Producer`` "
"and a ``Consumer`` actor as well as the inclusion of a custom Camel "
"route."
msgstr ""

#: ../../scala/camel.rst:482
msgid ""
"Quartz Scheduler Example - Showing how simple is to implement a cron-"
"style scheduler by using the Camel Quartz component"
msgstr ""

#: ../../scala/camel.rst:486
msgid "Configuration"
msgstr ""

#: ../../scala/camel.rst:488
msgid ""
"There are several configuration properties for the Camel module, please "
"refer to the :ref:`reference configuration <config-akka-camel>`."
msgstr ""

#: ../../scala/camel.rst:492
msgid "Additional Resources"
msgstr ""

#: ../../scala/camel.rst:493
msgid ""
"For an introduction to akka-camel 2, see also the Peter Gabryanczyk's "
"talk `Migrating akka-camel module to Akka 2.x`_."
msgstr ""

#: ../../scala/camel.rst:495
msgid ""
"For an introduction to akka-camel 1, see also the `Appendix E - Akka and "
"Camel`_ (pdf) of the book `Camel in Action`_."
msgstr ""

#: ../../scala/camel.rst:502
msgid "Other, more advanced external articles (for version 1) are:"
msgstr ""

#: ../../scala/camel.rst:504
msgid ""
"`Akka Consumer Actors: New Features and Best Practices "
"<http://krasserm.blogspot.com/2011/02/akka-consumer-actors-new-features-"
"and.html>`_"
msgstr ""

#: ../../scala/camel.rst:505
msgid ""
"`Akka Producer Actors: New Features and Best Practices "
"<http://krasserm.blogspot.com/2011/02/akka-producer-actor-new-features-"
"and.html>`_"
msgstr ""

