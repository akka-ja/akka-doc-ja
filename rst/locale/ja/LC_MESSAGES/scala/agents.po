# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/agents.rst:5
msgid "Agents"
msgstr ""

#: ../../scala/agents.rst:7
msgid "Agents in Akka are inspired by `agents in Clojure`_."
msgstr ""

#: ../../scala/agents.rst:11
msgid ""
"Agents provide asynchronous change of individual locations. Agents are bound"
" to a single storage location for their lifetime, and only allow mutation of"
" that location (to a new state) to occur as a result of an action. Update "
"actions are functions that are asynchronously applied to the Agent's state "
"and whose return value becomes the Agent's new state. The state of an Agent "
"should be immutable."
msgstr ""

#: ../../scala/agents.rst:17
msgid ""
"While updates to Agents are asynchronous, the state of an Agent is always "
"immediately available for reading by any thread (using ``get`` or ``apply``)"
" without any messages."
msgstr ""

#: ../../scala/agents.rst:21
msgid ""
"Agents are reactive. The update actions of all Agents get interleaved "
"amongst threads in an ``ExecutionContext``. At any point in time, at most "
"one ``send`` action for each Agent is being executed. Actions dispatched to "
"an agent from another thread will occur in the order they were sent, "
"potentially interleaved with actions dispatched to the same agent from other"
" threads."
msgstr ""

#: ../../scala/agents.rst:29
msgid ""
"Agents are local to the node on which they are created. This implies that "
"you should generally not include them in messages that may be passed to "
"remote Actors or as constructor parameters for remote Actors; those remote "
"Actors will not be able to read or update the Agent."
msgstr ""

#: ../../scala/agents.rst:35
msgid "Creating Agents"
msgstr ""

#: ../../scala/agents.rst:37
msgid ""
"Agents are created by invoking ``Agent(value)`` passing in the Agent's "
"initial value and providing an implicit ``ExecutionContext`` to be used for "
"it, for these examples we're going to use the default global one, but YMMV:"
msgstr ""

#: ../../scala/agents.rst:44
msgid "Reading an Agent's value"
msgstr ""

#: ../../scala/agents.rst:46
msgid ""
"Agents can be dereferenced (you can get an Agent's value) by invoking the "
"Agent with parentheses like this:"
msgstr ""

#: ../../scala/agents.rst:51
msgid "Or by using the get method:"
msgstr ""

#: ../../scala/agents.rst:55
msgid ""
"Reading an Agent's current value does not involve any message passing and "
"happens immediately. So while updates to an Agent are asynchronous, reading "
"the state of an Agent is synchronous."
msgstr ""

#: ../../scala/agents.rst:60
msgid "Updating Agents (send & alter)"
msgstr ""

#: ../../scala/agents.rst:62
msgid ""
"You update an Agent by sending a function that transforms the current value "
"or by sending just a new value. The Agent will apply the new value or "
"function atomically and asynchronously. The update is done in a fire-forget "
"manner and you are only guaranteed that it will be applied. There is no "
"guarantee of when the update will be applied but dispatches to an Agent from"
" a single thread will occur in order. You apply a value or a function by "
"invoking the ``send`` function."
msgstr ""

#: ../../scala/agents.rst:72
msgid ""
"You can also dispatch a function to update the internal state but on its own"
" thread. This does not use the reactive thread pool and can be used for "
"long-running or blocking operations. You do this with the ``sendOff`` "
"method. Dispatches using either ``sendOff`` or ``send`` will still be "
"executed in order."
msgstr ""

#: ../../scala/agents.rst:80
msgid ""
"All ``send`` methods also have a corresponding ``alter`` method that returns"
" a ``Future``. See :ref:`futures-scala` for more information on ``Futures``."
msgstr ""

#: ../../scala/agents.rst:88
msgid "Awaiting an Agent's value"
msgstr ""

#: ../../scala/agents.rst:90
msgid ""
"You can also get a ``Future`` to the Agents value, that will be completed "
"after the currently queued updates have completed:"
msgstr ""

#: ../../scala/agents.rst:95
msgid "See :ref:`futures-scala` for more information on ``Futures``."
msgstr ""

#: ../../scala/agents.rst:98
msgid "Monadic usage"
msgstr ""

#: ../../scala/agents.rst:100
msgid ""
"Agents are also monadic, allowing you to compose operations using for-"
"comprehensions. In monadic usage, new Agents are created leaving the "
"original Agents untouched. So the old values (Agents) are still available "
"as-is. They are so-called 'persistent'."
msgstr ""

#: ../../scala/agents.rst:105
msgid "Example of monadic usage:"
msgstr ""

#: ../../scala/agents.rst:110
msgid "Configuration"
msgstr ""

#: ../../scala/agents.rst:112
msgid ""
"There are several configuration properties for the agents module, please "
"refer to the :ref:`reference configuration <config-akka-agent>`."
msgstr ""

#: ../../scala/agents.rst:116
msgid "Deprecated Transactional Agents"
msgstr ""

#: ../../scala/agents.rst:118
msgid ""
"Agents participating in enclosing STM transaction is a deprecated feature in"
" 2.3."
msgstr ""

#: ../../scala/agents.rst:120
msgid ""
"If an Agent is used within an enclosing transaction, then it will "
"participate in that transaction. If you send to an Agent within a "
"transaction then the dispatch to the Agent will be held until that "
"transaction commits, and discarded if the transaction is aborted. Here's an "
"example:"
msgstr ""
