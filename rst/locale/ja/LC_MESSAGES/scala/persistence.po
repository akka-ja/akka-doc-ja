# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-03 22:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../scala/persistence.rst:5
msgid "Persistence"
msgstr ""

#: ../../scala/persistence.rst:7
msgid ""
"Akka persistence enables stateful actors to persist their internal state "
"so that it can be recovered when an actor is started, restarted after a "
"JVM crash or by a supervisor, or migrated in a cluster. The key concept "
"behind Akka persistence is that only changes to an actor's internal state"
" are persisted but never its current state directly (except for optional "
"snapshots). These changes are only ever appended to storage, nothing is "
"ever mutated, which allows for very high transaction rates and efficient "
"replication. Stateful actors are recovered by replaying stored changes to"
" these actors from which they can rebuild internal state. This can be "
"either the full history of changes or starting from a snapshot which can "
"dramatically reduce recovery times. Akka persistence also provides point-"
"to-point communication with at-least-once message delivery semantics."
msgstr ""

#: ../../scala/persistence.rst:16
msgid ""
"Akka persistence is inspired by and the official replacement of the "
"`eventsourced`_ library. It follows the same concepts and architecture of"
" `eventsourced`_ but significantly differs on API and implementation "
"level. See also :ref:`migration-eventsourced-2.3`"
msgstr ""

#: ../../scala/persistence.rst:23
msgid "Dependencies"
msgstr ""

#: ../../scala/persistence.rst:25
msgid ""
"Akka persistence is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

#: ../../scala/persistence.rst:29
msgid ""
"The Akka persistence extension comes with few built-in persistence "
"plugins, including in-memory heap based journal, local file-system based "
"snapshot-store and LevelDB based journal."
msgstr ""

#: ../../scala/persistence.rst:32
msgid ""
"LevelDB based plugins will require the following additional dependency "
"declaration::"
msgstr ""

#: ../../scala/persistence.rst:38
msgid "Architecture"
msgstr ""

#: ../../scala/persistence.rst:40
msgid ""
"*PersistentActor*: Is a persistent, stateful actor. It is able to persist"
" events to a journal and can react to them in a thread-safe manner. It "
"can be used to implement both *command* as well as *event sourced* "
"actors. When a persistent actor is started or restarted, journaled "
"messages are replayed to that actor so that it can recover internal state"
" from these messages."
msgstr ""

#: ../../scala/persistence.rst:45
msgid ""
"*PersistentView*: A view is a persistent, stateful actor that receives "
"journaled messages that have been written by another persistent actor. A "
"view itself does not journal new messages, instead, it updates internal "
"state only from a persistent actor's replicated message stream."
msgstr ""

#: ../../scala/persistence.rst:49
msgid ""
"*AtLeastOnceDelivery*: To send messages with at-least-once delivery "
"semantics to destinations, also in case of sender and receiver JVM "
"crashes."
msgstr ""

#: ../../scala/persistence.rst:52
msgid ""
"*AsyncWriteJournal*: A journal stores the sequence of messages sent to a "
"persistent actor. An application can control which messages are journaled"
" and which are received by the persistent actor without being journaled. "
"Journal maintains *highestSequenceNr* that is increased on each message. "
"The storage backend of a journal is pluggable. The persistence extension "
"comes with a \"leveldb\" journal plugin, which writes to the local "
"filesystem. Replicated journals are available as `Community plugins`_."
msgstr ""

#: ../../scala/persistence.rst:57
msgid ""
"*Snapshot store*: A snapshot store persists snapshots of a persistent "
"actor's or a view's internal state. Snapshots are used for optimizing "
"recovery times. The storage backend of a snapshot store is pluggable. The"
" persistence extension comes with a \"local\" snapshot storage plugin, "
"which writes to the local filesystem. Replicated snapshot stores are "
"available as `Community plugins`_."
msgstr ""

#: ../../scala/persistence.rst:67
msgid "Event sourcing"
msgstr ""

#: ../../scala/persistence.rst:69
msgid ""
"The basic idea behind `Event Sourcing`_ is quite simple. A persistent "
"actor receives a (non-persistent) command which is first validated if it "
"can be applied to the current state. Here validation can mean anything, "
"from simple inspection of a command message's fields up to a conversation"
" with several external services, for example. If validation succeeds, "
"events are generated from the command, representing the effect of the "
"command. These events are then persisted and, after successful "
"persistence, used to change the actor's state. When the persistent actor "
"needs to be recovered, only the persisted events are replayed of which we"
" know that they can be successfully applied. In other words, events "
"cannot fail when being replayed to a persistent actor, in contrast to "
"commands. Event sourced actors may of course also process commands that "
"do not change application state such as query commands for example."
msgstr ""

#: ../../scala/persistence.rst:80
msgid ""
"Akka persistence supports event sourcing with the ``PersistentActor`` "
"trait. An actor that extends this trait uses the ``persist`` method to "
"persist and handle events. The behavior of a ``PersistentActor`` is "
"defined by implementing ``receiveRecover`` and ``receiveCommand``. This "
"is demonstrated in the following example."
msgstr ""

#: ../../scala/persistence.rst:86
msgid ""
"The example defines two data types, ``Cmd`` and ``Evt`` to represent "
"commands and events, respectively. The ``state`` of the "
"``ExamplePersistentActor`` is a list of persisted event data contained in"
" ``ExampleState``."
msgstr ""

#: ../../scala/persistence.rst:89
msgid ""
"The persistent actor's ``receiveRecover`` method defines how ``state`` is"
" updated during recovery by handling ``Evt`` and ``SnapshotOffer`` "
"messages. The persistent actor's ``receiveCommand`` method is a command "
"handler. In this example, a command is handled by generating two events "
"which are then persisted and handled. Events are persisted by calling "
"``persist`` with an event (or a sequence of events) as first argument and"
" an event handler as second argument."
msgstr ""

#: ../../scala/persistence.rst:94
msgid ""
"The ``persist`` method persists events asynchronously and the event "
"handler is executed for successfully persisted events. Successfully "
"persisted events are internally sent back to the persistent actor as "
"individual messages that trigger event handler executions. An event "
"handler may close over persistent actor state and mutate it. The sender "
"of a persisted event is the sender of the corresponding command. This "
"allows event handlers to reply to the sender of a command (not shown)."
msgstr ""

#: ../../scala/persistence.rst:100
msgid ""
"The main responsibility of an event handler is changing persistent actor "
"state using event data and notifying others about successful state "
"changes by publishing events."
msgstr ""

#: ../../scala/persistence.rst:103
msgid ""
"When persisting events with ``persist`` it is guaranteed that the "
"persistent actor will not receive further commands between the "
"``persist`` call and the execution(s) of the associated event handler. "
"This also holds for multiple ``persist`` calls in context of a single "
"command. Incoming messages are :ref:`stashed <internal-stash-scala>` "
"until the ``persist`` is completed."
msgstr ""

#: ../../scala/persistence.rst:108
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped. If persistence of an event is rejected before it is stored, e.g."
" due to serialization error, ``onPersistRejected`` will be invoked "
"(logging a warning by default) and the actor continues with the next "
"message."
msgstr ""

#: ../../scala/persistence.rst:113
msgid ""
"The easiest way to run this example yourself is to download `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_ and open the "
"tutorial named `Akka Persistence Samples with Scala "
"<http://www.lightbend.com/activator/template/akka-sample-persistence-"
"scala>`_. It contains instructions on how to run the "
"``PersistentActorExample``."
msgstr ""

#: ../../scala/persistence.rst:119
msgid ""
"It's also possible to switch between different command handlers during "
"normal processing and recovery with ``context.become()`` and "
"``context.unbecome()``. To get the actor into the same state after "
"recovery you need to take special care to perform the same state "
"transitions with ``become`` and ``unbecome`` in the ``receiveRecover`` "
"method as you would have done in the command handler. Note that when "
"using ``become`` from ``receiveRecover`` it will still only use the "
"``receiveRecover`` behavior when replaying the events. When replay is "
"completed it will use the new behavior."
msgstr ""

#: ../../scala/persistence.rst:127 ../../scala/persistence.rst:510
msgid "Identifiers"
msgstr ""

#: ../../scala/persistence.rst:129
msgid ""
"A persistent actor must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``persistenceId`` method."
msgstr ""

#: ../../scala/persistence.rst:137 ../../scala/persistence.rst:501
msgid "Recovery"
msgstr ""

#: ../../scala/persistence.rst:139
msgid ""
"By default, a persistent actor is automatically recovered on start and on"
" restart by replaying journaled messages. New messages sent to a "
"persistent actor during recovery do not interfere with replayed messages."
" They are cached and received by a persistent actor after recovery phase "
"completes."
msgstr ""

#: ../../scala/persistence.rst:144
msgid ""
"Accessing the ``sender()`` for replayed messages will always result in a "
"``deadLetters`` reference, as the original sender is presumed to be long "
"gone. If you indeed have to notify an actor during recovery in the "
"future, store its ``ActorPath`` explicitly in your persisted events."
msgstr ""

#: ../../scala/persistence.rst:149
msgid "Recovery customization"
msgstr ""

#: ../../scala/persistence.rst:151
msgid ""
"Applications may also customise how recovery is performed by returning a "
"customised ``Recovery`` object in the ``recovery`` method of a "
"``PersistentActor``, for example setting an upper bound to the replay "
"which allows the actor to be replayed to a certain point \"in the past\" "
"instead to its most up to date state:"
msgstr ""

#: ../../scala/persistence.rst:157
msgid ""
"Recovery can be disabled by returning ``Recovery.none()`` in the "
"``recovery`` method of a ``PersistentActor``:"
msgstr ""

#: ../../scala/persistence.rst:162
msgid "Recovery status"
msgstr ""

#: ../../scala/persistence.rst:164
msgid "A persistent actor can query its own recovery status via the methods"
msgstr ""

#: ../../scala/persistence.rst:168
msgid ""
"Sometimes there is a need for performing additional initialization when "
"the recovery has completed before processing any other message sent to "
"the persistent actor. The persistent actor will receive a special "
":class:`RecoveryCompleted` message right after recovery and before any "
"other received messages."
msgstr ""

#: ../../scala/persistence.rst:175
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal, ``onRecoveryFailure`` is called (logging the error by default) "
"and the actor will be stopped."
msgstr ""

#: ../../scala/persistence.rst:181
msgid "Internal stash"
msgstr ""

#: ../../scala/persistence.rst:183
msgid ""
"The persistent actor has a private :ref:`stash <stash-scala>` for "
"internally caching incoming messages during :ref:`recovery <recovery>` or"
" the ``persist\\persistAll`` method persisting events. You can still "
"use/inherit from the ``Stash`` interface. The internal stash cooperates "
"with the normal stash by hooking into ``unstashAll`` method and making "
"sure messages are unstashed properly to the internal stash to maintain "
"ordering guarantees."
msgstr ""

#: ../../scala/persistence.rst:188
msgid ""
"You should be careful to not send more messages to a persistent actor "
"than it can keep up with, otherwise the number of stashed messages will "
"grow without bounds. It can be wise to protect against "
"``OutOfMemoryError`` by defining a maximum stash capacity in the mailbox "
"configuration::"
msgstr ""

#: ../../scala/persistence.rst:194
msgid ""
"Note that the stash capacity is per actor. If you have many persistent "
"actors, e.g. when using cluster sharding, you may need to define a small "
"stash capacity to ensure that the total number of stashed messages in the"
" system don't consume too much memory. Additionally, The persistent actor"
" defines three strategies to handle failure when the internal stash "
"capacity is exceeded. The default overflow strategy is the "
"``ThrowOverflowExceptionStrategy``, which discards the current received "
"message and throws a ``StashOverflowException``, causing actor restart if"
" default supervision strategy is used. you can override the "
"``internalStashOverflowStrategy`` method to return "
"``DiscardToDeadLetterStrategy`` or ``ReplyToStrategy`` for any "
"\"individual\" persistent actor, or define the \"default\" for all "
"persistent actors by providing FQCN, which must be a subclass of "
"``StashOverflowStrategyConfigurator``, in the persistence configuration::"
msgstr ""

#: ../../scala/persistence.rst:207
msgid ""
"The ``DiscardToDeadLetterStrategy`` strategy also has a pre-packaged "
"companion configurator ``akka.persistence.DiscardConfigurator``."
msgstr ""

#: ../../scala/persistence.rst:210
msgid ""
"You can also query default strategy via the Akka persistence extension "
"singleton::"
msgstr ""

#: ../../scala/persistence.rst:215
msgid ""
"The bounded mailbox should be avoided in the persistent actor, by which "
"the messages come from storage backends may be discarded. You can use "
"bounded stash instead of it."
msgstr ""

#: ../../scala/persistence.rst:221
msgid "Relaxed local consistency requirements and high throughput use-cases"
msgstr ""

#: ../../scala/persistence.rst:223
msgid ""
"If faced with relaxed local consistency requirements and high throughput "
"demands sometimes ``PersistentActor`` and its ``persist`` may not be "
"enough in terms of consuming incoming Commands at a high rate, because it"
" has to wait until all Events related to a given Command are processed in"
" order to start processing the next Command. While this abstraction is "
"very useful for most cases, sometimes you may be faced with relaxed "
"requirements about consistency – for example you may want to process "
"commands as fast as you can, assuming that the Event will eventually be "
"persisted and handled properly in the background, retroactively reacting "
"to persistence failures if needed."
msgstr ""

#: ../../scala/persistence.rst:230
msgid ""
"The ``persistAsync`` method provides a tool for implementing high-"
"throughput persistent actors. It will *not* stash incoming Commands while"
" the Journal is still working on persisting and/or user code is executing"
" event callbacks."
msgstr ""

#: ../../scala/persistence.rst:233
msgid ""
"In the below example, the event callbacks may be called \"at any time\", "
"even after the next Command has been processed. The ordering between "
"events is still guaranteed (\"evt-b-1\" will be sent after \"evt-a-2\", "
"which will be sent after \"evt-a-1\" etc.)."
msgstr ""

#: ../../scala/persistence.rst:239
msgid ""
"In order to implement the pattern known as \"*command sourcing*\" simply "
"call ``persistAsync(cmd)(...)`` right away on all incoming messages and "
"handle them in the callback."
msgstr ""

#: ../../scala/persistence.rst:243
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) "
"in between the call to ``persistAsync`` and the journal has confirmed the"
" write."
msgstr ""

#: ../../scala/persistence.rst:249
msgid "Deferring actions until preceding persist handlers have executed"
msgstr ""

#: ../../scala/persistence.rst:251
msgid ""
"Sometimes when working with ``persistAsync`` you may find that it would "
"be nice to define some actions in terms of ''happens-after the previous "
"``persistAsync`` handlers have been invoked''. ``PersistentActor`` "
"provides an utility method called ``deferAsync``, which works similarly "
"to ``persistAsync`` yet does not persist the passed in event. It is "
"recommended to use it for *read* operations, and actions which do not "
"have corresponding events in your domain model."
msgstr ""

#: ../../scala/persistence.rst:256
msgid ""
"Using this method is very similar to the persist family of methods, yet "
"it does **not** persist the passed in event. It will be kept in memory "
"and used when invoking the handler."
msgstr ""

#: ../../scala/persistence.rst:261
msgid ""
"Notice that the ``sender()`` is **safe** to access in the handler "
"callback, and will be pointing to the original sender of the command for "
"which this ``deferAsync`` handler was called."
msgstr ""

#: ../../scala/persistence.rst:264
msgid "The calling side will get the responses in this (guaranteed) order:"
msgstr ""

#: ../../scala/persistence.rst:269
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) "
"in between the call to ``deferAsync`` and the journal has processed and "
"confirmed all preceding writes."
msgstr ""

#: ../../scala/persistence.rst:275
msgid "Nested persist calls"
msgstr ""

#: ../../scala/persistence.rst:276
msgid ""
"It is possible to call ``persist`` and ``persistAsync`` inside their "
"respective callback blocks and they will properly retain both the thread "
"safety (including the right value of ``sender()``) as well as stashing "
"guarantees."
msgstr ""

#: ../../scala/persistence.rst:279
msgid ""
"In general it is encouraged to create command handlers which do not need "
"to resort to nested event persisting, however there are situations where "
"it may be useful. It is important to understand the ordering of callback "
"execution in those situations, as well as their implication on the "
"stashing behaviour (that ``persist()`` enforces). In the following "
"example two persist calls are issued, and each of them issues another "
"persist inside its callback:"
msgstr ""

#: ../../scala/persistence.rst:286
msgid ""
"When sending two commands to this ``PersistentActor``, the persist "
"handlers will be executed in the following order:"
msgstr ""

#: ../../scala/persistence.rst:290
msgid ""
"First the \"outer layer\" of persist calls is issued and their callbacks "
"are applied. After these have successfully completed, the inner callbacks"
" will be invoked (once the events they are persisting have been confirmed"
" to be persisted by the journal). Only after all these handlers have been"
" successfully invoked will the next command be delivered to the "
"persistent Actor. In other words, the stashing of incoming commands that "
"is guaranteed by initially calling ``persist()`` on the outer layer is "
"extended until all nested ``persist`` callbacks have been handled."
msgstr ""

#: ../../scala/persistence.rst:296
msgid ""
"It is also possible to nest ``persistAsync`` calls, using the same "
"pattern:"
msgstr ""

#: ../../scala/persistence.rst:300
msgid ""
"In this case no stashing is happening, yet events are still persisted and"
" callbacks are executed in the expected order:"
msgstr ""

#: ../../scala/persistence.rst:304
msgid ""
"While it is possible to nest mixed ``persist`` and ``persistAsync`` with "
"keeping their respective semantics it is not a recommended practice, as "
"it may lead to overly complex nesting."
msgstr ""

#: ../../scala/persistence.rst:310
msgid "Failures"
msgstr ""

#: ../../scala/persistence.rst:312
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped."
msgstr ""

#: ../../scala/persistence.rst:315
msgid ""
"The reason that it cannot resume when persist fails is that it is unknown"
" if the event was actually persisted or not, and therefore it is in an "
"inconsistent state. Restarting on persistent failures will most likely "
"fail anyway since the journal is probably unavailable. It is better to "
"stop the actor and after a back-off timeout start it again. The "
"``akka.pattern.BackoffSupervisor`` actor is provided to support such "
"restarts."
msgstr ""

#: ../../scala/persistence.rst:323
msgid ""
"If persistence of an event is rejected before it is stored, e.g. due to "
"serialization error, ``onPersistRejected`` will be invoked (logging a "
"warning by default), and the actor continues with next message."
msgstr ""

#: ../../scala/persistence.rst:327
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal when the actor is started, ``onRecoveryFailure`` is called "
"(logging the error by default), and the actor will be stopped."
msgstr ""

#: ../../scala/persistence.rst:331
msgid "Atomic writes"
msgstr ""

#: ../../scala/persistence.rst:333
msgid ""
"Each event is of course stored atomically, but it is also possible to "
"store several events atomically by using the ``persistAll`` or "
"``persistAllAsync`` method. That means that all events passed to that "
"method are stored or none of them are stored if there is an error."
msgstr ""

#: ../../scala/persistence.rst:337
msgid ""
"The recovery of a persistent actor will therefore never be done partially"
" with only a subset of events persisted by `persistAll`."
msgstr ""

#: ../../scala/persistence.rst:340
msgid ""
"Some journals may not support atomic writes of several events and they "
"will then reject the ``persistAll`` command, i.e. ``onPersistRejected`` "
"is called with an exception (typically "
"``UnsupportedOperationException``)."
msgstr ""

#: ../../scala/persistence.rst:346
msgid "Batch writes"
msgstr ""

#: ../../scala/persistence.rst:348
msgid ""
"In order to optimize throughput when using ``persistAsync``, a persistent"
" actor internally batches events to be stored under high load before "
"writing them to the journal (as a single batch). The batch size is "
"dynamically determined by how many events are emitted during the time of "
"a journal round-trip: after sending a batch to the journal no further "
"batch can be sent before confirmation has been received that the previous"
" batch has been written. Batch writes are never timer-based which keeps "
"latencies at a minimum."
msgstr ""

#: ../../scala/persistence.rst:357
msgid "Message deletion"
msgstr ""

#: ../../scala/persistence.rst:359
msgid ""
"It is possible to delete all messages (journaled by a single persistent "
"actor) up to a specified sequence number; Persistent actors may call the "
"``deleteMessages`` method to this end."
msgstr ""

#: ../../scala/persistence.rst:362
msgid ""
"Deleting messages in event sourcing based applications is typically "
"either not used at all, or used in conjunction with :ref:`snapshotting "
"<snapshots>`, i.e. after a snapshot has been successfully stored, a "
"``deleteMessages(toSequenceNr)`` up until the sequence number of the data"
" held by that snapshot can be issued to safely delete the previous events"
" while still having access to the accumulated state during replays - by "
"loading the snapshot."
msgstr ""

#: ../../scala/persistence.rst:367
msgid ""
"The result of the ``deleteMessages`` request is signaled to the "
"persistent actor with a ``DeleteMessagesSuccess`` message if the delete "
"was successful or a ``DeleteMessagesFailure`` message if it failed."
msgstr ""

#: ../../scala/persistence.rst:370
msgid ""
"Message deletion doesn't affect the highest sequence number of the "
"journal, even if all messages were deleted from it after "
"``deleteMessages`` invocation."
msgstr ""

#: ../../scala/persistence.rst:373
msgid "Persistence status handling"
msgstr ""

#: ../../scala/persistence.rst:374
msgid "Persisting, deleting, and replaying messages can either succeed or fail."
msgstr ""

#: ../../scala/persistence.rst:377 ../../scala/persistence.rst:578
msgid "**Method**"
msgstr ""

#: ../../scala/persistence.rst:377 ../../scala/persistence.rst:578
msgid "**Success**"
msgstr ""

#: ../../scala/persistence.rst:377
msgid "**Failure / Rejection**"
msgstr ""

#: ../../scala/persistence.rst:377
msgid "**After failure handler invoked**"
msgstr ""

#: ../../scala/persistence.rst:379
msgid "``persist`` / ``persistAsync``"
msgstr ""

#: ../../scala/persistence.rst:379
msgid "persist handler invoked"
msgstr ""

#: ../../scala/persistence.rst:379
msgid "``onPersistFailure``"
msgstr ""

#: ../../scala/persistence.rst:379 ../../scala/persistence.rst:383
msgid "Actor is stopped."
msgstr ""

#: ../../scala/persistence.rst:381
msgid "``onPersistRejected``"
msgstr ""

#: ../../scala/persistence.rst:381 ../../scala/persistence.rst:385
msgid "No automatic actions."
msgstr ""

#: ../../scala/persistence.rst:383
msgid "``recovery``"
msgstr ""

#: ../../scala/persistence.rst:383
msgid "``RecoveryCompleted``"
msgstr ""

#: ../../scala/persistence.rst:383
msgid "``onRecoveryFailure``"
msgstr ""

#: ../../scala/persistence.rst:385
msgid "``deleteMessages``"
msgstr ""

#: ../../scala/persistence.rst:385
msgid "``DeleteMessagesSuccess``"
msgstr ""

#: ../../scala/persistence.rst:385
msgid "``DeleteMessagesFailure``"
msgstr ""

#: ../../scala/persistence.rst:388
msgid ""
"The most important operations (``persist`` and ``recovery``) have failure"
" handlers modelled as explicit callbacks which the user can override in "
"the ``PersistentActor``. The default implementations of these handlers "
"emit a log message (``error`` for persist/recovery failures, and "
"``warning`` for others), logging the failure cause and information about "
"which message caused the failure."
msgstr ""

#: ../../scala/persistence.rst:393
msgid ""
"For critical failures, such as recovery or persisting events failing, the"
" persistent actor will be stopped after the failure handler is invoked. "
"This is because if the underlying journal implementation is signalling "
"persistence failures it is most likely either failing completely or "
"overloaded and restarting right-away and trying to persist the event "
"again will most likely not help the journal recover – as it would likely "
"cause a `Thundering herd problem`_, as many persistent actors would "
"restart and try to persist their events again. Instead, using a "
"``BackoffSupervisor`` (as described in :ref:`failures-scala`) which "
"implements an exponential-backoff strategy which allows for more "
"breathing room for the journal to recover between restarts of the "
"persistent actor."
msgstr ""

#: ../../scala/persistence.rst:402
msgid ""
"Journal implementations may choose to implement a retry mechanism, e.g. "
"such that only after a write fails N number of times a persistence "
"failure is signalled back to the user. In other words, once a journal "
"returns a failure, it is considered *fatal* by Akka Persistence, and the "
"persistent actor which caused the failure will be stopped."
msgstr ""

#: ../../scala/persistence.rst:406
msgid ""
"Check the documentation of the journal implementation you are using for "
"details if/how it is using this technique."
msgstr ""

#: ../../scala/persistence.rst:413
msgid "Safely shutting down persistent actors"
msgstr ""

#: ../../scala/persistence.rst:415
msgid ""
"Special care should be given when shutting down persistent actors from "
"the outside. With normal Actors it is often acceptable to use the special"
" :ref:`PoisonPill <poison-pill-scala>` message to signal to an Actor that"
" it should stop itself once it receives this message – in fact this "
"message is handled automatically by Akka, leaving the target actor no way"
" to refuse stopping itself when given a poison pill."
msgstr ""

#: ../../scala/persistence.rst:420
msgid ""
"This can be dangerous when used with :class:`PersistentActor` due to the "
"fact that incoming commands are *stashed* while the persistent actor is "
"awaiting confirmation from the Journal that events have been written when"
" ``persist()`` was used. Since the incoming commands will be drained from"
" the Actor's mailbox and put into its internal stash while awaiting the "
"confirmation (thus, before calling the persist handlers) the Actor **may "
"receive and (auto)handle the PoisonPill before it processes the other "
"messages which have been put into its stash**, causing a pre-mature "
"shutdown of the Actor."
msgstr ""

#: ../../scala/persistence.rst:427
msgid ""
"Consider using explicit shut-down messages instead of :class:`PoisonPill`"
" when working with persistent actors."
msgstr ""

#: ../../scala/persistence.rst:429
msgid ""
"The example below highlights how messages arrive in the Actor's mailbox "
"and how they interact with its internal stashing mechanism when "
"``persist()`` is used. Notice the early stop behaviour that occurs when "
"``PoisonPill`` is used:"
msgstr ""

#: ../../scala/persistence.rst:439
msgid "Persistent Views"
msgstr ""

#: ../../scala/persistence.rst:443
msgid ""
"``PersistentView`` is deprecated. Use :ref:`persistence-query-scala` "
"instead. The corresponding query type is ``EventsByPersistenceId``. There"
" are several alternatives for connecting the ``Source`` to an actor "
"corresponding to a previous ``PersistentView`` actor:"
msgstr ""

#: ../../scala/persistence.rst:447
msgid ""
"`Sink.actorRef`_ is simple, but has the disadvantage that there is no "
"back-pressure signal from the destination actor, i.e. if the actor is not"
" consuming the messages fast enough the mailbox of the actor will grow"
msgstr ""

#: ../../scala/persistence.rst:449
msgid ""
"`mapAsync`_ combined with :ref:`actors-ask-lambda` is almost as simple "
"with the advantage of back-pressure being propagated all the way"
msgstr ""

#: ../../scala/persistence.rst:451
msgid "`ActorSubscriber`_ in case you need more fine grained control"
msgstr ""

#: ../../scala/persistence.rst:453
msgid ""
"The consuming actor may be a plain ``Actor`` or a ``PersistentActor`` if "
"it needs to store its own state (e.g. fromSequenceNr offset)."
msgstr ""

#: ../../scala/persistence.rst:460
msgid ""
"Persistent views can be implemented by extending the ``PersistentView`` "
"trait  and implementing the ``receive`` and the ``persistenceId`` "
"methods."
msgstr ""

#: ../../scala/persistence.rst:465
msgid ""
"The ``persistenceId`` identifies the persistent actor from which the view"
" receives journaled messages. It is not necessary that the referenced "
"persistent actor is actually running. Views read messages from a "
"persistent actor's journal directly. When a persistent actor is started "
"later and begins to write new messages, by default the corresponding view"
" is updated automatically."
msgstr ""

#: ../../scala/persistence.rst:469
msgid ""
"It is possible to determine if a message was sent from the Journal or "
"from another actor in user-land by calling the ``isPersistent`` method. "
"Having that said, very often you don't need this information at all and "
"can simply apply the same logic to both cases (skip the ``if "
"isPersistent`` check)."
msgstr ""

#: ../../scala/persistence.rst:474
msgid "Updates"
msgstr ""

#: ../../scala/persistence.rst:476
msgid ""
"The default update interval of all views of an actor system is "
"configurable:"
msgstr ""

#: ../../scala/persistence.rst:480
msgid ""
"``PersistentView`` implementation classes may also override the "
"``autoUpdateInterval`` method to return a custom update interval for a "
"specific view class or view instance. Applications may also trigger "
"additional updates at any time by sending a view an ``Update`` message."
msgstr ""

#: ../../scala/persistence.rst:486
msgid ""
"If the ``await`` parameter is set to ``true``, messages that follow the "
"``Update`` request are processed when the incremental message replay, "
"triggered by that update request, completed. If set to ``false`` "
"(default), messages following the update request may interleave with the "
"replayed message stream. Automated updates always run with ``await = "
"false``."
msgstr ""

#: ../../scala/persistence.rst:491
msgid ""
"Automated updates of all persistent views of an actor system can be "
"turned off by configuration:"
msgstr ""

#: ../../scala/persistence.rst:495
msgid ""
"Implementation classes may override the configured default value by "
"overriding the ``autoUpdate`` method. To limit the number of replayed "
"messages per update request, applications can configure a custom "
"``akka.persistence.view.auto-update-replay-max`` value or override the "
"``autoUpdateReplayMax`` method. The number of replayed messages for "
"manual updates can be limited with the ``replayMax`` parameter of the "
"``Update`` message."
msgstr ""

#: ../../scala/persistence.rst:503
msgid ""
"Initial recovery of persistent views works the very same way as for "
"persistent actors (i.e. by sending a ``Recover`` message to self). The "
"maximum number of replayed messages during initial recovery is determined"
" by ``autoUpdateReplayMax``. Further possibilities to customize initial "
"recovery are explained in section :ref:`recovery`."
msgstr ""

#: ../../scala/persistence.rst:512
msgid ""
"A persistent view must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``viewId`` method."
msgstr ""

#: ../../scala/persistence.rst:515
msgid ""
"The ``viewId`` must differ from the referenced ``persistenceId``, unless "
":ref:`snapshots` of a view and its persistent actor should be shared "
"(which is what applications usually do not want)."
msgstr ""

#: ../../scala/persistence.rst:521
msgid "Snapshots"
msgstr ""

#: ../../scala/persistence.rst:523
msgid ""
"Snapshots can dramatically reduce recovery times of persistent actors and"
" views. The following discusses snapshots in context of persistent actors"
" but this is also applicable to persistent views."
msgstr ""

#: ../../scala/persistence.rst:526
msgid ""
"Persistent actors can save snapshots of internal state by calling the  "
"``saveSnapshot`` method. If saving of a snapshot succeeds, the persistent"
" actor receives a ``SaveSnapshotSuccess`` message, otherwise a "
"``SaveSnapshotFailure`` message"
msgstr ""

#: ../../scala/persistence.rst:531
msgid "where ``metadata`` is of type ``SnapshotMetadata``:"
msgstr ""

#: ../../scala/persistence.rst:535
msgid ""
"During recovery, the persistent actor is offered a previously saved "
"snapshot via a ``SnapshotOffer`` message from which it can initialize "
"internal state."
msgstr ""

#: ../../scala/persistence.rst:540
msgid ""
"The replayed messages that follow the ``SnapshotOffer`` message, if any, "
"are younger than the offered snapshot. They finally recover the "
"persistent actor to its current (i.e. latest) state."
msgstr ""

#: ../../scala/persistence.rst:543
msgid ""
"In general, a persistent actor is only offered a snapshot if that "
"persistent actor has previously saved one or more snapshots and at least "
"one of these snapshots matches the ``SnapshotSelectionCriteria`` that can"
" be specified for recovery."
msgstr ""

#: ../../scala/persistence.rst:548
msgid ""
"If not specified, they default to ``SnapshotSelectionCriteria.Latest`` "
"which selects the latest (= youngest) snapshot. To disable snapshot-based"
" recovery, applications should use ``SnapshotSelectionCriteria.None``. A "
"recovery where no saved snapshot matches the specified "
"``SnapshotSelectionCriteria`` will replay all journaled messages."
msgstr ""

#: ../../scala/persistence.rst:553
msgid ""
"In order to use snapshots, a default snapshot-store (``akka.persistence"
".snapshot-store.plugin``) must be configured, or the ``PersistentActor`` "
"can pick a snapshot store explicitly by overriding ``def "
"snapshotPluginId: String``."
msgstr ""

#: ../../scala/persistence.rst:556
msgid ""
"Since it is acceptable for some applications to not use any snapshotting,"
" it is legal to not configure a snapshot store. However, Akka will log a "
"warning message when this situation is detected and then continue to "
"operate until an actor tries to store a snapshot, at which point the "
"operation will fail (by replying with an ``SaveSnapshotFailure`` for "
"example)."
msgstr ""

#: ../../scala/persistence.rst:560
msgid ""
"Note that :ref:`cluster_sharding_scala` is using snapshots, so if you use"
" Cluster Sharding you need to define a snapshot store plugin."
msgstr ""

#: ../../scala/persistence.rst:563
msgid "Snapshot deletion"
msgstr ""

#: ../../scala/persistence.rst:565
msgid ""
"A persistent actor can delete individual snapshots by calling the "
"``deleteSnapshot`` method with the sequence number of when the snapshot "
"was taken."
msgstr ""

#: ../../scala/persistence.rst:568
msgid ""
"To bulk-delete a range of snapshots matching "
"``SnapshotSelectionCriteria``, persistent actors should use the "
"``deleteSnapshots`` method."
msgstr ""

#: ../../scala/persistence.rst:572
msgid "Snapshot status handling"
msgstr ""

#: ../../scala/persistence.rst:574
msgid ""
"Saving or deleting snapshots can either succeed or fail – this "
"information is reported back to the persistent actor via status messages "
"as illustrated in the following table."
msgstr ""

#: ../../scala/persistence.rst:578
msgid "**Failure message**"
msgstr ""

#: ../../scala/persistence.rst:580
msgid "``saveSnapshot(Any)``"
msgstr ""

#: ../../scala/persistence.rst:580
msgid "``SaveSnapshotSuccess``"
msgstr ""

#: ../../scala/persistence.rst:580
msgid "``SaveSnapshotFailure``"
msgstr ""

#: ../../scala/persistence.rst:581
msgid "``deleteSnapshot(Long)``"
msgstr ""

#: ../../scala/persistence.rst:581
msgid "``DeleteSnapshotSuccess``"
msgstr ""

#: ../../scala/persistence.rst:581
msgid "``DeleteSnapshotFailure``"
msgstr ""

#: ../../scala/persistence.rst:582
msgid "``deleteSnapshots(SnapshotSelectionCriteria)``"
msgstr ""

#: ../../scala/persistence.rst:582
msgid "``DeleteSnapshotsSuccess``"
msgstr ""

#: ../../scala/persistence.rst:582
msgid "``DeleteSnapshotsFailure``"
msgstr ""

#: ../../scala/persistence.rst:585
msgid ""
"If failure messages are left unhandled by the actor, a default warning "
"log message will be logged for each incoming failure message. No default "
"action is performed on the success messages, however you're free to "
"handle them e.g. in order to delete an in memory representation of the "
"snapshot, or in the case of failure to attempt save the snapshot again."
msgstr ""

#: ../../scala/persistence.rst:592
msgid "At-Least-Once Delivery"
msgstr ""

#: ../../scala/persistence.rst:594
msgid ""
"To send messages with at-least-once delivery semantics to destinations "
"you can mix-in ``AtLeastOnceDelivery`` trait to your ``PersistentActor`` "
"on the sending side.  It takes care of re-sending messages when they have"
" not been confirmed within a configurable timeout."
msgstr ""

#: ../../scala/persistence.rst:598
msgid ""
"The state of the sending actor, including which messages have been sent "
"that have not been confirmed by the recipient must be persistent so that "
"it can survive a crash of the sending actor or JVM. The "
"``AtLeastOnceDelivery`` trait does not persist anything by itself. It is "
"your responsibility to persist the intent that a message is sent and that"
" a confirmation has been received."
msgstr ""

#: ../../scala/persistence.rst:606
msgid ""
"At-least-once delivery implies that original message sending order is not"
" always preserved, and the destination may receive duplicate messages. "
"Semantics do not match those of a normal :class:`ActorRef` send "
"operation:"
msgstr ""

#: ../../scala/persistence.rst:610
msgid "it is not at-most-once delivery"
msgstr ""

#: ../../scala/persistence.rst:612
msgid ""
"message order for the same sender–receiver pair is not preserved due to "
"possible resends"
msgstr ""

#: ../../scala/persistence.rst:615
msgid ""
"after a crash and restart of the destination messages are still delivered"
" to the new actor incarnation"
msgstr ""

#: ../../scala/persistence.rst:618
msgid ""
"These semantics are similar to what an :class:`ActorPath` represents (see"
" :ref:`actor-lifecycle-scala`), therefore you need to supply a path and "
"not a reference when delivering messages. The messages are sent to the "
"path with an actor selection."
msgstr ""

#: ../../scala/persistence.rst:623
msgid ""
"Use the ``deliver`` method to send a message to a destination. Call the "
"``confirmDelivery`` method when the destination has replied with a "
"confirmation message."
msgstr ""

#: ../../scala/persistence.rst:627
msgid "Relationship between deliver and confirmDelivery"
msgstr ""

#: ../../scala/persistence.rst:629
msgid ""
"To send messages to the destination path, use the ``deliver`` method "
"after you have persisted the intent to send the message."
msgstr ""

#: ../../scala/persistence.rst:632
msgid ""
"The destination actor must send back a confirmation message. When the "
"sending actor receives this confirmation message you should persist the "
"fact that the message was delivered successfully and then call the "
"``confirmDelivery`` method."
msgstr ""

#: ../../scala/persistence.rst:636
msgid ""
"If the persistent actor is not currently recovering, the ``deliver`` "
"method will send the message to the destination actor. When recovering, "
"messages will be buffered until they have been confirmed using "
"``confirmDelivery``. Once recovery has completed, if there are "
"outstanding messages that have not been confirmed (during the message "
"replay), the persistent actor will resend these before sending any other "
"messages."
msgstr ""

#: ../../scala/persistence.rst:641
msgid ""
"Deliver requires a ``deliveryIdToMessage`` function to pass the provided "
"``deliveryId`` into the message so that the correlation between "
"``deliver`` and ``confirmDelivery`` is possible. The ``deliveryId`` must "
"do the round trip. Upon receipt of the message, the destination actor "
"will send the same``deliveryId`` wrapped in a confirmation message back "
"to the sender. The sender will then use it to call ``confirmDelivery`` "
"method to complete the delivery routine."
msgstr ""

#: ../../scala/persistence.rst:648
msgid ""
"The ``deliveryId`` generated by the persistence module is a strictly "
"monotonically increasing sequence number without gaps. The same sequence "
"is used for all destinations of the actor, i.e. when sending to multiple "
"destinations the destinations will see gaps in the sequence. It is not "
"possible to use custom ``deliveryId``. However, you can send a custom "
"correlation identifier in the message to the destination. You must then "
"retain a mapping between the internal ``deliveryId`` (passed into the "
"``deliveryIdToMessage`` function) and your custom correlation id (passed "
"into the message). You can do this by storing such mapping in a "
"``Map(correlationId -> deliveryId)`` from which you can retrieve the "
"``deliveryId`` to be passed into the ``confirmDelivery`` method once the "
"receiver of your message has replied with your custom correlation id."
msgstr ""

#: ../../scala/persistence.rst:657
msgid ""
"The ``AtLeastOnceDelivery`` trait has a state consisting of unconfirmed "
"messages and a sequence number. It does not store this state itself. You "
"must persist events corresponding to the ``deliver`` and "
"``confirmDelivery`` invocations from your ``PersistentActor`` so that the"
" state can be restored by calling the same methods during the recovery "
"phase of the ``PersistentActor``. Sometimes these events can be derived "
"from other business level events, and sometimes you must create separate "
"events. During recovery, calls to ``deliver`` will not send out messages,"
" those will be sent later if no matching ``confirmDelivery`` will have "
"been performed."
msgstr ""

#: ../../scala/persistence.rst:665
msgid ""
"Support for snapshots is provided by ``getDeliverySnapshot`` and "
"``setDeliverySnapshot``. The ``AtLeastOnceDeliverySnapshot`` contains the"
" full delivery state, including unconfirmed messages. If you need a "
"custom snapshot for other parts of the actor state you must also include "
"the ``AtLeastOnceDeliverySnapshot``. It is serialized using protobuf with"
" the ordinary Akka serialization mechanism. It is easiest to include the "
"bytes of the ``AtLeastOnceDeliverySnapshot`` as a blob in your custom "
"snapshot."
msgstr ""

#: ../../scala/persistence.rst:672
msgid ""
"The interval between redelivery attempts is defined by the "
"``redeliverInterval`` method. The default value can be configured with "
"the ``akka.persistence.at-least-once-delivery.redeliver-interval`` "
"configuration key. The method can be overridden by implementation classes"
" to return non-default values."
msgstr ""

#: ../../scala/persistence.rst:676
msgid ""
"The maximum number of messages that will be sent at each redelivery burst"
" is defined by the ``redeliveryBurstLimit`` method (burst frequency is "
"half of the redelivery interval). If there's a lot of unconfirmed "
"messages (e.g. if the destination is not available for a long time), this"
" helps to prevent an overwhelming amount of messages to be sent at once. "
"The default value can be configured with the ``akka.persistence.at-least-"
"once-delivery.redelivery-burst-limit`` configuration key. The method can "
"be overridden by implementation classes to return non-default values."
msgstr ""

#: ../../scala/persistence.rst:683
msgid ""
"After a number of delivery attempts a "
"``AtLeastOnceDelivery.UnconfirmedWarning`` message will be sent to "
"``self``. The re-sending will still continue, but you can choose to call "
"``confirmDelivery`` to cancel the re-sending. The number of delivery "
"attempts before emitting the warning is defined by the "
"``warnAfterNumberOfUnconfirmedAttempts`` method. The default value can be"
" configured with the ``akka.persistence.at-least-once-delivery.warn-"
"after-number-of-unconfirmed-attempts`` configuration key. The method can "
"be overridden by implementation classes to return non-default values."
msgstr ""

#: ../../scala/persistence.rst:690
msgid ""
"The ``AtLeastOnceDelivery`` trait holds messages in memory until their "
"successful delivery has been confirmed. The maximum number of unconfirmed"
" messages that the actor is allowed to hold in memory is defined by the "
"``maxUnconfirmedMessages`` method. If this limit is exceed the "
"``deliver`` method will not accept more messages and it will throw "
"``AtLeastOnceDelivery.MaxUnconfirmedMessagesExceededException``. The "
"default value can be configured with the ``akka.persistence.at-least-"
"once-delivery.max-unconfirmed-messages`` configuration key. The method "
"can be overridden by implementation classes to return non-default values."
msgstr ""

#: ../../scala/persistence.rst:700
msgid "Event Adapters"
msgstr ""

#: ../../scala/persistence.rst:702
msgid ""
"In long running projects using event sourcing sometimes the need arises "
"to detach the data model from the domain model completely."
msgstr ""

#: ../../scala/persistence.rst:705
msgid "Event Adapters help in situations where:"
msgstr ""

#: ../../scala/persistence.rst:707
msgid ""
"**Version Migrations** – existing events stored in *Version 1* should be "
"\"upcasted\" to a new *Version 2* representation, and the process of "
"doing so involves actual code, not just changes on the serialization "
"layer. For these scenarios the ``toJournal`` function is usually an "
"identity function, however the ``fromJournal`` is implemented as "
"``v1.Event=>v2.Event``, performing the neccessary mapping inside the "
"fromJournal method. This technique is sometimes refered to as "
"\"upcasting\" in other CQRS libraries."
msgstr ""

#: ../../scala/persistence.rst:712
msgid ""
"**Separating Domain and Data models** – thanks to EventAdapters it is "
"possible to completely separate the domain model from the model used to "
"persist data in the Journals. For example one may want to use case "
"classes in the domain model, however persist their protocol-buffer (or "
"any other binary serialization format) counter-parts to the Journal. A "
"simple ``toJournal:MyModel=>MyDataModel`` and "
"``fromJournal:MyDataModel=>MyModel`` adapter can be used to implement "
"this feature."
msgstr ""

#: ../../scala/persistence.rst:716
msgid ""
"**Journal Specialized Data Types** – exposing data types understood by "
"the underlying Journal, for example for data stores which understand JSON"
" it is possible to write an EventAdapter ``toJournal:Any=>JSON`` such "
"that the Journal can *directly* store the json instead of serializing the"
" object to its binary representation."
msgstr ""

#: ../../scala/persistence.rst:720
msgid "Implementing an EventAdapter is rather stright forward:"
msgstr ""

#: ../../scala/persistence.rst:724
msgid ""
"Then in order for it to be used on events coming to and from the journal "
"you must bind it using the below configuration syntax:"
msgstr ""

#: ../../scala/persistence.rst:728
msgid ""
"It is possible to bind multiple adapters to one class *for recovery*, in "
"which case the ``fromJournal`` methods of all bound adapters will be "
"applied to a given matching event (in order of definition in the "
"configuration). Since each adapter may return from ``0`` to ``n`` adapted"
" events (called as ``EventSeq``), each adapter can investigate the event "
"and if it should indeed adapt it return the adapted event(s) for it. "
"Other adapters which do not have anything to contribute during this "
"adaptation simply return ``EventSeq.empty``. The adapted events are then "
"delivered in-order to the ``PersistentActor`` during replay."
msgstr ""

#: ../../scala/persistence.rst:735 ../../scala/persistence.rst:1077
msgid ""
"For more advanced schema evolution techniques refer to the :ref"
":`persistence-schema-evolution-scala` documentation."
msgstr ""

#: ../../scala/persistence.rst:740
msgid "Persistent FSM"
msgstr ""

#: ../../scala/persistence.rst:741
msgid ""
"``PersistentFSM`` handles the incoming messages in an FSM like fashion. "
"Its internal state is persisted as a sequence of changes, later referred "
"to as domain events. Relationship between incoming messages, FSM's states"
" and transitions, persistence of domain events is defined by a DSL."
msgstr ""

#: ../../scala/persistence.rst:747
msgid ""
"``PersistentFSM`` is marked as **“experimental”** as of its introduction "
"in Akka 2.4.0. We will continue to improve this API based on our users’ "
"feedback, which implies that while we try to keep incompatible changes to"
" a minimum the binary compatibility guarantee for maintenance releases "
"does not apply to the contents of the `classes related to "
"``PersistentFSM``."
msgstr ""

#: ../../scala/persistence.rst:753
msgid "A Simple Example"
msgstr ""

#: ../../scala/persistence.rst:754
msgid ""
"To demonstrate the features of the ``PersistentFSM`` trait, consider an "
"actor which represents a Web store customer. The contract of our "
"\"WebStoreCustomerFSMActor\" is that it accepts the following commands:"
msgstr ""

#: ../../scala/persistence.rst:759
msgid ""
"``AddItem`` sent when the customer adds an item to a shopping cart "
"``Buy`` - when the customer finishes the purchase ``Leave`` - when the "
"customer leaves the store without purchasing anything ``GetCurrentCart`` "
"allows to query the current state of customer's shopping cart"
msgstr ""

#: ../../scala/persistence.rst:764
msgid "The customer can be in one of the following states:"
msgstr ""

#: ../../scala/persistence.rst:768
msgid ""
"``LookingAround`` customer is browsing the site, but hasn't added "
"anything to the shopping cart ``Shopping`` customer has recently added "
"items to the shopping cart ``Inactive`` customer has items in the "
"shopping cart, but hasn't added anything recently ``Paid`` customer has "
"purchased the items"
msgstr ""

#: ../../scala/persistence.rst:775
msgid ""
"``PersistentFSM`` states must inherit from trait "
"``PersistentFSM.FSMState`` and implement the ``def identifier: String`` "
"method. This is required in order to simplify the serialization of FSM "
"states. String identifiers should be unique!"
msgstr ""

#: ../../scala/persistence.rst:779
msgid ""
"Customer's actions are \"recorded\" as a sequence of \"domain events\" "
"which are persisted. Those events are replayed on an actor's start in "
"order to restore the latest customer's state:"
msgstr ""

#: ../../scala/persistence.rst:784
msgid "Customer state data represents the items in a customer's shopping cart:"
msgstr ""

#: ../../scala/persistence.rst:788
msgid "Here is how everything is wired together:"
msgstr ""

#: ../../scala/persistence.rst:794
msgid ""
"State data can only be modified directly on initialization. Later it's "
"modified only as a result of applying domain events. Override the "
"``applyEvent`` method to define how state data is affected by domain "
"events, see the example below"
msgstr ""

#: ../../scala/persistence.rst:799
msgid ""
"``andThen`` can be used to define actions which will be executed "
"following event's persistence - convenient for \"side effects\" like "
"sending a message or logging. Notice that actions defined in ``andThen`` "
"block are not executed on recovery:"
msgstr ""

#: ../../scala/persistence.rst:804
msgid ""
"A snapshot of state data can be persisted by calling the "
"``saveStateSnapshot()`` method:"
msgstr ""

#: ../../scala/persistence.rst:808
msgid ""
"On recovery state data is initialized according to the latest available "
"snapshot, then the remaining domain events are replayed, triggering the "
"``applyEvent`` method."
msgstr ""

#: ../../scala/persistence.rst:814
msgid "Storage plugins"
msgstr ""

#: ../../scala/persistence.rst:816
msgid ""
"Storage backends for journals and snapshot stores are pluggable in the "
"Akka persistence extension."
msgstr ""

#: ../../scala/persistence.rst:818
msgid ""
"A directory of persistence journal and snapshot store plugins is "
"available at the Akka Community Projects page, see `Community plugins`_"
msgstr ""

#: ../../scala/persistence.rst:820
msgid ""
"Plugins can be selected either by \"default\" for all persistent actors "
"and views, or \"individually\", when a persistent actor or view defines "
"its own set of plugins."
msgstr ""

#: ../../scala/persistence.rst:823
msgid ""
"When a persistent actor or view does NOT override the ``journalPluginId``"
" and ``snapshotPluginId`` methods, the persistence extension will use the"
" \"default\" journal and snapshot-store plugins configured in "
"``reference.conf``::"
msgstr ""

#: ../../scala/persistence.rst:829
msgid ""
"However, these entries are provided as empty \"\", and require explicit "
"user configuration via override in the user ``application.conf``. For an "
"example of a journal plugin which writes messages to LevelDB see :ref"
":`local-leveldb-journal`. For an example of a snapshot store plugin which"
" writes snapshots as individual files to the local filesystem see :ref"
":`local-snapshot-store`."
msgstr ""

#: ../../scala/persistence.rst:833
msgid ""
"Applications can provide their own plugins by implementing a plugin API "
"and activating them by configuration. Plugin development requires the "
"following imports:"
msgstr ""

#: ../../scala/persistence.rst:839
msgid "Eager initialization of persistence plugin"
msgstr ""

#: ../../scala/persistence.rst:841
msgid ""
"By default, persistence plugins are started on-demand, as they are used. "
"In some case, however, it might be beneficial to start a certain plugin "
"eagerly. In order to do that, you should first add the "
"``akka.persistence.Persistence`` under the ``akka.extensions`` key. Then,"
" specify the IDs of plugins you wish to start automatically under "
"``akka.persistence.journal.auto-start-journals`` and ``akka.persistence"
".snapshot-store.auto-start-snapshot-stores``."
msgstr ""

#: ../../scala/persistence.rst:849
msgid "Journal plugin API"
msgstr ""

#: ../../scala/persistence.rst:851
msgid "A journal plugin extends ``AsyncWriteJournal``."
msgstr ""

#: ../../scala/persistence.rst:853
msgid "``AsyncWriteJournal`` is an actor and the methods to be implemented are:"
msgstr ""

#: ../../scala/persistence.rst:857
msgid ""
"If the storage backend API only supports synchronous, blocking writes, "
"the methods should be implemented as:"
msgstr ""

#: ../../scala/persistence.rst:861
msgid ""
"A journal plugin must also implement the methods defined in "
"``AsyncRecovery`` for replays and sequence number recovery:"
msgstr ""

#: ../../scala/persistence.rst:865
msgid ""
"A journal plugin can be activated with the following minimal "
"configuration:"
msgstr ""

#: ../../scala/persistence.rst:869 ../../scala/persistence.rst:892
msgid ""
"The specified plugin ``class`` must have a no-arg constructor. The "
"``plugin-dispatcher`` is the dispatcher used for the plugin actor. If not"
" specified, it defaults to ``akka.persistence.dispatchers.default-plugin-"
"dispatcher``."
msgstr ""

#: ../../scala/persistence.rst:872
msgid ""
"The journal plugin instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may "
"delegate to asynchronous libraries, spawn futures, or delegate to other "
"actors to achive parallelism."
msgstr ""

#: ../../scala/persistence.rst:876
msgid ""
"The journal plugin class must have a constructor without parameters or a "
"constructor with one ``com.typesafe.config.Config`` parameter. The plugin"
" section of the actor system's config will be passed in the config "
"constructor parameter."
msgstr ""

#: ../../scala/persistence.rst:879
msgid ""
"Don't run journal tasks/futures on the system default dispatcher, since "
"that might starve other tasks."
msgstr ""

#: ../../scala/persistence.rst:882
msgid "Snapshot store plugin API"
msgstr ""

#: ../../scala/persistence.rst:884
msgid ""
"A snapshot store plugin must extend the ``SnapshotStore`` actor and "
"implement the following methods:"
msgstr ""

#: ../../scala/persistence.rst:888
msgid ""
"A snapshot store plugin can be activated with the following minimal "
"configuration:"
msgstr ""

#: ../../scala/persistence.rst:895
msgid ""
"The snapshot store instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may "
"delegate to asynchronous libraries, spawn futures, or delegate to other "
"actors to achive parallelism."
msgstr ""

#: ../../scala/persistence.rst:899
msgid ""
"The snapshot store plugin class must have a constructor without "
"parameters or a constructor with one ``com.typesafe.config.Config`` "
"parameter. The plugin section of the actor system's config will be passed"
" in the config constructor parameter."
msgstr ""

#: ../../scala/persistence.rst:902
msgid ""
"Don't run snapshot store tasks/futures on the system default dispatcher, "
"since that might starve other tasks."
msgstr ""

#: ../../scala/persistence.rst:905
msgid "Plugin TCK"
msgstr ""

#: ../../scala/persistence.rst:906
msgid ""
"In order to help developers build correct and high quality storage "
"plugins, we provide a Technology Compatibility Kit (`TCK "
"<http://en.wikipedia.org/wiki/Technology_Compatibility_Kit>`_ for short)."
msgstr ""

#: ../../scala/persistence.rst:908
msgid ""
"The TCK is usable from Java as well as Scala projects. For Scala you need"
" to include the akka-persistence-tck dependency::"
msgstr ""

#: ../../scala/persistence.rst:912
msgid ""
"To include the Journal TCK tests in your test suite simply extend the "
"provided ``JournalSpec``:"
msgstr ""

#: ../../scala/persistence.rst:916
msgid ""
"Please note that some of the tests are optional, and by overriding the "
"``supports...`` methods you give the TCK the needed information about "
"which tests to run. You can implement these methods using boolean falues "
"or the provided ``CapabilityFlag.on`` / ``CapabilityFlag.off`` values."
msgstr ""

#: ../../scala/persistence.rst:920
msgid ""
"We also provide a simple benchmarking class ``JournalPerfSpec`` which "
"includes all the tests that ``JournalSpec`` has, and also performs some "
"longer operations on the Journal while printing its performance stats. "
"While it is NOT aimed to provide a proper benchmarking environment it can"
" be used to get a rough feel about your journal's performance in the most"
" typical scenarios."
msgstr ""

#: ../../scala/persistence.rst:925
msgid ""
"In order to include the ``SnapshotStore`` TCK tests in your test suite "
"simply extend the ``SnapshotStoreSpec``:"
msgstr ""

#: ../../scala/persistence.rst:929
msgid ""
"In case your plugin requires some setting up (starting a mock database, "
"removing temporary files etc.) you can override the ``beforeAll`` and "
"``afterAll`` methods to hook into the tests lifecycle:"
msgstr ""

#: ../../scala/persistence.rst:934
msgid ""
"We *highly recommend* including these specifications in your test suite, "
"as they cover a broad range of cases you might have otherwise forgotten "
"to test for when writing a plugin from scratch."
msgstr ""

#: ../../scala/persistence.rst:940
msgid "Pre-packaged plugins"
msgstr ""

#: ../../scala/persistence.rst:945
msgid "Local LevelDB journal"
msgstr ""

#: ../../scala/persistence.rst:947
msgid ""
"The LevelDB journal plugin config entry is "
"``akka.persistence.journal.leveldb``. It writes messages to a local "
"LevelDB instance. Enable this plugin by defining config property:"
msgstr ""

#: ../../scala/persistence.rst:952
msgid ""
"LevelDB based plugins will also require the following additional "
"dependency declaration::"
msgstr ""

#: ../../scala/persistence.rst:957
msgid ""
"The default location of LevelDB files is a directory named ``journal`` in"
" the current working directory. This location can be changed by "
"configuration where the specified path can be relative or absolute:"
msgstr ""

#: ../../scala/persistence.rst:962
msgid "With this plugin, each actor system runs its own private LevelDB instance."
msgstr ""

#: ../../scala/persistence.rst:968
msgid "Shared LevelDB journal"
msgstr ""

#: ../../scala/persistence.rst:970
msgid ""
"A LevelDB instance can also be shared by multiple actor systems (on the "
"same or on different nodes). This, for example, allows persistent actors "
"to failover to a backup node and continue using the shared journal "
"instance from the backup node."
msgstr ""

#: ../../scala/persistence.rst:976
msgid ""
"A shared LevelDB instance is a single point of failure and should "
"therefore only be used for testing purposes. Highly-available, replicated"
" journals are available as `Community plugins`_."
msgstr ""

#: ../../scala/persistence.rst:981
msgid ""
"This plugin has been supplanted by :ref:`Persistence Plugin Proxy"
"<persistence-plugin-proxy>`."
msgstr ""

#: ../../scala/persistence.rst:983
msgid ""
"A shared LevelDB instance is started by instantiating the "
"``SharedLeveldbStore`` actor."
msgstr ""

#: ../../scala/persistence.rst:987
msgid ""
"By default, the shared instance writes journaled messages to a local "
"directory named ``journal`` in the current working directory. The storage"
" location can be changed by configuration:"
msgstr ""

#: ../../scala/persistence.rst:992
msgid ""
"Actor systems that use a shared LevelDB store must activate the "
"``akka.persistence.journal.leveldb-shared`` plugin."
msgstr ""

#: ../../scala/persistence.rst:997
msgid ""
"This plugin must be initialized by injecting the (remote) "
"``SharedLeveldbStore`` actor reference. Injection is done by calling the "
"``SharedLeveldbJournal.setStore`` method with the actor reference as "
"argument."
msgstr ""

#: ../../scala/persistence.rst:1002
msgid ""
"Internal journal commands (sent by persistent actors) are buffered until "
"injection completes. Injection is idempotent i.e. only the first "
"injection is used."
msgstr ""

#: ../../scala/persistence.rst:1009
msgid "Local snapshot store"
msgstr ""

#: ../../scala/persistence.rst:1011
msgid ""
"The local snapshot store plugin config entry is ``akka.persistence"
".snapshot-store.local``. It writes snapshot files to the local "
"filesystem. Enable this plugin by defining config property:"
msgstr ""

#: ../../scala/persistence.rst:1016
msgid ""
"The default storage location is a directory named ``snapshots`` in the "
"current working directory. This can be changed by configuration where the"
" specified path can be relative or absolute:"
msgstr ""

#: ../../scala/persistence.rst:1021
msgid ""
"Note that it is not mandatory to specify a snapshot store plugin. If you "
"don't use snapshots you don't have to configure it."
msgstr ""

#: ../../scala/persistence.rst:1028
msgid "Persistence Plugin Proxy"
msgstr ""

#: ../../scala/persistence.rst:1030
msgid ""
"A persistence plugin proxy allows sharing of journals and snapshot stores"
" across multiple actor systems (on the same or on different nodes). This,"
" for example, allows persistent actors to failover to a backup node and "
"continue using the shared journal instance from the backup node. The "
"proxy works by forwarding all the journal/snapshot store messages to a "
"single, shared, persistence plugin instance, and therefor supports any "
"use case supported by the proxied plugin."
msgstr ""

#: ../../scala/persistence.rst:1037
msgid ""
"A shared journal/snapshot store is a single point of failure and should "
"therefore only be used for testing purposes. Highly-available, replicated"
" persistence plugins are available as `Community plugins`_."
msgstr ""

#: ../../scala/persistence.rst:1040
msgid ""
"The journal and snapshot store proxies are controlled via the "
"``akka.persistence.journal.proxy`` and ``akka.persistence.snapshot-"
"store.proxy`` configuration entries, respectively. Set the ``target-"
"journal-plugin`` or ``target-snapshot-store-plugin`` keys to the "
"underlying plugin you wish to use (for example: "
"``akka.persistence.journal.leveldb``). The ``start-target-journal`` and "
"``start-target-snapshot-store`` keys should be set to ``on`` in exactly "
"one actor system - this is the system that will instantiate the shared "
"persistence plugin. Next, the proxy needs to be told how to find the "
"shared plugin. This can be done by setting the ``target-journal-address``"
" and ``target-snapshot-store-address`` configuration keys, or "
"programmatically by calling the "
"``PersistencePluginProxy.setTargetLocation`` method."
msgstr ""

#: ../../scala/persistence.rst:1051
msgid ""
"Akka starts extensions lazily when they are required, and this includes "
"the proxy. This means that in order for the proxy to work, the "
"persistence plugin on the target node must be instantiated. This can be "
"done by instantiating the ``PersistencePluginProxyExtension`` "
":ref:`extension<extending-akka-scala>`, or by calling the "
"``PersistencePluginProxy.start`` method."
msgstr ""

#: ../../scala/persistence.rst:1057
msgid ""
"The proxied persistence plugin can (and should) be configured using its "
"original configuration keys."
msgstr ""

#: ../../scala/persistence.rst:1063
msgid "Custom serialization"
msgstr ""

#: ../../scala/persistence.rst:1065
msgid ""
"Serialization of snapshots and payloads of ``Persistent`` messages is "
"configurable with Akka's :ref:`serialization-scala` infrastructure. For "
"example, if an application wants to serialize"
msgstr ""

#: ../../scala/persistence.rst:1068
msgid "payloads of type ``MyPayload`` with a custom ``MyPayloadSerializer`` and"
msgstr ""

#: ../../scala/persistence.rst:1069
msgid "snapshots of type ``MySnapshot`` with a custom ``MySnapshotSerializer``"
msgstr ""

#: ../../scala/persistence.rst:1071
msgid "it must add"
msgstr ""

#: ../../scala/persistence.rst:1075
msgid ""
"to the application configuration. If not specified, a default serializer "
"is used."
msgstr ""

#: ../../scala/persistence.rst:1080
msgid "Testing"
msgstr ""

#: ../../scala/persistence.rst:1082
msgid ""
"When running tests with LevelDB default settings in ``sbt``, make sure to"
" set ``fork := true`` in your sbt project. Otherwise, you'll see an "
"``UnsatisfiedLinkError``. Alternatively, you can switch to a LevelDB Java"
" port by setting"
msgstr ""

#: ../../scala/persistence.rst:1086
msgid "or"
msgstr ""

#: ../../scala/persistence.rst:1090
msgid ""
"in your Akka configuration. The LevelDB Java port is for testing purposes"
" only."
msgstr ""

#: ../../scala/persistence.rst:1093
msgid ""
"It is not possible to test persistence provided classes (i.e. "
":ref:`PersistentActor <event-sourcing-scala>` and "
":ref:`AtLeastOnceDelivery <at-least-once-delivery-scala>`) using "
"``TestActorRef`` due to its *synchronous* nature. These traits need to be"
" able to perform asynchronous tasks in the background in order to handle "
"internal persistence related events."
msgstr ""

#: ../../scala/persistence.rst:1098
msgid ""
"When testing Persistence based projects always rely on :ref:`asynchronous"
" messaging using the TestKit <async-integration-testing-scala>`."
msgstr ""

#: ../../scala/persistence.rst:1101
msgid "Configuration"
msgstr ""

#: ../../scala/persistence.rst:1103
msgid ""
"There are several configuration properties for the persistence module, "
"please refer to the :ref:`reference configuration <config-akka-"
"persistence>`."
msgstr ""

#: ../../scala/persistence.rst:1107
msgid "Multiple persistence plugin configurations"
msgstr ""

#: ../../scala/persistence.rst:1109
msgid ""
"By default, a persistent actor or view will use the \"default\" journal "
"and snapshot store plugins configured in the following sections of the "
"``reference.conf`` configuration resource:"
msgstr ""

#: ../../scala/persistence.rst:1114
msgid ""
"Note that in this case the actor or view overrides only the "
"``persistenceId`` method:"
msgstr ""

#: ../../scala/persistence.rst:1118
msgid ""
"When the persistent actor or view overrides the ``journalPluginId`` and "
"``snapshotPluginId`` methods, the actor or view will be serviced by these"
" specific persistence plugins instead of the defaults:"
msgstr ""

#: ../../scala/persistence.rst:1123
msgid ""
"Note that ``journalPluginId`` and ``snapshotPluginId`` must refer to "
"properly configured ``reference.conf`` plugin entries with a standard "
"``class`` property as well as settings which are specific for those "
"plugins, i.e.:"
msgstr ""

