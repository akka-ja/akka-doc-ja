# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-03 22:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../scala/http/client-side/websocket-support.rst:4
msgid "Client-Side WebSocket Support"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:6
msgid ""
"Client side WebSocket support is available through "
"``Http.singleWebSocketRequest`` , ``Http.webSocketClientFlow`` and "
"``Http.webSocketClientLayer``."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:9
msgid ""
"A WebSocket consists of two streams of messages, incoming messages (a "
":class:`Sink`) and outgoing messages (a :class:`Source`) where either may"
" be signalled first; or even be the only direction in which messages flow"
" during the lifetime of the connection. Therefore a WebSocket connection "
"is modelled as either something you connect a ``Flow[Message, Message, "
"Mat]`` to or a ``Flow[Message, Message, Mat]`` that you connect a "
"``Source[Message, Mat]`` and a ``Sink[Message, Mat]`` to."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:15
msgid ""
"A WebSocket request starts with a regular HTTP request which contains an "
"``Upgrade`` header (and possibly other regular HTTP request properties), "
"so in addition to the flow of messages there also is an initial response "
"from the server, this is modelled with :class:`WebSocketUpgradeResponse`."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:19
msgid ""
"The methods of the WebSocket client API handle the upgrade to WebSocket "
"on connection success and materializes the connected WebSocket stream. If"
" the connection fails, for example with a ``404 NotFound`` error, this "
"regular HTTP result can be found in ``WebSocketUpgradeResponse.response``"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:24
msgid ""
"Make sure to read and understand the section about :ref:`half-closed-"
"client-websockets` as the behavior when using WebSockets for one-way "
"communication may not be what you would expect."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:28
msgid "Message"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:29
msgid ""
"Messages sent and received over a WebSocket can be either "
":class:`TextMessage` s or :class:`BinaryMessage` s and each of those has "
"two subtypes :class:`Strict` or :class:`Streamed`. In typical "
"applications messages will be ``Strict`` as WebSockets are usually "
"deployed to communicate using small messages not stream data, the "
"protocol does however allow this (by not marking the first fragment as "
"final, as described in `rfc 6455 section 5.2`__)."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:36
msgid ""
"For such streamed messages :class:`BinaryMessage.Streamed` and "
":class:`TextMessage.Streamed` will be used. In these cases the data is "
"provided as a ``Source[ByteString, NotUsed]`` for binary and "
"``Source[String, NotUsed]`` for text messages."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:41
msgid "singleWebSocketRequest"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:42
msgid ""
"``singleWebSocketRequest`` takes a :class:`WebSocketRequest` and a flow "
"it will connect to the source and sink of the WebSocket connection. It "
"will trigger the request right away and returns a tuple containing the "
"``Future[WebSocketUpgradeResponse]`` and the materialized value from the "
"flow passed to the method."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:46
msgid ""
"The future will succeed when the WebSocket connection has been "
"established or the server returned a regular HTTP response, or fail if "
"the connection fails with an exception."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:49
#: ../../scala/http/client-side/websocket-support.rst:72
msgid "Simple example sending a message and printing any incoming message:"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:55
msgid ""
"The websocket request may also include additional headers, like in this "
"example, HTTP Basic Auth:"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:62
msgid "webSocketClientFlow"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:63
msgid ""
"``webSocketClientFlow`` takes a request, and returns a ``Flow[Message, "
"Message, Future[WebSocketUpgradeResponse]]``."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:65
msgid ""
"The future that is materialized from the flow will succeed when the "
"WebSocket connection has been established or the server returned a "
"regular HTTP response, or fail if the connection fails with an exception."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:69
msgid ""
"The :class:`Flow` that is returned by this method can only be "
"materialized once. For each request a new flow must be acquired by "
"calling the method again."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:80
msgid "webSocketClientLayer"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:81
msgid ""
"Just like the :ref:`http-client-layer` for regular HTTP requests, the "
"WebSocket layer can be used fully detached from the underlying TCP "
"interface. The same scenarios as described for regular HTTP requests "
"apply here."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:84
msgid ""
"The returned layer forms a ``BidiFlow[Message, SslTlsOutbound, "
"SslTlsInbound, Message, Future[WebSocketUpgradeResponse]]``."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:90
msgid "Half-Closed WebSockets"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:91
msgid ""
"The Akka HTTP WebSocket API does not support half-closed connections "
"which means that if the either stream completes the entire connection is "
"closed (after a \"Closing Handshake\" has been exchanged or a timeout of "
"3 seconds has passed). This may lead to unexpected behavior, for example "
"if we are trying to only consume messages coming from the server, like "
"this:"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:99
msgid ""
"This will in fact quickly close the connection because of the "
"``Source.empty`` being completed immediately when the stream is "
"materialized. To solve this you can make sure to not complete the "
"outgoing source by using for example ``Source.maybe`` like this:"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:106
msgid ""
"This will keep the outgoing source from completing, but without emitting "
"any elements until the ``Promise`` is manually completed which makes the "
"``Source`` complete and the connection to close."
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:109
msgid ""
"The same problem holds true if emitting a finite number of elements, as "
"soon as the last element is reached the ``Source`` will close and cause "
"the connection to close. To avoid that you can concatenate "
"``Source.maybe`` to the finite stream:"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:115
msgid ""
"Scenarios that exist with the two streams in a WebSocket and possible "
"ways to deal with it:"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:118
msgid "Scenario"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:118
msgid "Possible solution"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:120
msgid "Two-way communication"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:120
msgid ""
"``Flow.fromSinkAndSource``, or ``Flow.map`` for a request-response "
"protocol"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:121
msgid "Infinite incoming stream, no outgoing"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:121
msgid "``Flow.fromSinkAndSource(someSink, Source.maybe)``"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:122
msgid "Infinite outgoing stream, no incoming"
msgstr ""

#: ../../scala/http/client-side/websocket-support.rst:122
msgid "``Flow.fromSinkAndSource(Sink.ignore, yourSource)``"
msgstr ""

