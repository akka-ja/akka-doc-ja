# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/http/routing-dsl/source-streaming-support.rst:4
msgid "Source Streaming"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:6
msgid ""
"Akka HTTP supports completing a request with an Akka ``Source[T, _]``, which"
" makes it possible to easily build and consume streaming end-to-end APIs "
"which apply back-pressure throughout the entire stack."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:9
msgid ""
"It is possible to complete requests with raw ``Source[ByteString, _]``, "
"however often it is more convenient to stream on an element-by-element "
"basis, and allow Akka HTTP to handle the rendering internally - for example "
"as a JSON array, or CSV stream (where each element is separated by a new-"
"line)."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:13
msgid ""
"In the following sections we investigate how to make use of the JSON "
"Streaming infrastructure, however the general hints apply to any kind of "
"element-by-element streaming you could imagine."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:17
msgid "JSON Streaming"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:19
msgid ""
"`JSON Streaming`_ is a term refering to streaming a (possibly infinite) "
"stream of element as independent JSON objects as a continuous HTTP request "
"or response. The elements are most often separated using newlines, however "
"do not have to be. Concatenating elements side-by-side or emitting \"very "
"long\" JSON array is also another use case."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:24
msgid ""
"In the below examples, we'll be refering to the ``Tweet`` and "
"``Measurement`` case classes as our model, which are defined as:"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:29
msgid ""
"And as always with spray-json, we provide our (Un)Marshaller instances as "
"implicit values using the ``jsonFormat##`` method to generate them "
"statically:"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:38
msgid "Responding with JSON Streams"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:40
msgid ""
"In this example we implement an API representing an infinite stream of "
"tweets, very much like Twitter's `Streaming API`_."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:42
msgid ""
"Firstly, we'll need to get some additional marshalling infrastructure set "
"up, that is able to marshal to and from an Akka Streams ``Source[T,_]``. One"
" such trait, containing the needed marshallers is ``SprayJsonSupport``, "
"which uses spray-json (a high performance json parser library), and is "
"shipped as part of Akka HTTP in the ``akka-http-spray-json-experimental`` "
"module."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:47
msgid ""
"Once the general infrastructure is prepared we import our model's "
"marshallers, generated by spray-json (Step 1), and enable JSON Streaming by "
"making an implicit ``EntityStreamingSupport`` instance available (Step 2). "
"Akka HTTP pre-packages JSON and CSV entity streaming support, however it is "
"simple to add your own, in case you'd like to stream a different content "
"type (for example plists or protobuf)."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:52
msgid ""
"The final step is simply completing a request using a Source of tweets, as "
"simple as that:"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:57
msgid ""
"The reason the ``EntityStreamingSupport`` has to be enabled explicitly is "
"that one might want to configure how the stream should be rendered. We'll "
"dicuss this in depth in the next section though."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:63
msgid "Customising response rendering mode"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:64
msgid ""
"Since it is not always possible to directly and confidently answer the "
"question of how a stream of ``T`` should look on the wire, the "
"``EntityStreamingSupport`` traits come into play and allow fine-tuning the "
"streams rendered representation."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:67
msgid ""
"For example, in case of JSON Streaming, there isn't really one standard "
"about rendering the response. Some APIs prefer to render multiple JSON "
"objects in a line-by-line fashion (Twitter's streaming APIs for example), "
"while others simply return very large arrays, which could be streamed as "
"well."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:71
msgid ""
"Akka defaults to the second one (streaming a JSON Array), as it is correct "
"JSON and clients not expecting a streaming API would still be able to "
"consume it in a naive way if they'd want to."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:74
msgid ""
"The line-by-line aproach however is also pretty popular even though it is "
"not valid JSON. It's relatively simplicity for client-side parsing is a "
"strong point in case to pick this format for your Streaming APIs. Below we "
"demonstrate how to reconfigure the support trait to render the JSON as"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:81
msgid ""
"Another interesting feature is parallel marshalling. Since marshalling can "
"potentially take much time, it is possible to marshal multiple elements of "
"the stream in parallel. This is simply a configuration option on "
"``EntityStreamingSupport`` and is configurable like this:"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:88
msgid ""
"The above shown mode perserves ordering of the Source's elements, which may "
"sometimes be a required property, for example when streaming a strictly "
"ordered dataset. Sometimes the contept of strict-order does not apply to the"
" data being streamed though, which allows us to exploit this property and "
"use an ``unordered`` rendering."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:92
msgid ""
"This also is a configuration option and is used as shown below. Effectively "
"this will allow Akka's marshalling infrastructure to concurrently marshallup"
" to ``parallelism`` elements and emit the first which is marshalled onto the"
" ``HttpResponse``:"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:98
msgid ""
"This allows us to _potentially_ render elements faster onto the "
"HttpResponse, since it can avoid \"head of line blocking\", in case one "
"element in front of the stream takes a long time to marshall, yet others "
"after it are very quick to marshall."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:102
msgid "Consuming JSON Streaming uploads"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:104
msgid ""
"Sometimes the client may be sending a streaming request, for example an "
"embedded device initiated a connection with the server and is feeding it "
"with one line of measurement data."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:107
msgid ""
"In this example, we want to consume this data in a streaming fashion from "
"the request entity, and also apply back-pressure to the underlying TCP "
"connection, if the server can not cope with the rate of incoming data (back-"
"pressure will be applied automatically thanks to using Akka HTTP/Streams)."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:116
msgid "Simple CSV streaming example"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:118
msgid ""
"Akka HTTP provides another ``EntityStreamingSupport`` out of the box, namely"
" ``csv`` (comma-separated values). For completeness, we demonstrate its "
"usage in the below snippet. As you'll notice, switching betweeen streaming "
"modes is fairly simple, one only has to make sure that an implicit "
"``Marshaller`` of the requested type is available, and that the streaming "
"support operates on the same ``Content-Type`` as the rendered values. "
"Otherwise you'll see an error during runtime that the marshaller did not "
"expose the expected content type and thus we can not render the streaming "
"response)."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:129
msgid "Implementing custom EntityStreamingSupport traits"
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:131
msgid ""
"The ``EntityStreamingSupport`` infrastructure is open for extension and not "
"bound to any single format, content type or marshalling library. The "
"provided JSON support does not rely on Spray JSON directly, but uses "
"``Marshaller[T, ByteString]`` instances, which can be provided using any "
"JSON marshalling library (such as Circe, Jawn or Play JSON)."
msgstr ""

#: ../../scala/http/routing-dsl/source-streaming-support.rst:135
msgid ""
"When implementing a custom support trait, one should simply extend the "
"``EntityStreamingSupport`` abstract class, and implement all of it's "
"methods. It's best to use the existing implementations as a guideline."
msgstr ""
