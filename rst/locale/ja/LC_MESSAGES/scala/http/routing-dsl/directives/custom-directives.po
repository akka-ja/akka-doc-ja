# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-03 22:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:4
msgid "Custom Directives"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:6
msgid ""
"Part of the power of akka-http directives comes from the ease with which "
"it’s possible to define custom directives at differing levels of "
"abstraction."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:9
msgid "There are essentially three ways of creating custom directives:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:11
msgid "By introducing new “labels” for configurations of existing directives"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:12
msgid "By transforming existing directives"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:13
msgid "By writing a directive “from scratch”"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:16
msgid "Configuration Labeling"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:17
msgid ""
"The easiest way to create a custom directive is to simply assign a new "
"name for a certain configuration of one or more existing directives. In "
"fact, most of the predefined akka-http directives can be considered named"
" configurations of more low-level directives."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:21
msgid ""
"The basic technique is explained in the chapter about Composing "
"Directives, where, for example, a new directive ``getOrPut`` is defined "
"like this:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:27
msgid ""
"Another example is the :ref:`MethodDirectives` which are simply instances"
" of a preconfigured :ref:`-method-` directive. The low-level directives "
"that most often form the basis of higher-level “named configuration” "
"directives are grouped together in the :ref:`BasicDirectives` trait."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:33
msgid "Transforming Directives"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:35
msgid ""
"The second option for creating new directives is to transform an existing"
" one using one of the “transformation methods”, which are defined on the "
"`Directive`__ class, the base class of all “regular” directives."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:40
msgid ""
"Apart from the combinator operators (``|`` and ``&``) and the case-class "
"extractor (``as[T]``) there following transformations is also defined on "
"all ``Directive`` instances:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:43
msgid ":ref:`map/tmap`"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:44
msgid ":ref:`flatMap/tflatMap`"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:45
msgid ":ref:`require/trequire`"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:46
msgid ":ref:`recover/recoverPF`"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:51
msgid "map and tmap"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:52
msgid ""
"If the Directive is a single-value ``Directive``, the ``map`` method "
"allows for simple transformations:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:58
msgid ""
"One example of a predefined directive relying on ``map`` is the "
"`optionalHeaderValue`__ directive."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:62
msgid "The tmap modifier has this signature (somewhat simplified)::"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:66
msgid ""
"It can be used to transform the ``Tuple`` of extractions into another "
"``Tuple``. The number and/or types of the extractions can be changed "
"arbitrarily. For example if ``R`` is ``Tuple2[A, B]`` then the result "
"will be a ``Directive[(A, B)]``. Here is a somewhat contrived example:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:79
msgid "flatMap and tflatMap"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:81
msgid ""
"With map and tmap you can transform the values a directive extracts but "
"you cannot change the “extracting” nature of the directive. For example, "
"if you have a directive extracting an ``Int`` you can use map to turn it "
"into a directive that extracts that ``Int`` and doubles it, but you "
"cannot transform it into a directive, that doubles all positive ``Int`` "
"values and rejects all others."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:87
msgid ""
"In order to do the latter you need ``flatMap`` or ``tflatMap``. The "
"``tflatMap`` modifier has this signature::"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:92
msgid ""
"The given function produces a new directive depending on the Tuple of "
"extractions of the underlying one. As in the case of :ref:`map/tmap` "
"there is also a single-value variant called ``flatMap``, which simplifies"
" the operation for Directives only extracting one single value."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:96
msgid ""
"Here is the (contrived) example from above, which doubles positive Int "
"values and rejects all others:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:101
msgid ""
"A common pattern that relies on flatMap is to first extract a value from "
"the RequestContext with the extract directive and then flatMap with some "
"kind of filtering logic. For example, this is the implementation of the "
"method directive:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:109
msgid ""
"The explicit type parameter ``[Unit]`` on the flatMap i`s needed in this "
"case because the result of the flatMap is directly concatenated with the "
"``cancelAllRejections`` directive, thereby preventing “outside-in” "
"inference of the type parameter value."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:117
msgid "require and trequire"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:119
msgid ""
"The require modifier transforms a single-extraction directive into a "
"directive without extractions, which filters the requests according the a"
" predicate function. All requests, for which the predicate is false are "
"rejected, all others pass unchanged."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:123
msgid "The signature of require is this::"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:127
msgid ""
"One example of a predefined directive relying on require is the first "
"overload of the host directive:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:132
msgid ""
"You can only call require on single-extraction directives. The trequire "
"modifier is the more general variant, which takes a predicate of type "
"``Tuple => Boolean``. It can therefore also be used on directives with "
"several extractions."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:140
msgid "recover and recoverPF"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:142
msgid ""
"The ``recover`` modifier allows you “catch” rejections produced by the "
"underlying directive and, instead of rejecting, produce an alternative "
"directive with the same type(s) of extractions."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:145
msgid "The signature of recover is this::"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:149
msgid ""
"In many cases the very similar ``recoverPF`` modifier might be little bit"
" easier to use since it doesn’t require the handling of all rejections::"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:156
msgid ""
"One example of a predefined directive relying ``recoverPF`` is the "
"optionalHeaderValue directive:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:164
msgid "Directives from Scratch"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:166
msgid ""
"The third option for creating custom directives is to do it “from "
"scratch”, by directly subclassing the Directive class. The Directive is "
"defined like this (leaving away operators and modifiers):"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:173
msgid ""
"It only has one abstract member that you need to implement, the happly "
"method, which creates the Route the directives presents to the outside "
"from its inner Route building function (taking the extractions as "
"parameter)."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:177
msgid "Extractions are kept as a Tuple. Here are a few examples:"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:179
msgid ""
"A ``Directive[Unit]`` extracts nothing (like the get directive). Because "
"this type is used quite frequently akka-http defines a type alias for "
"it::"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:184
msgid ""
"A ``Directive[(String)]`` extracts one String value (like the hostName "
"directive). The type alias for it is::"
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:188
msgid ""
"A Directive[(Int, String)] extracts an ``Int`` value and a ``String`` "
"value (like a ``parameters('a.as[Int], 'b.as[String])`` directive)."
msgstr ""

#: ../../scala/http/routing-dsl/directives/custom-directives.rst:191
msgid ""
"Keeping extractions as ``Tuples`` has a lot of advantages, mainly great "
"flexibility while upholding full type safety and “inferability”. However,"
" the number of times where you’ll really have to fall back to defining a "
"directive from scratch should be very small. In fact, if you find "
"yourself in a position where a “from scratch” directive is your only "
"option, we’d like to hear about it, so we can provide a higher-level "
"“something” for other users."
msgstr ""

