# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: y2k2mt <y2.k2mt@gmail.com>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/http/routing-dsl/overview.rst:2
msgid "Routing DSL Overview"
msgstr "ルーティングDSLの概要"

#: ../../scala/http/routing-dsl/overview.rst:4
msgid ""
"The Akka HTTP :ref:`http-low-level-server-side-api` provides a ``Flow``- or "
"``Function``-level interface that allows an application to respond to "
"incoming HTTP requests by simply mapping requests to responses:"
msgstr ""
"Akka HTTP :ref:`http-low-level-server-side-api` "
"は、アプリケーションが受信したHTTPリクエストを簡単にレスポンスにマッピングする為の ``Flow`` 若しくは ``Function`` "
"レベルのインターフェースを提供しています。"

#: ../../scala/http/routing-dsl/overview.rst:10
msgid ""
"While it'd be perfectly possible to define a complete REST API service "
"purely by pattern-matching against the incoming ``HttpRequest`` (maybe with "
"the help of a few extractors in the way of `Unfiltered`_) this approach "
"becomes somewhat unwieldy for larger services due to the amount of syntax "
"\"ceremony\" required. Also, it doesn't help in keeping your service "
"definition as DRY_ as you might like."
msgstr ""
"受信した ``HttpRequest`` に対してパターンマッチを使った完璧なREST APIを ( `Unfiltered`_ の抽出子を少し使って)"
" "
"完全に定義する事が可能ですが、このアプローチは大量の文法の\"儀式\"を必要とし、比較的大きなサービスにはいくらか扱いにくくなってしまいます。また、サービスの定義をあなたが好む"
" DRY_ に保つのに役に立ちません。"

#: ../../scala/http/routing-dsl/overview.rst:15
msgid ""
"As an alternative Akka HTTP provides a flexible DSL for expressing your "
"service behavior as a structure of composable elements (called "
":ref:`Directives`) in a concise and readable way. Directives are assembled "
"into a so called *route structure* which, at its top-level, forms a handler "
"``Flow`` (or, alternatively, an async handler function) that can be directly"
" supplied to a ``bind`` call. The conversion from ``Route`` to flow can "
"either be invoked explicitly using ``Route.handlerFlow`` or, otherwise, the "
"conversion is also provided implicitly by ``RouteResult.route2HandlerFlow`` "
"[1]_."
msgstr ""
"Akka HTTPはその代わりとして、あなたのサービスの振る舞いを簡潔で読みやすく記述できる要素の構造( :ref:`Directives` "
"と呼ばれています)として表現できる柔軟なDSLを提供しています。ディレクティブは トップレベルにおいて ``bind`` を呼ぶ事で直接供給される "
"``Flow`` 処理 (若しくは、非同期な処理関数)で構成されるルート構造体として組み上げられます。 ``Route`` からFlowへの変換は "
"``Route.handlerFlow`` を使用する事で明示的に行う事が出来ます。また、 "
"``RouteResult.route2HandlerFlow`` [1]_ による暗黙的な変換も提供されています。"

#: ../../scala/http/routing-dsl/overview.rst:22
msgid ""
"For example, the service definition from above, written using the routing "
"DSL, would look like this:"
msgstr "例えば、ルーティングDSLを使用して記述された上記のサービスの定義は次ようになります:"

#: ../../scala/http/routing-dsl/overview.rst:27
msgid "The core of the Routing DSL becomes available with a single import::"
msgstr "ルーティングDSLのコアは、一つのインポートで有効になります"

#: ../../scala/http/routing-dsl/overview.rst:31
msgid ""
"This example also relies on the pre-defined support for Scala XML with::"
msgstr "この例では、予め定義されたScala XMLをサポートする機能にも依存しています"

#: ../../scala/http/routing-dsl/overview.rst:35
msgid ""
"The very short example shown here is certainly not the best for illustrating"
" the savings in \"ceremony\" and improvements in conciseness and readability"
" that the Routing DSL promises. The :ref:`Long Example` might do a better "
"job in this regard."
msgstr ""
"ここで示されている非常に短い例は、\"儀式\"を抑えられる事を示すものとしても、ルーティングDSLが約束する簡潔さと可読性の改善を示すものとしても最適ではありません。"
" :ref:`Long Example` は、この点において良い仕事をしてくれるでしょう。"

#: ../../scala/http/routing-dsl/overview.rst:39
msgid ""
"For learning how to work with the Routing DSL you should first understand "
"the concept of :ref:`Routes`."
msgstr "ルーティングDSLがどのように動作しているかについて学ぶには、まず :ref:`Routes` のコンセプトを理解するべきです。"

#: ../../scala/http/routing-dsl/overview.rst:42
msgid ""
"To be picked up automatically, the implicit conversion needs to be provided "
"in the companion object of the source type. However, as ``Route`` is just a "
"type alias for ``RequestContext => Future[RouteResult]``, there's no "
"companion object for ``Route``. Fortunately, the `implicit scope`_ for "
"finding an implicit conversion also includes all types that are \"associated"
" with any part\" of the source type which in this case means that the "
"implicit conversion will also be picked up from "
"``RouteResult.route2HandlerFlow`` automatically."
msgstr ""
"暗黙的な変換対象を自動的に拾い上げるには、型に対するコンパニオンオブジェクトを必要とします。しかし、 ``Route`` は "
"``RequestContext => Future[RouteResult]`` のエイリアスでしかなく、 ``Route`` "
"のコンパニオンオブジェクトはありません。幸運にも、暗黙的な変換対象を見つける為の `implicit scope`_ "
"には、元の型に関連する全ての型が含まれており、 ``RouteResult.route2HandlerFlow`` "
"によって自動的に拾われ、暗黙的に変換されます。"
