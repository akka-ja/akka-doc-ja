# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/http/common/marshalling.rst:4
msgid "Marshalling"
msgstr ""

#: ../../scala/http/common/marshalling.rst:6
msgid ""
"\"Marshalling\" is the process of converting a higher-level (object) "
"structure into some kind of lower-level representation, often a \"wire "
"format\". Other popular names for it are \"Serialization\" or \"Pickling\"."
msgstr ""

#: ../../scala/http/common/marshalling.rst:9
msgid ""
"In Akka HTTP \"Marshalling\" means the conversion of an object of type ``T``"
" into a lower-level target type, e.g. a ``MessageEntity`` (which forms the "
"\"entity body\" of an HTTP request or response) or a full ``HttpRequest`` or"
" ``HttpResponse``."
msgstr ""

#: ../../scala/http/common/marshalling.rst:15
msgid "Basic Design"
msgstr ""

#: ../../scala/http/common/marshalling.rst:17
msgid ""
"Marshalling of instances of type ``A`` into instances of type ``B`` is "
"performed by a ``Marshaller[A, B]``. Akka HTTP also predefines a number of "
"helpful aliases for the types of marshallers that you'll likely work with "
"most:"
msgstr ""

#: ../../scala/http/common/marshalling.rst:23
msgid ""
"Contrary to what you might initially expect ``Marshaller[A, B]`` is not a "
"plain function ``A => B`` but rather essentially a function ``A => "
"Future[List[Marshalling[B]]]``. Let's dissect this rather complicated "
"looking signature piece by piece to understand what marshallers are designed"
" this way. Given an instance of type ``A`` a ``Marshaller[A, B]`` produces:"
msgstr ""

#: ../../scala/http/common/marshalling.rst:29
msgid ""
"1. A ``Future``: This is probably quite clear. Marshallers are not required "
"to synchronously produce a result, so instead they return a future, which "
"allows for asynchronicity in the marshalling process."
msgstr ""

#: ../../scala/http/common/marshalling.rst:32
msgid ""
"2. of ``List``: Rather than only a single target representation for ``A`` "
"marshallers can offer several ones. Which one will be rendered onto the wire"
" in the end is decided by content negotiation. For example, the "
"``ToEntityMarshaller[OrderConfirmation]`` might offer a JSON as well as an "
"XML representation. The client can decide through the addition of an "
"``Accept`` request header which one is preferred. If the client doesn't "
"express a preference the first representation is picked."
msgstr ""

#: ../../scala/http/common/marshalling.rst:38
msgid ""
"3. of ``Marshalling[B]``: Rather than returning an instance of ``B`` "
"directly marshallers first produce a ``Marshalling[B]``. This allows for "
"querying the ``MediaType`` and potentially the ``HttpCharset`` that the "
"marshaller will produce before the actual marshalling is triggered. Apart "
"from enabling content negotiation this design allows for delaying the actual"
" construction of the marshalling target instance to the very last moment "
"when it is really needed."
msgstr ""

#: ../../scala/http/common/marshalling.rst:43
msgid "This is how ``Marshalling`` is defined:"
msgstr ""

#: ../../scala/http/common/marshalling.rst:50
msgid "Predefined Marshallers"
msgstr ""

#: ../../scala/http/common/marshalling.rst:52
msgid ""
"Akka HTTP already predefines a number of marshallers for the most common "
"types. Specifically these are:"
msgstr ""

#: ../../scala/http/common/marshalling.rst:55
msgid "PredefinedToEntityMarshallers_"
msgstr ""

#: ../../scala/http/common/marshalling.rst:57
msgid "``Array[Byte]``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:58
msgid "``ByteString``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:59
msgid "``Array[Char]``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:60
msgid "``String``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:61
msgid "``akka.http.scaladsl.model.FormData``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:62
msgid "``akka.http.scaladsl.model.MessageEntity``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:63
msgid "``T <: akka.http.scaladsl.model.Multipart``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:65
msgid "PredefinedToResponseMarshallers_"
msgstr ""

#: ../../scala/http/common/marshalling.rst:67
msgid "``T``, if a ``ToEntityMarshaller[T]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:68
msgid "``HttpResponse``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:69
msgid "``StatusCode``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:70
msgid "``(StatusCode, T)``, if a ``ToEntityMarshaller[T]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:71
msgid "``(Int, T)``, if a ``ToEntityMarshaller[T]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:72
msgid ""
"``(StatusCode, immutable.Seq[HttpHeader], T)``, if a "
"``ToEntityMarshaller[T]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:73
msgid ""
"``(Int, immutable.Seq[HttpHeader], T)``, if a ``ToEntityMarshaller[T]`` is "
"available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:75
msgid "PredefinedToRequestMarshallers_"
msgstr ""

#: ../../scala/http/common/marshalling.rst:77
msgid "``HttpRequest``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:78
msgid "``Uri``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:79
msgid "``(HttpMethod, Uri, T)``, if a ``ToEntityMarshaller[T]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:80
msgid ""
"``(HttpMethod, Uri, immutable.Seq[HttpHeader], T)``, if a "
"``ToEntityMarshaller[T]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:82
msgid "GenericMarshallers_"
msgstr ""

#: ../../scala/http/common/marshalling.rst:84
msgid "``Marshaller[Throwable, T]``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:85
msgid ""
"``Marshaller[Option[A], B]``, if a ``Marshaller[A, B]`` and an "
"``EmptyValue[B]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:86
msgid ""
"``Marshaller[Either[A1, A2], B]``, if a ``Marshaller[A1, B]`` and a "
"``Marshaller[A2, B]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:87
msgid "``Marshaller[Future[A], B]``, if a ``Marshaller[A, B]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:88
msgid "``Marshaller[Try[A], B]``, if a ``Marshaller[A, B]`` is available"
msgstr ""

#: ../../scala/http/common/marshalling.rst:97
msgid "Implicit Resolution"
msgstr ""

#: ../../scala/http/common/marshalling.rst:99
msgid ""
"The marshalling infrastructure of Akka HTTP relies on a type-class based "
"approach, which means that ``Marshaller`` instances from a certain type "
"``A`` to a certain type ``B`` have to be available implicitly."
msgstr ""

#: ../../scala/http/common/marshalling.rst:102
msgid ""
"The implicits for most of the predefined marshallers in Akka HTTP are "
"provided through the companion object of the ``Marshaller`` trait. This "
"means that they are always available and never need to be explicitly "
"imported. Additionally, you can simply \"override\" them by bringing your "
"own custom version into local scope."
msgstr ""

#: ../../scala/http/common/marshalling.rst:108
msgid "Custom Marshallers"
msgstr ""

#: ../../scala/http/common/marshalling.rst:110
msgid ""
"Akka HTTP gives you a few convenience tools for constructing marshallers for"
" your own types. Before you do that you need to think about what kind of "
"marshaller you want to create. If all your marshaller needs to produce is a "
"``MessageEntity`` then you should probably provide a "
"``ToEntityMarshaller[T]``. The advantage here is that it will work on both "
"the client- as well as the server-side since a ``ToResponseMarshaller[T]`` "
"as well as a ``ToRequestMarshaller[T]`` can automatically be created if a "
"``ToEntityMarshaller[T]`` is available."
msgstr ""

#: ../../scala/http/common/marshalling.rst:117
msgid ""
"If, however, your marshaller also needs to set things like the response "
"status code, the request method, the request URI or any headers then a "
"``ToEntityMarshaller[T]`` won't work. You'll need to fall down to providing "
"a ``ToResponseMarshaller[T]`` or a ``ToRequestMarshaller[T]`` directly."
msgstr ""

#: ../../scala/http/common/marshalling.rst:121
msgid ""
"For writing your own marshallers you won't have to \"manually\" implement "
"the ``Marshaller`` trait directly. Rather, it should be possible to use one "
"of the convenience construction helpers defined on the ``Marshaller`` "
"companion:"
msgstr ""

#: ../../scala/http/common/marshalling.rst:130
msgid "Deriving Marshallers"
msgstr ""

#: ../../scala/http/common/marshalling.rst:132
msgid ""
"Sometimes you can save yourself some work by reusing existing marshallers "
"for your custom ones. The idea is to \"wrap\" an existing marshaller with "
"some logic to \"re-target\" it to your type."
msgstr ""

#: ../../scala/http/common/marshalling.rst:135
msgid ""
"In this regard wrapping a marshaller can mean one or both of the following "
"two things:"
msgstr ""

#: ../../scala/http/common/marshalling.rst:137
msgid "Transform the input before it reaches the wrapped marshaller"
msgstr ""

#: ../../scala/http/common/marshalling.rst:138
msgid "Transform the output of the wrapped marshaller"
msgstr ""

#: ../../scala/http/common/marshalling.rst:140
msgid ""
"For the latter (transforming the output) you can use ``baseMarshaller.map``,"
" which works exactly as it does for functions. For the former (transforming "
"the input) you have four alternatives:"
msgstr ""

#: ../../scala/http/common/marshalling.rst:143
msgid "``baseMarshaller.compose``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:144
msgid "``baseMarshaller.composeWithEC``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:145
msgid "``baseMarshaller.wrap``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:146
msgid "``baseMarshaller.wrapWithEC``"
msgstr ""

#: ../../scala/http/common/marshalling.rst:148
msgid ""
"``compose`` works just like it does for functions. ``wrap`` is a compose "
"that allows you to also change the ``ContentType`` that the marshaller "
"marshals to. The ``...WithEC`` variants allow you to receive an "
"``ExecutionContext`` internally if you need one, without having to depend on"
" one being available implicitly at the usage site."
msgstr ""

#: ../../scala/http/common/marshalling.rst:155
msgid "Using Marshallers"
msgstr ""

#: ../../scala/http/common/marshalling.rst:157
msgid ""
"In many places throughput Akka HTTP marshallers are used implicitly, e.g. "
"when you define how to :ref:`-complete-` a request using the :ref:`Routing "
"DSL <http-high-level-server-side-api>`."
msgstr ""

#: ../../scala/http/common/marshalling.rst:160
msgid ""
"However, you can also use the marshalling infrastructure directly if you "
"wish, which can be useful for example in tests. The best entry point for "
"this is the ``akka.http.scaladsl.marshalling.Marshal`` object, which you can"
" use like this:"
msgstr ""
