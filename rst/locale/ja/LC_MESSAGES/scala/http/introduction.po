# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Atsushi Araki <senalove2007@gmail.com>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/http/introduction.rst:4
msgid "Introduction"
msgstr "イントロダクション"

#: ../../scala/http/introduction.rst:6
msgid ""
"The Akka HTTP modules implement a full server- and client-side HTTP stack on"
" top of *akka-actor* and *akka-stream*. It's not a web-framework but rather "
"a more general toolkit for providing and consuming HTTP-based services. "
"While interaction with a browser is of course also in scope it is not the "
"primary focus of Akka HTTP."
msgstr ""
"Akka HTTPモジュールは完全なサーバーを実装します - そして、*akka-actor* と *akka-stream* "
"の頂点にあるクライアントサイドHTTPスタックです。これはwebフレームワークというよりもむしろより汎用的なツールキットで、HTTPベースのサービスの提供と利用を行います。もちろんブラウザとのインタラクションもスコープには含まれていますが、Akka"
" HTTPの主要な焦点ではありません。"

#: ../../scala/http/introduction.rst:10
msgid ""
"Akka HTTP follows a rather open design and many times offers several "
"different API levels for \"doing the same thing\". You get to pick the API "
"level of abstraction that is most suitable for your application. This means "
"that, if you have trouble achieving something using a high-level API, "
"there's a good chance that you can get it done with a low-level API, which "
"offers more flexibility but might require you to write more application "
"code."
msgstr ""
"Akka "
"HTTPはオープンに設計されていて、多くの場合で\"同じことをする\"ためのいくつかの異なったAPIレベルを提供します。あなたはアプリケーションに最も適した抽象化のAPIレベルを選択することができます。これが意味するのは、もし高レベルのAPIを使うことで何かを達成する際に問題が生じたら、より柔軟ですがより多くのアプリケーションコードを書かなければならない、低レベルのAPIを使って対処する、よい機会であるということです。"

#: ../../scala/http/introduction.rst:16
msgid "Philosophy"
msgstr "哲学"

#: ../../scala/http/introduction.rst:18
msgid ""
"Akka HTTP has been driven with a clear focus on providing tools for building"
" integration layers rather than application cores. As such it regards itself"
" as a suite of libraries rather than a framework."
msgstr ""
"Akka HTTPは　"
"アプリケーションのコアというよりも、統合レイヤーを構築するためのツールを提供することに明確な重点をおいています。フレームワークというよりも、ライブラリのスイートとして考えられています。"

#: ../../scala/http/introduction.rst:20
msgid ""
"A framework, as we’d like to think of the term, gives you a “frame”, in "
"which you build your application. It comes with a lot of decisions already "
"pre-made and provides a foundation including support structures that lets "
"you get started and deliver results quickly. In a way a framework is like a "
"skeleton onto which you put the “flesh” of your application in order to have"
" it come alive. As such frameworks work best if you choose them before you "
"start application development and try to stick to the frameworks “way of "
"doing things” as you go along."
msgstr ""
"フレームワークという用語を考えることは好まれることですが、それはアプリケーションを構築する際の枠組みを与えるものです。多くの決定はすでになされていて、すぐに始められて結果をすばやく届けられるサポートの構成を含む基礎を提供します。ある意味で、フレームワークは骨格であり、生命を与えるためにアプリケーションという肉付けを行うものです。このようなフレームワークは、アプリケーション開発を開始する以前に選択できて、フレームワークの「物事のやり方」に沿うようにするならば最高の働きをします。"

#: ../../scala/http/introduction.rst:22
msgid ""
"For example, if you are building a browser-facing web application it makes "
"sense to choose a web framework and build your application on top of it "
"because the “core” of the application is the interaction of a browser with "
"your code on the web-server. The framework makers have chosen one “proven” "
"way of designing such applications and let you “fill in the blanks” of a "
"more or less flexible “application-template”. Being able to rely on best-"
"practice architecture like this can be a great asset for getting things done"
" quickly."
msgstr ""
"例えば、もしブラウザで見えるwebアプリケーションを構築しているなら、webフレームワークを選んでその上にアプリケーションを構築することには意味があります。なぜなら、アプリケーションの「コア」はブラウザとwebサーバーのコードとの相互作用であるからです。フレームワークの作者はこのようなアプリケーションを設計する「実績のある」方法のひとつを選んでいて、アプリケーションテンプレートの空白を埋めさせます。このようなベストプラクティスのアーキテクチャに頼れることは、物事をすばやく行うための偉大な財産です。"

#: ../../scala/http/introduction.rst:24
msgid ""
"However, if your application is not primarily a web application because its "
"core is not browser-interaction but some specialized maybe complex business "
"service and you are merely trying to connect it to the world via a REST/HTTP"
" interface a web-framework might not be what you need. In this case the "
"application architecture should be dictated by what makes sense for the core"
" not the interface layer. Also, you probably won’t benefit from the possibly"
" existing browser-specific framework components like view templating, asset "
"management, JavaScript- and CSS generation/manipulation/minification, "
"localization support, AJAX support, etc."
msgstr ""
"しかしながら、アプリケーションのコアがブラウザとの相互作用ではなく、何かに特化した複雑と思われるビジネスサービスであるために、およそwebアプリケーションであるとは言えず、なおかつ外界との接続にREST/HTTPをめったに使わないのであれば、webフレームワークはあなたの必要とするものではないでしょう。この場合、アプリケーションアーキテクチャはインターフェースではなく、コアにとって意味のあるもので記述されるべきです。その上、ビューテンプレート、アセット管理、JavaScriptとCSSの生成/操作/最小化、国際化サポート、AJAXサポート、といった、存在するであろうブラウザに特化したフレームワークコンポーネントからは何の利益も得られないでしょう。"

#: ../../scala/http/introduction.rst:26
msgid ""
"Akka HTTP was designed specifically as “not-a-framework”, not because we "
"don’t like frameworks, but for use cases where a framework is not the right "
"choice. Akka HTTP is made for building integration layers based on HTTP and "
"as such tries to “stay on the sidelines”. Therefore you normally don’t build"
" your application “on top of” Akka HTTP, but you build your application on "
"top of whatever makes sense and use Akka HTTP merely for the HTTP "
"integration needs."
msgstr ""
"Akka "
"HTTPは「フレームワークではない」ように特別に設計されていますが、それは私たちがフレームワークを嫌っているのではなくて、ユースケース上フレームワークが正しい選択でないためです。Akka"
" HTTPはHTTPベースの統合レイヤーの構築のためにあり、傍観者であろうとします。したがって、Akka "
"HTTPの「上に」アプリケーションを構築することは通常なく、何か意味のあるものの上にアプリケーションを構築します。Akka "
"HTTPはHTTPインテグレーションの要求に対してはめったに使われません。"

#: ../../scala/http/introduction.rst:29
msgid "Using Akka HTTP"
msgstr "Akka HTTPの使用"

#: ../../scala/http/introduction.rst:30
msgid ""
"Akka HTTP is provided in a separate jar file, to use it make sure to include"
" the following dependency::"
msgstr "Akka HTTPは別のjarファイルとして提供されています。使用する際は以下の依存関係をインクルードしていることを確認してください。"

#: ../../scala/http/introduction.rst:34
msgid ""
"Mind that ``akka-http`` comes in two modules: ``akka-http-experimental`` and"
" ``akka-http-core``. Because ``akka-http-experimental`` depends on ``akka-"
"http-core`` you don't need to bring the latter explicitly. Still you may "
"need to this in case you rely solely on low-level API."
msgstr ""
"``akka-http``は2つのモジュール``akka-http-experimental``と``akka-http-"
"core``からなることを心に留めておいてください。``akka-http-experimental``は``akka-http-"
"core``に依存しているので、後者を明示的に持ってくる必要はありません。もっぱら低レベルAPIに頼る場合ではまだこのようにする必要があります。"

#: ../../scala/http/introduction.rst:40
msgid "Routing DSL for HTTP servers"
msgstr "HTTPサーバーのルーティングDSL"

#: ../../scala/http/introduction.rst:41
msgid ""
"The high-level, routing API of Akka HTTP provides a DSL to describe HTTP "
"\"routes\" and how they should be handled. Each route is composed of one or "
"more level of ``Directive`` s that narrows down to handling one specific "
"type of request."
msgstr ""
"Akkaの高レベルのルーティングAPIは、HTTPの「経路」を記述し、それらがどのように扱われるのかを記述するDSLを提供します。各経路は、特定の1種類のリクエストに絞り込む、1つまたは複数のレベルの``Directive``からなります。"

#: ../../scala/http/introduction.rst:45
msgid ""
"For example one route might start with matching the ``path`` of the request,"
" only matching if it is \"/hello\", then narrowing it down to only handle "
"HTTP ``get`` requests and then ``complete`` those with a string literal, "
"which will be sent back as a HTTP OK with the string as response body."
msgstr ""
"例えば、ある経路がリクエストの``path``とマッチすることにより開始するかもしれないとき、これがもし「/hello」にしかマッチしないとしたら、それはHTTP"
" ``get``リクエストのみに絞り込まれて、HTTP "
"OKとともにレスポンスボディの文字列として返された文字列リテラルと共に``complete``します。"

#: ../../scala/http/introduction.rst:49
msgid ""
"Transforming request and response bodies between over-the-wire formats and "
"objects to be used in your application is done separately from the route "
"declarations, in marshallers, which are pulled in implicitly using the "
"\"magnet\" pattern. This means that you can ``complete`` a request with any "
"kind of object a as long as there is an implicit marshaller available in "
"scope."
msgstr ""
"通信のフォーマットとオブジェクトの間でのリクエストとレスポンスの本体の変換は、ルーティングの定義とは切り離されていて、「磁石の」パターンにより暗黙に引き寄せられたマーシャラーにより行われます。これはスコープ中で暗黙のマーシャラーが有効である限り、どのような種類のオブジェクトによるリクエストであっても``complete``することができることを意味します。"

#: ../../scala/http/introduction.rst:54
msgid ""
"Default marshallers are provided for simple objects like String or "
"ByteString, and you can define your own for example for JSON. An additional "
"module provides JSON serialization using the spray-json library (see :ref"
":`akka-http-spray-json` for details)."
msgstr ""
"デフォルトのマーシャラーはStringやByteStringのような他純なオブジェクトとして提供されますし、例えばJSONのようにあなた自身で定義することもできます"
"。追加のモジュールはspray-jsonライブラリを使ってJSONシリアライゼーションを提供します(詳細は:ref:`akka-http-spray-"
"json`を参照してください)。"

#: ../../scala/http/introduction.rst:58
msgid ""
"The ``Route`` created using the Route DSL is then \"bound\" to a port to "
"start serving HTTP requests:"
msgstr "Route DSLを使って作られた``Route``はHTTPリクエストを受けるためにポートに「バインドされます」:"

#: ../../scala/http/introduction.rst:63
msgid ""
"A common use case is to reply to a request using a model object having the "
"marshaller transform it into JSON. In this case shown by two separate "
"routes. The first route queries an asynchronous database and marshalls the "
"``Future[Option[Item]]`` result into a JSON response. The second unmarshalls"
" an ``Order`` from the incoming request saves it to the database and replies"
" with an OK when done."
msgstr ""
"よくあるユースケースは、JSONへのマーシャラー変換を持つモデルオブジェクトを使ってリクエストに応答するものです。この場合、2つの別々のルーティングが見られます。最初のルーティングはデータベースへの非同期クエリを発行し、JSONレスポンスの中に``Future[Option[Item]]``をマーシャリングします。2つめはデータベースを保存して完了したときにOKを返すようなリクエストを受信し、``Order``をアンマーシャリングします。"

#: ../../scala/http/introduction.rst:71
msgid ""
"The logic for the marshalling and unmarshalling JSON in this example is "
"provided by the \"spray-json\" library (details on how to use that here: "
":ref:`akka-http-spray-json`)."
msgstr ""
"この例でのマーシャリングとアンマーシャリングのロジックはspray-jsonライブラリによって提供されています(使い方の詳細はこちら:  :ref"
":`akka-http-spray-json`)。"

#: ../../scala/http/introduction.rst:74
msgid ""
"One of the strengths of Akka HTTP is that streaming data is at its heart "
"meaning that both request and response bodies can be streamed through the "
"server achieving constant memory usage even for very large requests or "
"responses. Streaming responses will be backpressured by the remote client so"
" that the server will not push data faster than the client can handle, "
"streaming requests means that the server decides how fast the remote client "
"can push the data of the request body."
msgstr ""
"Akka "
"HTTPの強力さのひとつは、ストリーミングデータがその心臓部にあるということです。これが意味するのは、非常に巨大なリクエストやレスポンスであっても、サーバーが一定のメモリ使用量にしか達しないように、リクエストとレスポンスの本体がともに流れていくことができるということです。ストリーミングのレスポンスはリモートクライアントによりバックプレッシャーされます。サーバーはクライアントが扱えるよりもデータをすばやく送信することはできないためです。リクエストのストリーミングとは、サーバーがリモートクライアントに対してどの程度すばやくリクエスト本体のデータを送信するかを決定することを意味しています。"

#: ../../scala/http/introduction.rst:80
msgid ""
"Example that streams random numbers as long as the client accepts them:"
msgstr "クライアントが受け入れるまでランダムな数をストリームする例:"

#: ../../scala/http/introduction.rst:85
msgid ""
"Connecting to this service with a slow HTTP client would backpressure so "
"that the next random number is produced on demand with constant memory usage"
" on the server. This can be seen using curl and limiting the rate ``curl "
"--limit-rate 50b 127.0.0.1:8080/random``"
msgstr ""
"低速のHTTPクライアントでこのサービスに接続すると、サーバーで一定のメモリ使用量により次の乱数が必要に応じて生成されるようにバックプレッシャーがかかります。これはcurlを使って転送レートを制限すると見ることができます:"
" `curl --limit-rate 50b 127.0.0.1:8080/random``"

#: ../../scala/http/introduction.rst:90
msgid ""
"Akka HTTP routes easily interacts with actors. In this example one route "
"allows for placing bids in a fire-and-forget style while the second route "
"contains a request-response interaction with an actor. The resulting "
"response is rendered as json and returned when the response arrives from the"
" actor."
msgstr ""
"Akka HTTPルーティングはアクターと簡単にやりとりします。 この例では、1つのルートではfire and "
"forgetスタイルで入札を行うことを可能とし、2番目のルートにはアクターとのリクエスト/レスポンスインタラクションが含まれています。結果のレスポンスはjsonとしてレンダリングされ、レスポンスがアクターから到着したときに返されます。"

#: ../../scala/http/introduction.rst:97
msgid ""
"Again the logic for the marshalling and unmarshalling JSON in this example "
"is provided by the \"spray-json\" library (details on how to use that here: "
":ref:`akka-http-spray-json`)"
msgstr ""
"この例のJSONのマーシャリングとアンマーシャリングのロジックは、\"spray-json\"ライブラリ(これを使用する方法の詳細は: :ref"
":`akka-http-spray-json`)で提供されています。"

#: ../../scala/http/introduction.rst:101
msgid ""
"Read more about the details of the high level APIs in the section :ref"
":`http-high-level-server-side-api`."
msgstr ""
"高レベルAPIの詳細については、:ref:`http-high-level-server-side-api` のセクションを参照してください。"

#: ../../scala/http/introduction.rst:104
msgid "Low-level HTTP server APIs"
msgstr "低レベルのHTTPサーバーAPI"

#: ../../scala/http/introduction.rst:105
msgid ""
"The low-level Akka HTTP server APIs allows for handling connections or "
"individual requests by accepting ``HttpRequest`` s and answering them by "
"producing ``HttpResponse`` s. This is provided by the ``akka-http-core`` "
"module. APIs for handling such request-responses as function calls and as a "
"``Flow[HttpRequest, HttpResponse, _]`` are available."
msgstr ""
"低レベルのAkka HTTPサーバAPIは、``HttpRequest``を受け取り、``HttpResponse`` "
"を生成することによって応答することによって、接続や個々のリクエストを扱うことを可能にします。 これは``akka-http-core`` "
"モジュールによって提供されます。 関数呼び出しや``Flow[HttpRequest, HttpResponse, "
"_]``などのリクエストレスポンスを処理するためのAPIが用意されています。"

#: ../../scala/http/introduction.rst:112
msgid ""
"Read more details about the low level APIs in the section :ref:`http-low-"
"level-server-side-api`."
msgstr "高レベルAPIの詳細については、:ref:`http-low-level-server-side-api`のセクションを参照してください。"

#: ../../scala/http/introduction.rst:116
msgid "HTTP client API"
msgstr "HTTPクライアントAPI"

#: ../../scala/http/introduction.rst:117
msgid ""
"The client APIs provide methods for calling a HTTP server using the same "
"``HttpRequest`` and ``HttpResponse`` abstractions that Akka HTTP server uses"
" but adds the concept of connection pools to allow multiple requests to the "
"same server to be handled more performantly by re-using TCP connections to "
"the server."
msgstr ""
"クライアントAPIは、Akka HTTPサーバが使用する同じ``HttpRequest`` および``HttpResponse`` "
"の抽象化を使用してHTTPサーバを呼び出すメソッドを提供しますが、サーバーへのTCP接続を再利用することにより、同じサーバーへの複数の要求をより効率的に処理できるようにする接続プールの概念が追加されています。"

#: ../../scala/http/introduction.rst:121
msgid "Example simple request:"
msgstr "単純なリクエストの例："

#: ../../scala/http/introduction.rst:127
msgid ""
"Read more about the details of the client APIs in the section :ref:`http-"
"client-side`."
msgstr "クライアントAPIの詳細については、:ref:`http-client-side`のセクションを参照してください。"

#: ../../scala/http/introduction.rst:132
msgid "The modules that make up Akka HTTP"
msgstr "Akka HTTPを構成するモジュール"

#: ../../scala/http/introduction.rst:133
msgid "Akka HTTP is structured into several modules:"
msgstr "Akka HTTPはいくつかのモジュールで構成されています。"

#: ../../scala/http/introduction.rst:138
msgid "akka-http"
msgstr "akka-http"

#: ../../scala/http/introduction.rst:136
msgid ""
"Higher-level functionality, like (un)marshalling, (de)compression as well as"
" a powerful DSL for defining HTTP-based APIs on the server-side, this is the"
" recommended way to write HTTP servers with Akka HTTP. Details can be found "
"in the section :ref:`http-high-level-server-side-api`"
msgstr ""
"サーバー側でHTTPベースのAPIを定義するためのパワフルなDSLと同様に、(非)マーシャリング、(非)圧縮のような高レベルの機能は、Akka "
"HTTPでHTTPサーバーを作成するための推奨方法です。 詳細は、:ref:`http-high-level-server-side-"
"api`のセクションにあります。"

#: ../../scala/http/introduction.rst:142
msgid "akka-http-core"
msgstr "akka-http-core"

#: ../../scala/http/introduction.rst:141
msgid ""
"A complete, mostly low-level, server- and client-side implementation of HTTP"
" (incl. WebSockets) Details can be found in sections :ref:`http-low-level-"
"server-side-api` and :ref:`http-client-side`"
msgstr ""
"HTTP(WebSocketsを含む)の詳細については、主に低レベルのサーバー側とクライアント側の実装がセクションにあります :ref:`http-"
"low-level-server-side-api` と :ref:`http-client-side`"

#: ../../scala/http/introduction.rst:145
msgid "akka-http-testkit"
msgstr "akka-http-testkit"

#: ../../scala/http/introduction.rst:145
msgid ""
"A test harness and set of utilities for verifying server-side service "
"implementations"
msgstr "サーバー側のサービス実装を検証するためのテストハーネスと一連のユーティリティ"

#: ../../scala/http/introduction.rst:149
msgid "akka-http-spray-json"
msgstr "akka-http-spray-json"

#: ../../scala/http/introduction.rst:148
msgid ""
"Predefined glue-code for (de)serializing custom types from/to JSON with "
"spray-json_ Details can be found here: :ref:`akka-http-spray-json`"
msgstr ""
"カスタム型をJSONから、またはJSONへ、(デ)シリアライズを行うためのあらかじめ定義されたglue-code 詳細はここにあります :ref"
":`akka-http-spray-json`_ "

#: ../../scala/http/introduction.rst:153
msgid "akka-http-xml"
msgstr "akka-http-xml"

#: ../../scala/http/introduction.rst:152
msgid ""
"Predefined glue-code for (de)serializing custom types from/to XML with "
"scala-xml_ Details can be found here: :ref:`akka-http-xml-marshalling`"
msgstr ""
"scala-xmlでカスタム型をXMLから、または、XMLへ、(デ)シリアライズするための事前定義されたglue-code 詳細は:ref:`akka-"
"http-xml-marshalling`_ を参照してください。"
