# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kazuki Negoro <negokaz@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../scala/cluster-sharding.rst:4
msgid "Cluster Sharding"
msgstr "クラスターシャーディング"

#: ../../scala/cluster-sharding.rst:6
msgid ""
"Cluster sharding is useful when you need to distribute actors across several"
" nodes in the cluster and want to be able to interact with them using their "
"logical identifier, but without having to care about their physical location"
" in the cluster, which might also change over time."
msgstr ""
"クラスターシャーディングはクラスタのいくつかのノードにまたがってアクターを分散させ、時間とともに変化するであろうクラスタでの物理的な位置を気にすることなしに、それらを論理的な識別子を使って相互作用できるようにしたいときに便利です。"

#: ../../scala/cluster-sharding.rst:10
msgid ""
"It could for example be actors representing Aggregate Roots in Domain-Driven"
" Design terminology. Here we call these actors \"entities\". These actors "
"typically have persistent (durable) state, but this feature is not limited "
"to actors with persistent state."
msgstr ""
"例として、アクターをドメイン駆動設計の用語で集約ルートとして表すこともできます。ここではアクターのことを \"エンティティ\" "
"と呼びます。これらのアクターは一般的に永続化された (耐久性のある) 状態を持ちますが、この機能では状態が永続化されたアクターとは限りません。"

#: ../../scala/cluster-sharding.rst:14
msgid ""
"Cluster sharding is typically used when you have many stateful actors that "
"together consume more resources (e.g. memory) than fit on one machine. If "
"you only have a few stateful actors it might be easier to run them on a :ref"
":`cluster-singleton-scala` node."
msgstr ""
"クラスターシャーディングは一般的に、たくさんのステートフルなアクターがあり、一つのマシンにあるよりも多くのリソース (例えばメモリ) "
"を消費するときに使います。もし少ない数のステートフルなアクターがあるだけの場合は、 :ref:`cluster-singleton-scala` "
"のノードで動かすほうが簡単になる可能性があります。"

#: ../../scala/cluster-sharding.rst:18
msgid ""
"In this context sharding means that actors with an identifier, so called "
"entities, can be automatically distributed across multiple nodes in the "
"cluster. Each entity actor runs only at one place, and messages can be sent "
"to the entity without requiring the sender to know the location of the "
"destination actor. This is achieved by sending the messages via a "
"``ShardRegion`` actor provided by this extension, which knows how to route "
"the message with the entity id to the final destination."
msgstr ""
"この文脈においてシャーディングは識別子を持ったアクターを意味するので、エンティティと呼び、クラスターの復数のノードにまたっがって自動的に分散させることができるようになります。それぞれのエンティティのアクターは一箇所でのみ稼働し、メッセージは送り元が宛先のアクターの居場所を必要とせず送れるようになります。これはこの拡張から提供される、エンティティ"
" ID が含まれているメッセージをどうルートすれば最終的な宛先に届くのかを知っている `ShardRegion` "
"アクターを通じてメッセージを送ることで成し遂げられます。"

#: ../../scala/cluster-sharding.rst:25
msgid ""
"Cluster sharding will not be active on members with status :ref:`WeaklyUp "
"<weakly_up_scala>` if that feature is enabled."
msgstr ""
"クラスターシャーディングは、ステータスが :ref:`WeaklyUp <weakly_up_scala>`  "
"になる機能が有効になっていて、そのステータスのメンバがいるとアクティブになりません。"

#: ../../scala/cluster-sharding.rst:29
msgid ""
"**Don't use Cluster Sharding together with Automatic Downing**, since it "
"allows the cluster to split up into two separate clusters, which in turn "
"will result in *multiple shards and entities* being started, one in each "
"separate cluster! See :ref:`automatic-vs-manual-downing-java`."
msgstr ""
"**クラスターシャーディングを自動ダウン機能と一緒に使わないでください**。クラスタが2つの別のクラスタに分断するのを許してしまい、 "
"*復数のシャードとエンティティ* がそれぞれ別のクラスタで起動してしまう結果になるからです！:ref:`automatic-vs-manual-"
"downing-java` を参照してください。"

#: ../../scala/cluster-sharding.rst:35
msgid "An Example"
msgstr "例"

#: ../../scala/cluster-sharding.rst:37
msgid "This is how an entity actor may look like:"
msgstr "エンティティのアクターがどう見えるか:"

#: ../../scala/cluster-sharding.rst:41
msgid ""
"The above actor uses event sourcing and the support provided in "
"``PersistentActor`` to store its state. It does not have to be a persistent "
"actor, but in case of failure or migration of entities between nodes it must"
" be able to recover its state if it is valuable."
msgstr ""
"上記のアクターは `PersistentActor` "
"からサポートが提供されるイベントソーシングを使い、状態を保存します。永続アクターになる必要はありませんが、障害やノード間でのエンティティのマイグレーションといったケースでは、その状態が重要であるなら復元できる必要があります。"

#: ../../scala/cluster-sharding.rst:45
msgid ""
"Note how the ``persistenceId`` is defined. The name of the actor is the "
"entity identifier (utf-8 URL-encoded). You may define it another way, but it"
" must be unique."
msgstr ""
"``persistenceId`` がどう定義されているか注目してください。アクターの名前はエンティティの識別子 (URL エンコードされた "
"utf-8) です。あなたは他の方法で定義するかもしれませんが、ユニークになる必要があります。"

#: ../../scala/cluster-sharding.rst:48
msgid ""
"When using the sharding extension you are first, typically at system startup"
" on each node in the cluster, supposed to register the supported entity "
"types with the ``ClusterSharding.start`` method. ``ClusterSharding.start`` "
"gives you the reference which you can pass along."
msgstr ""
"シャーディングの拡張を使うときはまず、一般的にはクラスターのそれぞれのノードのシステム起動時に、``ClusterSharding.start`` "
"メソッドでサポートされているエンティティの型を登録することになっています。``ClusterSharding.start`` "
"は参照を提供し、その参照を伝って渡すことができます。"

#: ../../scala/cluster-sharding.rst:54
msgid ""
"The ``extractEntityId`` and ``extractShardId`` are two application specific "
"functions to extract the entity identifier and the shard identifier from "
"incoming messages."
msgstr ""
"``extractEntityId`` と ``extractShardId`` は 2 "
"つのアプリケーション固有の機能で、やってくるメッセージからエンティティの識別子とシャードの識別子を取り出します。"

#: ../../scala/cluster-sharding.rst:59
msgid ""
"This example illustrates two different ways to define the entity identifier "
"in the messages:"
msgstr "この例はメッセージにあるエンティティの識別子を定義する 2 つの異なる方法を示しています。"

#: ../../scala/cluster-sharding.rst:61
msgid "The ``Get`` message includes the identifier itself."
msgstr "``Get`` メッセージはそれ自身の識別子を含んでいます。"

#: ../../scala/cluster-sharding.rst:62
msgid ""
"The ``EntityEnvelope`` holds the identifier, and the actual message that is "
"sent to the entity actor is wrapped in the envelope."
msgstr ""
"``EntityEnvelope`` は識別子を保持しており、エンティティのアクターに送られる本当のメッセージはそのエンベロープに包まれています。"

#: ../../scala/cluster-sharding.rst:65
msgid ""
"Note how these two messages types are handled in the ``extractEntityId`` "
"function shown above. The message sent to the entity actor is the second "
"part of the tuple return by the ``extractEntityId`` and that makes it "
"possible to unwrap envelopes if needed."
msgstr ""
"上記に示された ``extractEntityId`` 関数で 2 "
"つのメッセージの型がどう処理されるか注目してください。エンティティのアクターに送ったメッセージは ``extractEntityId`` "
"から返されるタプルの 2 番目で、必要であればエンベロープから取り出させることができます。"

#: ../../scala/cluster-sharding.rst:69
msgid ""
"A shard is a group of entities that will be managed together. The grouping "
"is defined by the ``extractShardId`` function shown above. For a specific "
"entity identifier the shard identifier must always be the same."
msgstr ""
"シャードはエンティティのグループで、一緒に管理されます。そのグループは上記に示した ``extractShardId`` "
"関数で定義されます。特定のエンティティの識別子に対するシャードの識別子はいつも同じである必要があります。"

#: ../../scala/cluster-sharding.rst:73
msgid ""
"Creating a good sharding algorithm is an interesting challenge in itself. "
"Try to produce a uniform distribution, i.e. same amount of entities in each "
"shard. As a rule of thumb, the number of shards should be a factor ten "
"greater than the planned maximum number of cluster nodes. Less shards than "
"number of nodes will result in that some nodes will not host any shards. Too"
" many shards will result in less efficient management of the shards, e.g. "
"rebalancing overhead, and increased latency because the coordinator is "
"involved in the routing of the first message for each shard. The sharding "
"algorithm must be the same on all nodes in a running cluster. It can be "
"changed after stopping all nodes in the cluster."
msgstr ""
"良いシャーディングアルゴリズムを作ることは、それ自体が興味深い挑戦です。均一な分散、すなわちそれぞれのシャードに同じ量のエンティティになるように作ってみてください。経験則として、シャードの数はクラスターノードの計画された最大数の"
" 10 "
"倍より大きい数にすべきです。ノード数よりも少ないシャードだと、いくつかのノードにはシャードが一つもホストされなくなります。多すぎるシャードはシャードによる管理効率を損ない、例えば、リバランスのオーバーヘッドと、レイテンシの増加に繋がります。コーディネーターがそれぞれのシャードへの最初のメッセージルーティングに関わっているからです。シャーディングのアルゴリズムは稼働しているクラスタの全てのノードで同じである必要があります。クラスタの全てのノードを停止させた後、変更することができるようになります。"

#: ../../scala/cluster-sharding.rst:81
msgid ""
"A simple sharding algorithm that works fine in most cases is to take the "
"absolute value of the ``hashCode`` of the entity identifier modulo number of"
" shards. As a convenience this is provided by the "
"``ShardRegion.HashCodeMessageExtractor``."
msgstr ""
"ほとんどのケースにおいて、エンティティの識別子の ``hashCode`` "
"の絶対値をシャードの数で余剰を取るシンプルなシャードのアルゴリズムで上手くいきます。これは利便性のために "
"``ShardRegion.HashCodeMessageExtractor`` で提供されています。"

#: ../../scala/cluster-sharding.rst:85
msgid ""
"Messages to the entities are always sent via the local ``ShardRegion``. The "
"``ShardRegion`` actor reference for a named entity type is returned by "
"``ClusterSharding.start`` and it can also be retrieved with "
"``ClusterSharding.shardRegion``. The ``ShardRegion`` will lookup the "
"location of the shard for the entity if it does not already know its "
"location. It will delegate the message to the right node and it will create "
"the entity actor on demand, i.e. when the first message for a specific "
"entity is delivered."
msgstr ""
"エンティティへのメッセージはいつもローカルの ``ShardRegion`` を通じて送信されます。名付けられた、あるエンティティの型のための "
"``ShardRegion`` アクターの参照は ``ClusterSharding.start`` "
"から返され、``ClusterSharding.shardRegion`` "
"でも取り出すことができます。エンティティのシャードの位置をまだ知らないとき、``ShardRegion`` "
"は、その位置を見つけ出します。それはメッセージを正しいノードに委譲し、オンデマンドで、すなわち特定のエンティティに最初のメッセージが送られたときにエンティティのアクターを作ります。"

#: ../../scala/cluster-sharding.rst:93
msgid ""
"A more comprehensive sample is available in the `Lightbend Activator "
"<http://www.lightbend.com/platform/getstarted>`_ tutorial named `Akka "
"Cluster Sharding with Scala! <http://www.lightbend.com/activator/template"
"/akka-cluster-sharding-scala>`_."
msgstr ""
"さらに包括的なサンプルは `Lightbend Activator "
"<http://www.lightbend.com/platform/getstarted>`_ の `Akka Cluster Sharding "
"with Scala! <http://www.lightbend.com/activator/template/akka-cluster-"
"sharding-scala>`_ と名付けられたチュートリアルにあります。"

#: ../../scala/cluster-sharding.rst:97
msgid "How it works"
msgstr "どのように動作するか"

#: ../../scala/cluster-sharding.rst:99
msgid ""
"The ``ShardRegion`` actor is started on each node in the cluster, or group "
"of nodes tagged with a specific role. The ``ShardRegion`` is created with "
"two application specific functions to extract the entity identifier and the "
"shard identifier from incoming messages. A shard is a group of entities that"
" will be managed together. For the first message in a specific shard the "
"``ShardRegion`` request the location of the shard from a central "
"coordinator, the ``ShardCoordinator``."
msgstr ""
"``ShardRegion`` アクターはクラスターのそれぞれのノードか、特定のロールでタグ付けされたノードで開始されます。 "
"``ShardRegion`` は入ってくるメッセージからエンティティの識別子とシャードの識別子を取り出す、アプリケーションの特定の 2 "
"つの関数によって作られます。シャードは一緒に管理されるエンティティのグループです。特定のシャードに最初のメッセージが来ると、 "
"``ShardRegion`` は中央のコーディネーターからシャードの位置をリクエストします。"

#: ../../scala/cluster-sharding.rst:106
msgid ""
"The ``ShardCoordinator`` decides which ``ShardRegion`` shall own the "
"``Shard`` and informs that ``ShardRegion``. The region will confirm this "
"request and create the ``Shard`` supervisor as a child actor. The individual"
" ``Entities`` will then be created when needed by the ``Shard`` actor. "
"Incoming messages thus travel via the ``ShardRegion`` and the ``Shard`` to "
"the target ``Entity``."
msgstr ""
"``ShardCoordinator`` はどの ``ShardRegion`` が ``Shard`` を所有するのかを決定し、そのことを "
"``ShardRegion`` に告げます。そのリージョンはこのリクエストを確認し、子アクターとして ``Shard`` "
"スーパーバイザーを作ります。個別の ``Entities`` は ``Shard`` アクターに必要とされたときに作られます。入ってくるメッセージは "
"``ShardRegion`` と ``Shard`` 経由することでターゲットの ``Entity`` へ旅をします。"

#: ../../scala/cluster-sharding.rst:112
msgid ""
"If the shard home is another ``ShardRegion`` instance messages will be "
"forwarded to that ``ShardRegion`` instance instead. While resolving the "
"location of a shard incoming messages for that shard are buffered and later "
"delivered when the shard home is known. Subsequent messages to the resolved "
"shard can be delivered to the target destination immediately without "
"involving the ``ShardCoordinator``."
msgstr ""
"もしシャードが別の ``ShardRegion`` インスタンスに所属している場合、メッセージは代わりにその ``ShardRegion`` "
"へ転送されます。シャードの場所を解決している間、そのシャードへ宛てて入ってくるメッセージはバッファされ、シャードの所属が解決された後に配送されます。解決したシャードに宛てた後続のメッセージは"
" ``ShardCoordinator`` の関与なしに、即座にターゲットの宛先へ配送させることができます。"

#: ../../scala/cluster-sharding.rst:118
msgid "Scenario 1:"
msgstr "シナリオ 1:"

#: ../../scala/cluster-sharding.rst:120
msgid "Incoming message M1 to ``ShardRegion`` instance R1."
msgstr "M1 メッセージが R1 ``ShardRegion`` インスタンスに宛てて入ってきます。"

#: ../../scala/cluster-sharding.rst:121
msgid ""
"M1 is mapped to shard S1. R1 doesn't know about S1, so it asks the "
"coordinator C for the location of S1."
msgstr "M1 は S1 シャードにマッピングされます。R1 は S1 について知らないので、C コーディネーターに S1 の場所を尋ねます。"

#: ../../scala/cluster-sharding.rst:122
msgid "C answers that the home of S1 is R1."
msgstr "S1 の所属は R1 だと C が答えます。"

#: ../../scala/cluster-sharding.rst:123
msgid ""
"R1 creates child actor for the entity E1 and sends buffered messages for S1 "
"to E1 child"
msgstr "R1 は E1 エンティティのための子アクターを作成し、バッファした E1 に宛てたメッセージを子の S1 に送ります。"

#: ../../scala/cluster-sharding.rst:124
msgid ""
"All incoming messages for S1 which arrive at R1 can be handled by R1 without"
" C. It creates entity children as needed, and forwards messages to them."
msgstr ""
"R1 に届く、S1 に向けて入ってくるメッセージは 全て C なしに R1 "
"によって処理されます。それは必要に応じて子のエンティティを作成し、それらにメッセージを転送します。"

#: ../../scala/cluster-sharding.rst:126
msgid "Scenario 2:"
msgstr "シナリオ 2:"

#: ../../scala/cluster-sharding.rst:128
msgid "Incoming message M2 to R1."
msgstr "M2 メッセージが R1 に向けて入ってきます。"

#: ../../scala/cluster-sharding.rst:129
msgid ""
"M2 is mapped to S2. R1 doesn't know about S2, so it asks C for the location "
"of S2."
msgstr "M2 は S2 にマッピングされています。R1 は S2 について知らないので、C に S2 の場所を問い合わせます。"

#: ../../scala/cluster-sharding.rst:130
msgid "C answers that the home of S2 is R2."
msgstr "S2 の所属は R2 だと C が答えます。"

#: ../../scala/cluster-sharding.rst:131
msgid "R1 sends buffered messages for S2 to R2"
msgstr "R1 はバッファした S2 に宛てたメッセージを R2 に送ります。"

#: ../../scala/cluster-sharding.rst:132
msgid ""
"All incoming messages for S2 which arrive at R1 can be handled by R1 without"
" C. It forwards messages to R2."
msgstr "R1 に届く、S2 に宛てて入ってくるメッセージは全て C なしに R1 によって処理されます。それはメッセージを R2 に転送します。"

#: ../../scala/cluster-sharding.rst:133
msgid ""
"R2 receives message for S2, ask C, which answers that the home of S2 is R2, "
"and we are in Scenario 1 (but for R2)."
msgstr ""
"R2 は S2 に宛てたメッセージを受け取り、C に尋ね、C は S2 の所属が R2 だと答え、(R2のための) シナリオ 1 に入ります。"

#: ../../scala/cluster-sharding.rst:135
msgid ""
"To make sure that at most one instance of a specific entity actor is running"
" somewhere in the cluster it is important that all nodes have the same view "
"of where the shards are located. Therefore the shard allocation decisions "
"are taken by the central ``ShardCoordinator``, which is running as a cluster"
" singleton, i.e. one instance on the oldest member among all cluster nodes "
"or a group of nodes tagged with a specific role."
msgstr ""
"特定のエンティティアクターのインスタンスは、高々一つだけクラスターのどこかで実行されています。全てのノードがどこにシャードが位置しているのかを同じように認識しているのは重要です。シャード割り当ての決定はクラスターシングルトンで実行されている中央の"
"  ``ShardCoordinator`` "
"によって行われるからです。シングルトンとはすなわち、全てのクラスターノードで最も古いメンバか、特定のロールでタグ付けされたノードのグループ内でインスタンスが一つです。"

#: ../../scala/cluster-sharding.rst:142
msgid ""
"The logic that decides where a shard is to be located is defined in a "
"pluggable shard allocation strategy. The default implementation "
"``ShardCoordinator.LeastShardAllocationStrategy`` allocates new shards to "
"the ``ShardRegion`` with least number of previously allocated shards. This "
"strategy can be replaced by an application specific implementation."
msgstr ""
"シャードをどこに配置するかを決定するロジックは付け替えできるシャードのアロケーションストラテジーで定義されています。デフォルトの実装である "
"``ShardCoordinator.LeastShardAllocationStrategy`` はそれまでに割り当てたシャードが一番少ない "
"``ShardRegion`` に新しいシャードを割り当てます。このストラテジーはアプリケーション特有の実装に置き換えられます。"

#: ../../scala/cluster-sharding.rst:147
msgid ""
"To be able to use newly added members in the cluster the coordinator "
"facilitates rebalancing of shards, i.e. migrate entities from one node to "
"another. In the rebalance process the coordinator first notifies all "
"``ShardRegion`` actors that a handoff for a shard has started. That means "
"they will start buffering incoming messages for that shard, in the same way "
"as if the shard location is unknown. During the rebalance process the "
"coordinator will not answer any requests for the location of shards that are"
" being rebalanced, i.e. local buffering will continue until the handoff is "
"completed. The ``ShardRegion`` responsible for the rebalanced shard will "
"stop all entities in that shard by sending the specified "
"``handOffStopMessage`` (default ``PoisonPill``) to them. When all entities "
"have been terminated the ``ShardRegion`` owning the entities will "
"acknowledge the handoff as completed to the coordinator. Thereafter the "
"coordinator will reply to requests for the location of the shard and thereby"
" allocate a new home for the shard and then buffered messages in the "
"``ShardRegion`` actors are delivered to the new location. This means that "
"the state of the entities are not transferred or migrated. If the state of "
"the entities are of importance it should be persistent (durable), e.g. with "
":ref:`persistence-scala`, so that it can be recovered at the new location."
msgstr ""
"新たに追加されたメンバをクラスターで使用できるようにするために、コーディネータはシャードのリバランス、すなわち、あるノードから別のノードへエンティティを移行することをアシストします。リバランスプロセスでは、コーディネーターは最初にシャードのハンドオフが開始されたことをすべての"
" ``ShardRegion`` "
"アクターに通知します。つまり、シャードの位置がわからない場合と同じ方法で、そのシャードの受信メッセージをバッファリングし始めます。リバランス中、コーディネータはリバランスされているシャードの位置に対する要求には応答せず、すなわち、ハンドオフが完了するまでローカルのバッファリングが継続されます。リバランスされたシャードに対する責任を負う"
" ``ShardRegion`` は、指定された ``handOffStopMessage`` （デフォルトは ``PoisonPill`` "
"）をそれらのシャードに送ることによって、そのシャードのすべてのエンティティを停止します。すべてのエンティティが終了したとき、エンティティを所有する "
"``ShardRegion`` "
"はコーディネータへハンドオフの完了確認を通知します。その後コーディネータは、シャードの位置に関するリクエストに応答し、それによってシャードの新しい位置を割り当て、次いで"
" ``ShardRegion`` "
"アクターにバッファされたメッセージが新しい位置に配信されます。これは、エンティティの状態が転送されたり、移行されたりしないことを意味します。エンティティの状態が重要である場合、エンティティは永続的（耐久性のある状態）でなければなりません。"
"  :ref:`persistence-scala` を追加すると、新しい場所で状態を復元できます。"

#: ../../scala/cluster-sharding.rst:164
msgid ""
"The logic that decides which shards to rebalance is defined in a pluggable "
"shard allocation strategy. The default implementation "
"``ShardCoordinator.LeastShardAllocationStrategy`` picks shards for handoff "
"from the ``ShardRegion`` with most number of previously allocated shards. "
"They will then be allocated to the ``ShardRegion`` with least number of "
"previously allocated shards, i.e. new members in the cluster. There is a "
"configurable threshold of how large the difference must be to begin the "
"rebalancing. This strategy can be replaced by an application specific "
"implementation."
msgstr ""
"リバランスするシャードを決定するロジックは、付け替えできるシャードのアロケーションストラテジーで定義されています。 デフォルト実装の "
"``ShardCoordinator.LeastShardAllocationStrategy`` "
"はハンドオフのために、以前に割り当てられたシャードを多く持つ ``ShardRegion`` から、シャードを選びます。 "
"次に、以前に割り当てられたシャードの数が最も少ない ``ShardRegion`` 、すなわち、クラスターの新しいメンバに割り当てられます。 "
"リバランスを開始するのに、差がどれだけ大きくなければならないかという、設定可能な閾値があります。 "
"この戦略は、アプリケーション固有の実装に置き換えることができます。"

#: ../../scala/cluster-sharding.rst:172
msgid ""
"The state of shard locations in the ``ShardCoordinator`` is persistent "
"(durable) with :ref:`persistence-scala` to survive failures. Since it is "
"running in a cluster :ref:`persistence-scala` must be configured with a "
"distributed journal. When a crashed or unreachable coordinator node has been"
" removed (via down) from the cluster a new ``ShardCoordinator`` singleton "
"actor will take over and the state is recovered. During such a failure "
"period shards with known location are still available, while messages for "
"new (unknown) shards are buffered until the new ``ShardCoordinator`` becomes"
" available."
msgstr ""
"``ShardCoordinator`` のシャードロケーションの状態は、障害から生き残るために :ref:`persistence-scala` "
"を使って永続化されます (耐久性がある)。これはクラスタ内で実行されているため、 :ref:`persistence-scala` "
"は分散されたジャーナルで構成する必要があります。 クラッシュするか、疎通できないコーディネータノードが (ダウン状態を経由して) "
"クラスターから削除されると、新しい ``ShardCoordinator`` のシングルトンアクターが引き継ぎ、状態が回復します。 "
"このような障害中には、既知の場所のシャードは引き続き使用できますが、新しい (未知の) シャードのメッセージは、新しい "
"``ShardCoordinator`` が利用可能になるまでバッファリングされます。"

#: ../../scala/cluster-sharding.rst:180
msgid ""
"As long as a sender uses the same ``ShardRegion`` actor to deliver messages "
"to an entity actor the order of the messages is preserved. As long as the "
"buffer limit is not reached messages are delivered on a best effort basis, "
"with at-most once delivery semantics, in the same way as ordinary message "
"sending. Reliable end-to-end messaging, with at-least-once semantics can be "
"added by using ``AtLeastOnceDelivery``  in :ref:`persistence-scala`."
msgstr ""
"送信者が同じ ``ShardRegion`` アクターを使用してエンティティアクターにメッセージを配信する限り、メッセージの順序は維持されます。 "
"バッファの上限に達していない限り、メッセージは通常のメッセージ送信と同じ方法で、at-least-once "
"のセマンティクスを使いベストエフォートで配信されます。  :ref:`persistence-scala` の "
"``AtLeastOnceDelivery`` を使うことで、at-least-once "
"のセマンティクスを持つ信頼性の高いエンドツーエンドメッセージングを実現できます。"

#: ../../scala/cluster-sharding.rst:186
msgid ""
"Some additional latency is introduced for messages targeted to new or "
"previously unused shards due to the round-trip to the coordinator. "
"Rebalancing of shards may also add latency. This should be considered when "
"designing the application specific shard resolution, e.g. to avoid too fine "
"grained shards."
msgstr ""
"新しいか、それまで使用されていないシャードを宛先とするメッセージには、コーディネーターへの往復のためのレイテンシが追加されます。 "
"シャードのリバランスでもレイテンシが増える可能性があります。 これは、アプリケーション固有の分割粒度を設計するときに考慮しておく必要があります。 "
"例えば、細かすぎる粒度のシャードにしないなどです。"

#: ../../scala/cluster-sharding.rst:192
msgid "Distributed Data Mode"
msgstr "分散されたデータモード"

#: ../../scala/cluster-sharding.rst:194
msgid ""
"Instead of using :ref:`persistence-scala` it is possible to use the "
":ref:`distributed_data_scala` module as storage for the state of the "
"sharding coordinator. In such case the state of the ``ShardCoordinator`` "
"will be replicated inside a cluster by the :ref:`distributed_data_scala` "
"module with ``WriteMajority``/``ReadMajority`` consistency."
msgstr ""
":ref:`persistence-scala` を使う代わりに、 :ref:`distributed_data_scala` "
"モジュールをシャードコーディネーターの状態のストレージとして使うことができます。 そのような場合、 ``ShardCoordinator`` の状態は "
":ref:`distributed_data_scala` モジュールによって ``WriteMajority`` / ``ReadMajority``"
" の整合性を持ってクラスター内で複製されます。"

#: ../../scala/cluster-sharding.rst:199
msgid "This mode can be enabled by setting configuration property::"
msgstr "このモードは、次の設定プロパティで有効にできます::"

#: ../../scala/cluster-sharding.rst:203
msgid ""
"It is using the Distributed Data extension that must be running on all nodes"
" in the cluster. Therefore you should add that extension to the "
"configuration to make sure that it is started on all nodes::"
msgstr ""
"クラスター内のすべてのノードで実行されている必要があるDistributed Data 拡張機能を使用します。 "
"したがって、すべてのノードに拡張機能の設定を追加して、起動する必要があります::"

#: ../../scala/cluster-sharding.rst:209
msgid ""
"You must explicitly add the ``akka-distributed-data-experimental`` "
"dependency to your build if you use this mode. It is possible to remove "
"``akka-persistence`` dependency from a project if it is not used in user "
"code and ``remember-entities`` is ``off``. Using it together with ``Remember"
" Entities`` shards will be recreated after rebalancing, however will not be "
"recreated after a clean cluster start as the Sharding Coordinator state is "
"empty after a clean cluster start when using ddata mode. When ``Remember "
"Entities`` is ``on`` Sharding Region always keeps data usig persistence, no "
"matter how ``State Store Mode`` is set."
msgstr ""
"このモードを使用する場合は、ビルドへ明示的に ``akka-distributed-data-experimental`` "
"の依存関係を追加する必要があります。もし ``akka-persistence`` がユーザーコードで使われておらず、 ``remember-"
"entities`` が  ``off`` であれば、 ``akka-persistence`` の依存関係をプロジェクトから削除できます。これを "
"``Remember Entities`` "
"と一緒に使うと、リバランス後に再作成されますが、何もない状態からクラスタの開始した後には再作成されません。ddata "
"モードを使用する場合、何もない状態からクラスターを起動した後のシャードコーディネーターの状態は空です。  ``Remember Entities`` が"
" ``on`` のとき、シャードリージョンは、 ``State Store Mode`` がどのように設定されていても、常にデータの永続性を維持します。"

#: ../../scala/cluster-sharding.rst:219
msgid ""
"The ``ddata`` mode is considered as **“experimental”** as of its "
"introduction in Akka 2.4.0, since it depends on the experimental Distributed"
" Data module."
msgstr ""
"``ddata`` モードは、Akka 2.4.0 で導入され、実験的な Distributed Data モジュールに依存するため、 "
"**\"実験的\"** であるとみなされています。"

#: ../../scala/cluster-sharding.rst:223
msgid "Proxy Only Mode"
msgstr "プロキシ専用モード"

#: ../../scala/cluster-sharding.rst:225
msgid ""
"The ``ShardRegion`` actor can also be started in proxy only mode, i.e. it "
"will not host any entities itself, but knows how to delegate messages to the"
" right location. A ``ShardRegion`` is started in proxy only mode with the "
"method ``ClusterSharding.startProxy`` method."
msgstr ""
"``ShardRegion`` "
"アクターは、プロキシ専用モードで開始することもできます。つまり、エンティティを自身にホストせず、メッセージを適切な場所に委譲する方法を知っています。 "
"``ShardRegion`` は ``ClusterSharding.startProxy`` メソッドを使うとプロキシ専用モードで起動します。"

#: ../../scala/cluster-sharding.rst:231
msgid "Passivation"
msgstr "不活性化"

#: ../../scala/cluster-sharding.rst:233
msgid ""
"If the state of the entities are persistent you may stop entities that are "
"not used to reduce memory consumption. This is done by the application "
"specific implementation of the entity actors for example by defining receive"
" timeout (``context.setReceiveTimeout``). If a message is already enqueued "
"to the entity when it stops itself the enqueued message in the mailbox will "
"be dropped. To support graceful passivation without losing such messages the"
" entity actor can send ``ShardRegion.Passivate`` to its parent ``Shard``. "
"The specified wrapped message in ``Passivate`` will be sent back to the "
"entity, which is then supposed to stop itself. Incoming messages will be "
"buffered by the ``Shard`` between reception of ``Passivate`` and termination"
" of the entity. Such buffered messages are thereafter delivered to a new "
"incarnation of the entity."
msgstr ""
"エンティティの状態が永続的な場合は、メモリ消費を減らすために使用されていないエンティティを停止することがあります。 これは、受信タイムアウト ( "
"``context.setReceiveTimeout`` ) を定義するなど、エンティティアクターのアプリケーション固有の実装によって行われます。 "
"メッセージがエンティティにすでにエンキューされていて、エンティティ自体が停止した場合、メールボックスにエンキューされたメッセージは破棄されます。 "
"このようにメッセージを失うことなくグレースフルな不活性化をサポートするために、エンティティのアクターは親の ``Shard`` に "
"``ShardRegion.Passivate`` を送ることができます。 ``Passivate`` "
"にラップされた特定のメッセージはエンティティに返送され、エンティティは自分自身を停止するはずです。 ``Passivate`` "
"を受信してからエンティティが終了するまでの間の受信メッセージは、 ``Shard`` によってバッファリングされます。 "
"そのようにバッファされたメッセージは、その後、エンティティの新しいインスタンスに配信されます。"

#: ../../scala/cluster-sharding.rst:245
msgid "Remembering Entities"
msgstr "エンティティの再現"

#: ../../scala/cluster-sharding.rst:247
msgid ""
"The list of entities in each ``Shard`` can be made persistent (durable) by "
"setting the ``rememberEntities`` flag to true in ``ClusterShardingSettings``"
" when calling ``ClusterSharding.start``. When configured to remember "
"entities, whenever a ``Shard`` is rebalanced onto another node or recovers "
"after a crash it will recreate all the entities which were previously "
"running in that ``Shard``. To permanently stop entities, a ``Passivate`` "
"message must be sent to the parent of the entity actor, otherwise the entity"
" will be automatically restarted after the entity restart backoff specified "
"in the configuration."
msgstr ""
"``ClusterSharding.start`` を呼び出すとき ``ClusterShardingSettings`` の "
"``rememberEntities`` フラグを true に設定することで、各 ``Shard`` のエンティティのリストを永続化 "
"(耐久性がある状態に) できます。 エンティティを覚えるように設定されている場合、 ``Shard`` "
"が別のノードにリバランスされるか、クラッシュ後の復旧をするとき、それ以前にその ``Shard`` "
"で起動していた全てのエンティティを再作成します。エンティティを永久に停止させるには、エンティティアクタの親に ``Passivate`` "
"メッセージを送信しなければなりません。そうしないと、エンティティが撤退した後、設定で指定されたように自動的にそのエンティティが再起動します。"

#: ../../scala/cluster-sharding.rst:256
msgid ""
"When ``rememberEntities`` is set to false, a ``Shard`` will not "
"automatically restart any entities after a rebalance or recovering from a "
"crash. Entities will only be started once the first message for that entity "
"has been received in the ``Shard``. Entities will not be restarted if they "
"stop without using a ``Passivate``."
msgstr ""
"``rememberEntities`` が false に設定されている場合、 ``Shard`` "
"は、リバランス後やクラッシュからの復旧後にエンティティを自動的に再起動しません。 エンティティは、そのエンティティに宛てた最初のメッセージが "
"``Shard`` で受信されたときにのみ開始されます。 ``Passivate`` "
"を使わずにエンティティを停止すると、エンティティは再起動されません。"

#: ../../scala/cluster-sharding.rst:261
msgid ""
"Note that the state of the entities themselves will not be restored unless "
"they have been made persistent, e.g. with :ref:`persistence-scala`."
msgstr ""
"エンティティ自身の状態は、 :ref:`persistence-scala` などで永続化されていなければ復元されないことに注意してください。"

#: ../../scala/cluster-sharding.rst:265
msgid "Supervision"
msgstr "スーパービジョン"

#: ../../scala/cluster-sharding.rst:267
msgid ""
"If you need to use another ``supervisorStrategy`` for the entity actors than"
" the default (restarting) strategy you need to create an intermediate parent"
" actor that defines the ``supervisorStrategy`` to the child entity actor."
msgstr ""
"デフォルトの (再起動) 戦略の代わりに、エンティティアクターで別の ``supervisorStrategy`` "
"を使う必要がある場合は、子のエンティティアクターに対する ``supervisorStrategy`` "
"を定義する中間の親アクターを作成する必要があります。"

#: ../../scala/cluster-sharding.rst:273
msgid ""
"You start such a supervisor in the same way as if it was the entity actor."
msgstr "そのようなスーパーバイザーを、エンティティアクターであるかのように開始します。"

#: ../../scala/cluster-sharding.rst:277
msgid ""
"Note that stopped entities will be started again when a new message is "
"targeted to the entity."
msgstr "停止したエンティティは、新しいメッセージがそのエンティティに宛てられたときに再び開始されることに注意してください。"

#: ../../scala/cluster-sharding.rst:280
msgid "Graceful Shutdown"
msgstr "グレースフルシャットダウン"

#: ../../scala/cluster-sharding.rst:282
msgid ""
"You can send the message ``ShardRegion.GracefulShutdown`` message to the "
"``ShardRegion`` actor to handoff all shards that are hosted by that "
"``ShardRegion`` and then the ``ShardRegion`` actor will be stopped. You can "
"``watch`` the ``ShardRegion`` actor to know when it is completed. During "
"this period other regions will buffer messages for those shards in the same "
"way as when a rebalance is triggered by the coordinator. When the shards "
"have been stopped the coordinator will allocate these shards elsewhere."
msgstr ""
"``ShardRegion.GracefulShutdown`` メッセージを ``ShardRegion`` アクターに送って、 "
"``ShardRegion`` でホストされているすべてのシャードを切り離し、 ``ShardRegion`` アクターを止めることができます。 "
"それがいつ完了したのかを知るために ``ShardRegion`` アクターを ``watch`` "
"することができます。この期間中、コーディネーターによってリバランスがトリガーされたときと同じ方法で、他のリージョンがこれらのシャードのメッセージをバッファします。シャードが停止すると、コーディネーターはこれらのシャードを他の場所に割り当てます。"

#: ../../scala/cluster-sharding.rst:287
msgid ""
"When the ``ShardRegion`` has terminated you probably want to ``leave`` the "
"cluster, and shut down the ``ActorSystem``."
msgstr ""
"``ShardRegion`` が終了したら、クラスターから ``leave`` し、 ``ActorSystem`` をシャットダウンするでしょう。"

#: ../../scala/cluster-sharding.rst:289
msgid "This is how to do that:"
msgstr "これを行う方法:"

#: ../../scala/cluster-sharding.rst:296
msgid "Removal of Internal Cluster Sharding Data"
msgstr "クラスターシャーディングの内部データの削除"

#: ../../scala/cluster-sharding.rst:298
msgid ""
"The Cluster Sharding coordinator stores the locations of the shards using "
"Akka Persistence. This data can safely be removed when restarting the whole "
"Akka Cluster. Note that this is not application data."
msgstr ""
"クラスターシャーディングのコーディネーターは、Akka Persistence を使ってシャードの場所を保存します。このデータは、Akka "
"のクラスタ全体を再起動するときに安全に削除できます。 削除するのはアプリケーションデータではないことに注意してください。"

#: ../../scala/cluster-sharding.rst:302
msgid ""
"There is a utility program "
"``akka.cluster.sharding.RemoveInternalClusterShardingData`` that removes "
"this data."
msgstr ""
"このデータを削除する ``akka.cluster.sharding.RemoveInternalClusterShardingData`` "
"というユーティリティプログラムがあります。"

#: ../../scala/cluster-sharding.rst:307
msgid ""
"Never use this program while there are running Akka Cluster nodes that are "
"using Cluster Sharding. Stop all Cluster nodes before using this program."
msgstr ""
"クラスターシャーディングを使用している Akka のクラスターノードを実行しているときは、このプログラムを決して使わないでください。 "
"このプログラムを使用する前に、すべてのクラスターノードを停止してください。"

#: ../../scala/cluster-sharding.rst:310
msgid ""
"It can be needed to remove the data if the Cluster Sharding coordinator "
"cannot startup because of corrupt data, which may happen if accidentally two"
" clusters were running at the same time, e.g. caused by using auto-down and "
"there was a network partition."
msgstr ""
"例えば、auto-down を使ったためにネットワークの分断が発生した場合など、偶発的に 2 "
"つのクラスターが同時に実行されてしまった場合に発生する可能性のある破損データによって、クラスターシャーディングのコーディネータが起動できない場合は、データを削除する必要があります。"

#: ../../scala/cluster-sharding.rst:316
msgid ""
"**Don't use Cluster Sharding together with Automatic Downing**, since it "
"allows the cluster to split up into two separate clusters, which in turn "
"will result in *multiple shards and entities* being started, one in each "
"separate cluster! See :ref:`automatic-vs-manual-downing-scala`."
msgstr ""
"**クラスターシャーディングと自動ダウン機能を一緒に使用しないでください** 。クラスターが2つの別々のクラスターに分離してしまう可能性があります! "
"その結果、 *シャードとエンティティが復数* 起動します。 :ref:`automatic-vs-manual-downing-scala` "
"を参照してください。"

#: ../../scala/cluster-sharding.rst:321
msgid "Use this program as a standalone Java main program::"
msgstr "このプログラムをスタンドアローンのJavaメインプログラムとして使用する::"

#: ../../scala/cluster-sharding.rst:327
msgid ""
"The program is included in the ``akka-cluster-sharding`` jar file. It is "
"easiest to run it with same classpath and configuration as your ordinary "
"application. It can be run from sbt or maven in similar way."
msgstr ""
"このプログラムは ``akka-cluster-sharding`` の JAR ファイルに含まれています。 "
"通常のアプリケーションと同じクラスパスと設定で実行するのが最も簡単です。同様の方法で sbt または maven から実行できます。"

#: ../../scala/cluster-sharding.rst:331
msgid ""
"Specify the entity type names (same as you use in the ``start`` method of "
"``ClusterSharding``) as program arguments."
msgstr ""
"エンティティタイプ名 ( ``ClusterSharding`` の ``start`` メソッドで使用するのと同じもの) を引数として指定します。"

#: ../../scala/cluster-sharding.rst:334
msgid ""
"If you specify ``-2.3`` as the first program argument it will also try to "
"remove data that was stored by Cluster Sharding in Akka 2.3.x using "
"different persistenceId."
msgstr ""
"プログラムの最初の引数に ``-2.3`` を指定すると、Akka 2.3.x の Cluster Sharding によって、異なる "
"persistenceId で保存されたデータの削除を試みます。"

#: ../../scala/cluster-sharding.rst:339
msgid "Dependencies"
msgstr "依存関係"

#: ../../scala/cluster-sharding.rst:341
msgid ""
"To use the Cluster Sharding you must add the following dependency in your "
"project."
msgstr "クラスターシャーディングを使うには、下記の依存関係をあなたのプロジェクトに追加する必要があります。"

#: ../../scala/cluster-sharding.rst:343
msgid "sbt::"
msgstr "sbt::"

#: ../../scala/cluster-sharding.rst:347
msgid "maven::"
msgstr "maven::"

#: ../../scala/cluster-sharding.rst:356
msgid "Configuration"
msgstr "設定"

#: ../../scala/cluster-sharding.rst:358
msgid ""
"The ``ClusterSharding`` extension can be configured with the following "
"properties. These configuration properties are read by the "
"``ClusterShardingSettings`` when created with a ``ActorSystem`` parameter. "
"It is also possible to amend the ``ClusterShardingSettings`` or create it "
"from another config section with the same layout as below. "
"``ClusterShardingSettings`` is a parameter to the ``start`` method of the "
"``ClusterSharding`` extension, i.e. each each entity type can be configured "
"with different settings if needed."
msgstr ""
"``ClusterSharding`` の拡張機能は以下のプロパティで設定できます。 これらの設定プロパティは、 ``ActorSystem`` "
"のパラメータで作成された場合、 ``ClusterShardingSettings`` を使って読み込まれます。 "
"``ClusterShardingSettings`` を修正することも、以下のようなレイアウトで別の設定セクションから作成することもできます。 "
"``ClusterShardingSettings`` は、 ``ClusterSharding`` 拡張の ``start`` "
"メソッドに渡すパラメータです。つまり、それぞれのエンティティタイプを、必要に応じて異なる設定で構成できます。"

#: ../../scala/cluster-sharding.rst:367
msgid ""
"Custom shard allocation strategy can be defined in an optional parameter to "
"``ClusterSharding.start``. See the API documentation of "
"``ShardAllocationStrategy`` for details of how to implement a custom shard "
"allocation strategy."
msgstr ""
"独自のシャード割り当て戦略は、 ``ClusterSharding.start`` のオプションパラメータで定義することができます。 "
"独自のシャード割り当て戦略の実装方法の詳細については、 ``ShardAllocationStrategy`` のAPIドキュメントを参照してください。"

#: ../../scala/cluster-sharding.rst:373
msgid "Inspecting cluster sharding state"
msgstr "クラスターシャーディングの状態検査"

#: ../../scala/cluster-sharding.rst:374
msgid "Two requests to inspect the cluster state are available:"
msgstr "クラスターの状態を検査するために、2 種類のリクエストが利用できます。"

#: ../../scala/cluster-sharding.rst:376
msgid ""
"``ShardRegion.GetShardRegionState`` which will return a "
"``ShardRegion.CurrentShardRegionState`` that contains the identifiers of the"
" shards running in a Region and what entities are alive for each of them."
msgstr ""
"``ShardRegion.GetShardRegionState`` "
"は、リージョン内で実行されているシャードの識別子と、それぞれのシャードにどのエンティティが生存しているのかを示す "
"``ShardRegion.CurrentShardRegionState`` を返します。"

#: ../../scala/cluster-sharding.rst:379
msgid ""
"``ShardRegion.GetClusterShardingStats`` which will query all the regions in "
"the cluster and return a ``ShardRegion.ClusterShardingStats`` containing the"
" identifiers of the shards running in each region and a count of entities "
"that are alive in each shard."
msgstr ""
"``ShardRegion.GetClusterShardingStats`` "
"は、クラスター内のすべてのリージョンを照会し、各リージョンで実行されているシャードの識別子と、各シャード内に存在するエンティティの数を含んだ "
"``ShardRegion.ClusterShardingStats`` を返します。"

#: ../../scala/cluster-sharding.rst:383
msgid ""
"The purpose of these messages is testing and monitoring, they are not "
"provided to give access to directly sending messages to the individual "
"entities."
msgstr "これらのメッセージの目的は、テストと監視であり、メッセージを個々のエンティティに直接送信するための手段を提供するものではありません。"
