# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-03 22:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../scala/actordsl.rst:5
msgid "Actor DSL"
msgstr ""

#: ../../scala/actordsl.rst:8
msgid "The Actor DSL"
msgstr ""

#: ../../scala/actordsl.rst:10
msgid ""
"Simple actors—for example one-off workers or even when trying things out "
"in the REPL—can be created more concisely using the :class:`Act` trait. "
"The supporting infrastructure is bundled in the following import:"
msgstr ""

#: ../../scala/actordsl.rst:16
msgid ""
"This import is assumed for all code samples throughout this section. The "
"implicit actor system serves as :class:`ActorRefFactory` for all examples"
" below. To define a simple actor, the following is sufficient:"
msgstr ""

#: ../../scala/actordsl.rst:22
msgid ""
"Here, :meth:`actor` takes the role of either ``system.actorOf`` or "
"``context.actorOf``, depending on which context it is called in: it takes"
" an implicit :class:`ActorRefFactory`, which within an actor is available"
" in the form of the ``implicit val context: ActorContext``. Outside of an"
" actor, you’ll have to either declare an implicit :class:`ActorSystem`, "
"or you can give the factory explicitly (see further below)."
msgstr ""

#: ../../scala/actordsl.rst:29
msgid ""
"The two possible ways of issuing a ``context.become`` (replacing or "
"adding the new behavior) are offered separately to enable a clutter-free "
"notation of nested receives:"
msgstr ""

#: ../../scala/actordsl.rst:35
msgid ""
"Please note that calling ``unbecome`` more often than ``becomeStacked`` "
"results in the original behavior being installed, which in case of the "
":class:`Act` trait is the empty behavior (the outer ``become`` just "
"replaces it during construction)."
msgstr ""

#: ../../scala/actordsl.rst:41
msgid "Life-cycle management"
msgstr ""

#: ../../scala/actordsl.rst:43
msgid ""
"Life-cycle hooks are also exposed as DSL elements (see :ref:`start-hook-"
"scala` and :ref:`stop-hook-scala`), where later invocations of the "
"methods shown below will replace the contents of the respective hooks:"
msgstr ""

#: ../../scala/actordsl.rst:47
msgid ""
"The above is enough if the logical life-cycle of the actor matches the "
"restart cycles (i.e. ``whenStopping`` is executed before a restart and "
"``whenStarting`` afterwards). If that is not desired, use the following "
"two hooks (see :ref:`restart-hook-scala`):"
msgstr ""

#: ../../scala/actordsl.rst:53
msgid ""
"It is also possible to create nested actors, i.e. grand-children, like "
"this:"
msgstr ""

#: ../../scala/actordsl.rst:59
msgid ""
"In some cases it will be necessary to explicitly pass the "
":class:`ActorRefFactory` to the :meth:`actor()` method (you will notice "
"when the compiler tells you about ambiguous implicits)."
msgstr ""

#: ../../scala/actordsl.rst:63
msgid ""
"The grand-child will be supervised by the child; the supervisor strategy "
"for this relationship can also be configured using a DSL element "
"(supervision directives are part of the :class:`Act` trait):"
msgstr ""

#: ../../scala/actordsl.rst:70
msgid "Actor with :class:`Stash`"
msgstr ""

#: ../../scala/actordsl.rst:72
msgid ""
"Last but not least there is a little bit of convenience magic built-in, "
"which detects if the runtime class of the statically given actor subtype "
"extends the :class:`RequiresMessageQueue` trait via the :class:`Stash` "
"trait (this is a complicated way of saying that ``new Act with Stash`` "
"would not work because its runtime erased type is just an anonymous "
"subtype of ``Act``). The purpose is to automatically use the appropriate "
"deque-based mailbox type required by :class:`Stash`. If you want to use "
"this magic, simply extend :class:`ActWithStash`:"
msgstr ""

