# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-03 22:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../general/jmm.rst:4
msgid "Akka and the Java Memory Model"
msgstr ""

#: ../../general/jmm.rst:6
msgid ""
"A major benefit of using the Lightbend Platform, including Scala and "
"Akka, is that it simplifies the process of writing concurrent software.  "
"This article discusses how the Lightbend Platform, and Akka in "
"particular, approaches shared memory in concurrent applications."
msgstr ""

#: ../../general/jmm.rst:11
msgid "The Java Memory Model"
msgstr ""

#: ../../general/jmm.rst:12
msgid ""
"Prior to Java 5, the Java Memory Model (JMM) was ill defined. It was "
"possible to get all kinds of strange results when shared memory was "
"accessed by multiple threads, such as:"
msgstr ""

#: ../../general/jmm.rst:15
msgid "a thread not seeing values written by other threads: a visibility problem"
msgstr ""

#: ../../general/jmm.rst:16
msgid ""
"a thread observing 'impossible' behavior of other threads, caused by "
"instructions not being executed in the order expected: an instruction "
"reordering problem."
msgstr ""

#: ../../general/jmm.rst:20
msgid ""
"With the implementation of JSR 133 in Java 5, a lot of these issues have "
"been resolved. The JMM is a set of rules based on the \"happens-before\" "
"relation, which constrain when one memory access must happen before "
"another, and conversely, when they are allowed to happen out of order. "
"Two examples of these rules are:"
msgstr ""

#: ../../general/jmm.rst:24
msgid ""
"**The monitor lock rule:** a release of a lock happens before every "
"subsequent acquire of the same lock."
msgstr ""

#: ../../general/jmm.rst:25
msgid ""
"**The volatile variable rule:** a write of a volatile variable happens "
"before every subsequent read of the same volatile variable"
msgstr ""

#: ../../general/jmm.rst:27
msgid ""
"Although the JMM can seem complicated, the specification tries to find a "
"balance between ease of use and the ability to write performant and "
"scalable concurrent data structures."
msgstr ""

#: ../../general/jmm.rst:31
msgid "Actors and the Java Memory Model"
msgstr ""

#: ../../general/jmm.rst:32
msgid ""
"With the Actors implementation in Akka, there are two ways multiple "
"threads can execute actions on shared memory:"
msgstr ""

#: ../../general/jmm.rst:34
msgid ""
"if a message is sent to an actor (e.g. by another actor). In most cases "
"messages are immutable, but if that message is not a properly constructed"
" immutable object, without a \"happens before\" rule, it would be "
"possible for the receiver to see partially initialized data structures "
"and possibly even values out of thin air (longs/doubles)."
msgstr ""

#: ../../general/jmm.rst:37
msgid ""
"if an actor makes changes to its internal state while processing a "
"message, and accesses that state while processing another message moments"
" later. It is important to realize that with the actor model you don't "
"get any guarantee that the same thread will be executing the same actor "
"for different messages."
msgstr ""

#: ../../general/jmm.rst:41
msgid ""
"To prevent visibility and reordering problems on actors, Akka guarantees "
"the following two \"happens before\" rules:"
msgstr ""

#: ../../general/jmm.rst:43
msgid ""
"**The actor send rule:** the send of the message to an actor happens "
"before the receive of that message by the same actor."
msgstr ""

#: ../../general/jmm.rst:44
msgid ""
"**The actor subsequent processing rule:** processing of one message "
"happens before processing of the next message by the same actor."
msgstr ""

#: ../../general/jmm.rst:48
msgid ""
"In layman's terms this means that changes to internal fields of the actor"
" are visible when the next message is processed by that actor. So fields "
"in your actor need not be volatile or equivalent."
msgstr ""

#: ../../general/jmm.rst:52
msgid ""
"Both rules only apply for the same actor instance and are not valid if "
"different actors are used."
msgstr ""

#: ../../general/jmm.rst:55
msgid "Futures and the Java Memory Model"
msgstr ""

#: ../../general/jmm.rst:57
msgid ""
"The completion of a Future \"happens before\" the invocation of any "
"callbacks registered to it are executed."
msgstr ""

#: ../../general/jmm.rst:59
msgid ""
"We recommend not to close over non-final fields (final in Java and val in"
" Scala), and if you *do* choose to close over non-final fields, they must"
" be marked *volatile* in order for the current value of the field to be "
"visible to the callback."
msgstr ""

#: ../../general/jmm.rst:62
msgid ""
"If you close over a reference, you must also ensure that the instance "
"that is referred to is thread safe. We highly recommend staying away from"
" objects that use locking, since it can introduce performance problems "
"and in the worst case, deadlocks. Such are the perils of synchronized."
msgstr ""

#: ../../general/jmm.rst:69
msgid "Actors and shared mutable state"
msgstr ""

#: ../../general/jmm.rst:71
msgid "Since Akka runs on the JVM there are still some rules to be followed."
msgstr ""

#: ../../general/jmm.rst:73
msgid "Closing over internal Actor state and exposing it to other threads"
msgstr ""

#: ../../general/jmm.rst:105
msgid ""
"Messages **should** be immutable, this is to avoid the shared mutable "
"state trap."
msgstr ""

