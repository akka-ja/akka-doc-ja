# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kentaro Maeda <many.front@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../general/remoting.rst:4
msgid "Location Transparency"
msgstr "位置透過性"

#: ../../general/remoting.rst:6
msgid ""
"The previous section describes how actor paths are used to enable location "
"transparency. This special feature deserves some extra explanation, because "
"the related term “transparent remoting” was used quite differently in the "
"context of programming languages, platforms and technologies."
msgstr ""
"前節ではアクターパスを使用して、どのようにして位置透過性を有効にするかを述べました。 “リモート透過性” "
"という用語はプログラミング言語、プラットフォーム、技術それぞれの文脈で全く異なった使われ方がされますので、 "
"この特別な機能にはさらなる説明を行う必要があります。"

#: ../../general/remoting.rst:12
msgid "Distributed by Default"
msgstr "デフォルトでの分散"

#: ../../general/remoting.rst:14
msgid ""
"Everything in Akka is designed to work in a distributed setting: all "
"interactions of actors use purely message passing and everything is "
"asynchronous. This effort has been undertaken to ensure that all functions "
"are available equally when running within a single JVM or on a cluster of "
"hundreds of machines. The key for enabling this is to go from remote to "
"local by way of optimization instead of trying to go from local to remote by"
" way of generalization. See `this classic paper "
"<http://doc.akka.io/docs/misc/smli_tr-94-29.pdf>`_ for a detailed discussion"
" on why the second approach is bound to fail."
msgstr ""
"Akka "
"は全ての場所で分散設定で動作するように設計されています。アクターの全ての相互作用は純粋ナメッセージパッシングを用い、また全てが非同期です。この努力は全ての機能が単一の"
" JVM "
"でも数百のマシンから成るクラスタ上でも動作可能であることを実現するために行われています。これを可能にする鍵は、一般的な方法であるローカルからリモートへ向かうことの代わりに、最適化された方法でリモートからローカルへ向かうようにすることです。1つめのアプローチがなぜ失敗に向かうのかについては、"
" `こちらの昔の文書 <http://doc.akka.io/docs/misc/smli_tr-94-29.pdf>`_  を見てください。"

#: ../../general/remoting.rst:25
msgid "Ways in which Transparency is Broken"
msgstr "透過性を使いこなすには"

#: ../../general/remoting.rst:27
msgid ""
"What is true of Akka need not be true of the application which uses it, "
"since designing for distributed execution poses some restrictions on what is"
" possible. The most obvious one is that all messages sent over the wire must"
" be serializable. While being a little less obvious this includes closures "
"which are used as actor factories (i.e. within :class:`Props`) if the actor "
"is to be created on a remote node."
msgstr ""
"分散実行を行うための設計では、それを可能にするためにいくつかの制約が課されるので、通常のアプリケーションでの常識が Akka "
"では常識にならないことがあります。 "
"最も明示的なものの一つは通信する全てのメッセージがシリアライゼーション可能でなけれなばならないことです。一方わかりづらいものとして、 "
"アクターがリモートノードとして作成される場合は、アクターのファクトリ ( :class:`Props` の内部 ) "
"として使用されるクロージャが含まれていることが挙げられます。"

#: ../../general/remoting.rst:34
msgid ""
"Another consequence is that everything needs to be aware of all interactions"
" being fully asynchronous, which in a computer network might mean that it "
"may take several minutes for a message to reach its recipient (depending on "
"configuration). It also means that the probability for a message to be lost "
"is much higher than within one JVM, where it is close to zero (still: no "
"hard guarantee!)."
msgstr ""
"他の結果として、全ての作業が完全に非同期で行われることを認識しておく必要があり、(設定にもよりますが) "
"コンピュータネットワーク越しでは受信者にメッセージが届くまで数分を要する可能性があります。これはまた、メッセージが失われる可能性が JVM内では 0 "
"に近くなりますが (それでも完全には保証されていません) 、そうでない場合は非常に高くなることを意味します。"

#: ../../general/remoting.rst:42
msgid "How is Remoting Used?"
msgstr "リモーティングをどうやって使用するか"

#: ../../general/remoting.rst:44
msgid ""
"We took the idea of transparency to the limit in that there is nearly no API"
" for the remoting layer of Akka: it is purely driven by configuration. Just "
"write your application according to the principles outlined in the previous "
"sections, then specify remote deployment of actor sub-trees in the "
"configuration file. This way, your application can be scaled out without "
"having to touch the code. The only piece of the API which allows "
"programmatic influence on remote deployment is that :class:`Props` contain a"
" field which may be set to a specific :class:`Deploy` instance; this has the"
" same effect as putting an equivalent deployment into the configuration file"
" (if both are given, configuration file wins)."
msgstr ""
"透過性の考え方は、Akka のリモートレイヤのための API "
"を可能な限り制限し、純粋に設定によって動かすことに専念しています。前節で示した原則に従ってアプリケーションを書くと、設定ファイルにアクターのサブツリーのリモートデプロイを明記できます。この場合、コードに触れることなくアプリケーションをスケールアウトさせることができます。リモートデプロイをプログラム的に行うことができる唯一の"
" API は、特定の :class:`Deploy` インスタンスをフィールドに含む :class:`Props` "
"です。これは設定ファイル内のデプロイと同等の作用をします(両方とも設定がある場合は、設定ファイルを優先します)。"

#: ../../general/remoting.rst:58
msgid "Peer-to-Peer vs. Client-Server"
msgstr "ピアツーピア 対 クライアントサーバー"

#: ../../general/remoting.rst:60
msgid ""
"Akka Remoting is a communication module for connecting actor systems in a "
"peer-to-peer fashion, and it is the foundation for Akka Clustering. The "
"design of remoting is driven by two (related) design decisions:"
msgstr ""
"Akka リモーティング は　ピアツーピア風のアクターシステムどうしを接続するための通信モジュールで、Akka "
"クラスタリングの基盤にもなっています。リモーティングの設計は、2つの(関連している)設計上の方針によって進めています。"

#: ../../general/remoting.rst:64
msgid ""
"Communication between involved systems is symmetric: if a system A can "
"connect to a system B then system B must also be able to connect to system A"
" independently."
msgstr ""
"関係のあるシステム間の通信は対称性があり、もしシステムAがシステムBと通信できるなら、システムBもまたシステムA に個別に通信できる必要があります。"

#: ../../general/remoting.rst:66
msgid ""
"The role of the communicating systems are symmetric in regards to connection"
" patterns: there is no system that only accepts connections, and there is no"
" system that only initiates connections."
msgstr "通信システムの役割は、通信パターンに関する対象性です。接続を受け付けるだけのシステムや、接続を発信するだけのシステムはありません。"

#: ../../general/remoting.rst:69
msgid ""
"The consequence of these decisions is that it is not possible to safely "
"create pure client-server setups with predefined roles (violates assumption "
"2). For client-server setups it is better to use HTTP or Akka I/O."
msgstr ""
"この方針の結果。予め定義された役割を持つ安全に純粋なクライアントサーバーの構成を作ることはできません(仮説2 に違反します)。 "
"クライアントサーバーの構成には、HTTP や Alla I/O を使う方がよいでしょう。"

#: ../../general/remoting.rst:73
msgid ""
"**Important**: Using setups involving Network Address Translation, Load "
"Balancers or Docker containers violates assumption 1, unless additional "
"steps are taken in the network configuration to allow symmetric "
"communication between involved systems. In such situations Akka can be "
"configured to bind to a different network address than the one used for "
"establishing connections between Akka nodes. See :ref:`remote-configuration-"
"nat`."
msgstr ""
"**重要**: ネットワークアドレス変換を含む構成では、追加のネットワーク設定によりシステム間の対称通信を許可しない限り、ロードバランサーや "
"Docler コンテナは仮説1 に違反します。そのような状況では Akka は Akka "
"ノード間での通信を成立させるために1つ以上の異なるネットワークアドレスを結びつけるように設定します。 詳細は、:ref:`remote-"
"configuration-nat` を見てください。"

#: ../../general/remoting.rst:82
msgid "Marking Points for Scaling Up with Routers"
msgstr "ルーターによるスケープアップの要点"

#: ../../general/remoting.rst:84
msgid ""
"In addition to being able to run different parts of an actor system on "
"different nodes of a cluster, it is also possible to scale up onto more "
"cores by multiplying actor sub-trees which support parallelization (think "
"for example a search engine processing different queries in parallel). The "
"clones can then be routed to in different fashions, e.g. round-robin. The "
"only thing necessary to achieve this is that the developer needs to declare "
"a certain actor as “withRouter”, then—in its stead—a router actor will be "
"created which will spawn up a configurable number of children of the desired"
" type and route to them in the configured fashion. Once such a router has "
"been declared, its configuration can be freely overridden from the "
"configuration file, including mixing it with the remote deployment of (some "
"of) the children. Read more about this in :ref:`Routing (Scala) <routing-"
"scala>` and :ref:`Routing (Java) <routing-java>`."
msgstr ""
"クラスター内の複数のノード上のアクターシステムで複数の部品を実行することに加えて、並列性をサポートするアクターのサブツリーを掛け合わせてより多くのコアの上でスケールアップすることができます(例えば、サーチエンジンが異なるクエリを並列で処理するのを想像してみてください)。クローンは、ラウンドロビンなど複数の方法でルーティングされます。開発者がこれを実行するのに唯一必要なのは、"
" “withRouter” "
"としてアクターを宣言することです。すると、アクターの代わりにルーターアクターが作成され、設定済みの数の子供を要求した型で産み出し、設定した方法でルーティングさせます。そのようなルータを一度宣言すると、その設定を設定ファイルで自由に上書きでき、(いくつかの)子供をリモートデプロイに含めるようなことも可能になります。これについてより詳しくは、"
" :ref:`Routing (Scala) <routing-scala>` と :ref:`Routing (Java) <routing-"
"java>`  を読んでください。"
