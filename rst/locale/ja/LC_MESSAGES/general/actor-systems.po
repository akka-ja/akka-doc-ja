# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kazuki Negoro <negokaz@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../general/actor-systems.rst:4
msgid "Actor Systems"
msgstr "アクターシステム"

#: ../../general/actor-systems.rst:6
msgid ""
"Actors are objects which encapsulate state and behavior, they communicate "
"exclusively by exchanging messages which are placed into the recipient’s "
"mailbox. In a sense, actors are the most stringent form of object-oriented "
"programming, but it serves better to view them as persons: while modeling a "
"solution with actors, envision a group of people and assign sub-tasks to "
"them, arrange their functions into an organizational structure and think "
"about how to escalate failure (all with the benefit of not actually dealing "
"with people, which means that we need not concern ourselves with their "
"emotional state or moral issues). The result can then serve as a mental "
"scaffolding for building the software implementation."
msgstr ""
"アクターは、状態と振る舞いをカプセル化するオブジェクトであり、受信者のメールボックスにメッセージを置くことでメッセージを交換し、排他的に通信します。 "
"ある意味では、アクターはオブジェクト指向プログラミングの中で最も厳格な形式ですが、人間にとってはより理解しやすいものです。アクターを使って問題の解決策をモデル化し、人々のグループを構想し、それらにサブタスクを割り当て、その機能を組織体系に整理し、障害をエスカレートする方法を考えます"
" (実際には人を扱わないという利点があります。つまり、感情的な状態や道徳的な問題に心配する必要はありません) "
"。その結果、ソフトウェア実装を構築するための精神的な足場として役立ちます。"

#: ../../general/actor-systems.rst:19
msgid ""
"An ActorSystem is a heavyweight structure that will allocate 1…N Threads, so"
" create one per logical application."
msgstr "アクターシステムは、1 ... N のスレッドを割り当てる重い構造体なので、論理的なアプリケーションごとに 1 つ作成します。"

#: ../../general/actor-systems.rst:23
msgid "Hierarchical Structure"
msgstr "階層構造"

#: ../../general/actor-systems.rst:25
msgid ""
"Like in an economic organization, actors naturally form hierarchies. One "
"actor, which is to oversee a certain function in the program might want to "
"split up its task into smaller, more manageable pieces. For this purpose it "
"starts child actors which it supervises. While the details of supervision "
"are explained :ref:`here <supervision>`, we shall concentrate on the "
"underlying concepts in this section. The only prerequisite is to know that "
"each actor has exactly one supervisor, which is the actor that created it."
msgstr ""
"経済組織のように、アクターは自然に階層を形成します。 プログラムの特定の機能を監督する 1 "
"人のアクターは、その仕事をより小さく、より管理しやすいものに分割したいかもしれません。この目的のために、それが監督する子アクターを導入します。スーパービジョン"
" (監督) の詳細は :ref:`ここ <supervision>` "
"で説明されていますが、このセクションでは根底にある概念に集中します。理解のための唯一の前提条件は、各アクターが、そのアクターを作り出した、ちょうど 1 "
"人のスーパーバイザーを持つということです。"

#: ../../general/actor-systems.rst:33
msgid ""
"The quintessential feature of actor systems is that tasks are split up and "
"delegated until they become small enough to be handled in one piece. In "
"doing so, not only is the task itself clearly structured, but the resulting "
"actors can be reasoned about in terms of which messages they should process,"
" how they should react normally and how failure should be handled. If one "
"actor does not have the means for dealing with a certain situation, it sends"
" a corresponding failure message to its supervisor, asking for help. The "
"recursive structure then allows to handle failure at the right level."
msgstr ""
"アクターシステムの典型的な特徴は、1 "
"つの部分で扱えるほど十分に小さくなるまでタスクが分割され、委任されることです。そうすることで、タスクそのものが明確に構造化されているだけでなく、結果的に、どのメッセージを処理すべきか、どのように正常に反応すべきか、そしてどのように障害を処理すべきかということがアクターから推論することができるようになります。1"
" 人のアクターが特定の状況に対処する手段を持っていない場合、対応する失敗メッセージをスーパーバイザーに送信して、助けを求めます。 "
"再帰的な構造によって正しいレベルで障害が処理できるようになります。"

#: ../../general/actor-systems.rst:42
msgid ""
"Compare this to layered software design which easily devolves into defensive"
" programming with the aim of not leaking any failure out: if the problem is "
"communicated to the right person, a better solution can be found than if "
"trying to keep everything “under the carpet”."
msgstr ""
"これを、障害を漏れ無く考慮した防御的プログラミングになりやすい、階層化されたソフトウェア設計と比較してください。問題が適切な人に伝達されれば、すべてを「カーペットの下に」入れてしまうよりも優れた解決策を見出すことができます。"

#: ../../general/actor-systems.rst:47
msgid ""
"Now, the difficulty in designing such a system is how to decide who should "
"supervise what. There is of course no single best solution, but there are a "
"few guidelines which might be helpful:"
msgstr ""
"そのようなシステムを設計することの難しいところは、誰が何を監督すべきかということの決定方法です。もちろん最高の解決方法はありませんが、役立つガイドラインがいくつかあります:"

#: ../../general/actor-systems.rst:51
msgid ""
"If one actor manages the work another actor is doing, e.g. by passing on "
"sub-tasks, then the manager should supervise the child. The reason is that "
"the manager knows which kind of failures are expected and how to handle "
"them."
msgstr ""
"1 "
"つのアクターがサブタスクを他のアクターに委譲したりして、そのアクターがしている仕事を管理しているとすると、マネージャは子供を監督すべきです。なぜなら管理者が、どの種類の障害が予想され、どのように対処するのかを知っているからです。"

#: ../../general/actor-systems.rst:56
msgid ""
"If one actor carries very important data (i.e. its state shall not be lost "
"if avoidable), this actor should source out any possibly dangerous sub-tasks"
" to children it supervises and handle failures of these children as "
"appropriate. Depending on the nature of the requests, it may be best to "
"create a new child for each request, which simplifies state management for "
"collecting the replies. This is known as the “Error Kernel Pattern” from "
"Erlang."
msgstr ""
"1 つのアクターが非常に重要なデータを運ぶ場合 "
"(避けられるなら状態は失われないようにすべき)、このアクターは、危険なサブタスクを監督している子供に送信し、これらの子供の失敗を適切に処理すべきです。 "
"リクエストの性質によっては、リクエストごとに新しい子を作成することが最善であることがあり、返信を収集するための状態管理をシンプルにできます。 これは "
"Erlang の \"Error Kernel Pattern\" として知られています。"

#: ../../general/actor-systems.rst:64
msgid ""
"If one actor depends on another actor for carrying out its duty, it should "
"watch that other actor’s liveness and act upon receiving a termination "
"notice. This is different from supervision, as the watching party has no "
"influence on the supervisor strategy, and it should be noted that a "
"functional dependency alone is not a criterion for deciding where to place a"
" certain child actor in the hierarchy."
msgstr ""
"あるアクターがその義務を果たすために、別のアクターに依存している場合、他のアクターの生死を監視し、終了の通知を受け取って行動する必要があります。 "
"監視者がスーパーバイザー戦略に影響を与えることはないので、スーパービジョンとは異なります。機能的な依存関係だけでは、特定の子アクターを階層のどこに配置するのかを決定する基準にはなりません。"

#: ../../general/actor-systems.rst:71
msgid ""
"There are of course always exceptions to these rules, but no matter whether "
"you follow the rules or break them, you should always have a reason."
msgstr "もちろん、これらのルールには常に例外がありますが、ルールを守るか破るかにかかわらず、常に理由を持つべきです。"

#: ../../general/actor-systems.rst:75
msgid "Configuration Container"
msgstr "コンテナを構成"

#: ../../general/actor-systems.rst:77
msgid ""
"The actor system as a collaborating ensemble of actors is the natural unit "
"for managing shared facilities like scheduling services, configuration, "
"logging, etc. Several actor systems with different configuration may co-"
"exist within the same JVM without problems, there is no global shared state "
"within Akka itself. Couple this with the transparent communication between "
"actor systems—within one node or across a network connection—to see that "
"actor systems themselves can be used as building blocks in a functional "
"hierarchy."
msgstr ""
"アクターがアンサンブルするアクターシステムは、スケジューリングサービス、構成、ロギングなどの共有設備を管理するための自然な単位です。異なる構成を持つ複数のアクターシステムは"
" Akka 自身の中でグローバルな状態共有が無ければ、同じ JVM 内で問題なく共存できるはずです。これを 1 "
"つのノード内、またはネットワーク接続全体にわたるアクターシステム間の透過的な通信と組み合わせることで、アクターシステム自体を機能階層の構成要素として使用できます。"

#: ../../general/actor-systems.rst:86
msgid "Actor Best Practices"
msgstr "アクターのベストプラクティス"

#: ../../general/actor-systems.rst:88
msgid ""
"Actors should be like nice co-workers: do their job efficiently without "
"bothering everyone else needlessly and avoid hogging resources. Translated "
"to programming this means to process events and generate responses (or more "
"requests) in an event-driven manner. Actors should not block (i.e. passively"
" wait while occupying a Thread) on some external entity—which might be a "
"lock, a network socket, etc.—unless it is unavoidable; in the latter case "
"see below."
msgstr ""
"アクターは素敵な同僚のようになるべきです。他の人の気を不必要に遣わせることなく効率的に仕事をし、リソースを奪わないようにします。 "
"プログラミングの言葉にすると、イベント駆動型の方法でイベントを処理し、レスポンス (または更なるリクエスト) を生成することを意味します。 "
"アクターは、やむを得ない場合を除いて、ロック、ネットワークソケットなどの外部のエンティティをブロックしてはいけません "
"(つまり、スレッドを占有している間は受動的に待機してはいけません) 。例外は以下の後者の場合を参照してください。"

#: ../../general/actor-systems.rst:96
msgid ""
"Do not pass mutable objects between actors. In order to ensure that, prefer "
"immutable messages. If the encapsulation of actors is broken by exposing "
"their mutable state to the outside, you are back in normal Java concurrency "
"land with all the drawbacks."
msgstr ""
"アクター間で可変なオブジェクトをやりとりしないでください。そのためには、メッセージが不変であることが好ましいです。 "
"変更可能な状態を外部に公開することでアクターのカプセル化が壊れると、通常の Java "
"の並行処理の土俵に戻ってしまい、あらゆる欠点を抱えることになります。"

#: ../../general/actor-systems.rst:101
msgid ""
"Actors are made to be containers for behavior and state, embracing this "
"means to not routinely send behavior within messages (which may be tempting "
"using Scala closures). One of the risks is to accidentally share mutable "
"state between actors, and this violation of the actor model unfortunately "
"breaks all the properties which make programming in actors such a nice "
"experience."
msgstr ""
"アクターは、振る舞いと状態のコンテナであり、ふつうはメッセージで振る舞いを送信することはしません (Scala "
"のクロージャを使う誘惑があるかもしれません)。そのリスクの 1 "
"つは、アクター間で誤って可変の状態を共有してしまうことです。このアクターモデルの違反は、残念なことにアクタープログラミングのすばらしい体験をもたらす性質を台無しにします。"

#: ../../general/actor-systems.rst:108
msgid ""
"Top-level actors are the innermost part of your Error Kernel, so create them"
" sparingly and prefer truly hierarchical systems. This has benefits with "
"respect to fault-handling (both considering the granularity of configuration"
" and the performance) and it also reduces the strain on the guardian actor, "
"which is a single point of contention if over-used."
msgstr ""
"トップレベルのアクターは、エラーカーネルの最も奥にあるので、それらは控えめに作成し、本当に階層的なシステムであることが好ましいです。 "
"これは、障害のハンドリング (構成の細かさとパフォーマンスの両方を考慮する場合) "
"において利点があります。また、ガーディアンアクターの負荷を軽減します。これを過度に使うと、競合ポイントの一つになります。"

#: ../../general/actor-systems.rst:115
msgid "Blocking Needs Careful Management"
msgstr "ブロッキングには慎重な管理が必要"

#: ../../general/actor-systems.rst:117
msgid ""
"In some cases it is unavoidable to do blocking operations, i.e. to put a "
"thread to sleep for an indeterminate time, waiting for an external event to "
"occur. Examples are legacy RDBMS drivers or messaging APIs, and the "
"underlying reason is typically that (network) I/O occurs under the covers. "
"When facing this, you may be tempted to just wrap the blocking call inside a"
" :class:`Future` and work with that instead, but this strategy is too "
"simple: you are quite likely to find bottlenecks or run out of memory or "
"threads when the application runs under increased load."
msgstr ""
"場合によっては、ブロッキング操作、つまりスレッドが不定期にスリープするようにして外部イベントが発生するのを待つことは避けられないことです。例えば、従来の"
" RDBMS ドライバーやメッセージング API があり、その根底にある理由は、一般的に (ネットワーク) I/O "
"がカバーの下で発生するためです。このようなことに直面した場合、ブロッキングコールを単に class:`Future` "
"の中にラップして、その代わりに使うことができますが、この戦略は単純すぎます。アプリケーションが高い負荷で実行されているときに、ボトルネックになったり、メモリやスレッドを使い果たす可能性が非常に高いです。"

#: ../../general/actor-systems.rst:126
msgid ""
"The non-exhaustive list of adequate solutions to the “blocking problem” "
"includes the following suggestions:"
msgstr "この \"ブロッキング問題\" に対する適切な解決策の非網羅的なリストには、以下のような提案があります。"

#: ../../general/actor-systems.rst:129
msgid ""
"Do the blocking call within an actor (or a set of actors managed by a router"
" [:ref:`Java <routing-java>`, :ref:`Scala <routing-scala>`]), making sure to"
" configure a thread pool which is either dedicated for this purpose or "
"sufficiently sized."
msgstr ""
"アクター (またはルーター [:ref:`Java <routing-java>`, :ref:`Scala <routing-scala>] "
"によって管理されているアクター) の中でブロッキングコールを行い、この目的専用にしているか、または十分な大きさのスレッドプールを設定してください。"

#: ../../general/actor-systems.rst:134
msgid ""
"Do the blocking call within a :class:`Future`, ensuring an upper bound on "
"the number of such calls at any point in time (submitting an unbounded "
"number of tasks of this nature will exhaust your memory or thread limits)."
msgstr ""
"ブロッキングコールを :class:`Future`  内で行い、このような呼び出しの数の上限をある時点で設けます "
"(タスクを無制限に実行すると、メモリやスレッドを使い切ってしまいます) 。"

#: ../../general/actor-systems.rst:138
msgid ""
"Do the blocking call within a :class:`Future`, providing a thread pool with "
"an upper limit on the number of threads which is appropriate for the "
"hardware on which the application runs."
msgstr ""
"アプリケーションを実行するハードウェアに適したスレッド数の上限をスレッドプールに設定し、 :class:`Future` "
"内でブロッキングコールを行います。"

#: ../../general/actor-systems.rst:142
msgid ""
"Dedicate a single thread to manage a set of blocking resources (e.g. a NIO "
"selector driving multiple channels) and dispatch events as they occur as "
"actor messages."
msgstr ""
"単一のスレッドを一連のブロッキングリソース (たとえば、複数のチャネルを駆動させる NIO セレクタ) "
"の管理専用にして、アクターメッセージとして、発生するイベントをディスパッチします。"

#: ../../general/actor-systems.rst:146
msgid ""
"The first possibility is especially well-suited for resources which are "
"single-threaded in nature, like database handles which traditionally can "
"only execute one outstanding query at a time and use internal "
"synchronization to ensure this. A common pattern is to create a router for N"
" actors, each of which wraps a single DB connection and handles queries as "
"sent to the router. The number N must then be tuned for maximum throughput, "
"which will vary depending on which DBMS is deployed on what hardware."
msgstr ""
"最初の可能性としては、一度に 1 "
"つの未処理のクエリのみを実行し、内部同期を使用してこれを保証する伝統的なデータベース処理など、自然にシングルスレッドであるリソースが特に適しています。 "
"一般的なパターンは、N 個のアクターのためのルーターを作成することです。各アクターは、1 "
"つのDB接続をラップし、ルーターに送信されたクエリを処理します。 スループットを最大化するために N をチューニングしなければなりません。これは、どの "
"DBMS がどのハードウェアに配備されているかによって異なります。"

#: ../../general/actor-systems.rst:156
msgid ""
"Configuring thread pools is a task best delegated to Akka, simply configure "
"in the ``application.conf`` and instantiate through an :class:`ActorSystem` "
"[:ref:`Java <dispatcher-lookup-java>`, :ref:`Scala <dispatcher-lookup-"
"scala>`]"
msgstr ""
"スレッドプールの設定は、Akka に委譲するのが最適です。単純に ``application.conf`` で設定し、 "
":class:`ActorSystem` [:ref:`Java <dispatcher-lookup-java>`, :ref:`Scala "
"<dispatcher-lookup-scala>`] でインスタンス化するだけです。"

#: ../../general/actor-systems.rst:162
msgid "What you should not concern yourself with"
msgstr "あなたが心配すべきでないこと"

#: ../../general/actor-systems.rst:164
msgid ""
"An actor system manages the resources it is configured to use in order to "
"run the actors which it contains. There may be millions of actors within one"
" such system, after all the mantra is to view them as abundant and they "
"weigh in at an overhead of only roughly 300 bytes per instance. Naturally, "
"the exact order in which messages are processed in large systems is not "
"controllable by the application author, but this is also not intended. Take "
"a step back and relax while Akka does the heavy lifting under the hood."
msgstr ""
"アクターシステムは、それ自身に含まれるアクターを実行するために、構成されたリソースを管理します。このシステムには数百万ものアクターがいるかもしれません。それらが大量にあるとみなすのが全てのマントラであり、オーバーヘッドはインスタンスごとに、たった約"
" 300 "
"バイトの重さです。当然ながら、大規模なシステムでメッセージが処理される正確な順序は、アプリケーション作成者が制御できるものではありませんが、これも意図したものではありません。"
" Akka がカバーの下で重いものを持ち上げている間、リラックスして一歩踏み出してください。"
