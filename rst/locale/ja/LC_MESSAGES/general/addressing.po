# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kentaro Maeda <many.front@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../general/addressing.rst:4
msgid "Actor References, Paths and Addresses"
msgstr "アクターの参照、パス、アドレス"

#: ../../general/addressing.rst:6
msgid ""
"This chapter describes how actors are identified and located within a "
"possibly distributed actor system. It ties into the central idea that :ref"
":`actor-systems` form intrinsic supervision hierarchies as well as that "
"communication between actors is transparent with respect to their placement "
"across multiple network nodes."
msgstr ""
"この章では、分散型の場合もありえるアクターシステムに、アクターがどのようのして区別され配置されるのかについて記述します。  :ref:`actor-"
"systems` "
"が固有のスーパービジョン階層で構成されていることと、アクター間のコミュニケーションが複数のネットワークノードを跨いでも透過的であることを中心の考えとして取り掛かりましょう。"

#: ../../general/addressing.rst:14
msgid ""
"The above image displays the relationship between the most important "
"entities within an actor system, please read on for the details."
msgstr "上のイメージはアクターシステム内のとても重要なエンティティ間の関係を描いています。詳細については次を読んでください。"

#: ../../general/addressing.rst:18
msgid "What is an Actor Reference?"
msgstr "アクターの参照とは何か?"

#: ../../general/addressing.rst:20
msgid ""
"An actor reference is a subtype of :class:`ActorRef`, whose foremost purpose"
" is to support sending messages to the actor it represents. Each actor has "
"access to its canonical (local) reference through the :meth:`self` field; "
"this reference is also included as sender reference by default for all "
"messages sent to other actors. Conversely, during message processing the "
"actor has access to a reference representing the sender of the current "
"message through the :meth:`sender()` method."
msgstr ""
"アクターの参照とは :class:`ActorRef` "
"のサブタイプで、主要な目的はアクターへのメッセージ送信をサポートすることです。それぞれのアクターは :meth:`self`  フィールドを通して標準的"
" (ローカル) "
"な参照へのアクセスを取得します。また、この参照は送信者の参照として、他のアクターへ送信する全てのメッセージにデフォルトで含まれます。反対に言えば、メッセージの処理中にアクターは、:meth:`sender()`"
" メソッドを通して現在のメッセージの送信者を示す参照へのアクセスを取得します。"

#: ../../general/addressing.rst:28
msgid ""
"There are several different types of actor references that are supported "
"depending on the configuration of the actor system:"
msgstr "アクターリファレンスはアクターシステムの設定に応じてサポートされるいくつかの異なるタイプがあります。"

#: ../../general/addressing.rst:31
msgid ""
"Purely local actor references are used by actor systems which are not "
"configured to support networking functions. These actor references will not "
"function if sent across a network connection to a remote JVM."
msgstr ""
"純粋なローカルアクターの参照は、ネットワーク機能のサポートを設定していないアクターシステムによって使用されます。このアクターの参照は、リモートJVMへのネットワーク接続を行う送信を行う場合は機能しません。"

#: ../../general/addressing.rst:34
msgid ""
"Local actor references when remoting is enabled are used by actor systems "
"which support networking functions for those references which represent "
"actors within the same JVM. In order to also be reachable when sent to other"
" network nodes, these references include protocol and remote addressing "
"information."
msgstr ""
"リモーティングが有効である場合、ローカルアクターの参照は、同じJVM内のアクターである参照に対してもネットワーク機能をサポートしているアクターシステムが使用されます。また、他のネットワークノードに到達可能にするため、これらの参照はプロトコルとリモートアドレス情報も含んでいます。"

#: ../../general/addressing.rst:39
msgid ""
"There is a subtype of local actor references which is used for routers (i.e."
" actors mixing in the :class:`Router` trait). Its logical structure is the "
"same as for the aforementioned local references, but sending a message to "
"them dispatches to one of their children directly instead."
msgstr ""
"ルーターのために使用されるローカルアクターのサブタイプがあります(例えば、:class:`Router`  "
"トレイトをミックスインしたアクターです)。論理的な構造は前述のローカルアクターの参照と同じですが、メッセージをルーターに送信するとルータに直接ではなく、ルーターの子のどれか一つにメッセージをディスパッチします。"

#: ../../general/addressing.rst:43
msgid ""
"Remote actor references represent actors which are reachable using remote "
"communication, i.e. sending messages to them will serialize the messages "
"transparently and send them to the remote JVM."
msgstr ""
"リモートアクターの参照は、リモート通信が到達可能なアクターとして表現され、例えば、それへのメッセージの送信はメッセージを透過的にシリアライズし、リモートのJVMへ送信されるでしょう。"

#: ../../general/addressing.rst:46
msgid ""
"There are several special types of actor references which behave like local "
"actor references for all practical purposes:"
msgstr "実用的な目的のため、ローカルアクターの参照のように振る舞う特別なアクターの参照がいくつかあります。"

#: ../../general/addressing.rst:49
msgid ""
":class:`PromiseActorRef` is the special representation of a :meth:`Promise` "
"for the purpose of being completed by the response from an actor. "
":meth:`akka.pattern.ask` creates this actor reference."
msgstr ""
":class:`PromiseActorRef` はアクターからの応答によって完了する意図を表す :meth:`Promise`  "
"の特別な表現です。:meth:`akka.pattern.ask` がこのアクターの参照を生成します。"

#: ../../general/addressing.rst:52
msgid ""
":class:`DeadLetterActorRef` is the default implementation of the dead "
"letters service to which Akka routes all messages whose destinations are "
"shut down or non-existent."
msgstr ""
":class:`DeadLetterActorRef` は  デッドレターサービスのデフォルトの実装で、Akka "
"は、シャットダウンした、または存在しない送信先へメッセージを全てここに送ります。"

#: ../../general/addressing.rst:55
msgid ""
":class:`EmptyLocalActorRef` is what Akka returns when looking up a non-"
"existent local actor path: it is equivalent to a "
":class:`DeadLetterActorRef`, but it retains its path so that Akka can send "
"it over the network and compare it to other existing actor references for "
"that path, some of which might have been obtained before the actor died."
msgstr ""
":class:`EmptyLocalActorRef` は、存在しないアクターパスを探した場合に Akka が返すものです。これは "
":class:`DeadLetterActorRef` と同等のようですが、パスを保持しているため、Akka "
"はネットワークを超えて送信することや、存在している他のアクターとパスを比較することができます。これらの内の幾つかはアクターが死ぬ前に獲得されているかもしれません。"

#: ../../general/addressing.rst:61
msgid ""
"And then there are some one-off internal implementations which you should "
"never really see:"
msgstr "それから、実際に見るべきではない一度限りの内部実装も幾つかあります。"

#: ../../general/addressing.rst:64
msgid ""
"There is an actor reference which does not represent an actor but acts only "
"as a pseudo-supervisor for the root guardian, we call it “the one who walks "
"the bubbles of space-time”."
msgstr ""
"アクターとして表現されず、ルートガーディアンに対する擬似スーパバイザーとしてだけ機能するアクターの参照があり、我々はこれを \"時空の泡を歩く者\" "
"と呼んでします。"

#: ../../general/addressing.rst:67
msgid ""
"The first logging service started before actually firing up actor creation "
"facilities is a fake actor reference which accepts log events and prints "
"them directly to standard output; it is :class:`Logging.StandardOutLogger`."
msgstr ""
"一番最初のロギングサービスは、アクターの動作環境の生成が実際に稼働するよりも前に開始し、ログイベントを受け付け内容を直接標準出力に出力する偽のアクターの参照になります。これは、"
" :class:`Logging.StandardOutLogger` です。"

#: ../../general/addressing.rst:72
msgid "What is an Actor Path?"
msgstr "アクターパスとは何か?"

#: ../../general/addressing.rst:74
msgid ""
"Since actors are created in a strictly hierarchical fashion, there exists a "
"unique sequence of actor names given by recursively following the "
"supervision links between child and parent down towards the root of the "
"actor system. This sequence can be seen as enclosing folders in a file "
"system, hence we adopted the name “path” to refer to it, although actor "
"hierarchy has some fundamental difference from file system hierarchy."
msgstr ""
"アクターは厳密に階層構造のように作成されるため、アクターシステムのルートから下っていく親と子の間のスーパービジョンの連結を再帰的にたどる事で与えられるアクターの名前には一意に順序付けられています。"

#: ../../general/addressing.rst:80
msgid ""
"An actor path consists of an anchor, which identifies the actor system, "
"followed by the concatenation of the path elements, from root guardian to "
"the designated actor; the path elements are the names of the traversed "
"actors and are separated by slashes."
msgstr ""
"アクターパスは、アクターシステムを区別し、ルートガーディアンから対象のアクターへのパス要素が連結されているアンカーで構成されていいます。パス要素は途中にあるアクターの名前で、スラッシュで区切られています。"

#: ../../general/addressing.rst:86
msgid "What is the Difference Between Actor Reference and Path?"
msgstr "アクターの参照とパスの違いは何か?"

#: ../../general/addressing.rst:88
msgid ""
"An actor reference designates a single actor and the life-cycle of the "
"reference matches that actor’s life-cycle; an actor path represents a name "
"which may or may not be inhabited by an actor and the path itself does not "
"have a life-cycle, it never becomes invalid. You can create an actor path "
"without creating an actor, but you cannot create an actor reference without "
"creating corresponding actor."
msgstr ""
"アクターの参照は、単一のアクターを指し示し、そのライフサイクルはアクターのライフサイクルと一致します。アクターパスは、存在しているかどうかわからないアクターの名前として表現され、ライフサイクルを持たず、決して無効にはなりません。アクターパスはアクターを生成しなくても作ることができますが、アクターの参照は対応するアクターを生成しなければ作ることはできません。"

#: ../../general/addressing.rst:94
msgid ""
"You can create an actor, terminate it, and then create a new actor with the "
"same actor path. The newly created actor is a new incarnation of the actor. "
"It is not the same actor. An actor reference to the old incarnation is not "
"valid for the new incarnation. Messages sent to the old actor reference will"
" not be delivered to the new incarnation even though they have the same "
"path."
msgstr ""
"アクターを生成したあと、それを終了し、同じアクターパスで新しいアクターを再度生成できます。この新しく生成されたアクターは、アクターの新しい実体です。これは以前と同じアクターではありません。古い実体へのアクターの参照は、新しい実体に対しては無効です。古いアクターの参照へ送信したメッセージは、たとえ同じパスであったとしても、新しい実体のほうへ届くことはないでしょう。"

#: ../../general/addressing.rst:101
msgid "Actor Path Anchors"
msgstr "アクターパスのアンカー"

#: ../../general/addressing.rst:103
msgid ""
"Each actor path has an address component, describing the protocol and "
"location by which the corresponding actor is reachable, followed by the "
"names of the actors in the hierarchy from the root up. Examples are::"
msgstr ""
"それぞれのアクターパスはアドレス構成になっていて、プロトコルと、ルートを頂点に対象のアクターまでの間にある各階層のアクターの名前が続く形式になった場所が記述されています。以下が例です。"

#: ../../general/addressing.rst:110
msgid ""
"Here, ``akka.tcp`` is the default remote transport for the 2.4 release; "
"other transports are pluggable. The interpretation of the host and port part"
" (i.e. ``host.example.com:5678`` in the example) depends on the transport "
"mechanism used, but it must abide by the URI structural rules."
msgstr ""
"ここの、 ``akka.tcp`` は 2.4 "
"リリースでデフォルトのリモート通信方法です。他の方法に差し替えもできます。ホストとポートの部分に表示される内容( "
"例では、``host.example.com:5678`` となっている箇所) は、使用する通信方法によって異なりますが、 URL "
"構造のルールの守るようになっています。"

#: ../../general/addressing.rst:116
msgid "Logical Actor Paths"
msgstr "論理的なアクターパス"

#: ../../general/addressing.rst:118
msgid ""
"The unique path obtained by following the parental supervision links towards"
" the root guardian is called the logical actor path. This path matches "
"exactly the creation ancestry of an actor, so it is completely deterministic"
" as soon as the actor system’s remoting configuration (and with it the "
"address component of the path) is set."
msgstr ""
"親のスーパービジョンのリンクをルートガーディアンまで辿って得られた一意のパスは、論理的なアクターパスと呼ばれます。このパスはアクターを生成してきた先祖の家系と確実に一致するので、アクターシステムのリモート構成(パスのアドレス構成も含まれる)が設定してあると、完全な決定性を持ちます。"

#: ../../general/addressing.rst:125
msgid "Physical Actor Paths"
msgstr "物理的なアクターパス"

#: ../../general/addressing.rst:127
msgid ""
"While the logical actor path describes the functional location within one "
"actor system, configuration-based remote deployment means that an actor may "
"be created on a different network host than its parent, i.e. within a "
"different actor system. In this case, following the actor path from the root"
" guardian up entails traversing the network, which is a costly operation. "
"Therefore, each actor also has a physical path, starting at the root "
"guardian of the actor system where the actual actor object resides. Using "
"this path as sender reference when querying other actors will let them reply"
" directly to this actor, minimizing delays incurred by routing."
msgstr ""
"論理的なアクターパスは1つのアクターシステム内で正常に機能する位置を表していますが、一方で、設定に基づくリモートデプロイでは、異なるアクターシステムのような別のネットワークホストにある親からアクターが生成される可能性があることを意味しています。この場合、ルートガディアンまで辿るアクターパスでは、ネットワークを横断する必要があり、コストがかかる操作になります。しかしながら、それぞれのアクターは物理的なパスも保有していて、そのパスはアクターが実際に所属しているアクターシステムのルートガーディアンから始まっています。他のアクターを照会する際に、このパスを送信者の参照として使うと、ルーティングの遅延を最小限に抑えた上で、直接応答ができるようになります。"

#: ../../general/addressing.rst:137
msgid ""
"One important aspect is that a physical actor path never spans multiple "
"actor systems or JVMs. This means that the logical path (supervision "
"hierarchy) and the physical path (actor deployment) of an actor may diverge "
"if one of its ancestors is remotely supervised."
msgstr ""
"物理的なアクターパスは決して複数のJVMやアクターシステムにまたがることは決してないという重要な一面があります。これは、先祖のどこかでリモートのスーパーバイザーを使っている場合は、アクターの論理的なパス(スーパービジョンの階層)と、物理的なパス(アクターの配置)"
" が乖離するかもしれないということを意味しています。"

#: ../../general/addressing.rst:144
msgid "Actor path alias or symbolic link?"
msgstr "アクターパスはエイリアスやシンボリックリンクなのか?"

#: ../../general/addressing.rst:145
msgid ""
"As in some real file-systems you might think of a “path alias” or “symbolic "
"link” for an actor, i.e. one actor may be reachable using more than one "
"path. However, you should note that actor hierarchy is different from file "
"system hierarchy. You cannot freely create actor paths like symbolic links "
"to refer to arbitrary actors. As described in the above logical and physical"
" actor path sections, an actor path must be either logical path which "
"represents supervision hierarchy, or physical path which represents actor "
"deployment."
msgstr ""
"実際のファイルシステムにあるように、アクターを “パスのエイリアス” や “シンボリックリンク”  "
"と考えているかもしれません。言い換えると、アクターは１つ以上のパスを使うことで到達可能になるかもしれないということです。しかし、アクターの階層はファイルシステムの階層と異なることに注意するべきです。任意のアクターを参照するためにシンボリックリンクのようなアクターパスを自由に作ることはできません。上記の論理的と物理的のアクターパスのセクションで述べたように、アクターパスはスーパービジョンの階層で表現される論理的なパスか、アクターの配置で表現される物理的なパスのどちらかである必要があります。"

#: ../../general/addressing.rst:155
msgid "How are Actor References obtained?"
msgstr "どうやってアクターの参照を取得するか?"

#: ../../general/addressing.rst:157
msgid ""
"There are two general categories to how actor references may be obtained: by"
" creating actors or by looking them up, where the latter functionality comes"
" in the two flavours of creating actor references from concrete actor paths "
"and querying the logical actor hierarchy."
msgstr ""
"アクターの参照を取得する方法は、一般的に "
"2種類あります。アクターを生成することか、アクターを探すことかのどちらかで、後者の機能には具体的なアクターパスからアクターリファレンスを生成することと、論理的なアクターの階層を照会することの"
" 2つ方法があります。"

#: ../../general/addressing.rst:163
msgid "Creating Actors"
msgstr "アクターの生成"

#: ../../general/addressing.rst:165
msgid ""
"An actor system is typically started by creating actors beneath the guardian"
" actor using the :meth:`ActorSystem.actorOf` method and then using "
":meth:`ActorContext.actorOf` from within the created actors to spawn the "
"actor tree. These methods return a reference to the newly created actor. "
"Each actor has direct access (through its ``ActorContext``) to references "
"for its parent, itself and its children. These references may be sent within"
" messages to other actors, enabling those to reply directly."
msgstr ""
"アクターシステムは通常、 :meth:`ActorSystem.actorOf` "
"を使用して、ガーディアンアクター配下のアクターを生成することから始まり、それから生成したアクターに含まれる "
":meth:`ActorContext.actorOf` を使って、 "
"アクターのツリーを広げていきます。これらのメソッドは、新しく生成されたアクターの参照を返します。各アクターは、親、自分自身、子供に対して( "
"``ActorContext`` を通して) "
"直接アクセスできます。これらの参照は他のアクターへメッセージを送信し、直接返信を受け取ることができるかもしれません。"

#: ../../general/addressing.rst:174
msgid "Looking up Actors by Concrete Path"
msgstr "具体的なパスでアクターを探す"

#: ../../general/addressing.rst:176
msgid ""
"In addition, actor references may be looked up using the "
":meth:`ActorSystem.actorSelection` method. The selection can be used for "
"communicating with said actor and the actor corresponding to the selection "
"is looked up when delivering each message."
msgstr ""
"さらに、アクターの参照は、 :meth:`ActorSystem.actorSelection`  メソッドでも検索できます。 "
"セレクションは前述のアクターとのコミニュケーションに使用可能で、セレクションにメッセージが届いた時は、セレクションに対応するアクターが照会されます。"

#: ../../general/addressing.rst:181
msgid ""
"To acquire an :class:`ActorRef` that is bound to the life-cycle of a "
"specific actor you need to send a message, such as the built-in "
":class:`Identify` message, to the actor and use the ``sender()`` reference "
"of a reply from the actor."
msgstr ""
"特定のアクターのライフサイクルが束縛された :class:`ActorRef` を取得するためには、組み込みの  :class:`Identify` "
"メッセージのようなメッセージをアクター送る必要があり、  ``sender()``  を使って応答したアクターの参照を取得します。"

#: ../../general/addressing.rst:186
msgid "Absolute vs. Relative Paths"
msgstr "絶対パス 対 相対パス"

#: ../../general/addressing.rst:188
msgid ""
"In addition to :meth:`ActorSystem.actorSelection` there is also "
":meth:`ActorContext.actorSelection`, which is available inside any actor as "
"``context.actorSelection``. This yields an actor selection much like its "
"twin on :class:`ActorSystem`, but instead of looking up the path starting "
"from the root of the actor tree it starts out on the current actor. Path "
"elements consisting of two dots (``\"..\"``) may be used to access the "
"parent actor. You can for example send a message to a specific sibling::"
msgstr ""
":meth:`ActorSystem.actorSelection` に加えて、 :meth:`ActorContext.actorSelection`"
" も あらゆるアクターの中で、 ``context.actorSelection`` として利用できます。これは、 "
":class:`ActorSystem` "
"のものと双子のように似ていて、アクターセレクションを生成できますが、パスの照会を、アクターのツリーのルートから開始する代わりに、現在のアクターの位置から開始します。"
" 2つのドット (``\"..\"``) "
"で構成されるパス要素は、親のアクターにアクセスするために使います。次の例では、特定の兄弟にメッセージを送っています。"

#: ../../general/addressing.rst:198
msgid ""
"Absolute paths may of course also be looked up on `context` in the usual "
"way, i.e."
msgstr "もちろん絶対パスによる照会も、 `context` では普通の方法として使えます。"

#: ../../general/addressing.rst:204
msgid "will work as expected."
msgstr "予期したとおりに動くでしょう"

#: ../../general/addressing.rst:207
msgid "Querying the Logical Actor Hierarchy"
msgstr "論理的のアクター階層への照会"

#: ../../general/addressing.rst:209
msgid ""
"Since the actor system forms a file-system like hierarchy, matching on paths"
" is possible in the same way as supported by Unix shells: you may replace "
"(parts of) path element names with wildcards (`«*»` and `«?»`) to formulate "
"a selection which may match zero or more actual actors. Because the result "
"is not a single actor reference, it has a different type "
":class:`ActorSelection` and does not support the full set of operations an "
":class:`ActorRef` does. Selections may be formulated using the "
":meth:`ActorSystem.actorSelection` and :meth:`ActorContext.actorSelection` "
"methods and do support sending messages::"
msgstr ""
"アクターシステムは階層のようなファイルシステムを形成しているので、Unix "
"シェルでサポートされている方法と同じようなパスのマッチングが可能です。0から複数の実際のアクターをまとめるために、パス要素 (一部でも可) "
"を、ワイルドカード ( `«*»` と `«?»` ) で置き換えることができます。この結果は単一のアクターの参照ではないので、 "
":class:`ActorSelection` とは異なる型を持ち、 :class:`ActorRef` "
"が持つ操作の全てをサポートしていません。セレクションは :meth:`ActorSystem.actorSelection`  と "
":meth:`ActorContext.actorSelection` メソッドを使ってまとめることができ、メッセージの送信をサポートします。"

#: ../../general/addressing.rst:220
msgid ""
"will send `msg` to all siblings including the current actor. As for "
"references obtained using `actorSelection`, a traversal of the supervision "
"hierarchy is done in order to perform the message send. As the exact set of "
"actors which match a selection may change even while a message is making its"
" way to the recipients, it is not possible to watch a selection for "
"liveliness changes. In order to do that, resolve the uncertainty by sending "
"a request and gathering all answers, extracting the sender references, and "
"then watch all discovered concrete actors. This scheme of resolving a "
"selection may be improved upon in a future release."
msgstr ""
"`msg` は現在のアクターも含むすべての兄弟に送信されるでしょう。 `actorSelection` "
"を使って取得した参照について言えば、メッセージ送信を実行するためにスーパービジョン階層の横断が行われます。メッセージが受信者へ届けられる間でさえもセレクションにマッチしたアクターの確実な集合は変化するため、死活状態の変化をセレクションで監視することは不可能です。それをするためには、リクエストを送信してすべての応答を収集することで不確実性を解決し、送信者の参照を取り出し、そして発見したすべての具体的なアクターを監視します。このセレクションを解決する仕組みは、将来のリリースで改善されるかもしれません。"

#: ../../general/addressing.rst:233
msgid "Summary: ``actorOf`` vs. ``actorSelection``"
msgstr "要約: ``actorOf`` 対 ``actorSelection``"

#: ../../general/addressing.rst:237
msgid ""
"What the above sections described in some detail can be summarized and "
"memorized easily as follows:"
msgstr "上のセクションで幾つか詳細に解説したことは、以下のとおり簡単に要約できて、記録できます。"

#: ../../general/addressing.rst:240
msgid ""
"``actorOf`` only ever creates a new actor, and it creates it as a direct "
"child of the context on which this method is invoked (which may be any actor"
" or actor system)."
msgstr ""
"``actorOf`` "
"は新しいアクターを作る用途で使います。そして作成されたアクターはメソッドを実行したコンテキスト(あらゆるアクターや、アクターシステム)の直接の子供になります。"

#: ../../general/addressing.rst:244
msgid ""
"``actorSelection`` only ever looks up existing actors when messages are "
"delivered, i.e. does not create actors, or verify existence of actors when "
"the selection is created."
msgstr ""
"``actorSelection`` "
"はメッセージを配信するときに、既存のアクターを検索する用途で使います。よって、アクターを生成しません。あるいは、セレクションを生成してアクターの存在の検証目的でも使用します。"

#: ../../general/addressing.rst:249
msgid "Actor Reference and Path Equality"
msgstr "アクターの参照と パス等価性"

#: ../../general/addressing.rst:251
msgid ""
"Equality of ``ActorRef`` match the intention that an ``ActorRef`` "
"corresponds to the target actor incarnation. Two actor references are "
"compared equal when they have the same path and point to the same actor "
"incarnation. A reference pointing to a terminated actor does not compare "
"equal to a reference pointing to another (re-created) actor with the same "
"path. Note that a restart of an actor caused by a failure still means that "
"it is the same actor incarnation, i.e. a restart is not visible for the "
"consumer of the ``ActorRef``."
msgstr ""
"``ActorRef`` の等価性は ``ActorRef`` "
"が対応する対象のアクターの実体そのものと目的が一致します。2つのアクターの参照が、同じパスを持ち同じアクターの実体を指している時、等価であると比較されます。終了したアクターを指している参照は、同じパスである別の(再生成した)アクターを比較しても等価ではありません。障害によるアクターのリスタートは、まだ同じアクターの実体であることに注意してください。つまり、リスタートは、"
" ``ActorRef`` の利用者に対しては 不可視となります。"

#: ../../general/addressing.rst:259
msgid ""
"If you need to keep track of actor references in a collection and do not "
"care about the exact actor incarnation you can use the ``ActorPath`` as key,"
" because the identifier of the target actor is not taken into account when "
"comparing actor paths."
msgstr ""
"もしコレクションのアクターの参照を記録する必要があり、正確なアクターの実体について気にする必要がないなら、キーとして ``ActorPath``  "
"が使えます。その理由は、アクターパスを比較する際は、対象のアクターの識別子を考慮しないためです。"

#: ../../general/addressing.rst:264
msgid "Reusing Actor Paths"
msgstr "アクターパスの再利用"

#: ../../general/addressing.rst:266
msgid ""
"When an actor is terminated, its reference will point to the dead letter "
"mailbox, DeathWatch will publish its final transition and in general it is "
"not expected to come back to life again (since the actor life cycle does not"
" allow this). While it is possible to create an actor at a later time with "
"an identical path—simply due to it being impossible to enforce the opposite "
"without keeping the set of all actors ever created available—this is not "
"good practice: messages sent with ``actorSelection`` to an actor which "
"“died” suddenly start to work again, but without any guarantee of ordering "
"between this transition and any other event, hence the new inhabitant of the"
" path may receive messages which were destined for the previous tenant."
msgstr ""
"アクターが終了した時、その参照はデッドレターのメールボックスを指し、 DeathWatch "
"は最後の状態変化を発行します。そして一般的に、死んだアクターが復活して戻ることは予期しないことでしょう(アクターのライフサイクルではこれは許容していません)。しばらくした後で同じパスのアクターを作ることは可能ですが、"
" - 今までに生成した利用可能なアクターの集合を保持することなしで反対を実施することは単に不可能であるため - これは良い習慣ではありません。 "
"``actorSelection`` で “死んだ” "
"アクターに送ったメッセージは突然再び動き始めますが、この状態変化とあらゆる他のイベントとの間に、何の順序保証もありません。そのため、パスの新しい所有者は以前の所有者に宛てたメッセージを受け取るかもしれません。"

#: ../../general/addressing.rst:277
msgid ""
"It may be the right thing to do in very specific circumstances, but make "
"sure to confine the handling of this precisely to the actor’s supervisor, "
"because that is the only actor which can reliably detect proper "
"deregistration of the name, before which creation of the new child will "
"fail."
msgstr ""
"それは非常に限られた状況では正しいことかもしれませんが、アクターのスーパーバイザーが操作を適切に制限していることを確認しておきます。その理由は、スーパバイザーが新しい子のアクターの生成が失敗する前に、その名前の適切に登録解除されることを発見できる唯一のアクターであるためです。"

#: ../../general/addressing.rst:282
msgid ""
"It may also be required during testing, when the test subject depends on "
"being instantiated at a specific path. In that case it is best to mock its "
"supervisor so that it will forward the Terminated message to the appropriate"
" point in the test procedure, enabling the latter to await proper "
"deregistration of the name."
msgstr ""
"また、テスト対象が特定のパスでインスタンス化することに依存するとき、テスト中でも必要になります。この場合では、スーパーバイザーをモック化することがベストなので、テストの手続きの適切なポイントで、"
" Terminated メッセージを送り、名前の適切な登録解除を待機可能にします。"

#: ../../general/addressing.rst:288
msgid "The Interplay with Remote Deployment"
msgstr "リモートデプロイ使用時の内部動作"

#: ../../general/addressing.rst:290
msgid ""
"When an actor creates a child, the actor system’s deployer will decide "
"whether the new actor resides in the same JVM or on another node. In the "
"second case, creation of the actor will be triggered via a network "
"connection to happen in a different JVM and consequently within a different "
"actor system. The remote system will place the new actor below a special "
"path reserved for this purpose and the supervisor of the new actor will be a"
" remote actor reference (representing that actor which triggered its "
"creation). In this case, :meth:`context.parent` (the supervisor reference) "
"and :meth:`context.path.parent` (the parent node in the actor’s path) do not"
" represent the same actor. However, looking up the child’s name within the "
"supervisor will find it on the remote node, preserving logical structure "
"e.g. when sending to an unresolved actor reference."
msgstr ""
"アクターが子を生成するとき、アクターシステムのデプロイヤーは新しいアクターを同じ JVM "
"に生成するか別のノード上に生成するかを決定します。後者のケースでは、アクターの生成はネットワーク接続経由で異なる JVM "
"、したがって異なるアクターシステムの中で起こされます。リモートシステムは新しいアクターを、この目的のために予約された特別なパスの配下に置き、新しいアクターのスーパーバイザーはリモートアクターの参照(生成を起こしたアクターとして扱う)になります。この場合、"
" :meth:`context.parent` (スーパーバイザーの参照) と :meth:`context.path.parent` "
"(アクターのパスの親のノード) "
"は同じアクターとして表現されません。しかしながら、スーパーバイザー内部にある子供の名前の検索は、リモートノードの中から発見し、論理的な構造を、例えば未解決のアクターの参照に送信するときなどに、保存します。"
" "

#: ../../general/addressing.rst:306
msgid "What is the Address part used for?"
msgstr "アドレス部の用途は何か?"

#: ../../general/addressing.rst:308
msgid ""
"When sending an actor reference across the network, it is represented by its"
" path. Hence, the path must fully encode all information necessary to send "
"messages to the underlying actor. This is achieved by encoding protocol, "
"host and port in the address part of the path string. When an actor system "
"receives an actor path from a remote node, it checks whether that path’s "
"address matches the address of this actor system, in which case it will be "
"resolved to the actor’s local reference. Otherwise, it will be represented "
"by a remote actor reference."
msgstr ""
"ネットワークを横断してアクターの参照を送信するとき、それはそのパスによって表現されます。そのため、パスは配下のアクターにメッセージを送信するのに必要なすべての情報を完全にエンコードしなくてはいけません。これはエンコーディングプロトコル、パス文字列のアドレス部のホストとポートによって成り立ちます。リモートノードからアクターシステムがアクターパスを受け取った時、パスのアドレスがアクターシステムのアドレスと一致するかチェックし、一致する場合アクターのローカル参照として解決します。そうでない場合、リモートアクターの参照として扱います。"

#: ../../general/addressing.rst:320
msgid "Top-Level Scopes for Actor Paths"
msgstr "アクターパスのトップレベルスコープ"

#: ../../general/addressing.rst:322
msgid ""
"At the root of the path hierarchy resides the root guardian above which all "
"other actors are found; its name is ``\"/\"``. The next level consists of "
"the following:"
msgstr ""
"パス階層のルートにはすべてのアクターの上位にいるルートガーディアンがいることがわかります。その名前は ``\"/\"'`` "
"です。次のレベルは以下にあるもので構成されます。"

#: ../../general/addressing.rst:326
msgid ""
"``\"/user\"`` is the guardian actor for all user-created top-level actors; "
"actors created using :meth:`ActorSystem.actorOf` are found below this one."
msgstr ""
"``\"/user\"`` "
"はユーザーが作成するすべてのトップレベルアクターに対するガーディアンアクターで、:meth:`ActorSystem.actorOf` "
"を使って作成したアクターは、このアクターの配下で見つかります。"

#: ../../general/addressing.rst:328
msgid ""
"``\"/system\"`` is the guardian actor for all system-created top-level "
"actors, e.g. logging listeners or actors automatically deployed by "
"configuration at the start of the actor system."
msgstr ""
"``\"/system\"`` は "
"システムが作成したすべてのトップレベルアクターのガーディアンアクターです。たとえば、ロギングリスナーや、アクターシステムの開始時に設定によって自動的にデプロイされたアクターなどです。"

#: ../../general/addressing.rst:331
msgid ""
"``\"/deadLetters\"`` is the dead letter actor, which is where all messages "
"sent to stopped or non-existing actors are re-routed (on a best-effort "
"basis: messages may be lost even within the local JVM)."
msgstr ""
"``\"/deadLetters\"`` "
"はデッドレターアクターで、停止状態や存在しないアクターへ送信した全てのメッセージがここに再送されます(ただしベストエフォートベースであり、ローカル "
"JVM 内であってもメッセージは失われるかもしれません)。"

#: ../../general/addressing.rst:334
msgid ""
"``\"/temp\"`` is the guardian for all short-lived system-created actors, "
"e.g. those which are used in the implementation of :meth:`ActorRef.ask`."
msgstr ""
"``\"/temp\"`` は短命のシステムが作成したすべてのアクターに対するガーディアンです。例えば、 :meth:`ActorRef.ask` "
"の実装などに使われます。"

#: ../../general/addressing.rst:336
msgid ""
"``\"/remote\"`` is an artificial path below which all actors reside whose "
"supervisors are remote actor references"
msgstr "``\"/remote\"`` はスーパーバイザーがリモートアクターの参照に所属するアクターの人工のパスです。"

#: ../../general/addressing.rst:339
msgid ""
"The need to structure the name space for actors like this arises from a "
"central and very simple design goal: everything in the hierarchy is an "
"actor, and all actors function in the same way. Hence you can not only look "
"up the actors you created, you can also look up the system guardian and send"
" it a message (which it will dutifully discard in this case). This powerful "
"principle means that there are no quirks to remember, it makes the whole "
"system more uniform and consistent."
msgstr ""
"このようなアクターのネームスペース構造の必要性は、集中と非常に簡単な設計目標から生じています。全ての階層はアクターであり、全てのアクターの機能も同じ方法です。したがって、自分で作成したアクターを探すだけでなく、システムガーディアンも探すことができ、またメッセージを送ることもできます(この場合、メッセージをルールに従って破棄するでしょう)。このパワフルな法則は、思えることが苦ではないことを意味し、システム全体をより一体感と一貫性があるものにします。"

#: ../../general/addressing.rst:347
msgid ""
"If you want to read more about the top-level structure of an actor system, "
"have a look at :ref:`toplevel-supervisors`."
msgstr ""
"もしアクターシステムのトップレベルの構造についてより知りたいなら、 :ref:`toplevel-supervisors` を見てください。"
