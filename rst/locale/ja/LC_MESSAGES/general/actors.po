# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Yugo Maede <yugo.maede@gmail.com>, 2017\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../general/actors.rst:4
msgid "What is an Actor?"
msgstr "アクターとは何か？"

#: ../../general/actors.rst:6
msgid ""
"The previous section about :ref:`actor-systems` explained how actors form "
"hierarchies and are the smallest unit when building an application. This "
"section looks at one such actor in isolation, explaining the concepts you "
"encounter while implementing it. For a more in depth reference with all the "
"details please refer to :ref:`Actors (Scala) <actors-scala>` and "
":ref:`Untyped Actors (Java) <untyped-actors-java>`."
msgstr ""
"前のセクション :ref:`actor-systems` "
"では、アクターがどのように階層を形成し、アプリケーションを構築する際の最小単位であるかを説明しました。このセクションでは、そのようなアクターを単独で見て、それを実装する際に遭遇する概念について説明します。詳細は、"
" :ref:`Actors (Scala) <actors-scala>`  と :ref:`Untyped Actors (Java) "
"<untyped-actors-java>` を参照してください。"

#: ../../general/actors.rst:13
msgid ""
"An actor is a container for `State`_, `Behavior`_, a `Mailbox`_, `Child "
"Actors`_ and a `Supervisor Strategy`_. All of this is encapsulated behind an"
" `Actor Reference`_. One noteworthy aspect is that actors have an explicit "
"lifecycle, they are not automatically destroyed when no longer referenced; "
"after having created one, it is your responsibility to make sure that it "
"will eventually be terminated as well—which also gives you control over how "
"resources are released `When an Actor Terminates`_."
msgstr ""
"アクターは、 `状態`_ 、 `振る舞い`_ 、 `メールボックス`_ 、 `子アクター`_ 、  `スーパーバイザー戦略`_ "
"のコンテナです。これらのすべては `アクター参照`_ "
"の背後にカプセル化されています。注目すべき点の1つは、アクターが明示的なライフサイクルを持ち、参照されなくなったときに自動的に破棄されないことです。 "
"作成した後、最終的に終了することを確実にすることはあなたの責任であり、また、 `Actorを終了する時`_ "
"にリソースを解放する方法を制御することができます。"

#: ../../general/actors.rst:22
msgid "Actor Reference"
msgstr "アクター参照"

#: ../../general/actors.rst:24
msgid ""
"As detailed below, an actor object needs to be shielded from the outside in "
"order to benefit from the actor model. Therefore, actors are represented to "
"the outside using actor references, which are objects that can be passed "
"around freely and without restriction. This split into inner and outer "
"object enables transparency for all the desired operations: restarting an "
"actor without needing to update references elsewhere, placing the actual "
"actor object on remote hosts, sending messages to actors in completely "
"different applications. But the most important aspect is that it is not "
"possible to look inside an actor and get hold of its state from the outside,"
" unless the actor unwisely publishes this information itself."
msgstr ""
"以下に詳述するように、アクターモデルから恩恵を受けるためにアクターオブジェクトを外部から遮蔽する必要があります。 "
"したがって、アクターは自由に、制限なしに渡すことができるオブジェクトであるアクター参照を使用して外部に現れます。 "
"他の場所で参照を更新することなくアクターを再起動し、実際のアクターオブジェクトをリモートホストに配置し、まったく異なるアプリケーションでアクターにメッセージを送信します。"
" "
"しかし、最も重要な側面は、アクターがこの情報自体を無差別に公表しない限り、アクターの内部を見て外部からその状態を保持することは不可能であるということです。"

#: ../../general/actors.rst:36
msgid "State"
msgstr "状態"

#: ../../general/actors.rst:38
msgid ""
"Actor objects will typically contain some variables which reflect possible "
"states the actor may be in. This can be an explicit state machine (e.g. "
"using the :ref:`fsm-scala` module), or it could be a counter, set of "
"listeners, pending requests, etc. These data are what make an actor "
"valuable, and they must be protected from corruption by other actors. The "
"good news is that Akka actors conceptually each have their own light-weight "
"thread, which is completely shielded from the rest of the system. This means"
" that instead of having to synchronize access using locks you can just write"
" your actor code without worrying about concurrency at all."
msgstr ""
"Actorオブジェクトには通常、アクターが存在する可能性のある状態を反映する変数がいくつか含まれています。これは、明示的な状態マシン(例：  :ref"
":`fsm-scala`  モジュールを使用)でもかまいません。また、 "
"これらのデータは、アクターを高価なものにするものであり、他のアクターによる腐敗から保護されなければならない。 "
"素晴らしいことに、Akkaのアクターは概念的にはそれぞれ軽量のスレッドを持ち、残りのシステムから完全に遮蔽されています。 "
"つまり、ロックを使用してアクセスを同期させる代わりに、並行性を気にせずにアクターコードを書くことができます。"

#: ../../general/actors.rst:48
msgid ""
"Behind the scenes Akka will run sets of actors on sets of real threads, "
"where typically many actors share one thread, and subsequent invocations of "
"one actor may end up being processed on different threads. Akka ensures that"
" this implementation detail does not affect the single-threadedness of "
"handling the actor’s state."
msgstr ""
"背後でAkkaは、通常は多くのアクターが1つのスレッドを共有し、1つのアクターの後続の呼び出しが異なるスレッドで処理される可能性がある実際のスレッドのセットでアクターのセットを実行します。"
" Akkaは、この実装の詳細がアクターの状態を処理するシングルスレッドに影響しないことを保証します。"

#: ../../general/actors.rst:54
msgid ""
"Because the internal state is vital to an actor’s operations, having "
"inconsistent state is fatal. Thus, when the actor fails and is restarted by "
"its supervisor, the state will be created from scratch, like upon first "
"creating the actor. This is to enable the ability of self-healing of the "
"system."
msgstr ""
"内部状態はアクターの業務にとって不可欠であるため、矛盾した状態を持つことは致命的です。 "
"したがって、アクターが失敗し、スーパーバイザーによって再起動されると、最初にアクターを作成したときのように、状態はゼロから作成されます。 "
"これは、システムの自己治癒機能を有効にするためです。"

#: ../../general/actors.rst:59
msgid ""
"Optionally, an actor's state can be automatically recovered to the state "
"before a restart by persisting received messages and replaying them after "
"restart (see :ref:`persistence-scala`)."
msgstr ""
"オプションとして、アクターの状態は、受信したメッセージを永続化し、再起動後にリプレイすることで、再起動前の状態に自動的に回復することができます( "
":ref:`persistence-scala` を参照)。"

#: ../../general/actors.rst:64
msgid "Behavior"
msgstr "振る舞い"

#: ../../general/actors.rst:66
msgid ""
"Every time a message is processed, it is matched against the current "
"behavior of the actor. Behavior means a function which defines the actions "
"to be taken in reaction to the message at that point in time, say forward a "
"request if the client is authorized, deny it otherwise. This behavior may "
"change over time, e.g. because different clients obtain authorization over "
"time, or because the actor may go into an “out-of-service” mode and later "
"come back. These changes are achieved by either encoding them in state "
"variables which are read from the behavior logic, or the function itself may"
" be swapped out at runtime, see the ``become`` and ``unbecome`` operations. "
"However, the initial behavior defined during construction of the actor "
"object is special in the sense that a restart of the actor will reset its "
"behavior to this initial one."
msgstr ""
"メッセージが処理されるたびに、アクターの現在の振る舞いと照合されます。 "
"振る舞いとは、その時点でメッセージに反応するアクションを定義する関数を意味し、クライアントが許可されている場合は要求を転送し、それ以外の場合は否定します。"
" この振る舞いは時間の経過とともに変化する可能性があります。 異なるクライアントが時間の経過とともに権限を得るか、またはアクターが「out-of-"
"service」モードに入り、後で戻ってくる可能性があるからです。 "
"これらの変更は、振る舞いのロジックから読み込まれた状態変数をエンコードするか、実行時に関数自体をスワップアウトして、 ``become`` と "
"``unbecome`` の操作を参照することによって実現されます。 "
"しかし、アクターオブジェクトの構築中に定義される最初の振る舞いは、アクターの再起動がその振る舞いを初期アクションにリセットするという意味で特別です。"

#: ../../general/actors.rst:79
msgid "Mailbox"
msgstr "メールボックス"

#: ../../general/actors.rst:81
msgid ""
"An actor’s purpose is the processing of messages, and these messages were "
"sent to the actor from other actors (or from outside the actor system). The "
"piece which connects sender and receiver is the actor’s mailbox: each actor "
"has exactly one mailbox to which all senders enqueue their messages. "
"Enqueuing happens in the time-order of send operations, which means that "
"messages sent from different actors may not have a defined order at runtime "
"due to the apparent randomness of distributing actors across threads. "
"Sending multiple messages to the same target from the same actor, on the "
"other hand, will enqueue them in the same order."
msgstr ""
"アクターの目的はメッセージの処理であり、これらのメッセージはアクターへ別のアクター(またはアクターシステムの外から)から送らます。 "
"送信者と受信者を接続するのは、アクターのメールボックスです。各アクターは、すべての送信者がメッセージをエンキューするただ1つのメールボックスを持っています。"
" "
"エンキューは送信操作の時間順に行われます。つまり、異なるアクターから送信されたメッセージは、スレッド間でアクターを分散させるという明らかなランダム性により、実行時に定義された順序を維持しない場合があります。"
" 同じアクターから同じターゲットへ複数のメッセージを送信すると、同じ順序でエンキューされます。"

#: ../../general/actors.rst:91
msgid ""
"There are different mailbox implementations to choose from, the default "
"being a FIFO: the order of the messages processed by the actor matches the "
"order in which they were enqueued. This is usually a good default, but "
"applications may need to prioritize some messages over others. In this case,"
" a priority mailbox will enqueue not always at the end but at a position as "
"given by the message priority, which might even be at the front. While using"
" such a queue, the order of messages processed will naturally be defined by "
"the queue’s algorithm and in general not be FIFO."
msgstr ""
"さまざまなメールボックスの実装があり、デフォルトはFIFOです。つまり、アクターによって処理されるメッセージの順序は、エンキューされた順序と一致します。"
" これは通常、初期設定として適切ですが、アプリケーションはあるメッセージを別の優先順位付けにする必要があります。 "
"この場合、優先度の高いメールボックスは、必ずしも最後ではなく、メッセージ優先度によって指定された位置にエンキューされます。 "
"このようなキューを使用している間、処理されるメッセージの順序は、キューのアルゴリズムによって定義され、一般にFIFOではありません。"

#: ../../general/actors.rst:100
msgid ""
"An important feature in which Akka differs from some other actor model "
"implementations is that the current behavior must always handle the next "
"dequeued message, there is no scanning the mailbox for the next matching "
"one. Failure to handle a message will typically be treated as a failure, "
"unless this behavior is overridden."
msgstr ""
"Akkaが他のアクターモデルの実装と異なる重要な機能は、現在の動作では常にデキューされた次のメッセージを処理しなければならず、次に一致するメールのためにメールボックスをスキャンする必要がないことです。"
" この振る舞いがオーバーライドされない限り、メッセージの処理に失敗することは決まって、失敗とみなされます。"

#: ../../general/actors.rst:107
msgid "Child Actors"
msgstr "子アクター"

#: ../../general/actors.rst:109
msgid ""
"Each actor is potentially a supervisor: if it creates children for "
"delegating sub-tasks, it will automatically supervise them. The list of "
"children is maintained within the actor’s context and the actor has access "
"to it. Modifications to the list are done by creating "
"(``context.actorOf(...)``) or stopping (``context.stop(child)``) children "
"and these actions are reflected immediately. The actual creation and "
"termination actions happen behind the scenes in an asynchronous way, so they"
" do not “block” their supervisor."
msgstr ""
"各アクターは、潜在的にスーパーバイザーです。サブタスクを委任するための子を作成すると、それが自動的に監督されます。 "
"子のリストはアクターのコンテキスト内で管理され、アクターはそこにアクセスします。 リストへの変更は、子を作成する "
"(``context.actorOf(...)``) か、停止する (``context.stop(child)``) "
"ことによって行われ、これらのアクションは直ちに反映されます。 "
"実際の作成および終了処理は、バックグラウンドで非同期で行われるため、スーパーバイザを「ブロック」しません。"

#: ../../general/actors.rst:118
msgid "Supervisor Strategy"
msgstr "スーパーバイザー戦略"

#: ../../general/actors.rst:120
msgid ""
"The final piece of an actor is its strategy for handling faults of its "
"children. Fault handling is then done transparently by Akka, applying one of"
" the strategies described in :ref:`supervision` for each incoming failure. "
"As this strategy is fundamental to how an actor system is structured, it "
"cannot be changed once an actor has been created."
msgstr ""
"アクターの最後の部分は、子供たちの障害を処理する戦略です。 障害制御はAkkaによって透過的に行われ、入ってくる障害ごとに "
":ref:`supervision` に記述されている戦略の1つを適用します。 "
"この戦略は、アクターシステムがどのように構成されるかの基本であるため、アクターが作成されると変更することはできません。"

#: ../../general/actors.rst:126
msgid ""
"Considering that there is only one such strategy for each actor, this means "
"that if different strategies apply to the various children of an actor, the "
"children should be grouped beneath intermediate supervisors with matching "
"strategies, preferring once more the structuring of actor systems according "
"to the splitting of tasks into sub-tasks."
msgstr ""
"それぞれのアクターに対してこのような戦略が1つしかないことを考慮すれば、これは、アクターの様々な子に異なる戦略が適用される場合、子は中間スーパーバイザーの下でマッチする戦略でグループ化されなければならないことを意味し、"
" タスクをサブタスクに分割することによるアクターシステムの構造化を必要とします。"

#: ../../general/actors.rst:133
msgid "When an Actor Terminates"
msgstr "アクターが終了すると"

#: ../../general/actors.rst:135
msgid ""
"Once an actor terminates, i.e. fails in a way which is not handled by a "
"restart, stops itself or is stopped by its supervisor, it will free up its "
"resources, draining all remaining messages from its mailbox into the "
"system’s “dead letter mailbox” which will forward them to the EventStream as"
" DeadLetters. The mailbox is then replaced within the actor reference with a"
" system mailbox, redirecting all new messages to the EventStream as "
"DeadLetters. This is done on a best effort basis, though, so do not rely on "
"it in order to construct “guaranteed delivery”."
msgstr ""
"アクターが終了すると、例えば、再起動や自身の停止、スーパーバイザーに停止されたりすることによって制御されない方法で失敗しすると、リソースが解放され、メールボックスの残りすべてのメッセージがシステムの「デッドレターメールボックス」に排出されます。"
" それらを DeadLetter として EventStream に転送します。 "
"メールボックスは、アクター参照内でシステムメールボックスに置き換えられ、すべての新しいメッセージを DeadLetter として EventStream"
" にリダイレクトします。 これは最善の努力として行われますので、保証された配信を構築するために頼らないでください。"

#: ../../general/actors.rst:144
msgid ""
"The reason for not just silently dumping the messages was inspired by our "
"tests: we register the TestEventListener on the event bus to which the dead "
"letters are forwarded, and that will log a warning for every dead letter "
"received—this has been very helpful for deciphering test failures more "
"quickly. It is conceivable that this feature may also be of use for other "
"purposes."
msgstr ""
"メッセージを静かに捨ててしまうだけの理由は、我々のテストによって触発されました。デッドレターが転送されるイベントバスに "
"TestEventListener "
"を登録し、受け取ったデッドレターごとに警告を記録します。これは、テストの失敗をより迅速に解読するのに非常に役立ちました。この機能は、他の目的にも使用できる可能性があります。"
