# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kentaro Maeda <many.front@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../java/untyped-actors.rst:5
msgid "Actors"
msgstr "アクター"

#: ../../java/untyped-actors.rst:8
msgid ""
"The `Actor Model`_ provides a higher level of abstraction for writing "
"concurrent and distributed systems. It alleviates the developer from having "
"to deal with explicit locking and thread management, making it easier to "
"write correct concurrent and parallel systems. Actors were defined in the "
"1973 paper by Carl Hewitt but have been popularized by the Erlang language, "
"and used for example at Ericsson with great success to build highly "
"concurrent and reliable telecom systems."
msgstr ""
"`アクターモデル`は並行分散システムを作るための高度な抽象を提供します。アクターモデルを用いることで開発者は明示的なロックやスレッドの管理を行う労力を軽減した上で信頼性のある並行並列なシステムを作ることができます。アクターは"
" Cal Herwitt が1973年に論文として発表したものですが、Erlangによって世に広められ、この成功例として Ericsson "
"社による高い並行性と信頼性を持つ電気通信システムの構築が挙げられます。"

#: ../../java/untyped-actors.rst:16
msgid ""
"The API of Akka’s Actors is similar to Scala Actors which has borrowed some "
"of its syntax from Erlang."
msgstr "Akka のアクターは Erlang からシンタックスを拝借した Scala のアクターと似ています。"

#: ../../java/untyped-actors.rst:23
msgid "Creating Actors"
msgstr "アクターの生成"

#: ../../java/untyped-actors.rst:27
msgid ""
"Since Akka enforces parental supervision every actor is supervised and "
"(potentially) the supervisor of its children, it is advisable that you "
"familiarize yourself with :ref:`actor-systems` and :ref:`supervision` and it"
" may also help to read :ref:`addressing`."
msgstr ""
"Akka では全てのアクターが親となるアクターに監視され、同時に子供のアクターの supervisor "
"になる(可能性がある)という方式をとっています。この方式については :ref:`actor-systems` や :ref:`supervision` "
"あるいは :ref:`addressing` といった記事を参考に読んでみるとよいでしょう。"

#: ../../java/untyped-actors.rst:33
msgid "Defining an Actor class"
msgstr "アクターのクラスを定義する"

#: ../../java/untyped-actors.rst:35
msgid ""
"Actors in Java are implemented by extending the ``UntypedActor`` class and "
"implementing the :meth:`onReceive` method. This method takes the message as "
"a parameter."
msgstr ""

#: ../../java/untyped-actors.rst:38 ../../java/untyped-actors.rst:578
msgid "Here is an example:"
msgstr "以下はこのサンプルコードです。"

#: ../../java/untyped-actors.rst:43
msgid "Props"
msgstr "Props"

#: ../../java/untyped-actors.rst:45
msgid ""
":class:`Props` is a configuration class to specify options for the creation "
"of actors, think of it as an immutable and thus freely shareable recipe for "
"creating an actor including associated deployment information (e.g. which "
"dispatcher to use, see more below). Here are some examples of how to create "
"a :class:`Props` instance."
msgstr ""
":class:`Propsはアクターを生成するときのオプションを指定するための設定クラスです。このクラスのインスタンスは不変なので気軽に共有することができるアクターを生成するためのレシピと考えることができます。また、このレシピにはデプロイに関係した情報(例えばどのdispatcherを使うかとかいったもの)も含めることができます。"

#: ../../java/untyped-actors.rst:54
msgid ""
"The second line shows how to pass constructor arguments to the "
":class:`Actor` being created. The presence of a matching constructor is "
"verified during construction of the :class:`Props` object, resulting in an "
":class:`IllegalArgumentException` if no or multiple matching constructors "
"are found."
msgstr ""

#: ../../java/untyped-actors.rst:60
msgid ""
"The third line demonstrates the use of a :class:`Creator<T extends Actor>`. "
"The creator class must be static, which is verified during :class:`Props` "
"construction. The type parameter’s upper bound is used to determine the "
"produced actor class, falling back to :class:`Actor` if fully erased. An "
"example of a parametric factory could be:"
msgstr ""

#: ../../java/untyped-actors.rst:70
msgid ""
"In order for mailbox requirements—like using a deque-based mailbox for "
"actors using the stash—to be picked up, the actor type needs to be known "
"before creating it, which is what the :class:`Creator` type argument allows."
" Therefore make sure to use the specific type for your actors wherever "
"possible."
msgstr ""

#: ../../java/untyped-actors.rst:77
msgid "Recommended Practices"
msgstr "推奨される手法"

#: ../../java/untyped-actors.rst:79
msgid ""
"It is a good idea to provide static factory methods on the "
":class:`UntypedActor` which help keeping the creation of suitable "
":class:`Props` as close to the actor definition as possible. This also "
"allows usage of the :class:`Creator`-based methods which statically verify "
"that the used constructor actually exists instead relying only on a runtime "
"check."
msgstr ""

#: ../../java/untyped-actors.rst:87
msgid ""
"Another good practice is to declare what messages an Actor can receive as "
"close to the actor definition as possible (e.g. as static classes inside the"
" Actor or using other suitable class), which makes it easier to know what it"
" can receive."
msgstr ""

#: ../../java/untyped-actors.rst:95
msgid "Creating Actors with Props"
msgstr "Propsを使ったアクターの生成"

#: ../../java/untyped-actors.rst:97
msgid ""
"Actors are created by passing a :class:`Props` instance into the "
":meth:`actorOf` factory method which is available on :class:`ActorSystem` "
"and :class:`ActorContext`."
msgstr ""
"アクターは:class:`Props`のインスタンスを:class:`ActorSystem`や:class:`ActorContext`が持っている:meth:`actorOf`というファクトリメソッドに渡すことで生成できます。"

#: ../../java/untyped-actors.rst:104
msgid ""
"Using the :class:`ActorSystem` will create top-level actors, supervised by "
"the actor system’s provided guardian actor, while using an actor’s context "
"will create a child actor."
msgstr ""
":class:`ActorSystem`を使うとトップレベルのアクターを生成できます。トップレベルのアクターはアクターシステムが提供しているガーディアンアクターによって監視されます。一方でコンテクストから生成したアクターはそのアクターの子アクターになります。"

#: ../../java/untyped-actors.rst:111
msgid ""
"It is recommended to create a hierarchy of children, grand-children and so "
"on such that it fits the logical failure-handling structure of the "
"application, see :ref:`actor-systems`."
msgstr ""
"子供から孫といった階層を作るようにしてください。そのようにすることでアプリケーションの論理的なエラー処理の構造を作ることができます。詳しくは:ref"
":`actor-systems`を参照してください。"

#: ../../java/untyped-actors.rst:115
msgid ""
"The call to :meth:`actorOf` returns an instance of :class:`ActorRef`. This "
"is a handle to the actor instance and the only way to interact with it. The "
":class:`ActorRef` is immutable and has a one to one relationship with the "
"Actor it represents. The :class:`ActorRef` is also serializable and network-"
"aware. This means that you can serialize it, send it over the wire and use "
"it on a remote host and it will still be representing the same Actor on the "
"original node, across the network."
msgstr ""
":meth:`actorOf`を呼ぶことで:class:`ActorRef`のインスタンスを得ることができます。:class:`ActorRef`はアクターのインスタンスとつながっていて、アクターと対話するための唯一の手段となります。:class:`ActorRef`は不変でそれが表現しているアクターと一対一の関係を持っています。:class:`ActorRef`は永続化可能なのでネットワークを介することができます。つまり、シリアライズしたインスタンスをリモートのホストに送信した場合、元のノードのアクターをネットワークを超えて表現することができます。"

#: ../../java/untyped-actors.rst:123
msgid ""
"The name parameter is optional, but you should preferably name your actors, "
"since that is used in log messages and for identifying actors. The name must"
" not be empty or start with ``$``, but it may contain URL encoded characters"
" (eg. ``%20`` for a blank space).  If the given name is already in use by "
"another child to the same parent an `InvalidActorNameException` is thrown."
msgstr ""

#: ../../java/untyped-actors.rst:129
msgid "Actors are automatically started asynchronously when created."
msgstr "アクターは生成されたら非同期に自動的に開始されます。"

#: ../../java/untyped-actors.rst:134
msgid "Dependency Injection"
msgstr "依存性の注入"

#: ../../java/untyped-actors.rst:136
msgid ""
"If your UntypedActor has a constructor that takes parameters then those need"
" to be part of the :class:`Props` as well, as described `above`__. But there"
" are cases when a factory method must be used, for example when the actual "
"constructor arguments are determined by a dependency injection framework."
msgstr ""

#: ../../java/untyped-actors.rst:150
msgid ""
"You might be tempted at times to offer an :class:`IndirectActorProducer` "
"which always returns the same instance, e.g. by using a static field. This "
"is not supported, as it goes against the meaning of an actor restart, which "
"is described here: :ref:`supervision-restart`."
msgstr ""

#: ../../java/untyped-actors.rst:155
msgid ""
"When using a dependency injection framework, actor beans *MUST NOT* have "
"singleton scope."
msgstr "依存性の注入を行うフレームワークを使う場合、アクターのbeanはシングルトンスコープであることは*許可されません*。"

#: ../../java/untyped-actors.rst:158
msgid ""
"Techniques for dependency injection and integration with dependency "
"injection frameworks are described in more depth in the `Using Akka with "
"Dependency Injection <http://letitcrash.com/post/55958814293/akka-"
"dependency-injection>`_ guideline and the `Akka Java Spring "
"<http://www.lightbend.com/activator/template/akka-java-spring>`_ tutorial in"
" Lightbend Activator."
msgstr ""
"依存性の注入のためのテクニックや依存性注入を行うフレームワークとの統合については`Using Akka with Dependency "
"Injection  <http://letitcrash.com/post/55958814293/akka-dependency-"
"injection>`_ guidelineやLightbend Activatorの中の`Akka Java Spring "
"<http://www.lightbend.com/activator/template/akka-java-spring>`_ "
"tutorialにより詳しい情報があります。"

#: ../../java/untyped-actors.rst:165
msgid "The Inbox"
msgstr "Inbox"

#: ../../java/untyped-actors.rst:167
msgid ""
"When writing code outside of actors which shall communicate with actors, the"
" ``ask`` pattern can be a solution (see below), but there are two things it "
"cannot do: receiving multiple replies (e.g. by subscribing an "
":class:`ActorRef` to a notification service) and watching other actors’ "
"lifecycle. For these purposes there is the :class:`Inbox` class:"
msgstr ""
"アクターの外側のコードからアクターと通信をする場合、``ask``パターン(後で出てきます)を使うのが一つの方法ですが、それを使えない場合が二つあります。一つは複数のメッセージを受け取るような場合(例えば通知サービスとして実装されている:class:`ActorRef`を購読する場合)で、もう一つはActorのライフサイクルをwatchしている場合です。こういった場合のために:class:`Inbox`というクラスが用意されています。"

#: ../../java/untyped-actors.rst:175
msgid ""
"The :meth:`send` method wraps a normal :meth:`tell` and supplies the "
"internal actor’s reference as the sender. This allows the reply to be "
"received on the last line.  Watching an actor is quite simple as well:"
msgstr ""

#: ../../java/untyped-actors.rst:182
msgid "UntypedActor API"
msgstr ""

#: ../../java/untyped-actors.rst:184
msgid ""
"The :class:`UntypedActor` class defines only one abstract method, the above "
"mentioned :meth:`onReceive(Object message)`, which implements the behavior "
"of the actor."
msgstr ""

#: ../../java/untyped-actors.rst:187
msgid ""
"If the current actor behavior does not match a received message, it's "
"recommended that you call the :meth:`unhandled` method, which by default "
"publishes a ``new akka.actor.UnhandledMessage(message, sender, recipient)`` "
"on the actor system’s event stream (set configuration item "
"``akka.actor.debug.unhandled`` to ``on`` to have them converted into actual "
"Debug messages)."
msgstr ""

#: ../../java/untyped-actors.rst:193
msgid "In addition, it offers:"
msgstr ":class:`Actor` traitには他にも以下のようなメソッドがあります。"

#: ../../java/untyped-actors.rst:195
msgid ":meth:`getSelf()` reference to the :class:`ActorRef` of the actor"
msgstr ""

#: ../../java/untyped-actors.rst:197
msgid ""
":meth:`getSender()` reference sender Actor of the last received message, "
"typically used as described in :ref:`UntypedActor.Reply`"
msgstr ""

#: ../../java/untyped-actors.rst:199
msgid ""
":meth:`supervisorStrategy()` user overridable definition the strategy to use"
" for supervising child actors"
msgstr ""

#: ../../java/untyped-actors.rst:201
msgid ""
"This strategy is typically declared inside the actor in order to have access"
" to the actor’s internal state within the decider function: since failure is"
" communicated as a message sent to the supervisor and processed like other "
"messages (albeit outside of the normal behavior), all values and variables "
"within the actor are available, as is the ``getSender()`` reference (which "
"will be the immediate child reporting the failure; if the original failure "
"occurred within a distant descendant it is still reported one level up at a "
"time)."
msgstr ""

#: ../../java/untyped-actors.rst:210
msgid ""
":meth:`getContext()` exposes contextual information for the actor and the "
"current message, such as:"
msgstr ""

#: ../../java/untyped-actors.rst:212
msgid "factory methods to create child actors (:meth:`actorOf`)"
msgstr "子アクターを作るためのファクトリメソッド(:meth:`actorOf`)"

#: ../../java/untyped-actors.rst:213
msgid "system that the actor belongs to"
msgstr "アクターが所属しているシステム"

#: ../../java/untyped-actors.rst:214
msgid "parent supervisor"
msgstr "supervisorである親アクター"

#: ../../java/untyped-actors.rst:215
msgid "supervised children"
msgstr "監視している子アクター"

#: ../../java/untyped-actors.rst:216
msgid "lifecycle monitoring"
msgstr "ライフサイクルの監視"

#: ../../java/untyped-actors.rst:217
msgid "hotswap behavior stack as described in :ref:`UntypedActor.HotSwap`"
msgstr ""

#: ../../java/untyped-actors.rst:219
msgid ""
"The remaining visible methods are user-overridable life-cycle hooks which "
"are described in the following:"
msgstr ""
"ここまででまだ残っているアクセス可能なメソッドはユーザがオーバーライドすることで以下の述べるアクターのライフサイクルにフックすることができるメソッドです。"

#: ../../java/untyped-actors.rst:224
msgid ""
"The implementations shown above are the defaults provided by the "
":class:`UntypedActor` class."
msgstr ""

#: ../../java/untyped-actors.rst:230
msgid "Actor Lifecycle"
msgstr "アクターのライフサクル"

#: ../../java/untyped-actors.rst:236
msgid ""
"A path in an actor system represents a \"place\" which might be occupied by "
"a living actor. Initially (apart from system initialized actors) a path is "
"empty. When ``actorOf()`` is called it assigns an *incarnation* of the actor"
" described by the passed ``Props`` to the given path. An actor incarnation "
"is identified by the path *and a UID*. A restart only swaps the ``Actor`` "
"instance defined by the ``Props`` but the incarnation and hence the UID "
"remains the same."
msgstr ""
"アクターシステムにおけるパスは生存しているアクターによって占有されている\"場所\"を表現しています。始めは(システムによって初期化されたアクターを除き)パスは空になっています。"
" ``actorOf()`` を呼びだすと ``Prop`` "
"で表現されたアクターの*インカーネーション*が与えられたパスに生成されます。アクターのインカーネーションはパスと *UID* "
"によって識別されます。再起動が行われたときには ``Actor`` のインスタンスは置き換えられますが、インカーネーションの方は置き換えられないので "
"UID は同じものになります。"

#: ../../java/untyped-actors.rst:244
msgid ""
"The lifecycle of an incarnation ends when the actor is stopped. At that "
"point the appropriate lifecycle events are called and watching actors are "
"notified of the termination. After the incarnation is stopped, the path can "
"be reused again by creating an actor with ``actorOf()``. In this case the "
"name of the new incarnation will be the same as the previous one but the "
"UIDs will differ. An actor can be stopped by the actor itself, another actor"
" or the ``ActorSystem`` (see :ref:`stopping-actors-java`)."
msgstr ""

#: ../../java/untyped-actors.rst:254
msgid ""
"It is important to note that Actors do not stop automatically when no longer"
" referenced, every Actor that is created must also explicitly be destroyed. "
"The only simplification is that stopping a parent Actor will also "
"recursively stop all the child Actors that this parent has created."
msgstr ""
"アクターは参照されなくなったとしても自動的に停止することはないという点は重要です。生成された全てのアクターは明示的に破棄する必要があります。ただし親のアクターを停止する場合、そのアクターが生成した全ての子供のアクターも停止されるのでこの点は単純です。"

#: ../../java/untyped-actors.rst:259
msgid ""
"An ``ActorRef`` always represents an incarnation (path and UID) not just a "
"given path. Therefore if an actor is stopped and a new one with the same "
"name is created an ``ActorRef`` of the old incarnation will not point to the"
" new one."
msgstr ""
"``ActorRef``はただ単に与えられたパスを表現しているのではなくいつでもインカーネーション(パスとUID)を表現しています。つまりアクターを停止して同じ名前のアクターを生成した場合、新しく生成した``ActorRef``は古いインカーネーションでなく新しいインカーネーションを指しています。"

#: ../../java/untyped-actors.rst:264
msgid ""
"``ActorSelection`` on the other hand points to the path (or multiple paths "
"if wildcards are used) and is completely oblivious to which incarnation is "
"currently occupying it. ``ActorSelection`` cannot be watched for this "
"reason. It is possible to resolve the current incarnation's ``ActorRef`` "
"living under the path by sending an ``Identify`` message to the "
"``ActorSelection`` which will be replied to with an ``ActorIdentity`` "
"containing the correct reference (see :ref:`actorSelection-java`). This can "
"also be done with the ``resolveOne`` method of the :class:`ActorSelection`, "
"which returns a ``Future`` of the matching :class:`ActorRef`."
msgstr ""

#: ../../java/untyped-actors.rst:277
msgid "Lifecycle Monitoring aka DeathWatch"
msgstr "ライフサイクルの監視、DeathWatch"

#: ../../java/untyped-actors.rst:279
msgid ""
"In order to be notified when another actor terminates (i.e. stops "
"permanently, not temporary failure and restart), an actor may register "
"itself for reception of the :class:`Terminated` message dispatched by the "
"other actor upon termination (see `Stopping Actors`_). This service is "
"provided by the :class:`DeathWatch` component of the actor system."
msgstr ""
"他のアクターの停止を知るために(例えば、永久に停止された場合や一時的ではない障害によって再起動された場合など)、アクターは他のアクターが停止時に発する "
":class:`Terminated` メッセージを受け取るようにすることができます。(`Stopping "
"Actors`_も参照のこと)この機能はアクターシステムの :class:`DeathWatch` というコンポーネントによって提供されています。"

#: ../../java/untyped-actors.rst:285
msgid ""
"Registering a monitor is easy (see fourth line, the rest is for "
"demonstrating the whole functionality):"
msgstr ""

#: ../../java/untyped-actors.rst:291
msgid ""
"It should be noted that the :class:`Terminated` message is generated "
"independent of the order in which registration and termination occur. In "
"particular, the watching actor will receive a :class:`Terminated` message "
"even if the watched actor has already been terminated at the time of "
"registration."
msgstr ""
":class:`Terminated` "
"メッセージは登録や停止がどのような順番で起きたかとは独立して生成されることに注意してください。典型的な例として、監視を行うアクターは例え監視の登録を行った時点ですでに監視対象のアクターが停止されていたとしても"
" :class:`Treminated` メッセージを受け取ることになります。"

#: ../../java/untyped-actors.rst:296
msgid ""
"Registering multiple times does not necessarily lead to multiple messages "
"being generated, but there is no guarantee that only exactly one such "
"message is received: if termination of the watched actor has generated and "
"queued the message, and another registration is done before this message has"
" been processed, then a second message will be queued, because registering "
"for monitoring of an already terminated actor leads to the immediate "
"generation of the :class:`Terminated` message."
msgstr ""
"監視の登録を複数回行うことが必ずしも複数のメッセージを作ることになるわけではありませんが、こうしたメッセージを正確に一度受け取ることができる保障はありません。監視対象のアクターの停止メッセージが作られてキューに入ってから、このメッセージが処理される前に他のところで登録が行われたら、二つ目のメッセージがキューに入ります。何故なら既に停止したアクターの監視を登録すると、直ちに:"
" class:`Terminated` が生成されるためです。"

#: ../../java/untyped-actors.rst:304
msgid ""
"It is also possible to deregister from watching another actor’s liveliness "
"using ``getContext().unwatch(target)``. This works even if the "
":class:`Terminated` message has already been enqueued in the mailbox; after "
"calling :meth:`unwatch` no :class:`Terminated` message for that actor will "
"be processed anymore."
msgstr ""

#: ../../java/untyped-actors.rst:311
msgid "Start Hook"
msgstr "Start Hook"

#: ../../java/untyped-actors.rst:313
msgid ""
"Right after starting the actor, its :meth:`preStart` method is invoked."
msgstr "アクターが正しく起動すると、 :meth:`preStart` というメソッドが呼び出されます。"

#: ../../java/untyped-actors.rst:317
msgid ""
"This method is called when the actor is first created. During restarts it is"
" called by the default implementation of :meth:`postRestart`, which means "
"that by overriding that method you can choose whether the initialization "
"code in this method is called only exactly once for this actor or for every "
"restart. Initialization code which is part of the actor’s constructor will "
"always be called when an instance of the actor class is created, which "
"happens at every restart."
msgstr ""
"このメソッドはアクタがーが初めに生成されたときに呼び出されます。アクターが再起動したときには :meth:`postRestart` "
"のデフォルトの実装がこのメソッドの呼び出しを行いますが、このメソッドをオーバーライドすることによって初期化のコードを一度だけ呼び出されるようにするのか、再起動のたびに呼び出されるようにするのかを選択することができます。アクターのコンストラクタの中の初期化コードはアクターが生成された時や再起動したときに常に呼び出されます。"

#: ../../java/untyped-actors.rst:326
msgid "Restart Hooks"
msgstr "Restart Hook"

#: ../../java/untyped-actors.rst:328
msgid ""
"All actors are supervised, i.e. linked to another actor with a fault "
"handling strategy. Actors may be restarted in case an exception is thrown "
"while processing a message (see :ref:`supervision`). This restart involves "
"the hooks mentioned above:"
msgstr ""
"全てのアクターは、例えば他のアクターによるエラー処理のストラテジーに紐づくことによって監視されています。アクターがメッセージを処理しているときに例外をスローした場合は再起動が行われます。(:ref:`supervision`"
" を参照)この再起動は上記に挙げたフック処理のトリガになります。"

#: ../../java/untyped-actors.rst:333
msgid ""
"The old actor is informed by calling :meth:`preRestart` with the exception "
"which caused the restart and the message which triggered that exception; the"
" latter may be ``None`` if the restart was not caused by processing a "
"message, e.g. when a supervisor does not trap the exception and is restarted"
" in turn by its supervisor, or if an actor is restarted due to a sibling’s "
"failure. If the message is available, then that message’s sender is also "
"accessible in the usual way (i.e. by calling ``getSender()``)."
msgstr ""

#: ../../java/untyped-actors.rst:341
msgid ""
"This method is the best place for cleaning up, preparing hand-over to the "
"fresh actor instance, etc.  By default it stops all children and calls "
":meth:`postStop`."
msgstr ""
"このメソッドは新しいアクターのインスタンスなどへの引き継ぎのためにクリーンアップを行うのにもっともよい場所です。デフォルトの実装では全ての子アクターを停止して"
" :meth:`postStop` を呼び出すようになっています。"

#: ../../java/untyped-actors.rst:345
msgid ""
"The initial factory from the ``actorOf`` call is used to produce the fresh "
"instance."
msgstr "新しいインスタンスを生成するために :meth:`actorOf` の呼び出し時から引き継いだ初期化のファクトリを利用します。"

#: ../../java/untyped-actors.rst:348
msgid ""
"The new actor’s :meth:`postRestart` method is invoked with the exception "
"which caused the restart. By default the :meth:`preStart` is called, just as"
" in the normal start-up case."
msgstr ""
"新しく生成したアクターの :meth:`postRestart` に再起動の原因となった例外を受け渡して呼び出します。デフォルトの実装では "
":meth:`preStart` の呼び出しを行って通常のアクターの開始と同じように振る舞います。"

#: ../../java/untyped-actors.rst:352
msgid ""
"An actor restart replaces only the actual actor object; the contents of the "
"mailbox is unaffected by the restart, so processing of messages will resume "
"after the :meth:`postRestart` hook returns. The message that triggered the "
"exception will not be received again. Any message sent to an actor while it "
"is being restarted will be queued to its mailbox as usual."
msgstr ""
"アクターの再起動では実際のアクターのオブジェクトが入れ替わるだけです。再起動がメールボックの内容に影響を及ぼすことはないので、メッセージの処理は "
":metho:`postRestart` "
"の処理が終わった後に再開されます。例外の原因となったメッセージを再び受け取ることはありません。再起動中にアクターが受け取ったメッセージは通常メールボックスには入りません。"

#: ../../java/untyped-actors.rst:361
msgid ""
"Be aware that the ordering of failure notifications relative to user "
"messages is not deterministic. In particular, a parent might restart its "
"child before it has processed the last messages sent by the child before the"
" failure. See :ref:`message-ordering` for details."
msgstr ""
"障害の通知とユーザのメッセージの相対的な順番が決定的ではないことに注意してください。特に、親のアクターによって子アクターが障害が起きる前に受け取った最後のメッセージを処理する前に再起動してしまうことがあります。詳細については"
" :ref:`message-ordering` を参照してください。"

#: ../../java/untyped-actors.rst:368
msgid "Stop Hook"
msgstr "Stop Hook"

#: ../../java/untyped-actors.rst:370
msgid ""
"After stopping an actor, its :meth:`postStop` hook is called, which may be "
"used e.g. for deregistering this actor from other services. This hook is "
"guaranteed to run after message queuing has been disabled for this actor, "
"i.e. messages sent to a stopped actor will be redirected to the "
":obj:`deadLetters` of the :obj:`ActorSystem`."
msgstr ""
"アクターが停止した後には、そのアクターの :meth:`postStop` "
"フックが呼び出されるので、これを使って他のサービスからこのアクターを登録解除するといった処理を行うようにします。ここのフックはこのアクターに対するメッセージのキューイングが利用できなくなってから呼び出されることが保障されています。停止されたアクターに送信したメッセージは"
" :obj:`ActorSystem` の :obj:`deadLetters` にリダイレクトされるようになります。"

#: ../../java/untyped-actors.rst:380
msgid "Identifying Actors via Actor Selection"
msgstr "Actor Selectionを使ったアクターの識別"

#: ../../java/untyped-actors.rst:382
msgid ""
"As described in :ref:`addressing`, each actor has a unique logical path, "
"which is obtained by following the chain of actors from child to parent "
"until reaching the root of the actor system, and it has a physical path, "
"which may differ if the supervision chain includes any remote supervisors. "
"These paths are used by the system to look up actors, e.g. when a remote "
"message is received and the recipient is searched, but they are also useful "
"more directly: actors may look up other actors by specifying absolute or "
"relative paths—logical or physical—and receive back an "
":class:`ActorSelection` with the result:"
msgstr ""
":ref:`addressing` "
"で述べたように、アクターはそれぞれ一意な論理パスを持っていて、子供から親を辿ってアクターシステムのルートにまで遡ることができることができます。また、アクターは物理的なパスも持っていますが、監視のチェーンの中にリモートのsupervisorが存在する場合には論理的なパスと異なることがあります。これらのパスはリモートからメッセージを受け取った時に受信者を検索するのに利用されたりしますが、もっと直接的な利点があります。アクターは絶対パスもしくは相対パスを"
"--これらは論理的なものと物理的なものがあります--を使ってほかのアクターを検索し :class:`ActorSelection` "
"を使ってその結果を受け取ることができます。"

#: ../../java/untyped-actors.rst:396
msgid ""
"It is always preferable to communicate with other Actors using their "
"ActorRef instead of relying upon ActorSelection. Exceptions are"
msgstr "通常、アクターの通信はActorSelectionに頼らずにActorRefを使う方が望ましいです。ただし、次の場合は例外です。"

#: ../../java/untyped-actors.rst:399
msgid "sending messages using the :ref:`at-least-once-delivery-java` facility"
msgstr ""

#: ../../java/untyped-actors.rst:400
msgid "initiating first contact with a remote system"
msgstr "リモートシステムとの始めの通信を行う場合"

#: ../../java/untyped-actors.rst:402
msgid ""
"In all other cases ActorRefs can be provided during Actor creation or "
"initialization, passing them from parent to child or introducing Actors by "
"sending their ActorRefs to other Actors within messages."
msgstr ""
"上記以外のケースでは、親から子にActorRefを渡したり、ActorRefへの参照を含メッセージを他のアクターに送信するなど、アクターの生成時や初期化時にActorRefを受け渡す方法があります。"

#: ../../java/untyped-actors.rst:406
msgid ""
"The supplied path is parsed as a :class:`java.net.URI`, which basically "
"means that it is split on ``/`` into path elements. If the path starts with "
"``/``, it is absolute and the look-up starts at the root guardian (which is "
"the parent of ``\"/user\"``); otherwise it starts at the current actor. If a"
" path element equals ``..``, the look-up will take a step “up” towards the "
"supervisor of the currently traversed actor, otherwise it will step “down” "
"to the named child. It should be noted that the ``..`` in actor paths here "
"always means the logical structure, i.e. the supervisor."
msgstr ""

#: ../../java/untyped-actors.rst:415
msgid ""
"The path elements of an actor selection may contain wildcard patterns "
"allowing for broadcasting of messages to that section:"
msgstr ""

#: ../../java/untyped-actors.rst:420
msgid ""
"Messages can be sent via the :class:`ActorSelection` and the path of the "
":class:`ActorSelection` is looked up when delivering each message. If the "
"selection does not match any actors the message will be dropped."
msgstr ""

#: ../../java/untyped-actors.rst:424
msgid ""
"To acquire an :class:`ActorRef` for an :class:`ActorSelection` you need to "
"send a message to the selection and use the ``getSender`` reference of the "
"reply from the actor. There is a built-in ``Identify`` message that all "
"Actors will understand and automatically reply to with a ``ActorIdentity`` "
"message containing the :class:`ActorRef`. This message is handled specially "
"by the actors which are traversed in the sense that if a concrete name "
"lookup fails (i.e. a non-wildcard path element does not correspond to a live"
" actor) then a negative result is generated. Please note that this does not "
"mean that delivery of that reply is guaranteed, it still is a normal "
"message."
msgstr ""

#: ../../java/untyped-actors.rst:437
msgid ""
"You can also acquire an :class:`ActorRef` for an :class:`ActorSelection` "
"with the ``resolveOne`` method of the :class:`ActorSelection`. It returns a "
"``Future`` of the matching :class:`ActorRef` if such an actor exists. It is "
"completed with failure [[akka.actor.ActorNotFound]] if no such actor exists "
"or the identification didn't complete within the supplied `timeout`."
msgstr ""

#: ../../java/untyped-actors.rst:443
msgid ""
"Remote actor addresses may also be looked up, if :ref:`remoting <remoting-"
"java>` is enabled:"
msgstr ""

#: ../../java/untyped-actors.rst:447
msgid ""
"An example demonstrating remote actor look-up is given in :ref:`remote-"
"sample-java`."
msgstr ""

#: ../../java/untyped-actors.rst:450
msgid "Messages and immutability"
msgstr ""

#: ../../java/untyped-actors.rst:452
msgid ""
"**IMPORTANT**: Messages can be any kind of object but have to be immutable. "
"Akka can’t enforce immutability (yet) so this has to be by convention."
msgstr ""

#: ../../java/untyped-actors.rst:456
msgid "Here is an example of an immutable message:"
msgstr ""

#: ../../java/untyped-actors.rst:462
msgid "Send messages"
msgstr ""

#: ../../java/untyped-actors.rst:464
msgid "Messages are sent to an Actor through one of the following methods."
msgstr ""

#: ../../java/untyped-actors.rst:466
msgid ""
"``tell`` means “fire-and-forget”, e.g. send a message asynchronously and "
"return immediately."
msgstr ""

#: ../../java/untyped-actors.rst:468
msgid ""
"``ask`` sends a message asynchronously and returns a :class:`Future` "
"representing a possible reply."
msgstr ""

#: ../../java/untyped-actors.rst:471
msgid "Message ordering is guaranteed on a per-sender basis."
msgstr ""

#: ../../java/untyped-actors.rst:475
msgid ""
"There are performance implications of using ``ask`` since something needs to"
" keep track of when it times out, there needs to be something that bridges a"
" ``Promise`` into an ``ActorRef`` and it also needs to be reachable through "
"remoting. So always prefer ``tell`` for performance, and only ``ask`` if you"
" must."
msgstr ""

#: ../../java/untyped-actors.rst:480
msgid ""
"In all these methods you have the option of passing along your own "
"``ActorRef``. Make it a practice of doing so because it will allow the "
"receiver actors to be able to respond to your message, since the sender "
"reference is sent along with the message."
msgstr ""

#: ../../java/untyped-actors.rst:487
msgid "Tell: Fire-forget"
msgstr ""

#: ../../java/untyped-actors.rst:489
msgid ""
"This is the preferred way of sending messages. No blocking waiting for a "
"message. This gives the best concurrency and scalability characteristics."
msgstr ""

#: ../../java/untyped-actors.rst:494
msgid ""
"The sender reference is passed along with the message and available within "
"the receiving actor via its :meth:`getSender()` method while processing this"
" message. Inside of an actor it is usually :meth:`getSelf` who shall be the "
"sender, but there can be cases where replies shall be routed to some other "
"actor—e.g. the parent—in which the second argument to :meth:`tell` would be "
"a different one. Outside of an actor and if no reply is needed the second "
"argument can be ``null``; if a reply is needed outside of an actor you can "
"use the ask-pattern described next.."
msgstr ""

#: ../../java/untyped-actors.rst:506
msgid "Ask: Send-And-Receive-Future"
msgstr ""

#: ../../java/untyped-actors.rst:508
msgid ""
"The ``ask`` pattern involves actors as well as futures, hence it is offered "
"as a use pattern rather than a method on :class:`ActorRef`:"
msgstr ""

#: ../../java/untyped-actors.rst:514
msgid ""
"This example demonstrates ``ask`` together with the ``pipe`` pattern on "
"futures, because this is likely to be a common combination. Please note that"
" all of the above is completely non-blocking and asynchronous: ``ask`` "
"produces a :class:`Future`, two of which are composed into a new future "
"using the :meth:`Futures.sequence` and :meth:`map` methods and then ``pipe``"
" installs an ``onComplete``-handler on the future to effect the submission "
"of the aggregated :class:`Result` to another actor."
msgstr ""

#: ../../java/untyped-actors.rst:522
msgid ""
"Using ``ask`` will send a message to the receiving Actor as with ``tell``, "
"and the receiving actor must reply with ``getSender().tell(reply, "
"getSelf())`` in order to complete the returned :class:`Future` with a value."
" The ``ask`` operation involves creating an internal actor for handling this"
" reply, which needs to have a timeout after which it is destroyed in order "
"not to leak resources; see more below."
msgstr ""

#: ../../java/untyped-actors.rst:530
msgid ""
"A Java 8 variant of the ``ask`` pattern that returns a ``CompletionStage`` "
"instead of a Scala ``Future`` is available in the "
"``akka.pattern.PatternsCS`` object."
msgstr ""

#: ../../java/untyped-actors.rst:535
msgid ""
"To complete the future with an exception you need send a Failure message to "
"the sender. This is *not done automatically* when an actor throws an "
"exception while processing a message."
msgstr ""

#: ../../java/untyped-actors.rst:540
msgid ""
"If the actor does not complete the future, it will expire after the timeout "
"period, specified as parameter to the ``ask`` method; this will complete the"
" :class:`Future` with an :class:`AskTimeoutException`."
msgstr ""

#: ../../java/untyped-actors.rst:544
msgid ""
"See :ref:`futures-java` for more information on how to await or query a "
"future."
msgstr ""

#: ../../java/untyped-actors.rst:547
msgid ""
"The ``onComplete``, ``onSuccess``, or ``onFailure`` methods of the "
"``Future`` can be used to register a callback to get a notification when the"
" Future completes. Gives you a way to avoid blocking."
msgstr ""

#: ../../java/untyped-actors.rst:553
msgid ""
"When using future callbacks, inside actors you need to carefully avoid "
"closing over the containing actor’s reference, i.e. do not call methods or "
"access mutable state on the enclosing actor from within the callback. This "
"would break the actor encapsulation and may introduce synchronization bugs "
"and race conditions because the callback will be scheduled concurrently to "
"the enclosing actor. Unfortunately there is not yet a way to detect these "
"illegal accesses at compile time. See also: :ref:`jmm-shared-state`"
msgstr ""

#: ../../java/untyped-actors.rst:562
msgid "Forward message"
msgstr ""

#: ../../java/untyped-actors.rst:564
msgid ""
"You can forward a message from one actor to another. This means that the "
"original sender address/reference is maintained even though the message is "
"going through a 'mediator'. This can be useful when writing actors that work"
" as routers, load-balancers, replicators etc. You need to pass along your "
"context variable as well."
msgstr ""

#: ../../java/untyped-actors.rst:573
msgid "Receive messages"
msgstr ""

#: ../../java/untyped-actors.rst:575
msgid ""
"When an actor receives a message it is passed into the ``onReceive`` method,"
" this is an abstract method on the ``UntypedActor`` base class that needs to"
" be defined."
msgstr ""

#: ../../java/untyped-actors.rst:582
msgid ""
"An alternative to using if-instanceof checks is to use `Apache Commons "
"MethodUtils "
"<http://commons.apache.org/beanutils/api/org/apache/commons/beanutils/MethodUtils.html#invokeMethod(java.lang.Object,%20java.lang.String,%20java.lang.Object)>`_"
" to invoke a named method whose parameter type matches the message type."
msgstr ""

#: ../../java/untyped-actors.rst:589
msgid "Reply to messages"
msgstr ""

#: ../../java/untyped-actors.rst:591
msgid ""
"If you want to have a handle for replying to a message, you can use "
"``getSender()``, which gives you an ActorRef. You can reply by sending to "
"that ActorRef with ``getSender().tell(replyMsg, getSelf())``. You can also "
"store the ActorRef for replying later, or passing on to other actors. If "
"there is no sender (a message was sent without an actor or future context) "
"then the sender defaults to a 'dead-letter' actor ref."
msgstr ""

#: ../../java/untyped-actors.rst:602
msgid "Receive timeout"
msgstr ""

#: ../../java/untyped-actors.rst:604
msgid ""
"The `UntypedActorContext` :meth:`setReceiveTimeout` defines the inactivity "
"timeout after which the sending of a `ReceiveTimeout` message is triggered. "
"When specified, the receive function should be able to handle an "
"`akka.actor.ReceiveTimeout` message. 1 millisecond is the minimum supported "
"timeout."
msgstr ""

#: ../../java/untyped-actors.rst:609
msgid ""
"Please note that the receive timeout might fire and enqueue the "
"`ReceiveTimeout` message right after another message was enqueued; hence it "
"is **not guaranteed** that upon reception of the receive timeout there must "
"have been an idle period beforehand as configured via this method."
msgstr ""

#: ../../java/untyped-actors.rst:613
msgid ""
"Once set, the receive timeout stays in effect (i.e. continues firing "
"repeatedly after inactivity periods). Pass in `Duration.Undefined` to switch"
" off this feature."
msgstr ""

#: ../../java/untyped-actors.rst:618
msgid ""
"Messages marked with ``NotInfluenceReceiveTimeout`` will not reset the "
"timer. This can be useful when ``ReceiveTimeout`` should be fired by "
"external inactivity but not influenced by internal activity, e.g. scheduled "
"tick messages."
msgstr ""

#: ../../java/untyped-actors.rst:625
msgid "Stopping actors"
msgstr ""

#: ../../java/untyped-actors.rst:627
msgid ""
"Actors are stopped by invoking the :meth:`stop` method of a "
"``ActorRefFactory``, i.e. ``ActorContext`` or ``ActorSystem``. Typically the"
" context is used for stopping the actor itself or child actors and the "
"system for stopping top level actors. The actual termination of the actor is"
" performed asynchronously, i.e. :meth:`stop` may return before the actor is "
"stopped."
msgstr ""

#: ../../java/untyped-actors.rst:635
msgid ""
"Processing of the current message, if any, will continue before the actor is"
" stopped, but additional messages in the mailbox will not be processed. By "
"default these messages are sent to the :obj:`deadLetters` of the "
":obj:`ActorSystem`, but that depends on the mailbox implementation."
msgstr ""

#: ../../java/untyped-actors.rst:640
msgid ""
"Termination of an actor proceeds in two steps: first the actor suspends its "
"mailbox processing and sends a stop command to all its children, then it "
"keeps processing the internal termination notifications from its children "
"until the last one is gone, finally terminating itself (invoking "
":meth:`postStop`, dumping mailbox, publishing :class:`Terminated` on the "
":ref:`DeathWatch <deathwatch-java>`, telling its supervisor). This procedure"
" ensures that actor system sub-trees terminate in an orderly fashion, "
"propagating the stop command to the leaves and collecting their confirmation"
" back to the stopped supervisor. If one of the actors does not respond (i.e."
" processing a message for extended periods of time and therefore not "
"receiving the stop command), this whole process will be stuck."
msgstr ""

#: ../../java/untyped-actors.rst:652
msgid ""
"Upon :meth:`ActorSystem.terminate()`, the system guardian actors will be "
"stopped, and the aforementioned process will ensure proper termination of "
"the whole system."
msgstr ""

#: ../../java/untyped-actors.rst:656
msgid ""
"The :meth:`postStop()` hook is invoked after an actor is fully stopped. This"
" enables cleaning up of resources:"
msgstr ""

#: ../../java/untyped-actors.rst:664
msgid ""
"Since stopping an actor is asynchronous, you cannot immediately reuse the "
"name of the child you just stopped; this will result in an "
":class:`InvalidActorNameException`. Instead, :meth:`watch()` the terminating"
" actor and create its replacement in response to the :class:`Terminated` "
"message which will eventually arrive."
msgstr ""

#: ../../java/untyped-actors.rst:673
msgid "PoisonPill"
msgstr ""

#: ../../java/untyped-actors.rst:675
msgid ""
"You can also send an actor the ``akka.actor.PoisonPill`` message, which will"
" stop the actor when the message is processed. ``PoisonPill`` is enqueued as"
" ordinary messages and will be handled after messages that were already "
"queued in the mailbox."
msgstr ""

#: ../../java/untyped-actors.rst:680
msgid "Use it like this:"
msgstr ""

#: ../../java/untyped-actors.rst:686
msgid "Graceful Stop"
msgstr ""

#: ../../java/untyped-actors.rst:688
msgid ""
":meth:`gracefulStop` is useful if you need to wait for termination or "
"compose ordered termination of several actors:"
msgstr ""

#: ../../java/untyped-actors.rst:700
msgid ""
"When ``gracefulStop()`` returns successfully, the actor’s ``postStop()`` "
"hook will have been executed: there exists a happens-before edge between the"
" end of ``postStop()`` and the return of ``gracefulStop()``."
msgstr ""

#: ../../java/untyped-actors.rst:704
msgid ""
"In the above example a custom ``Manager.SHUTDOWN`` message is sent to the "
"target actor to initiate the process of stopping the actor. You can use "
"``PoisonPill`` for this, but then you have limited possibilities to perform "
"interactions with other actors before stopping the target actor. Simple "
"cleanup tasks can be handled in ``postStop``."
msgstr ""

#: ../../java/untyped-actors.rst:711
msgid ""
"Keep in mind that an actor stopping and its name being deregistered are "
"separate events which happen asynchronously from each other. Therefore it "
"may be that you will find the name still in use after ``gracefulStop()`` "
"returned. In order to guarantee proper deregistration, only reuse names from"
" within a supervisor you control and only in response to a "
":class:`Terminated` message, i.e. not for top-level actors."
msgstr ""

#: ../../java/untyped-actors.rst:721
msgid "HotSwap"
msgstr ""

#: ../../java/untyped-actors.rst:724
msgid "Upgrade"
msgstr ""

#: ../../java/untyped-actors.rst:726
msgid ""
"Akka supports hotswapping the Actor’s message loop (e.g. its implementation)"
" at runtime. Use the ``getContext().become`` method from within the Actor. "
"The hotswapped code is kept in a Stack which can be pushed (replacing or "
"adding at the top) and popped."
msgstr ""

#: ../../java/untyped-actors.rst:733
msgid ""
"Please note that the actor will revert to its original behavior when "
"restarted by its Supervisor."
msgstr ""

#: ../../java/untyped-actors.rst:735
msgid "To hotswap the Actor using ``getContext().become``:"
msgstr ""

#: ../../java/untyped-actors.rst:743
msgid ""
"This variant of the :meth:`become` method is useful for many different "
"things, such as to implement a Finite State Machine (FSM). It will replace "
"the current behavior (i.e. the top of the behavior stack), which means that "
"you do not use :meth:`unbecome`, instead always the next behavior is "
"explicitly installed."
msgstr ""

#: ../../java/untyped-actors.rst:748
msgid ""
"The other way of using :meth:`become` does not replace but add to the top of"
" the behavior stack. In this case care must be taken to ensure that the "
"number of “pop” operations (i.e. :meth:`unbecome`) matches the number of "
"“push” ones in the long run, otherwise this amounts to a memory leak (which "
"is why this behavior is not the default)."
msgstr ""

#: ../../java/untyped-actors.rst:759
msgid "Stash"
msgstr ""

#: ../../java/untyped-actors.rst:761
msgid ""
"The ``UntypedActorWithStash`` class enables an actor to temporarily stash "
"away messages that can not or should not be handled using the actor's "
"current behavior. Upon changing the actor's message handler, i.e., right "
"before invoking ``getContext().become()`` or ``getContext().unbecome()``, "
"all stashed messages can be \"unstashed\", thereby prepending them to the "
"actor's mailbox. This way, the stashed messages can be processed in the same"
" order as they have been received originally. An actor that extends "
"``UntypedActorWithStash`` will automatically get a deque-based mailbox."
msgstr ""

#: ../../java/untyped-actors.rst:772
msgid ""
"The abstract class ``UntypedActorWithStash`` implements the marker interface"
" ``RequiresMessageQueue<DequeBasedMessageQueueSemantics>`` which requests "
"the system to automatically choose a deque based mailbox implementation for "
"the actor. If you want more control over the mailbox, see the documentation "
"on mailboxes: :ref:`mailboxes-java`."
msgstr ""

#: ../../java/untyped-actors.rst:778
msgid "Here is an example of the ``UntypedActorWithStash`` class in action:"
msgstr ""

#: ../../java/untyped-actors.rst:783
msgid ""
"Invoking ``stash()`` adds the current message (the message that the actor "
"received last) to the actor's stash. It is typically invoked when handling "
"the default case in the actor's message handler to stash messages that "
"aren't handled by the other cases. It is illegal to stash the same message "
"twice; to do so results in an ``IllegalStateException`` being thrown. The "
"stash may also be bounded in which case invoking ``stash()`` may lead to a "
"capacity violation, which results in a ``StashOverflowException``. The "
"capacity of the stash can be configured using the ``stash-capacity`` setting"
" (an ``Int``) of the mailbox's configuration."
msgstr ""

#: ../../java/untyped-actors.rst:794
msgid ""
"Invoking ``unstashAll()`` enqueues messages from the stash to the actor's "
"mailbox until the capacity of the mailbox (if any) has been reached (note "
"that messages from the stash are prepended to the mailbox). In case a "
"bounded mailbox overflows, a ``MessageQueueAppendFailedException`` is "
"thrown. The stash is guaranteed to be empty after calling ``unstashAll()``."
msgstr ""

#: ../../java/untyped-actors.rst:801
msgid ""
"The stash is backed by a ``scala.collection.immutable.Vector``. As a result,"
" even a very large number of messages may be stashed without a major impact "
"on performance."
msgstr ""

#: ../../java/untyped-actors.rst:805
msgid ""
"Note that the stash is part of the ephemeral actor state, unlike the "
"mailbox. Therefore, it should be managed like other parts of the actor's "
"state which have the same property. The :class:`UntypedActorWithStash` "
"implementation of :meth:`preRestart` will call ``unstashAll()``, which is "
"usually the desired behavior."
msgstr ""

#: ../../java/untyped-actors.rst:813
msgid ""
"If you want to enforce that your actor can only work with an unbounded "
"stash, then you should use the ``UntypedActorWithUnboundedStash`` class "
"instead."
msgstr ""

#: ../../java/untyped-actors.rst:820
msgid "Killing an Actor"
msgstr ""

#: ../../java/untyped-actors.rst:822
msgid ""
"You can kill an actor by sending a ``Kill`` message. This will cause the "
"actor to throw a :class:`ActorKilledException`, triggering a failure. The "
"actor will suspend operation and its supervisor will be asked how to handle "
"the failure, which may mean resuming the actor, restarting it or terminating"
" it completely. See :ref:`supervision-directives` for more information."
msgstr ""

#: ../../java/untyped-actors.rst:828
msgid "Use ``Kill`` like this:"
msgstr ""

#: ../../java/untyped-actors.rst:834
msgid "Actors and exceptions"
msgstr ""

#: ../../java/untyped-actors.rst:836
msgid ""
"It can happen that while a message is being processed by an actor, that some"
" kind of exception is thrown, e.g. a database exception."
msgstr ""

#: ../../java/untyped-actors.rst:840
msgid "What happens to the Message"
msgstr ""

#: ../../java/untyped-actors.rst:842
msgid ""
"If an exception is thrown while a message is being processed (i.e. taken out"
" of its mailbox and handed over to the current behavior), then this message "
"will be lost. It is important to understand that it is not put back on the "
"mailbox. So if you want to retry processing of a message, you need to deal "
"with it yourself by catching the exception and retry your flow. Make sure "
"that you put a bound on the number of retries since you don't want a system "
"to livelock (so consuming a lot of cpu cycles without making progress). "
"Another possibility would be to have a look at the :ref:`PeekMailbox pattern"
" <mailbox-acking>`."
msgstr ""

#: ../../java/untyped-actors.rst:852
msgid "What happens to the mailbox"
msgstr ""

#: ../../java/untyped-actors.rst:854
msgid ""
"If an exception is thrown while a message is being processed, nothing "
"happens to the mailbox. If the actor is restarted, the same mailbox will be "
"there. So all messages on that mailbox will be there as well."
msgstr ""

#: ../../java/untyped-actors.rst:859
msgid "What happens to the actor"
msgstr ""

#: ../../java/untyped-actors.rst:861
msgid ""
"If code within an actor throws an exception, that actor is suspended and the"
" supervision process is started (see :ref:`supervision`). Depending on the "
"supervisor’s decision the actor is resumed (as if nothing happened), "
"restarted (wiping out its internal state and starting from scratch) or "
"terminated."
msgstr ""

#: ../../java/untyped-actors.rst:867
msgid "Initialization patterns"
msgstr ""

#: ../../java/untyped-actors.rst:869
msgid ""
"The rich lifecycle hooks of Actors provide a useful toolkit to implement "
"various initialization patterns. During the lifetime of an ``ActorRef``, an "
"actor can potentially go through several restarts, where the old instance is"
" replaced by a fresh one, invisibly to the outside observer who only sees "
"the ``ActorRef``."
msgstr ""

#: ../../java/untyped-actors.rst:873
msgid ""
"One may think about the new instances as \"incarnations\". Initialization "
"might be necessary for every incarnation of an actor, but sometimes one "
"needs initialization to happen only at the birth of the first instance when "
"the ``ActorRef`` is created. The following sections provide patterns for "
"different initialization needs."
msgstr ""

#: ../../java/untyped-actors.rst:878
msgid "Initialization via constructor"
msgstr ""

#: ../../java/untyped-actors.rst:880
msgid ""
"Using the constructor for initialization has various benefits. First of all,"
" it makes it possible to use ``val`` fields to store any state that does not"
" change during the life of the actor instance, making the implementation of "
"the actor more robust. The constructor is invoked for every incarnation of "
"the actor, therefore the internals of the actor can always assume that "
"proper initialization happened. This is also the drawback of this approach, "
"as there are cases when one would like to avoid reinitializing internals on "
"restart. For example, it is often useful to preserve child actors across "
"restarts. The following section provides a pattern for this case."
msgstr ""

#: ../../java/untyped-actors.rst:888
msgid "Initialization via preStart"
msgstr ""

#: ../../java/untyped-actors.rst:890
msgid ""
"The method ``preStart()`` of an actor is only called once directly during "
"the initialization of the first instance, that is, at creation of its "
"``ActorRef``. In the case of restarts, ``preStart()`` is called from "
"``postRestart()``, therefore if not overridden, ``preStart()`` is called on "
"every incarnation. However, overriding ``postRestart()`` one can disable "
"this behavior, and ensure that there is only one call to ``preStart()``."
msgstr ""

#: ../../java/untyped-actors.rst:895
msgid ""
"One useful usage of this pattern is to disable creation of new ``ActorRefs``"
" for children during restarts. This can be achieved by overriding "
"``preRestart()``:"
msgstr ""

#: ../../java/untyped-actors.rst:900
msgid ""
"Please note, that the child actors are *still restarted*, but no new "
"``ActorRef`` is created. One can recursively apply the same principles for "
"the children, ensuring that their ``preStart()`` method is called only at "
"the creation of their refs."
msgstr ""

#: ../../java/untyped-actors.rst:904
msgid "For more information see :ref:`supervision-restart`."
msgstr ""

#: ../../java/untyped-actors.rst:907
msgid "Initialization via message passing"
msgstr ""

#: ../../java/untyped-actors.rst:909
msgid ""
"There are cases when it is impossible to pass all the information needed for"
" actor initialization in the constructor, for example in the presence of "
"circular dependencies. In this case the actor should listen for an "
"initialization message, and use ``become()`` or a finite state-machine state"
" transition to encode the initialized and uninitialized states of the actor."
msgstr ""

#: ../../java/untyped-actors.rst:916
msgid ""
"If the actor may receive messages before it has been initialized, a useful "
"tool can be the ``Stash`` to save messages until the initialization "
"finishes, and replaying them after the actor became initialized."
msgstr ""

#: ../../java/untyped-actors.rst:921
msgid ""
"This pattern should be used with care, and applied only when none of the "
"patterns above are applicable. One of the potential issues is that messages "
"might be lost when sent to remote actors. Also, publishing an ``ActorRef`` "
"in an uninitialized state might lead to the condition that it receives a "
"user message before the initialization has been done."
msgstr ""
