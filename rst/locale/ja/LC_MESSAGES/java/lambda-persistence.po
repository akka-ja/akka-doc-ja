# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../java/lambda-persistence.rst:5
msgid "Persistence (Java with Lambda Support)"
msgstr ""

#: ../../java/lambda-persistence.rst:8
msgid ""
"Akka persistence enables stateful actors to persist their internal state so "
"that it can be recovered when an actor is started, restarted after a JVM "
"crash or by a supervisor, or migrated in a cluster. The key concept behind "
"Akka persistence is that only changes to an actor's internal state are "
"persisted but never its current state directly (except for optional "
"snapshots). These changes are only ever appended to storage, nothing is ever"
" mutated, which allows for very high transaction rates and efficient "
"replication. Stateful actors are recovered by replaying stored changes to "
"these actors from which they can rebuild internal state. This can be either "
"the full history of changes or starting from a snapshot which can "
"dramatically reduce recovery times. Akka persistence also provides point-to-"
"point communication with at-least-once message delivery semantics."
msgstr ""

#: ../../java/lambda-persistence.rst:17
msgid ""
"Akka persistence is inspired by the `eventsourced`_ library. It follows the "
"same concepts and architecture of `eventsourced`_ but significantly differs "
"on API and implementation level."
msgstr ""

#: ../../java/lambda-persistence.rst:23
msgid "Dependencies"
msgstr ""

#: ../../java/lambda-persistence.rst:25
msgid ""
"Akka persistence is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

#: ../../java/lambda-persistence.rst:33
msgid ""
"The Akka persistence extension comes with few built-in persistence plugins, "
"including in-memory heap based journal, local file-system based snapshot-"
"store and LevelDB based journal."
msgstr ""

#: ../../java/lambda-persistence.rst:36
msgid ""
"LevelDB based plugins will require the following additional dependency "
"declaration::"
msgstr ""

#: ../../java/lambda-persistence.rst:50
msgid "Architecture"
msgstr ""

#: ../../java/lambda-persistence.rst:52
msgid ""
"*AbstractPersistentActor*: Is a persistent, stateful actor. It is able to "
"persist events to a journal and can react to them in a thread-safe manner. "
"It can be used to implement both *command* as well as *event sourced* "
"actors. When a persistent actor is started or restarted, journaled messages "
"are replayed to that actor so that it can recover internal state from these "
"messages."
msgstr ""

#: ../../java/lambda-persistence.rst:57
msgid ""
"*AbstractPersistentView*: A view is a persistent, stateful actor that "
"receives journaled messages that have been written by another persistent "
"actor. A view itself does not journal new messages, instead, it updates "
"internal state only from a persistent actor's replicated message stream."
msgstr ""

#: ../../java/lambda-persistence.rst:61
msgid ""
"*AbstractPersistentActorAtLeastOnceDelivery*: To send messages with at-"
"least-once delivery semantics to destinations, also in case of sender and "
"receiver JVM crashes."
msgstr ""

#: ../../java/lambda-persistence.rst:64
msgid ""
"*AsyncWriteJournal*: A journal stores the sequence of messages sent to a "
"persistent actor. An application can control which messages are journaled "
"and which are received by the persistent actor without being journaled. The "
"storage backend of a journal is pluggable. The persistence extension comes "
"with a \"leveldb\" journal plugin which writes to the local filesystem. "
"Replicated journals are available as `Community plugins`_."
msgstr ""

#: ../../java/lambda-persistence.rst:69
msgid ""
"*Snapshot store*: A snapshot store persists snapshots of a persistent "
"actor's or a view's internal state. Snapshots are used for optimizing "
"recovery times. The storage backend of a snapshot store is pluggable. The "
"persistence extension comes with a \"local\" snapshot storage plugin which "
"writes to the local filesystem. Replicated snapshot stores are available as "
"`Community plugins`_."
msgstr ""

#: ../../java/lambda-persistence.rst:74
msgid ""
"*Event sourcing*. Based on the building blocks described above, Akka "
"persistence provides abstractions for the development of event sourced "
"applications (see section :ref:`event-sourcing-java-lambda`)"
msgstr ""

#: ../../java/lambda-persistence.rst:82
msgid "Event sourcing"
msgstr ""

#: ../../java/lambda-persistence.rst:84
msgid ""
"The basic idea behind `Event Sourcing`_ is quite simple. A persistent actor "
"receives a (non-persistent) command which is first validated if it can be "
"applied to the current state. Here validation can mean anything, from simple"
" inspection of a command message's fields up to a conversation with several "
"external services, for example. If validation succeeds, events are generated"
" from the command, representing the effect of the command. These events are "
"then persisted and, after successful persistence, used to change the actor's"
" state. When the persistent actor needs to be recovered, only the persisted "
"events are replayed of which we know that they can be successfully applied. "
"In other words, events cannot fail when being replayed to a persistent "
"actor, in contrast to commands. Event sourced actors may of course also "
"process commands that do not change application state such as query commands"
" for example."
msgstr ""

#: ../../java/lambda-persistence.rst:95
msgid ""
"Akka persistence supports event sourcing with the "
"``AbstractPersistentActor`` abstract class. An actor that extends this class"
" uses the ``persist`` method to persist and handle events. The behavior of "
"an ``AbstractPersistentActor`` is defined by implementing ``receiveRecover``"
" and ``receiveCommand``. This is demonstrated in the following example."
msgstr ""

#: ../../java/lambda-persistence.rst:101
msgid ""
"The example defines two data types, ``Cmd`` and ``Evt`` to represent "
"commands and events, respectively. The ``state`` of the "
"``ExamplePersistentActor`` is a list of persisted event data contained in "
"``ExampleState``."
msgstr ""

#: ../../java/lambda-persistence.rst:104
msgid ""
"The persistent actor's ``receiveRecover`` method defines how ``state`` is "
"updated during recovery by handling ``Evt`` and ``SnapshotOffer`` messages. "
"The persistent actor's ``receiveCommand`` method is a command handler. In "
"this example, a command is handled by generating two events which are then "
"persisted and handled. Events are persisted by calling ``persist`` with an "
"event (or a sequence of events) as first argument and an event handler as "
"second argument."
msgstr ""

#: ../../java/lambda-persistence.rst:109
msgid ""
"The ``persist`` method persists events asynchronously and the event handler "
"is executed for successfully persisted events. Successfully persisted events"
" are internally sent back to the persistent actor as individual messages "
"that trigger event handler executions. An event handler may close over "
"persistent actor state and mutate it. The sender of a persisted event is the"
" sender of the corresponding command. This allows event handlers to reply to"
" the sender of a command (not shown)."
msgstr ""

#: ../../java/lambda-persistence.rst:115
msgid ""
"The main responsibility of an event handler is changing persistent actor "
"state using event data and notifying others about successful state changes "
"by publishing events."
msgstr ""

#: ../../java/lambda-persistence.rst:118
msgid ""
"When persisting events with ``persist`` it is guaranteed that the persistent"
" actor will not receive further commands between the ``persist`` call and "
"the execution(s) of the associated event handler. This also holds for "
"multiple ``persist`` calls in context of a single command. Incoming messages"
" are :ref:`stashed <internal-stash-lambda>` until the ``persist`` is "
"completed."
msgstr ""

#: ../../java/lambda-persistence.rst:123
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped. If persistence of an event is rejected before it is stored, e.g. "
"due to serialization error, ``onPersistRejected`` will be invoked (logging a"
" warning by default), and the actor continues with next message."
msgstr ""

#: ../../java/lambda-persistence.rst:128
msgid ""
"The easiest way to run this example yourself is to download `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_ and open the "
"tutorial named `Akka Persistence Samples in Java with Lambdas "
"<http://www.lightbend.com/activator/template/akka-sample-persistence-java-"
"lambda>`_. It contains instructions on how to run the "
"``PersistentActorExample``."
msgstr ""

#: ../../java/lambda-persistence.rst:134
msgid ""
"It's also possible to switch between different command handlers during "
"normal processing and recovery with ``context().become()`` and "
"``context().unbecome()``. To get the actor into the same state after "
"recovery you need to take special care to perform the same state transitions"
" with ``become`` and ``unbecome`` in the ``receiveRecover`` method as you "
"would have done in the command handler. Note that when using ``become`` from"
" ``receiveRecover`` it will still only use the ``receiveRecover`` behavior "
"when replaying the events. When replay is completed it will use the new "
"behavior."
msgstr ""

#: ../../java/lambda-persistence.rst:142 ../../java/lambda-persistence.rst:519
msgid "Identifiers"
msgstr ""

#: ../../java/lambda-persistence.rst:144
msgid ""
"A persistent actor must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``persistenceId`` method."
msgstr ""

#: ../../java/lambda-persistence.rst:152 ../../java/lambda-persistence.rst:510
msgid "Recovery"
msgstr ""

#: ../../java/lambda-persistence.rst:154
msgid ""
"By default, a persistent actor is automatically recovered on start and on "
"restart by replaying journaled messages. New messages sent to a persistent "
"actor during recovery do not interfere with replayed messages. New messages "
"will only be received by a persistent actor after recovery completes."
msgstr ""

#: ../../java/lambda-persistence.rst:159
msgid ""
"Accessing the ``sender()`` for replayed messages will always result in a "
"``deadLetters`` reference, as the original sender is presumed to be long "
"gone. If you indeed have to notify an actor during recovery in the future, "
"store its ``ActorPath`` explicitly in your persisted events."
msgstr ""

#: ../../java/lambda-persistence.rst:164
msgid "Recovery customization"
msgstr ""

#: ../../java/lambda-persistence.rst:166
msgid ""
"Applications may also customise how recovery is performed by returning a "
"customised ``Recovery`` object in the ``recovery`` method of a "
"``AbstractPersistentActor``, for example setting an upper bound to the "
"replay which allows the actor to be replayed to a certain point \"in the "
"past\" instead to its most up to date state:"
msgstr ""

#: ../../java/lambda-persistence.rst:172
msgid ""
"Recovery can be disabled by returning ``Recovery.none`` in the ``recovery`` "
"method of a ``PersistentActor``:"
msgstr ""

#: ../../java/lambda-persistence.rst:177
msgid "Recovery status"
msgstr ""

#: ../../java/lambda-persistence.rst:179
msgid "A persistent actor can query its own recovery status via the methods"
msgstr ""

#: ../../java/lambda-persistence.rst:183
msgid ""
"Sometimes there is a need for performing additional initialization when the "
"recovery has completed before processing any other message sent to the "
"persistent actor. The persistent actor will receive a special "
":class:`RecoveryCompleted` message right after recovery and before any other"
" received messages."
msgstr ""

#: ../../java/lambda-persistence.rst:190
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal, ``onRecoveryFailure`` is called (logging the error by default), and"
" the actor will be stopped."
msgstr ""

#: ../../java/lambda-persistence.rst:196
msgid "Internal stash"
msgstr ""

#: ../../java/lambda-persistence.rst:198
msgid ""
"The persistent actor has a private :ref:`stash <stash-lambda>` for "
"internally caching incoming messages during :ref:`recovery <recovery-java-"
"lambda>` or the ``persist\\persistAll`` method persisting events. You can "
"still use/inherit from the ``Stash`` interface. The internal stash "
"cooperates with the normal stash by hooking into ``unstashAll`` method and "
"making sure messages are unstashed properly to the internal stash to "
"maintain ordering guarantees."
msgstr ""

#: ../../java/lambda-persistence.rst:204
msgid ""
"You should be careful to not send more messages to a persistent actor than "
"it can keep up with, otherwise the number of stashed messages will grow "
"without bounds. It can be wise to protect against ``OutOfMemoryError`` by "
"defining a maximum stash capacity in the mailbox configuration::"
msgstr ""

#: ../../java/lambda-persistence.rst:210
msgid ""
"Note that the stash capacity is per actor. If you have many persistent "
"actors, e.g. when using cluster sharding, you may need to define a small "
"stash capacity to ensure that the total number of stashed messages in the "
"system don't consume too much memory. Additionally, The persistent actor "
"defines three strategies to handle failure when the internal stash capacity "
"is exceeded. The default overflow strategy is the "
"``ThrowOverflowExceptionStrategy``, which discards the current received "
"message and throws a ``StashOverflowException``, causing actor restart if "
"default supervision strategy is used. you can override the "
"``internalStashOverflowStrategy`` method to return "
"``DiscardToDeadLetterStrategy`` or ``ReplyToStrategy`` for any "
"\"individual\" persistent actor, or define the \"default\" for all "
"persistent actors by providing FQCN, which must be a subclass of "
"``StashOverflowStrategyConfigurator``, in the persistence configuration::"
msgstr ""

#: ../../java/lambda-persistence.rst:223
msgid ""
"The ``DiscardToDeadLetterStrategy`` strategy also has a pre-packaged "
"companion configurator ``akka.persistence.DiscardConfigurator``."
msgstr ""

#: ../../java/lambda-persistence.rst:226
msgid ""
"You can also query default strategy via the Akka persistence extension "
"singleton::"
msgstr ""

#: ../../java/lambda-persistence.rst:231
msgid ""
"The bounded mailbox should be avoided in the persistent actor, by which the "
"messages come from storage backends may be discarded. You can use bounded "
"stash instead of it."
msgstr ""

#: ../../java/lambda-persistence.rst:236
msgid "Relaxed local consistency requirements and high throughput use-cases"
msgstr ""

#: ../../java/lambda-persistence.rst:238
msgid ""
"If faced with relaxed local consistency requirements and high throughput "
"demands sometimes ``PersistentActor`` and its ``persist`` may not be enough "
"in terms of consuming incoming Commands at a high rate, because it has to "
"wait until all Events related to a given Command are processed in order to "
"start processing the next Command. While this abstraction is very useful for"
" most cases, sometimes you may be faced with relaxed requirements about "
"consistency – for example you may want to process commands as fast as you "
"can, assuming that the Event will eventually be persisted and handled "
"properly in the background, retroactively reacting to persistence failures "
"if needed."
msgstr ""

#: ../../java/lambda-persistence.rst:245
msgid ""
"The ``persistAsync`` method provides a tool for implementing high-throughput"
" persistent actors. It will *not* stash incoming Commands while the Journal "
"is still working on persisting and/or user code is executing event "
"callbacks."
msgstr ""

#: ../../java/lambda-persistence.rst:248
msgid ""
"In the below example, the event callbacks may be called \"at any time\", "
"even after the next Command has been processed. The ordering between events "
"is still guaranteed (\"evt-b-1\" will be sent after \"evt-a-2\", which will "
"be sent after \"evt-a-1\" etc.)."
msgstr ""

#: ../../java/lambda-persistence.rst:254
msgid ""
"In order to implement the pattern known as \"*command sourcing*\" simply "
"call ``persistAsync`` on all incoming messages right away and handle them in"
" the callback."
msgstr ""

#: ../../java/lambda-persistence.rst:258
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) in "
"between the call to ``persistAsync`` and the journal has confirmed the "
"write."
msgstr ""

#: ../../java/lambda-persistence.rst:264
msgid "Deferring actions until preceding persist handlers have executed"
msgstr ""

#: ../../java/lambda-persistence.rst:266
msgid ""
"Sometimes when working with ``persistAsync`` you may find that it would be "
"nice to define some actions in terms of ''happens-after the previous "
"``persistAsync`` handlers have been invoked''. ``PersistentActor`` provides "
"an utility method called ``deferAsync``, which works similarly to "
"``persistAsync`` yet does not persist the passed in event. It is recommended"
" to use it for *read* operations, and actions which do not have "
"corresponding events in your domain model."
msgstr ""

#: ../../java/lambda-persistence.rst:271
msgid ""
"Using this method is very similar to the persist family of methods, yet it "
"does **not** persist the passed in event. It will be kept in memory and used"
" when invoking the handler."
msgstr ""

#: ../../java/lambda-persistence.rst:276
msgid ""
"Notice that the ``sender()`` is **safe** to access in the handler callback, "
"and will be pointing to the original sender of the command for which this "
"``deferAsync`` handler was called."
msgstr ""

#: ../../java/lambda-persistence.rst:282
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) in "
"between the call to ``deferAsync`` and the journal has processed and "
"confirmed all preceding writes."
msgstr ""

#: ../../java/lambda-persistence.rst:288
msgid "Nested persist calls"
msgstr ""

#: ../../java/lambda-persistence.rst:289
msgid ""
"It is possible to call ``persist`` and ``persistAsync`` inside their "
"respective callback blocks and they will properly retain both the thread "
"safety (including the right value of ``sender()``) as well as stashing "
"guarantees."
msgstr ""

#: ../../java/lambda-persistence.rst:292
msgid ""
"In general it is encouraged to create command handlers which do not need to "
"resort to nested event persisting, however there are situations where it may"
" be useful. It is important to understand the ordering of callback execution"
" in those situations, as well as their implication on the stashing behaviour"
" (that ``persist()`` enforces). In the following example two persist calls "
"are issued, and each of them issues another persist inside its callback:"
msgstr ""

#: ../../java/lambda-persistence.rst:299
msgid ""
"When sending two commands to this ``PersistentActor``, the persist handlers "
"will be executed in the following order:"
msgstr ""

#: ../../java/lambda-persistence.rst:303
msgid ""
"First the \"outer layer\" of persist calls is issued and their callbacks are"
" applied. After these have successfully completed, the inner callbacks will "
"be invoked (once the events they are persisting have been confirmed to be "
"persisted by the journal). Only after all these handlers have been "
"successfully invoked will the next command be delivered to the persistent "
"Actor. In other words, the stashing of incoming commands that is guaranteed "
"by initially calling ``persist()`` on the outer layer is extended until all "
"nested ``persist`` callbacks have been handled."
msgstr ""

#: ../../java/lambda-persistence.rst:309
msgid ""
"It is also possible to nest ``persistAsync`` calls, using the same pattern:"
msgstr ""

#: ../../java/lambda-persistence.rst:313
msgid ""
"In this case no stashing is happening, yet the events are still persisted "
"and callbacks executed in the expected order:"
msgstr ""

#: ../../java/lambda-persistence.rst:317
msgid ""
"While it is possible to nest mixed ``persist`` and ``persistAsync`` with "
"keeping their respective semantics it is not a recommended practice, as it "
"may lead to overly complex nesting."
msgstr ""

#: ../../java/lambda-persistence.rst:323
msgid "Failures"
msgstr ""

#: ../../java/lambda-persistence.rst:325
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped."
msgstr ""

#: ../../java/lambda-persistence.rst:328
msgid ""
"The reason that it cannot resume when persist fails is that it is unknown if"
" the even was actually persisted or not, and therefore it is in an "
"inconsistent state. Restarting on persistent failures will most likely fail "
"anyway, since the journal is probably unavailable. It is better to stop the "
"actor and after a back-off timeout start it again. The "
"``akka.pattern.BackoffSupervisor`` actor is provided to support such "
"restarts."
msgstr ""

#: ../../java/lambda-persistence.rst:336
msgid ""
"If persistence of an event is rejected before it is stored, e.g. due to "
"serialization error, ``onPersistRejected`` will be invoked (logging a "
"warning by default), and the actor continues with next message."
msgstr ""

#: ../../java/lambda-persistence.rst:340
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal when the actor is started, ``onRecoveryFailure`` is called (logging "
"the error by default), and the actor will be stopped."
msgstr ""

#: ../../java/lambda-persistence.rst:344
msgid "Atomic writes"
msgstr ""

#: ../../java/lambda-persistence.rst:346
msgid ""
"Each event is of course stored atomically, but it is also possible to store "
"several events atomically by using the ``persistAll`` or ``persistAllAsync``"
" method. That means that all events passed to that method are stored or none"
" of them are stored if there is an error."
msgstr ""

#: ../../java/lambda-persistence.rst:350
msgid ""
"The recovery of a persistent actor will therefore never be done partially "
"with only a subset of events persisted by `persistAll`."
msgstr ""

#: ../../java/lambda-persistence.rst:353
msgid ""
"Some journals may not support atomic writes of several events and they will "
"then reject the ``persistAll`` command, i.e. ``onPersistRejected`` is called"
" with an exception (typically ``UnsupportedOperationException``)."
msgstr ""

#: ../../java/lambda-persistence.rst:357
msgid "Batch writes"
msgstr ""

#: ../../java/lambda-persistence.rst:359
msgid ""
"In order to optimize throughput when using ``persistAsync``, a persistent "
"actor internally batches events to be stored under high load before writing "
"them to the journal (as a single batch). The batch size is dynamically "
"determined by how many events are emitted during the time of a journal "
"round-trip: after sending a batch to the journal no further batch can be "
"sent before confirmation has been received that the previous batch has been "
"written. Batch writes are never timer-based which keeps latencies at a "
"minimum."
msgstr ""

#: ../../java/lambda-persistence.rst:368
msgid "Message deletion"
msgstr ""

#: ../../java/lambda-persistence.rst:370
msgid ""
"It is possible to delete all messages (journaled by a single persistent "
"actor) up to a specified sequence number; Persistent actors may call the "
"``deleteMessages`` method to this end."
msgstr ""

#: ../../java/lambda-persistence.rst:373
msgid ""
"Deleting messages in event sourcing based applications is typically either "
"not used at all or used in conjunction with :ref:`snapshotting <snapshots>`,"
" i.e. after a snapshot has been successfully stored, a "
"``deleteMessages(toSequenceNr)`` up until the sequence number of the data "
"held by that snapshot can be issued to safely delete the previous events "
"while still having access to the accumulated state during replays - by "
"loading the snapshot."
msgstr ""

#: ../../java/lambda-persistence.rst:378
msgid ""
"The result of the ``deleteMessages`` request is signaled to the persistent "
"actor with a ``DeleteMessagesSuccess`` message if the delete was successful "
"or a ``DeleteMessagesFailure`` message if it failed."
msgstr ""

#: ../../java/lambda-persistence.rst:382
msgid "Persistence status handling"
msgstr ""

#: ../../java/lambda-persistence.rst:383
msgid ""
"Persisting, deleting and replaying messages can either succeed or fail."
msgstr ""

#: ../../java/lambda-persistence.rst:386 ../../java/lambda-persistence.rst:583
msgid "**Method**"
msgstr ""

#: ../../java/lambda-persistence.rst:386 ../../java/lambda-persistence.rst:583
msgid "**Success**"
msgstr ""

#: ../../java/lambda-persistence.rst:386
msgid "**Failure / Rejection**"
msgstr ""

#: ../../java/lambda-persistence.rst:386
msgid "**After failure handler invoked**"
msgstr ""

#: ../../java/lambda-persistence.rst:388
msgid "``persist`` / ``persistAsync``"
msgstr ""

#: ../../java/lambda-persistence.rst:388
msgid "persist handler invoked"
msgstr ""

#: ../../java/lambda-persistence.rst:388
msgid "``onPersistFailure``"
msgstr ""

#: ../../java/lambda-persistence.rst:388 ../../java/lambda-persistence.rst:392
msgid "Actor is stopped."
msgstr ""

#: ../../java/lambda-persistence.rst:390
msgid "``onPersistRejected``"
msgstr ""

#: ../../java/lambda-persistence.rst:390 ../../java/lambda-persistence.rst:394
msgid "No automatic actions."
msgstr ""

#: ../../java/lambda-persistence.rst:392
msgid "``recovery``"
msgstr ""

#: ../../java/lambda-persistence.rst:392
msgid "``RecoverySuccess``"
msgstr ""

#: ../../java/lambda-persistence.rst:392
msgid "``onRecoveryFailure``"
msgstr ""

#: ../../java/lambda-persistence.rst:394
msgid "``deleteMessages``"
msgstr ""

#: ../../java/lambda-persistence.rst:394
msgid "``DeleteMessagesSuccess``"
msgstr ""

#: ../../java/lambda-persistence.rst:394
msgid "``DeleteMessagesFailure``"
msgstr ""

#: ../../java/lambda-persistence.rst:397
msgid ""
"The most important operations (``persist`` and ``recovery``) have failure "
"handlers modelled as explicit callbacks which the user can override in the "
"``PersistentActor``. The default implementations of these handlers emit a "
"log message (``error`` for persist/recovery failures, and ``warning`` for "
"others), logging the failure cause and information about which message "
"caused the failure."
msgstr ""

#: ../../java/lambda-persistence.rst:402
msgid ""
"For critical failures, such as recovery or persisting events failing, the "
"persistent actor will be stopped after the failure handler is invoked. This "
"is because if the underlying journal implementation is signalling "
"persistence failures it is most likely either failing completely or "
"overloaded and restarting right-away and trying to persist the event again "
"will most likely not help the journal recover – as it would likely cause a "
"`Thundering herd problem`_, as many persistent actors would restart and try "
"to persist their events again. Instead, using a ``BackoffSupervisor`` (as "
"described in :ref:`failures-lambda`) which implements an exponential-backoff"
" strategy which allows for more breathing room for the journal to recover "
"between restarts of the persistent actor."
msgstr ""

#: ../../java/lambda-persistence.rst:411
msgid ""
"Journal implementations may choose to implement a retry mechanism, e.g. such"
" that only after a write fails N number of times a persistence failure is "
"signalled back to the user. In other words, once a journal returns a "
"failure, it is considered *fatal* by Akka Persistence, and the persistent "
"actor which caused the failure will be stopped."
msgstr ""

#: ../../java/lambda-persistence.rst:415
msgid ""
"Check the documentation of the journal implementation you are using for "
"details if/how it is using this technique."
msgstr ""

#: ../../java/lambda-persistence.rst:422
msgid "Safely shutting down persistent actors"
msgstr ""

#: ../../java/lambda-persistence.rst:424
msgid ""
"Special care should be given when when shutting down persistent actors from "
"the outside. With normal Actors it is often acceptable to use the special "
":ref:`PoisonPill <poison-pill-java>` message to signal to an Actor that it "
"should stop itself once it receives this message – in fact this message is "
"handled automatically by Akka, leaving the target actor no way to refuse "
"stopping itself when given a poison pill."
msgstr ""

#: ../../java/lambda-persistence.rst:429
msgid ""
"This can be dangerous when used with :class:`PersistentActor` due to the "
"fact that incoming commands are *stashed* while the persistent actor is "
"awaiting confirmation from the Journal that events have been written when "
"``persist()`` was used. Since the incoming commands will be drained from the"
" Actor's mailbox and put into its internal stash while awaiting the "
"confirmation (thus, before calling the persist handlers) the Actor **may "
"receive and (auto)handle the PoisonPill before it processes the other "
"messages which have been put into its stash**, causing a pre-mature shutdown"
" of the Actor."
msgstr ""

#: ../../java/lambda-persistence.rst:436
msgid ""
"Consider using explicit shut-down messages instead of :class:`PoisonPill` "
"when working with persistent actors."
msgstr ""

#: ../../java/lambda-persistence.rst:438
msgid ""
"The example below highlights how messages arrive in the Actor's mailbox and "
"how they interact with its internal stashing mechanism when ``persist()`` is"
" used. Notice the early stop behaviour that occurs when ``PoisonPill`` is "
"used:"
msgstr ""

#: ../../java/lambda-persistence.rst:448
msgid "Persistent Views"
msgstr ""

#: ../../java/lambda-persistence.rst:452
msgid ""
"``AbstractPersistentView`` is deprecated. Use :ref:`persistence-query-java` "
"instead. The corresponding query type is ``EventsByPersistenceId``. There "
"are several alternatives for connecting the ``Source`` to an actor "
"corresponding to a previous ``UntypedPersistentView`` actor:"
msgstr ""

#: ../../java/lambda-persistence.rst:456
msgid ""
"`Sink.actorRef`_ is simple, but has the disadvantage that there is no back-"
"pressure signal from the destination actor, i.e. if the actor is not "
"consuming the messages fast enough the mailbox of the actor will grow"
msgstr ""

#: ../../java/lambda-persistence.rst:458
msgid ""
"`mapAsync`_ combined with :ref:`actors-ask-lambda` is almost as simple with "
"the advantage of back-pressure being propagated all the way"
msgstr ""

#: ../../java/lambda-persistence.rst:460
msgid "`ActorSubscriber`_ in case you need more fine grained control"
msgstr ""

#: ../../java/lambda-persistence.rst:462
msgid ""
"The consuming actor may be a plain ``AbstractActor`` or an "
"``AbstractPersistentActor`` if it needs to store its own state (e.g. "
"fromSequenceNr offset)."
msgstr ""

#: ../../java/lambda-persistence.rst:469
msgid ""
"Persistent views can be implemented by extending the ``AbstractView`` "
"abstract class, implement the ``persistenceId`` method and setting the "
"“initial behavior” in the constructor by calling the :meth:`receive` method."
msgstr ""

#: ../../java/lambda-persistence.rst:474
msgid ""
"The ``persistenceId`` identifies the persistent actor from which the view "
"receives journaled messages. It is not necessary that the referenced "
"persistent actor is actually running. Views read messages from a persistent "
"actor's journal directly. When a persistent actor is started later and "
"begins to write new messages, by default the corresponding view is updated "
"automatically."
msgstr ""

#: ../../java/lambda-persistence.rst:478
msgid ""
"It is possible to determine if a message was sent from the Journal or from "
"another actor in user-land by calling the ``isPersistent`` method. Having "
"that said, very often you don't need this information at all and can simply "
"apply the same logic to both cases (skip the ``if isPersistent`` check)."
msgstr ""

#: ../../java/lambda-persistence.rst:483
msgid "Updates"
msgstr ""

#: ../../java/lambda-persistence.rst:485
msgid ""
"The default update interval of all persistent views of an actor system is "
"configurable:"
msgstr ""

#: ../../java/lambda-persistence.rst:489
msgid ""
"``AbstractPersistentView`` implementation classes may also override the "
"``autoUpdateInterval`` method to return a custom update interval for a "
"specific view class or view instance. Applications may also trigger "
"additional updates at any time by sending a view an ``Update`` message."
msgstr ""

#: ../../java/lambda-persistence.rst:495
msgid ""
"If the ``await`` parameter is set to ``true``, messages that follow the "
"``Update`` request are processed when the incremental message replay, "
"triggered by that update request, completed. If set to ``false`` (default), "
"messages following the update request may interleave with the replayed "
"message stream. Automated updates always run with ``await = false``."
msgstr ""

#: ../../java/lambda-persistence.rst:500
msgid ""
"Automated updates of all persistent views of an actor system can be turned "
"off by configuration:"
msgstr ""

#: ../../java/lambda-persistence.rst:504
msgid ""
"Implementation classes may override the configured default value by "
"overriding the ``autoUpdate`` method. To limit the number of replayed "
"messages per update request, applications can configure a custom "
"``akka.persistence.view.auto-update-replay-max`` value or override the "
"``autoUpdateReplayMax`` method. The number of replayed messages for manual "
"updates can be limited with the ``replayMax`` parameter of the ``Update`` "
"message."
msgstr ""

#: ../../java/lambda-persistence.rst:512
msgid ""
"Initial recovery of persistent views works the very same way as for "
"persistent actors (i.e. by sending a ``Recover`` message to self). The "
"maximum number of replayed messages during initial recovery is determined by"
" ``autoUpdateReplayMax``. Further possibilities to customize initial "
"recovery are explained in section :ref:`recovery-java-lambda`."
msgstr ""

#: ../../java/lambda-persistence.rst:521
msgid ""
"A persistent view must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``viewId`` method."
msgstr ""

#: ../../java/lambda-persistence.rst:524
msgid ""
"The ``viewId`` must differ from the referenced ``persistenceId``, unless "
":ref:`snapshots-java-lambda` of a view and its persistent actor should be "
"shared (which is what applications usually do not want)."
msgstr ""

#: ../../java/lambda-persistence.rst:530
msgid "Snapshots"
msgstr ""

#: ../../java/lambda-persistence.rst:532
msgid ""
"Snapshots can dramatically reduce recovery times of persistent actors and "
"views. The following discusses snapshots in context of persistent actors but"
" this is also applicable to persistent views."
msgstr ""

#: ../../java/lambda-persistence.rst:535
msgid ""
"Persistent actor can save snapshots of internal state by calling the  "
"``saveSnapshot`` method. If saving of a snapshot succeeds, the persistent "
"actor receives a ``SaveSnapshotSuccess`` message, otherwise a "
"``SaveSnapshotFailure`` message"
msgstr ""

#: ../../java/lambda-persistence.rst:540
msgid ""
"During recovery, the persistent actor is offered a previously saved snapshot"
" via a ``SnapshotOffer`` message from which it can initialize internal "
"state."
msgstr ""

#: ../../java/lambda-persistence.rst:545
msgid ""
"The replayed messages that follow the ``SnapshotOffer`` message, if any, are"
" younger than the offered snapshot. They finally recover the persistent "
"actor to its current (i.e. latest) state."
msgstr ""

#: ../../java/lambda-persistence.rst:548
msgid ""
"In general, a persistent actor is only offered a snapshot if that persistent"
" actor has previously saved one or more snapshots and at least one of these "
"snapshots matches the ``SnapshotSelectionCriteria`` that can be specified "
"for recovery."
msgstr ""

#: ../../java/lambda-persistence.rst:553
msgid ""
"If not specified, they default to ``SnapshotSelectionCriteria.latest()`` "
"which selects the latest (= youngest) snapshot. To disable snapshot-based "
"recovery, applications should use ``SnapshotSelectionCriteria.none()``. A "
"recovery where no saved snapshot matches the specified "
"``SnapshotSelectionCriteria`` will replay all journaled messages."
msgstr ""

#: ../../java/lambda-persistence.rst:558
msgid ""
"In order to use snapshots, a default snapshot-store (``akka.persistence"
".snapshot-store.plugin``) must be configured, or the persistent actor can "
"pick a snapshot store explicitly by overriding ``String "
"snapshotPluginId()``."
msgstr ""

#: ../../java/lambda-persistence.rst:561
msgid ""
"Since it is acceptable for some applications to not use any snapshotting, it"
" is legal to not configure a snapshot store. However Akka will log a warning"
" message when this situation is detected and then continue to operate until "
"an actor tries to store a snapshot, at which point the operation will fail "
"(by replying with an ``SaveSnapshotFailure`` for example)."
msgstr ""

#: ../../java/lambda-persistence.rst:565
msgid ""
"Note that :ref:`cluster_sharding_java` is using snapshots, so if you use "
"Cluster Sharding you need to define a snapshot store plugin."
msgstr ""

#: ../../java/lambda-persistence.rst:568
msgid "Snapshot deletion"
msgstr ""

#: ../../java/lambda-persistence.rst:570
msgid ""
"A persistent actor can delete individual snapshots by calling the "
"``deleteSnapshot`` method with the sequence number of when the snapshot was "
"taken."
msgstr ""

#: ../../java/lambda-persistence.rst:573
msgid ""
"To bulk-delete a range of snapshots matching ``SnapshotSelectionCriteria``, "
"persistent actors should use the ``deleteSnapshots`` method."
msgstr ""

#: ../../java/lambda-persistence.rst:577
msgid "Snapshot status handling"
msgstr ""

#: ../../java/lambda-persistence.rst:579
msgid ""
"Saving or deleting snapshots can either succeed or fail – this information "
"is reported back to the persistent actor via status messages as illustrated "
"in the following table."
msgstr ""

#: ../../java/lambda-persistence.rst:583
msgid "**Failure message**"
msgstr ""

#: ../../java/lambda-persistence.rst:585
msgid "``saveSnapshot(Any)``"
msgstr ""

#: ../../java/lambda-persistence.rst:585
msgid "``SaveSnapshotSuccess``"
msgstr ""

#: ../../java/lambda-persistence.rst:585
msgid "``SaveSnapshotFailure``"
msgstr ""

#: ../../java/lambda-persistence.rst:586
msgid "``deleteSnapshot(Long)``"
msgstr ""

#: ../../java/lambda-persistence.rst:586
msgid "``DeleteSnapshotSuccess``"
msgstr ""

#: ../../java/lambda-persistence.rst:586
msgid "``DeleteSnapshotFailure``"
msgstr ""

#: ../../java/lambda-persistence.rst:587
msgid "``deleteSnapshots(SnapshotSelectionCriteria)``"
msgstr ""

#: ../../java/lambda-persistence.rst:587
msgid "``DeleteSnapshotsSuccess``"
msgstr ""

#: ../../java/lambda-persistence.rst:587
msgid "``DeleteSnapshotsFailure``"
msgstr ""

#: ../../java/lambda-persistence.rst:593
msgid "At-Least-Once Delivery"
msgstr ""

#: ../../java/lambda-persistence.rst:595
msgid ""
"To send messages with at-least-once delivery semantics to destinations you "
"can extend the ``AbstractPersistentActorWithAtLeastOnceDelivery`` class "
"instead of ``AbstractPersistentActor`` on the sending side.  It takes care "
"of re-sending messages when they have not been confirmed within a "
"configurable timeout."
msgstr ""

#: ../../java/lambda-persistence.rst:599
msgid ""
"The state of the sending actor, including which messages have been sent that"
" have not been confirmed by the recepient must be persistent so that it can "
"survive a crash of the sending actor or JVM. The "
"``AbstractPersistentActorWithAtLeastOnceDelivery`` class does not persist "
"anything by itself. It is your responsibility to persist the intent that a "
"message is sent and that a confirmation has been received."
msgstr ""

#: ../../java/lambda-persistence.rst:607
msgid ""
"At-least-once delivery implies that original message send order is not "
"always preserved, and the destination may receive duplicate messages. "
"Semantics do not match those of a normal :class:`ActorRef` send operation:"
msgstr ""

#: ../../java/lambda-persistence.rst:610
msgid "it is not at-most-once delivery"
msgstr ""

#: ../../java/lambda-persistence.rst:612
msgid ""
"message order for the same sender–receiver pair is not preserved due to "
"possible resends"
msgstr ""

#: ../../java/lambda-persistence.rst:615
msgid ""
"after a crash and restart of the destination messages are still delivered to"
" the new actor incarnation"
msgstr ""

#: ../../java/lambda-persistence.rst:618
msgid ""
"These semantics are similar to what an :class:`ActorPath` represents (see "
":ref:`actor-lifecycle-scala`), therefore you need to supply a path and not a"
" reference when delivering messages. The messages are sent to the path with "
"an actor selection."
msgstr ""

#: ../../java/lambda-persistence.rst:623
msgid ""
"Use the ``deliver`` method to send a message to a destination. Call the "
"``confirmDelivery`` method when the destination has replied with a "
"confirmation message."
msgstr ""

#: ../../java/lambda-persistence.rst:627
msgid "Relationship between deliver and confirmDelivery"
msgstr ""

#: ../../java/lambda-persistence.rst:629
msgid ""
"To send messages to the destination path, use the ``deliver`` method after "
"you have persisted the intent to send the message."
msgstr ""

#: ../../java/lambda-persistence.rst:632
msgid ""
"The destination actor must send back a confirmation message. When the "
"sending actor receives this confirmation message you should persist the fact"
" that the message was delivered successfully and then call the "
"``confirmDelivery`` method."
msgstr ""

#: ../../java/lambda-persistence.rst:636
msgid ""
"If the persistent actor is not currently recovering, the ``deliver`` method "
"will send the message to the destination actor. When recovering, messages "
"will be buffered until they have been confirmed using ``confirmDelivery``. "
"Once recovery has completed, if there are outstanding messages that have not"
" been confirmed (during the message replay), the persistent actor will "
"resend these before sending any other messages."
msgstr ""

#: ../../java/lambda-persistence.rst:641
msgid ""
"Deliver requires a ``deliveryIdToMessage`` function to pass the provided "
"``deliveryId`` into the message so that the correlation between ``deliver`` "
"and ``confirmDelivery`` is possible. The ``deliveryId`` must do the round "
"trip. Upon receipt of the message, the destination actor will send the "
"same``deliveryId`` wrapped in a confirmation message back to the sender. The"
" sender will then use it to call ``confirmDelivery`` method to complete the "
"delivery routine."
msgstr ""

#: ../../java/lambda-persistence.rst:648
msgid ""
"The ``deliveryId`` generated by the persistence module is a strictly "
"monotonically increasing sequence number without gaps. The same sequence is "
"used for all destinations of the actor, i.e. when sending to multiple "
"destinations the destinations will see gaps in the sequence. It is not "
"possible to use custom ``deliveryId``. However, you can send a custom "
"correlation identifier in the message to the destination. You must then "
"retain a mapping between the internal ``deliveryId`` (passed into the "
"``deliveryIdToMessage`` function) and your custom correlation id (passed "
"into the message). You can do this by storing such mapping in a "
"``Map(correlationId -> deliveryId)`` from which you can retrieve the "
"``deliveryId`` to be passed into the ``confirmDelivery`` method once the "
"receiver of your message has replied with your custom correlation id."
msgstr ""

#: ../../java/lambda-persistence.rst:657
msgid ""
"The ``AbstractPersistentActorWithAtLeastOnceDelivery`` class has a state "
"consisting of unconfirmed messages and a sequence number. It does not store "
"this state itself. You must persist events corresponding to the ``deliver`` "
"and ``confirmDelivery`` invocations from your ``PersistentActor`` so that "
"the state can be restored by calling the same methods during the recovery "
"phase of the ``PersistentActor``. Sometimes these events can be derived from"
" other business level events, and sometimes you must create separate events."
" During recovery, calls to ``deliver`` will not send out messages, those "
"will be sent later if no matching ``confirmDelivery`` will have been "
"performed."
msgstr ""

#: ../../java/lambda-persistence.rst:665
msgid ""
"Support for snapshots is provided by ``getDeliverySnapshot`` and "
"``setDeliverySnapshot``. The ``AtLeastOnceDeliverySnapshot`` contains the "
"full delivery state, including unconfirmed messages. If you need a custom "
"snapshot for other parts of the actor state you must also include the "
"``AtLeastOnceDeliverySnapshot``. It is serialized using protobuf with the "
"ordinary Akka serialization mechanism. It is easiest to include the bytes of"
" the ``AtLeastOnceDeliverySnapshot`` as a blob in your custom snapshot."
msgstr ""

#: ../../java/lambda-persistence.rst:672
msgid ""
"The interval between redelivery attempts is defined by the "
"``redeliverInterval`` method. The default value can be configured with the "
"``akka.persistence.at-least-once-delivery.redeliver-interval`` configuration"
" key. The method can be overridden by implementation classes to return non-"
"default values."
msgstr ""

#: ../../java/lambda-persistence.rst:676
msgid ""
"After a number of delivery attempts a "
"``AtLeastOnceDelivery.UnconfirmedWarning`` message will be sent to ``self``."
" The re-sending will still continue, but you can choose to call "
"``confirmDelivery`` to cancel the re-sending. The number of delivery "
"attempts before emitting the warning is defined by the "
"``warnAfterNumberOfUnconfirmedAttempts`` method. The default value can be "
"configured with the ``akka.persistence.at-least-once-delivery.warn-after-"
"number-of-unconfirmed-attempts`` configuration key. The method can be "
"overridden by implementation classes to return non-default values."
msgstr ""

#: ../../java/lambda-persistence.rst:683
msgid ""
"The ``AbstractPersistentActorWithAtLeastOnceDelivery`` class holds messages "
"in memory until their successful delivery has been confirmed. The maximum "
"number of unconfirmed messages that the actor is allowed to hold in memory "
"is defined by the ``maxUnconfirmedMessages`` method. If this limit is exceed"
" the ``deliver`` method will not accept more messages and it will throw "
"``AtLeastOnceDelivery.MaxUnconfirmedMessagesExceededException``. The default"
" value can be configured with the ``akka.persistence.at-least-once-delivery"
".max-unconfirmed-messages`` configuration key. The method can be overridden "
"by implementation classes to return non-default values."
msgstr ""

#: ../../java/lambda-persistence.rst:693
msgid "Event Adapters"
msgstr ""

#: ../../java/lambda-persistence.rst:695
msgid ""
"In long running projects using event sourcing sometimes the need arises to "
"detach the data model from the domain model completely."
msgstr ""

#: ../../java/lambda-persistence.rst:698
msgid "Event Adapters help in situations where:"
msgstr ""

#: ../../java/lambda-persistence.rst:700
msgid ""
"**Version Migrations** – existing events stored in *Version 1* should be "
"\"upcasted\" to a new *Version 2* representation, and the process of doing "
"so involves actual code, not just changes on the serialization layer. For "
"these scenarios the ``toJournal`` function is usually an identity function, "
"however the ``fromJournal`` is implemented as ``v1.Event=>v2.Event``, "
"performing the neccessary mapping inside the fromJournal method. This "
"technique is sometimes refered to as \"upcasting\" in other CQRS libraries."
msgstr ""

#: ../../java/lambda-persistence.rst:705
msgid ""
"**Separating Domain and Data models** – thanks to EventAdapters it is "
"possible to completely separate the domain model from the model used to "
"persist data in the Journals. For example one may want to use case classes "
"in the domain model, however persist their protocol-buffer (or any other "
"binary serialization format) counter-parts to the Journal. A simple "
"``toJournal:MyModel=>MyDataModel`` and ``fromJournal:MyDataModel=>MyModel`` "
"adapter can be used to implement this feature."
msgstr ""

#: ../../java/lambda-persistence.rst:709
msgid ""
"**Journal Specialized Data Types** – exposing data types understood by the "
"underlying Journal, for example for data stores which understand JSON it is "
"possible to write an EventAdapter ``toJournal:Any=>JSON`` such that the "
"Journal can *directly* store the json instead of serializing the object to "
"its binary representation."
msgstr ""

#: ../../java/lambda-persistence.rst:713
msgid "Implementing an EventAdapter is rather stright forward:"
msgstr ""

#: ../../java/lambda-persistence.rst:717
msgid ""
"Then in order for it to be used on events coming to and from the journal you"
" must bind it using the below configuration syntax:"
msgstr ""

#: ../../java/lambda-persistence.rst:721
msgid ""
"It is possible to bind multiple adapters to one class *for recovery*, in "
"which case the ``fromJournal`` methods of all bound adapters will be applied"
" to a given matching event (in order of definition in the configuration). "
"Since each adapter may return from ``0`` to ``n`` adapted events (called as "
"``EventSeq``), each adapter can investigate the event and if it should "
"indeed adapt it return the adapted event(s) for it. Other adapters which do "
"not have anything to contribute during this adaptation simply return "
"``EventSeq.empty``. The adapted events are then delivered in-order to the "
"``PersistentActor`` during replay."
msgstr ""

#: ../../java/lambda-persistence.rst:728
#: ../../java/lambda-persistence.rst:1036
msgid ""
"For more advanced schema evolution techniques refer to the :ref"
":`persistence-schema-evolution-scala` documentation."
msgstr ""

#: ../../java/lambda-persistence.rst:733
msgid "Persistent FSM"
msgstr ""

#: ../../java/lambda-persistence.rst:734
msgid ""
"``AbstractPersistentFSM`` handles the incoming messages in an FSM like "
"fashion. Its internal state is persisted as a sequence of changes, later "
"referred to as domain events. Relationship between incoming messages, FSM's "
"states and transitions, persistence of domain events is defined by a DSL."
msgstr ""

#: ../../java/lambda-persistence.rst:740
msgid ""
"``AbstractPersistentFSM`` is marked as **“experimental”** as of its "
"introduction in Akka 2.4.0. We will continue to improve this API based on "
"our users’ feedback, which implies that while we try to keep incompatible "
"changes to a minimum the binary compatibility guarantee for maintenance "
"releases does not apply to the contents of the `classes related to "
"``AbstractPersistentFSM``."
msgstr ""

#: ../../java/lambda-persistence.rst:746
msgid "A Simple Example"
msgstr ""

#: ../../java/lambda-persistence.rst:747
msgid ""
"To demonstrate the features of the ``AbstractPersistentFSM``, consider an "
"actor which represents a Web store customer. The contract of our "
"\"WebStoreCustomerFSMActor\" is that it accepts the following commands:"
msgstr ""

#: ../../java/lambda-persistence.rst:752
msgid ""
"``AddItem`` sent when the customer adds an item to a shopping cart ``Buy`` -"
" when the customer finishes the purchase ``Leave`` - when the customer "
"leaves the store without purchasing anything ``GetCurrentCart`` allows to "
"query the current state of customer's shopping cart"
msgstr ""

#: ../../java/lambda-persistence.rst:757
msgid "The customer can be in one of the following states:"
msgstr ""

#: ../../java/lambda-persistence.rst:761
msgid ""
"``LookingAround`` customer is browsing the site, but hasn't added anything "
"to the shopping cart ``Shopping`` customer has recently added items to the "
"shopping cart ``Inactive`` customer has items in the shopping cart, but "
"hasn't added anything recently ``Paid`` customer has purchased the items"
msgstr ""

#: ../../java/lambda-persistence.rst:768
msgid ""
"``AbstractPersistentFSM`` states must inherit from "
"``PersistentFSM.FSMState`` and implement the ``String identifier()`` method."
" This is required in order to simplify the serialization of FSM states. "
"String identifiers should be unique!"
msgstr ""

#: ../../java/lambda-persistence.rst:772
msgid ""
"Customer's actions are \"recorded\" as a sequence of \"domain events\" which"
" are persisted. Those events are replayed on actor's start in order to "
"restore the latest customer's state:"
msgstr ""

#: ../../java/lambda-persistence.rst:777
msgid "Customer state data represents the items in customer's shopping cart:"
msgstr ""

#: ../../java/lambda-persistence.rst:781
msgid "Here is how everything is wired together:"
msgstr ""

#: ../../java/lambda-persistence.rst:787
msgid ""
"State data can only be modified directly on initialization. Later it's "
"modified only as a result of applying domain events. Override the "
"``applyEvent`` method to define how state data is affected by domain events,"
" see the example below"
msgstr ""

#: ../../java/lambda-persistence.rst:792
msgid ""
"``andThen`` can be used to define actions which will be executed following "
"event's persistence - convenient for \"side effects\" like sending a message"
" or logging. Notice that actions defined in ``andThen`` block are not "
"executed on recovery:"
msgstr ""

#: ../../java/lambda-persistence.rst:797
msgid ""
"A snapshot of state data can be persisted by calling the "
"``saveStateSnapshot()`` method:"
msgstr ""

#: ../../java/lambda-persistence.rst:801
msgid ""
"On recovery state data is initialized according to the latest available "
"snapshot, then the remaining domain events are replayed, triggering the "
"``applyEvent`` method."
msgstr ""

#: ../../java/lambda-persistence.rst:805
msgid "Storage plugins"
msgstr ""

#: ../../java/lambda-persistence.rst:807
msgid ""
"Storage backends for journals and snapshot stores are pluggable in the Akka "
"persistence extension."
msgstr ""

#: ../../java/lambda-persistence.rst:809
msgid ""
"A directory of persistence journal and snapshot store plugins is available "
"at the Akka Community Projects page, see `Community plugins`_"
msgstr ""

#: ../../java/lambda-persistence.rst:811
msgid ""
"Plugins can be selected either by \"default\", for all persistent actors and"
" views, or \"individually\", when persistent actor or view defines its own "
"set of plugins."
msgstr ""

#: ../../java/lambda-persistence.rst:814
msgid ""
"When persistent actor or view does NOT override ``journalPluginId`` and "
"``snapshotPluginId`` methods, persistence extension will use \"default\" "
"journal and snapshot-store plugins configured in the ``reference.conf``::"
msgstr ""

#: ../../java/lambda-persistence.rst:820
msgid ""
"However, these entries are provided as empty \"\", and require explicit user"
" configuration via override in the user ``application.conf``. For an example"
" of journal plugin which writes messages to LevelDB see :ref:`local-leveldb-"
"journal-java-lambda`. For an example of snapshot store plugin which writes "
"snapshots as individual files to the local filesystem see :ref:`local-"
"snapshot-store-java-lambda`."
msgstr ""

#: ../../java/lambda-persistence.rst:824
msgid ""
"Applications can provide their own plugins by implementing a plugin API and "
"activate them by configuration. Plugin development requires the following "
"imports:"
msgstr ""

#: ../../java/lambda-persistence.rst:830
msgid "Eager initialization of persistence plugin"
msgstr ""

#: ../../java/lambda-persistence.rst:832
msgid ""
"By default, persistence plugins are started on-demand, as they are used. In "
"some case, however, it might be beneficial to start a certain plugin "
"eagerly. In order to do that, you should first add the "
"``akka.persistence.Persistence`` under the ``akka.extensions`` key. Then, "
"specify the IDs of plugins you wish to start automatically under "
"``akka.persistence.journal.auto-start-journals`` and ``akka.persistence"
".snapshot-store.auto-start-snapshot-stores``."
msgstr ""

#: ../../java/lambda-persistence.rst:838
msgid "Journal plugin API"
msgstr ""

#: ../../java/lambda-persistence.rst:840
msgid "A journal plugin extends ``AsyncWriteJournal``."
msgstr ""

#: ../../java/lambda-persistence.rst:842
msgid ""
"``AsyncWriteJournal`` is an actor and the methods to be implemented are:"
msgstr ""

#: ../../java/lambda-persistence.rst:846
msgid ""
"If the storage backend API only supports synchronous, blocking writes, the "
"methods should be implemented as:"
msgstr ""

#: ../../java/lambda-persistence.rst:850
msgid ""
"A journal plugin must also implement the methods defined in "
"``AsyncRecovery`` for replays and sequence number recovery:"
msgstr ""

#: ../../java/lambda-persistence.rst:854
msgid ""
"A journal plugin can be activated with the following minimal configuration:"
msgstr ""

#: ../../java/lambda-persistence.rst:858 ../../java/lambda-persistence.rst:881
msgid ""
"The specified plugin ``class`` must have a no-arg constructor. The ``plugin-"
"dispatcher`` is the dispatcher used for the plugin actor. If not specified, "
"it defaults to ``akka.persistence.dispatchers.default-plugin-dispatcher``."
msgstr ""

#: ../../java/lambda-persistence.rst:861
msgid ""
"The journal plugin instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may delegate "
"to asynchronous libraries, spawn futures, or delegate to other actors to "
"achive parallelism."
msgstr ""

#: ../../java/lambda-persistence.rst:865
msgid ""
"The journal plugin class must have a constructor without parameters or a "
"constructor with one ``com.typesafe.config.Config`` parameter. The plugin "
"section of the actor system's config will be passed in the config "
"constructor parameter."
msgstr ""

#: ../../java/lambda-persistence.rst:868
msgid ""
"Don't run journal tasks/futures on the system default dispatcher, since that"
" might starve other tasks."
msgstr ""

#: ../../java/lambda-persistence.rst:871
msgid "Snapshot store plugin API"
msgstr ""

#: ../../java/lambda-persistence.rst:873
msgid ""
"A snapshot store plugin must extend the ``SnapshotStore`` actor and "
"implement the following methods:"
msgstr ""

#: ../../java/lambda-persistence.rst:877
msgid ""
"A snapshot store plugin can be activated with the following minimal "
"configuration:"
msgstr ""

#: ../../java/lambda-persistence.rst:884
msgid ""
"The snapshot store instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may delegate "
"to asynchronous libraries, spawn futures, or delegate to other actors to "
"achive parallelism."
msgstr ""

#: ../../java/lambda-persistence.rst:888
msgid ""
"The snapshot store plugin class must have a constructor without parameters "
"or constructor with one ``com.typesafe.config.Config`` parameter. The plugin"
" section of the actor system's config will be passed in the config "
"constructor parameter."
msgstr ""

#: ../../java/lambda-persistence.rst:891
msgid ""
"Don't run snapshot store tasks/futures on the system default dispatcher, "
"since that might starve other tasks."
msgstr ""

#: ../../java/lambda-persistence.rst:894
msgid "Pre-packaged plugins"
msgstr ""

#: ../../java/lambda-persistence.rst:899
msgid "Local LevelDB journal"
msgstr ""

#: ../../java/lambda-persistence.rst:901
msgid ""
"The LevelDB journal plugin config entry is "
"``akka.persistence.journal.leveldb``. It writes messages to a local LevelDB "
"instance. Enable this plugin by defining config property:"
msgstr ""

#: ../../java/lambda-persistence.rst:906
msgid ""
"LevelDB based plugins will also require the following additional dependency "
"declaration::"
msgstr ""

#: ../../java/lambda-persistence.rst:919
msgid ""
"The default location of LevelDB files is a directory named ``journal`` in "
"the current working directory. This location can be changed by configuration"
" where the specified path can be relative or absolute:"
msgstr ""

#: ../../java/lambda-persistence.rst:924
msgid ""
"With this plugin, each actor system runs its own private LevelDB instance."
msgstr ""

#: ../../java/lambda-persistence.rst:929
msgid "Shared LevelDB journal"
msgstr ""

#: ../../java/lambda-persistence.rst:931
msgid ""
"A LevelDB instance can also be shared by multiple actor systems (on the same"
" or on different nodes). This, for example, allows persistent actors to "
"failover to a backup node and continue using the shared journal instance "
"from the backup node."
msgstr ""

#: ../../java/lambda-persistence.rst:937
msgid ""
"A shared LevelDB instance is a single point of failure and should therefore "
"only be used for testing purposes. Highly-available, replicated journals are"
" available as `Community plugins`_."
msgstr ""

#: ../../java/lambda-persistence.rst:942
msgid ""
"This plugin has been supplanted by :ref:`Persistence Plugin Proxy"
"<persistence-plugin-proxy-lambda>`."
msgstr ""

#: ../../java/lambda-persistence.rst:944
msgid ""
"A shared LevelDB instance is started by instantiating the "
"``SharedLeveldbStore`` actor."
msgstr ""

#: ../../java/lambda-persistence.rst:948
msgid ""
"By default, the shared instance writes journaled messages to a local "
"directory named ``journal`` in the current working directory. The storage "
"location can be changed by configuration:"
msgstr ""

#: ../../java/lambda-persistence.rst:953
msgid ""
"Actor systems that use a shared LevelDB store must activate the "
"``akka.persistence.journal.leveldb-shared`` plugin."
msgstr ""

#: ../../java/lambda-persistence.rst:958
msgid ""
"This plugin must be initialized by injecting the (remote) "
"``SharedLeveldbStore`` actor reference. Injection is done by calling the "
"``SharedLeveldbJournal.setStore`` method with the actor reference as "
"argument."
msgstr ""

#: ../../java/lambda-persistence.rst:963
msgid ""
"Internal journal commands (sent by persistent actors) are buffered until "
"injection completes. Injection is idempotent i.e. only the first injection "
"is used."
msgstr ""

#: ../../java/lambda-persistence.rst:969
msgid "Local snapshot store"
msgstr ""

#: ../../java/lambda-persistence.rst:971
msgid ""
"Local snapshot store plugin config entry is ``akka.persistence.snapshot-"
"store.local``. It writes snapshot files to the local filesystem. Enable this"
" plugin by defining config property:"
msgstr ""

#: ../../java/lambda-persistence.rst:976
msgid ""
"The default storage location is a directory named ``snapshots`` in the "
"current working directory. This can be changed by configuration where the "
"specified path can be relative or absolute:"
msgstr ""

#: ../../java/lambda-persistence.rst:981
msgid ""
"Note that it is not mandatory to specify a snapshot store plugin. If you "
"don't use snapshots you don't have to configure it."
msgstr ""

#: ../../java/lambda-persistence.rst:987
msgid "Persistence Plugin Proxy"
msgstr ""

#: ../../java/lambda-persistence.rst:989
msgid ""
"A persistence plugin proxy allows sharing of journals and snapshot stores "
"across multiple actor systems (on the same or on different nodes). This, for"
" example, allows persistent actors to failover to a backup node and continue"
" using the shared journal instance from the backup node. The proxy works by "
"forwarding all the journal/snapshot store messages to a single, shared, "
"persistence plugin instance, and therefor supports any use case supported by"
" the proxied plugin."
msgstr ""

#: ../../java/lambda-persistence.rst:996
msgid ""
"A shared journal/snapshot store is a single point of failure and should "
"therefore only be used for testing purposes. Highly-available, replicated "
"persistence plugins are available as `Community plugins`_."
msgstr ""

#: ../../java/lambda-persistence.rst:999
msgid ""
"The journal and snapshot store proxies are controlled via the "
"``akka.persistence.journal.proxy`` and ``akka.persistence.snapshot-"
"store.proxy`` configuration entries, respectively. Set the ``target-journal-"
"plugin`` or ``target-snapshot-store-plugin`` keys to the underlying plugin "
"you wish to use (for example: ``akka.persistence.journal.leveldb``). The "
"``start-target-journal`` and ``start-target-snapshot-store`` keys should be "
"set to ``on`` in exactly one actor system - this is the system that will "
"instantiate the shared persistence plugin. Next, the proxy needs to be told "
"how to find the shared plugin. This can be done by setting the ``target-"
"journal-address`` and ``target-snapshot-store-address`` configuration keys, "
"or programmatically by calling the "
"``PersistencePluginProxy.setTargetLocation`` method."
msgstr ""

#: ../../java/lambda-persistence.rst:1010
msgid ""
"Akka starts extensions lazily when they are required, and this includes the "
"proxy. This means that in order for the proxy to work, the persistence "
"plugin on the target node must be instantiated. This can be done by "
"instantiating the ``PersistencePluginProxyExtension`` :ref:`extension"
"<extending-akka-java>`, or by calling the ``PersistencePluginProxy.start`` "
"method."
msgstr ""

#: ../../java/lambda-persistence.rst:1016
msgid ""
"The proxied persistence plugin can (and should) be configured using its "
"original configuration keys."
msgstr ""

#: ../../java/lambda-persistence.rst:1022
msgid "Custom serialization"
msgstr ""

#: ../../java/lambda-persistence.rst:1024
msgid ""
"Serialization of snapshots and payloads of ``Persistent`` messages is "
"configurable with Akka's :ref:`serialization-java` infrastructure. For "
"example, if an application wants to serialize"
msgstr ""

#: ../../java/lambda-persistence.rst:1027
msgid ""
"payloads of type ``MyPayload`` with a custom ``MyPayloadSerializer`` and"
msgstr ""

#: ../../java/lambda-persistence.rst:1028
msgid ""
"snapshots of type ``MySnapshot`` with a custom ``MySnapshotSerializer``"
msgstr ""

#: ../../java/lambda-persistence.rst:1030
msgid "it must add"
msgstr ""

#: ../../java/lambda-persistence.rst:1034
msgid ""
"to the application configuration. If not specified, a default serializer is "
"used."
msgstr ""

#: ../../java/lambda-persistence.rst:1039
msgid "Testing"
msgstr ""

#: ../../java/lambda-persistence.rst:1041
msgid ""
"When running tests with LevelDB default settings in ``sbt``, make sure to "
"set ``fork := true`` in your sbt project. Otherwise, you'll see an "
"``UnsatisfiedLinkError``. Alternatively, you can switch to a LevelDB Java "
"port by setting"
msgstr ""

#: ../../java/lambda-persistence.rst:1045
msgid "or"
msgstr ""

#: ../../java/lambda-persistence.rst:1049
msgid ""
"in your Akka configuration. The LevelDB Java port is for testing purposes "
"only."
msgstr ""

#: ../../java/lambda-persistence.rst:1052
msgid ""
"It is not possible to test persistence provided classes (i.e. "
":ref:`PersistentActor <event-sourcing-java>` and :ref:`AtLeastOnceDelivery "
"<at-least-once-delivery-java>`) using ``TestActorRef`` due to its "
"*synchronous* nature. These traits need to be able to perform asynchronous "
"tasks in the background in order to handle internal persistence related "
"events."
msgstr ""

#: ../../java/lambda-persistence.rst:1057
msgid ""
"When testing Persistence based projects always rely on :ref:`asynchronous "
"messaging using the TestKit <async-integration-testing-java>`."
msgstr ""

#: ../../java/lambda-persistence.rst:1060
msgid "Multiple persistence plugin configurations"
msgstr ""

#: ../../java/lambda-persistence.rst:1062
msgid ""
"By default, a persistent actor or view will use \"default\" journal and "
"snapshot store plugins configured in the following sections of the "
"``reference.conf`` configuration resource:"
msgstr ""

#: ../../java/lambda-persistence.rst:1067
msgid ""
"Note that in this case the actor or view overrides only ``persistenceId`` "
"method:"
msgstr ""

#: ../../java/lambda-persistence.rst:1071
msgid ""
"When a persistent actor or view overrides ``journalPluginId`` and "
"``snapshotPluginId`` methods, the actor or view will be serviced by these "
"specific persistence plugins instead of the defaults:"
msgstr ""

#: ../../java/lambda-persistence.rst:1076
msgid ""
"Note that ``journalPluginId`` and ``snapshotPluginId`` must refer to "
"properly configured ``reference.conf`` plugin entries with a standard "
"``class`` property as well as settings which are specific for those plugins,"
" i.e.:"
msgstr ""
