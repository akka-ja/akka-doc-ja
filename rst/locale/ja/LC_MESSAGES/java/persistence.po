# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-03 22:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../java/persistence.rst:5
msgid "Persistence"
msgstr ""

#: ../../java/persistence.rst:7
msgid ""
"Akka persistence enables stateful actors to persist their internal state "
"so that it can be recovered when an actor is started, restarted after a "
"JVM crash or by a supervisor, or migrated in a cluster. The key concept "
"behind Akka persistence is that only changes to an actor's internal state"
" are persisted but never its current state directly (except for optional "
"snapshots). These changes are only ever appended to storage, nothing is "
"ever mutated, which allows for very high transaction rates and efficient "
"replication. Stateful actors are recovered by replaying stored changes to"
" these actors from which they can rebuild internal state. This can be "
"either the full history of changes or starting from a snapshot which can "
"dramatically reduce recovery times. Akka persistence also provides point-"
"to-point communication with at-least-once message delivery semantics."
msgstr ""

#: ../../java/persistence.rst:18
msgid ""
"Java 8 lambda expressions are also supported. (See section :ref"
":`persistence-lambda-java`)"
msgstr ""

#: ../../java/persistence.rst:20
msgid ""
"Akka persistence is inspired by and the official replacement of the "
"`eventsourced`_ library. It follows the same concepts and architecture of"
" `eventsourced`_ but significantly differs on API and implementation "
"level. See also :ref:`migration-eventsourced-2.3`"
msgstr ""

#: ../../java/persistence.rst:27
msgid "Dependencies"
msgstr ""

#: ../../java/persistence.rst:29
msgid ""
"Akka persistence is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

#: ../../java/persistence.rst:37
msgid ""
"The Akka persistence extension comes with few built-in persistence "
"plugins, including in-memory heap based journal, local file-system based "
"snapshot-store and LevelDB based journal."
msgstr ""

#: ../../java/persistence.rst:40
msgid ""
"LevelDB based plugins will require the following additional dependency "
"declaration::"
msgstr ""

#: ../../java/persistence.rst:54
msgid "Architecture"
msgstr ""

#: ../../java/persistence.rst:56
msgid ""
"*UntypedPersistentActor*: Is a persistent, stateful actor. It is able to "
"persist events to a journal and can react to them in a thread-safe "
"manner. It can be used to implement both *command* as well as *event "
"sourced* actors. When a persistent actor is started or restarted, "
"journaled messages are replayed to that actor so that it can recover "
"internal state from these messages."
msgstr ""

#: ../../java/persistence.rst:61
msgid ""
"*UntypedPersistentView*: A view is a persistent, stateful actor that "
"receives journaled messages that have been written by another persistent "
"actor. A view itself does not journal new messages, instead, it updates "
"internal state only from a persistent actor's replicated message stream."
msgstr ""

#: ../../java/persistence.rst:65
msgid ""
"*UntypedPersistentActorAtLeastOnceDelivery*: To send messages with at-"
"least-once delivery semantics to destinations, also in case of sender and"
" receiver JVM crashes."
msgstr ""

#: ../../java/persistence.rst:68
msgid ""
"*AsyncWriteJournal*: A journal stores the sequence of messages sent to a "
"persistent actor. An application can control which messages are journaled"
" and which are received by the persistent actor without being journaled. "
"Journal maintains *highestSequenceNr* that is increased on each message. "
"The storage backend of a journal is pluggable. The persistence extension "
"comes with a \"leveldb\" journal plugin, which writes to the local "
"filesystem. Replicated journals are available as `Community plugins`_."
msgstr ""

#: ../../java/persistence.rst:73
msgid ""
"*Snapshot store*: A snapshot store persists snapshots of a persistent "
"actor's or a view's internal state. Snapshots are used for optimizing "
"recovery times. The storage backend of a snapshot store is pluggable. The"
" persistence extension comes with a \"local\" snapshot storage plugin, "
"which writes to the local filesystem. Replicated snapshot stores are "
"available as `Community plugins`_."
msgstr ""

#: ../../java/persistence.rst:83
msgid "Event sourcing"
msgstr ""

#: ../../java/persistence.rst:85
msgid ""
"The basic idea behind `Event Sourcing`_ is quite simple. A persistent "
"actor receives a (non-persistent) command which is first validated if it "
"can be applied to the current state. Here validation can mean anything "
"from simple inspection of a command message's fields up to a conversation"
" with several external services, for example. If validation succeeds, "
"events are generated from the command, representing the effect of the "
"command. These events are then persisted and, after successful "
"persistence, used to change the actor's state. When the persistent actor "
"needs to be recovered, only the persisted events are replayed of which we"
" know that they can be successfully applied. In other words, events "
"cannot fail when being replayed to a persistent actor, in contrast to "
"commands. Event sourced actors may of course also process commands that "
"do not change application state such as query commands for example."
msgstr ""

#: ../../java/persistence.rst:96
msgid ""
"Akka persistence supports event sourcing with the "
"``UntypedPersistentActor`` abstract class. An actor that extends this "
"class uses the ``persist`` method to persist and handle events. The "
"behavior of an ``UntypedPersistentActor`` is defined by implementing "
"``receiveRecover`` and ``receiveCommand``. This is demonstrated in the "
"following example."
msgstr ""

#: ../../java/persistence.rst:102
msgid ""
"The example defines two data types, ``Cmd`` and ``Evt`` to represent "
"commands and events, respectively. The ``state`` of the "
"``ExamplePersistentActor`` is a list of persisted event data contained in"
" ``ExampleState``."
msgstr ""

#: ../../java/persistence.rst:105
msgid ""
"The persistent actor's ``onReceiveRecover`` method defines how ``state`` "
"is updated during recovery by handling ``Evt`` and ``SnapshotOffer`` "
"messages. The persistent actor's ``onReceiveCommand`` method is a command"
" handler. In this example, a command is handled by generating two events "
"which are then persisted and handled. Events are persisted by calling "
"``persist`` with an event (or a sequence of events) as first argument and"
" an event handler as second argument."
msgstr ""

#: ../../java/persistence.rst:110
msgid ""
"The ``persist`` method persists events asynchronously and the event "
"handler is executed for successfully persisted events. Successfully "
"persisted events are internally sent back to the persistent actor as "
"individual messages that trigger event handler executions. An event "
"handler may close over persistent actor state and mutate it. The sender "
"of a persisted event is the sender of the corresponding command. This "
"allows event handlers to reply to the sender of a command (not shown)."
msgstr ""

#: ../../java/persistence.rst:116
msgid ""
"The main responsibility of an event handler is changing persistent actor "
"state using event data and notifying others about successful state "
"changes by publishing events."
msgstr ""

#: ../../java/persistence.rst:119
msgid ""
"When persisting events with ``persist`` it is guaranteed that the "
"persistent actor will not receive further commands between the "
"``persist`` call and the execution(s) of the associated event handler. "
"This also holds for multiple ``persist`` calls in context of a single "
"command. Incoming messages are :ref:`stashed <internal-stash-java>` until"
" the ``persist`` is completed."
msgstr ""

#: ../../java/persistence.rst:124
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped. If persistence of an event is rejected before it is stored, e.g."
" due to serialization error, ``onPersistRejected`` will be invoked "
"(logging a warning by default), and the actor continues with the next "
"message."
msgstr ""

#: ../../java/persistence.rst:129
msgid ""
"The easiest way to run this example yourself is to download `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_ and open the "
"tutorial named `Akka Persistence Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-persistence-"
"java>`_. It contains instructions on how to run the "
"``PersistentActorExample``."
msgstr ""

#: ../../java/persistence.rst:135
msgid ""
"It's also possible to switch between different command handlers during "
"normal processing and recovery with ``getContext().become()`` and "
"``getContext().unbecome()``. To get the actor into the same state after "
"recovery you need to take special care to perform the same state "
"transitions with ``become`` and ``unbecome`` in the ``receiveRecover`` "
"method as you would have done in the command handler. Note that when "
"using ``become`` from ``receiveRecover`` it will still only use the "
"``receiveRecover`` behavior when replaying the events. When replay is "
"completed it will use the new behavior."
msgstr ""

#: ../../java/persistence.rst:143 ../../java/persistence.rst:525
msgid "Identifiers"
msgstr ""

#: ../../java/persistence.rst:145
msgid ""
"A persistent actor must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``persistenceId`` method."
msgstr ""

#: ../../java/persistence.rst:154 ../../java/persistence.rst:516
msgid "Recovery"
msgstr ""

#: ../../java/persistence.rst:156
msgid ""
"By default, a persistent actor is automatically recovered on start and on"
" restart by replaying journaled messages. New messages sent to a "
"persistent actor during recovery do not interfere with replayed messages."
" They are cached and received by a persistent actor after recovery phase "
"completes."
msgstr ""

#: ../../java/persistence.rst:161
msgid ""
"Accessing the ``sender()`` for replayed messages will always result in a "
"``deadLetters`` reference, as the original sender is presumed to be long "
"gone. If you indeed have to notify an actor during recovery in the "
"future, store its ``ActorPath`` explicitly in your persisted events."
msgstr ""

#: ../../java/persistence.rst:166
msgid "Recovery customization"
msgstr ""

#: ../../java/persistence.rst:168
msgid ""
"Applications may also customise how recovery is performed by returning a "
"customised ``Recovery`` object in the ``recovery`` method of a "
"``UntypedPersistentActor``, for example setting an upper bound to the "
"replay which allows the actor to be replayed to a certain point \"in the "
"past\" instead to its most up to date state:"
msgstr ""

#: ../../java/persistence.rst:174
msgid ""
"Recovery can be disabled by returning ``Recovery.none()`` in the "
"``recovery`` method of a ``PersistentActor``:"
msgstr ""

#: ../../java/persistence.rst:179
msgid "Recovery status"
msgstr ""

#: ../../java/persistence.rst:181
msgid "A persistent actor can query its own recovery status via the methods"
msgstr ""

#: ../../java/persistence.rst:185
msgid ""
"Sometimes there is a need for performing additional initialization when "
"the recovery has completed before processing any other message sent to "
"the persistent actor. The persistent actor will receive a special "
":class:`RecoveryCompleted` message right after recovery and before any "
"other received messages."
msgstr ""

#: ../../java/persistence.rst:192
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal, ``onRecoveryFailure`` is called (logging the error by default) "
"and the actor will be stopped."
msgstr ""

#: ../../java/persistence.rst:198
msgid "Internal stash"
msgstr ""

#: ../../java/persistence.rst:200
msgid ""
"The persistent actor has a private :ref:`stash <stash-java>` for "
"internally caching incoming messages during :ref:`recovery <recovery-"
"java>` or the ``persist\\persistAll`` method persisting events. You can "
"still use/inherit from the ``Stash`` interface. The internal stash "
"cooperates with the normal stash by hooking into ``unstashAll`` method "
"and making sure messages are unstashed properly to the internal stash to "
"maintain ordering guarantees."
msgstr ""

#: ../../java/persistence.rst:205
msgid ""
"You should be careful to not send more messages to a persistent actor "
"than it can keep up with, otherwise the number of stashed messages will "
"grow without bounds. It can be wise to protect against "
"``OutOfMemoryError`` by defining a maximum stash capacity in the mailbox "
"configuration::"
msgstr ""

#: ../../java/persistence.rst:211
msgid ""
"Note that the stash capacity is per actor. If you have many persistent "
"actors, e.g. when using cluster sharding, you may need to define a small "
"stash capacity to ensure that the total number of stashed messages in the"
" system don't consume too much memory. Additionally, The persistent actor"
" defines three strategies to handle failure when the internal stash "
"capacity is exceeded. The default overflow strategy is the "
"``ThrowOverflowExceptionStrategy``, which discards the current received "
"message and throws a ``StashOverflowException``, causing actor restart if"
" default supervision strategy is used. you can override the "
"``internalStashOverflowStrategy`` method to return "
"``DiscardToDeadLetterStrategy`` or ``ReplyToStrategy`` for any "
"\"individual\" persistent actor, or define the \"default\" for all "
"persistent actors by providing FQCN, which must be a subclass of "
"``StashOverflowStrategyConfigurator``, in the persistence configuration::"
msgstr ""

#: ../../java/persistence.rst:224
msgid ""
"The ``DiscardToDeadLetterStrategy`` strategy also has a pre-packaged "
"companion configurator ``akka.persistence.DiscardConfigurator``."
msgstr ""

#: ../../java/persistence.rst:227
msgid ""
"You can also query default strategy via the Akka persistence extension "
"singleton::"
msgstr ""

#: ../../java/persistence.rst:232
msgid ""
"The bounded mailbox should be avoided in the persistent actor, by which "
"the messages come from storage backends may be discarded. You can use "
"bounded stash instead of it."
msgstr ""

#: ../../java/persistence.rst:239
msgid "Relaxed local consistency requirements and high throughput use-cases"
msgstr ""

#: ../../java/persistence.rst:241
msgid ""
"If faced with relaxed local consistency requirements and high throughput "
"demands sometimes ``PersistentActor`` and its ``persist`` may not be "
"enough in terms of consuming incoming Commands at a high rate, because it"
" has to wait until all Events related to a given Command are processed in"
" order to start processing the next Command. While this abstraction is "
"very useful for most cases, sometimes you may be faced with relaxed "
"requirements about consistency – for example you may want to process "
"commands as fast as you can, assuming that the Event will eventually be "
"persisted and handled properly in the background, retroactively reacting "
"to persistence failures if needed."
msgstr ""

#: ../../java/persistence.rst:248
msgid ""
"The ``persistAsync`` method provides a tool for implementing high-"
"throughput persistent actors. It will *not* stash incoming Commands while"
" the Journal is still working on persisting and/or user code is executing"
" event callbacks."
msgstr ""

#: ../../java/persistence.rst:251
msgid ""
"In the below example, the event callbacks may be called \"at any time\", "
"even after the next Command has been processed. The ordering between "
"events is still guaranteed (\"evt-b-1\" will be sent after \"evt-a-2\", "
"which will be sent after \"evt-a-1\" etc.)."
msgstr ""

#: ../../java/persistence.rst:257
msgid ""
"In order to implement the pattern known as \"*command sourcing*\" simply "
"``persistAsync`` all incoming messages right away and handle them in the "
"callback."
msgstr ""

#: ../../java/persistence.rst:261
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) "
"in between the call to ``persistAsync`` and the journal has confirmed the"
" write."
msgstr ""

#: ../../java/persistence.rst:267
msgid "Deferring actions until preceding persist handlers have executed"
msgstr ""

#: ../../java/persistence.rst:269
msgid ""
"Sometimes when working with ``persistAsync`` you may find that it would "
"be nice to define some actions in terms of ''happens-after the previous "
"``persistAsync`` handlers have been invoked''. ``PersistentActor`` "
"provides an utility method called ``deferAsync``, which works similarly "
"to ``persistAsync`` yet does not persist the passed in event. It is "
"recommended to use it for *read* operations, and actions which do not "
"have corresponding events in your domain model."
msgstr ""

#: ../../java/persistence.rst:274
msgid ""
"Using this method is very similar to the persist family of methods, yet "
"it does **not** persist the passed in event. It will be kept in memory "
"and used when invoking the handler."
msgstr ""

#: ../../java/persistence.rst:279
msgid ""
"Notice that the ``sender()`` is **safe** to access in the handler "
"callback, and will be pointing to the original sender of the command for "
"which this ``deferAsync`` handler was called."
msgstr ""

#: ../../java/persistence.rst:285
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) "
"in between the call to ``deferAsync`` and the journal has processed and "
"confirmed all preceding writes."
msgstr ""

#: ../../java/persistence.rst:291
msgid "Nested persist calls"
msgstr ""

#: ../../java/persistence.rst:292
msgid ""
"It is possible to call ``persist`` and ``persistAsync`` inside their "
"respective callback blocks and they will properly retain both the thread "
"safety (including the right value of ``sender()``) as well as stashing "
"guarantees."
msgstr ""

#: ../../java/persistence.rst:295
msgid ""
"In general it is encouraged to create command handlers which do not need "
"to resort to nested event persisting, however there are situations where "
"it may be useful. It is important to understand the ordering of callback "
"execution in those situations, as well as their implication on the "
"stashing behaviour (that ``persist()`` enforces). In the following "
"example two persist calls are issued, and each of them issues another "
"persist inside its callback:"
msgstr ""

#: ../../java/persistence.rst:302
msgid ""
"When sending two commands to this ``PersistentActor``, the persist "
"handlers will be executed in the following order:"
msgstr ""

#: ../../java/persistence.rst:306
msgid ""
"First the \"outer layer\" of persist calls is issued and their callbacks "
"are applied. After these have successfully completed, the inner callbacks"
" will be invoked (once the events they are persisting have been confirmed"
" to be persisted by the journal). Only after all these handlers have been"
" successfully invoked will the next command be delivered to the "
"persistent Actor. In other words, the stashing of incoming commands that "
"is guaranteed by initially calling ``persist()`` on the outer layer is "
"extended until all nested ``persist`` callbacks have been handled."
msgstr ""

#: ../../java/persistence.rst:312
msgid ""
"It is also possible to nest ``persistAsync`` calls, using the same "
"pattern:"
msgstr ""

#: ../../java/persistence.rst:316
msgid ""
"In this case no stashing is happening, yet events are still persisted and"
" callbacks are executed in the expected order:"
msgstr ""

#: ../../java/persistence.rst:320
msgid ""
"While it is possible to nest mixed ``persist`` and ``persistAsync`` with "
"keeping their respective semantics it is not a recommended practice, as "
"it may lead to overly complex nesting."
msgstr ""

#: ../../java/persistence.rst:326
msgid "Failures"
msgstr ""

#: ../../java/persistence.rst:328
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped."
msgstr ""

#: ../../java/persistence.rst:331
msgid ""
"The reason that it cannot resume when persist fails is that it is unknown"
" if the event was actually persisted or not, and therefore it is in an "
"inconsistent state. Restarting on persistent failures will most likely "
"fail anyway since the journal is probably unavailable. It is better to "
"stop the actor and after a back-off timeout start it again. The "
"``akka.pattern.BackoffSupervisor`` actor is provided to support such "
"restarts."
msgstr ""

#: ../../java/persistence.rst:339
msgid ""
"If persistence of an event is rejected before it is stored, e.g. due to "
"serialization error, ``onPersistRejected`` will be invoked (logging a "
"warning by default), and the actor continues with next message."
msgstr ""

#: ../../java/persistence.rst:343
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal when the actor is started, ``onRecoveryFailure`` is called "
"(logging the error by default), and the actor will be stopped."
msgstr ""

#: ../../java/persistence.rst:347
msgid "Atomic writes"
msgstr ""

#: ../../java/persistence.rst:349
msgid ""
"Each event is of course stored atomically, but it is also possible to "
"store several events atomically by using the ``persistAll`` or "
"``persistAllAsync`` method. That means that all events passed to that "
"method are stored or none of them are stored if there is an error."
msgstr ""

#: ../../java/persistence.rst:353
msgid ""
"The recovery of a persistent actor will therefore never be done partially"
" with only a subset of events persisted by `persistAll`."
msgstr ""

#: ../../java/persistence.rst:356
msgid ""
"Some journals may not support atomic writes of several events and they "
"will then reject the ``persistAll`` command, i.e. ``onPersistRejected`` "
"is called with an exception (typically "
"``UnsupportedOperationException``)."
msgstr ""

#: ../../java/persistence.rst:360
msgid "Batch writes"
msgstr ""

#: ../../java/persistence.rst:362
msgid ""
"In order to optimize throughput when using ``persistAsync``, a persistent"
" actor internally batches events to be stored under high load before "
"writing them to the journal (as a single batch). The batch size is "
"dynamically determined by how many events are emitted during the time of "
"a journal round-trip: after sending a batch to the journal no further "
"batch can be sent before confirmation has been received that the previous"
" batch has been written. Batch writes are never timer-based which keeps "
"latencies at a minimum."
msgstr ""

#: ../../java/persistence.rst:371
msgid "Message deletion"
msgstr ""

#: ../../java/persistence.rst:373
msgid ""
"It is possible to delete all messages (journaled by a single persistent "
"actor) up to a specified sequence number; Persistent actors may call the "
"``deleteMessages`` method to this end."
msgstr ""

#: ../../java/persistence.rst:376
msgid ""
"Deleting messages in event sourcing based applications is typically "
"either not used at all, or used in conjunction with :ref:`snapshotting "
"<snapshots>`, i.e. after a snapshot has been successfully stored, a "
"``deleteMessages(toSequenceNr)`` up until the sequence number of the data"
" held by that snapshot can be issued to safely delete the previous events"
" while still having access to the accumulated state during replays - by "
"loading the snapshot."
msgstr ""

#: ../../java/persistence.rst:381
msgid ""
"The result of the ``deleteMessages`` request is signaled to the "
"persistent actor with a ``DeleteMessagesSuccess`` message if the delete "
"was successful or a ``DeleteMessagesFailure`` message if it failed."
msgstr ""

#: ../../java/persistence.rst:384
msgid ""
"Message deletion doesn't affect the highest sequence number of the "
"journal, even if all messages were deleted from it after "
"``deleteMessages`` invocation."
msgstr ""

#: ../../java/persistence.rst:387
msgid "Persistence status handling"
msgstr ""

#: ../../java/persistence.rst:388
msgid "Persisting, deleting, and replaying messages can either succeed or fail."
msgstr ""

#: ../../java/persistence.rst:391 ../../java/persistence.rst:589
msgid "**Method**"
msgstr ""

#: ../../java/persistence.rst:391 ../../java/persistence.rst:589
msgid "**Success**"
msgstr ""

#: ../../java/persistence.rst:391
msgid "**Failure / Rejection**"
msgstr ""

#: ../../java/persistence.rst:391
msgid "**After failure handler invoked**"
msgstr ""

#: ../../java/persistence.rst:393
msgid "``persist`` / ``persistAsync``"
msgstr ""

#: ../../java/persistence.rst:393
msgid "persist handler invoked"
msgstr ""

#: ../../java/persistence.rst:393
msgid "``onPersistFailure``"
msgstr ""

#: ../../java/persistence.rst:393 ../../java/persistence.rst:397
msgid "Actor is stopped."
msgstr ""

#: ../../java/persistence.rst:395
msgid "``onPersistRejected``"
msgstr ""

#: ../../java/persistence.rst:395 ../../java/persistence.rst:399
msgid "No automatic actions."
msgstr ""

#: ../../java/persistence.rst:397
msgid "``recovery``"
msgstr ""

#: ../../java/persistence.rst:397
msgid "``RecoverySuccess``"
msgstr ""

#: ../../java/persistence.rst:397
msgid "``onRecoveryFailure``"
msgstr ""

#: ../../java/persistence.rst:399
msgid "``deleteMessages``"
msgstr ""

#: ../../java/persistence.rst:399
msgid "``DeleteMessagesSuccess``"
msgstr ""

#: ../../java/persistence.rst:399
msgid "``DeleteMessagesFailure``"
msgstr ""

#: ../../java/persistence.rst:402
msgid ""
"The most important operations (``persist`` and ``recovery``) have failure"
" handlers modelled as explicit callbacks which the user can override in "
"the ``PersistentActor``. The default implementations of these handlers "
"emit a log message (``error`` for persist/recovery failures, and "
"``warning`` for others), logging the failure cause and information about "
"which message caused the failure."
msgstr ""

#: ../../java/persistence.rst:407
msgid ""
"For critical failures such as recovery or persisting events failing the "
"persistent actor will be stopped after the failure handler is invoked. "
"This is because if the underlying journal implementation is signalling "
"persistence failures it is most likely either failing completely or "
"overloaded and restarting right-away and trying to persist the event "
"again will most likely not help the journal recover – as it would likely "
"cause a `Thundering herd problem`_, as many persistent actors would "
"restart and try to persist their events again. Instead, using a "
"``BackoffSupervisor`` (as described in :ref:`failures-java`) which "
"implements an exponential-backoff strategy which allows for more "
"breathing room for the journal to recover between restarts of the "
"persistent actor."
msgstr ""

#: ../../java/persistence.rst:416
msgid ""
"Journal implementations may choose to implement a retry mechanism, e.g. "
"such that only after a write fails N number of times a persistence "
"failure is signalled back to the user. In other words, once a journal "
"returns a failure, it is considered *fatal* by Akka Persistence, and the "
"persistent actor which caused the failure will be stopped."
msgstr ""

#: ../../java/persistence.rst:420
msgid ""
"Check the documentation of the journal implementation you are using for "
"details if/how it is using this technique."
msgstr ""

#: ../../java/persistence.rst:427
msgid "Safely shutting down persistent actors"
msgstr ""

#: ../../java/persistence.rst:429
msgid ""
"Special care should be given when shutting down persistent actors from "
"the outside. With normal Actors it is often acceptable to use the special"
" :ref:`PoisonPill <poison-pill-java>` message to signal to an Actor that "
"it should stop itself once it receives this message – in fact this "
"message is handled automatically by Akka, leaving the target actor no way"
" to refuse stopping itself when given a poison pill."
msgstr ""

#: ../../java/persistence.rst:434
msgid ""
"This can be dangerous when used with :class:`PersistentActor` due to the "
"fact that incoming commands are *stashed* while the persistent actor is "
"awaiting confirmation from the Journal that events have been written when"
" ``persist()`` was used. Since the incoming commands will be drained from"
" the Actor's mailbox and put into its internal stash while awaiting the "
"confirmation (thus, before calling the persist handlers) the Actor **may "
"receive and (auto)handle the PoisonPill before it processes the other "
"messages which have been put into its stash**, causing a pre-mature "
"shutdown of the Actor."
msgstr ""

#: ../../java/persistence.rst:441
msgid ""
"Consider using explicit shut-down messages instead of :class:`PoisonPill`"
" when working with persistent actors."
msgstr ""

#: ../../java/persistence.rst:443
msgid ""
"The example below highlights how messages arrive in the Actor's mailbox "
"and how they interact with its internal stashing mechanism when "
"``persist()`` is used. Notice the early stop behaviour that occurs when "
"``PoisonPill`` is used:"
msgstr ""

#: ../../java/persistence.rst:453
msgid "Persistent Views"
msgstr ""

#: ../../java/persistence.rst:457
msgid ""
"``UntypedPersistentView`` is deprecated. Use :ref:`persistence-query-"
"java` instead. The corresponding query type is ``EventsByPersistenceId``."
" There are several alternatives for connecting the ``Source`` to an actor"
" corresponding to a previous ``UntypedPersistentView`` actor:"
msgstr ""

#: ../../java/persistence.rst:461
msgid ""
"`Sink.actorRef`_ is simple, but has the disadvantage that there is no "
"back-pressure signal from the destination actor, i.e. if the actor is not"
" consuming the messages fast enough the mailbox of the actor will grow"
msgstr ""

#: ../../java/persistence.rst:463
msgid ""
"`mapAsync`_ combined with :ref:`actors-ask-lambda` is almost as simple "
"with the advantage of back-pressure being propagated all the way"
msgstr ""

#: ../../java/persistence.rst:465
msgid "`ActorSubscriber`_ in case you need more fine grained control"
msgstr ""

#: ../../java/persistence.rst:467
msgid ""
"The consuming actor may be a plain ``UntypedActor`` or an "
"``UntypedPersistentActor`` if it needs to store its own state (e.g. "
"fromSequenceNr offset)."
msgstr ""

#: ../../java/persistence.rst:474
msgid ""
"Persistent views can be implemented by extending the "
"``UntypedPersistentView`` trait  and implementing the ``onReceive`` and "
"the ``persistenceId`` methods."
msgstr ""

#: ../../java/persistence.rst:479
msgid ""
"The ``persistenceId`` identifies the persistent actor from which the view"
" receives journaled messages. It is not necessary that the referenced "
"persistent actor is actually running. Views read messages from a "
"persistent actor's journal directly. When a persistent actor is started "
"later and begins to write new messages, by default the corresponding view"
" is updated automatically."
msgstr ""

#: ../../java/persistence.rst:484
msgid ""
"It is possible to determine if a message was sent from the Journal or "
"from another actor in user-land by calling the ``isPersistent`` method. "
"Having that said, very often you don't need this information at all and "
"can simply apply the same logic to both cases (skip the ``if "
"isPersistent`` check)."
msgstr ""

#: ../../java/persistence.rst:489
msgid "Updates"
msgstr ""

#: ../../java/persistence.rst:491
msgid ""
"The default update interval of all persistent views of an actor system is"
" configurable:"
msgstr ""

#: ../../java/persistence.rst:495
msgid ""
"``UntypedPersistentView`` implementation classes may also override the "
"``autoUpdateInterval`` method to return a custom update interval for a "
"specific view class or view instance. Applications may also trigger "
"additional updates at any time by sending a view an ``Update`` message."
msgstr ""

#: ../../java/persistence.rst:501
msgid ""
"If the ``await`` parameter is set to ``true``, messages that follow the "
"``Update`` request are processed when the incremental message replay, "
"triggered by that update request, completed. If set to ``false`` "
"(default), messages following the update request may interleave with the "
"replayed message stream. Automated updates always run with ``await = "
"false``."
msgstr ""

#: ../../java/persistence.rst:506
msgid ""
"Automated updates of all persistent views of an actor system can be "
"turned off by configuration:"
msgstr ""

#: ../../java/persistence.rst:510
msgid ""
"Implementation classes may override the configured default value by "
"overriding the ``autoUpdate`` method. To limit the number of replayed "
"messages per update request, applications can configure a custom "
"``akka.persistence.view.auto-update-replay-max`` value or override the "
"``autoUpdateReplayMax`` method. The number of replayed messages for "
"manual updates can be limited with the ``replayMax`` parameter of the "
"``Update`` message."
msgstr ""

#: ../../java/persistence.rst:518
msgid ""
"Initial recovery of persistent views works the very same way as for "
"persistent actors (i.e. by sending a ``Recover`` message to self). The "
"maximum number of replayed messages during initial recovery is determined"
" by ``autoUpdateReplayMax``. Further possibilities to customize initial "
"recovery are explained in section :ref:`recovery-java`."
msgstr ""

#: ../../java/persistence.rst:527
msgid ""
"A persistent view must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``viewId`` method."
msgstr ""

#: ../../java/persistence.rst:530
msgid ""
"The ``viewId`` must differ from the referenced ``persistenceId``, unless "
":ref:`snapshots-java` of a view and its persistent actor should be shared"
" (which is what applications usually do not want)."
msgstr ""

#: ../../java/persistence.rst:536
msgid "Snapshots"
msgstr ""

#: ../../java/persistence.rst:538
msgid ""
"Snapshots can dramatically reduce recovery times of persistent actors and"
" views. The following discusses snapshots in context of persistent actors"
" but this is also applicable to persistent views."
msgstr ""

#: ../../java/persistence.rst:541
msgid ""
"Persistent actors can save snapshots of internal state by calling the  "
"``saveSnapshot`` method. If saving of a snapshot succeeds, the persistent"
" actor receives a ``SaveSnapshotSuccess`` message, otherwise a "
"``SaveSnapshotFailure`` message."
msgstr ""

#: ../../java/persistence.rst:546
msgid ""
"During recovery, the persistent actor is offered a previously saved "
"snapshot via a ``SnapshotOffer`` message from which it can initialize "
"internal state."
msgstr ""

#: ../../java/persistence.rst:551
msgid ""
"The replayed messages that follow the ``SnapshotOffer`` message, if any, "
"are younger than the offered snapshot. They finally recover the "
"persistent actor to its current (i.e. latest) state."
msgstr ""

#: ../../java/persistence.rst:554
msgid ""
"In general, a persistent actor is only offered a snapshot if that "
"persistent actor has previously saved one or more snapshots and at least "
"one of these snapshots matches the ``SnapshotSelectionCriteria`` that can"
" be specified for recovery."
msgstr ""

#: ../../java/persistence.rst:559
msgid ""
"If not specified, they default to ``SnapshotSelectionCriteria.latest()`` "
"which selects the latest (= youngest) snapshot. To disable snapshot-based"
" recovery, applications should use ``SnapshotSelectionCriteria.none()``. "
"A recovery where no saved snapshot matches the specified "
"``SnapshotSelectionCriteria`` will replay all journaled messages."
msgstr ""

#: ../../java/persistence.rst:564
msgid ""
"In order to use snapshots, a default snapshot-store (``akka.persistence"
".snapshot-store.plugin``) must be configured, or the persistent actor can"
" pick a snapshot store explicitly by overriding ``String "
"snapshotPluginId()``."
msgstr ""

#: ../../java/persistence.rst:567
msgid ""
"Since it is acceptable for some applications to not use any snapshotting,"
" it is legal to not configure a snapshot store. However, Akka will log a "
"warning message when this situation is detected and then continue to "
"operate until an actor tries to store a snapshot, at which point the "
"operation will fail (by replying with an ``SaveSnapshotFailure`` for "
"example)."
msgstr ""

#: ../../java/persistence.rst:571
msgid ""
"Note that :ref:`cluster_sharding_java` is using snapshots, so if you use "
"Cluster Sharding you need to define a snapshot store plugin."
msgstr ""

#: ../../java/persistence.rst:574
msgid "Snapshot deletion"
msgstr ""

#: ../../java/persistence.rst:576
msgid ""
"A persistent actor can delete individual snapshots by calling the "
"``deleteSnapshot`` method with the sequence number of when the snapshot "
"was taken."
msgstr ""

#: ../../java/persistence.rst:579
msgid ""
"To bulk-delete a range of snapshots matching "
"``SnapshotSelectionCriteria``, persistent actors should use the "
"``deleteSnapshots`` method."
msgstr ""

#: ../../java/persistence.rst:583
msgid "Snapshot status handling"
msgstr ""

#: ../../java/persistence.rst:585
msgid ""
"Saving or deleting snapshots can either succeed or fail – this "
"information is reported back to the persistent actor via status messages "
"as illustrated in the following table."
msgstr ""

#: ../../java/persistence.rst:589
msgid "**Failure message**"
msgstr ""

#: ../../java/persistence.rst:591
msgid "``saveSnapshot(Any)``"
msgstr ""

#: ../../java/persistence.rst:591
msgid "``SaveSnapshotSuccess``"
msgstr ""

#: ../../java/persistence.rst:591
msgid "``SaveSnapshotFailure``"
msgstr ""

#: ../../java/persistence.rst:592
msgid "``deleteSnapshot(Long)``"
msgstr ""

#: ../../java/persistence.rst:592
msgid "``DeleteSnapshotSuccess``"
msgstr ""

#: ../../java/persistence.rst:592
msgid "``DeleteSnapshotFailure``"
msgstr ""

#: ../../java/persistence.rst:593
msgid "``deleteSnapshots(SnapshotSelectionCriteria)``"
msgstr ""

#: ../../java/persistence.rst:593
msgid "``DeleteSnapshotsSuccess``"
msgstr ""

#: ../../java/persistence.rst:593
msgid "``DeleteSnapshotsFailure``"
msgstr ""

#: ../../java/persistence.rst:599
msgid "At-Least-Once Delivery"
msgstr ""

#: ../../java/persistence.rst:601
msgid ""
"To send messages with at-least-once delivery semantics to destinations "
"you can extend the ``UntypedPersistentActorWithAtLeastOnceDelivery`` "
"class instead of ``UntypedPersistentActor`` on the sending side.  It "
"takes care of re-sending messages when they have not been confirmed "
"within a configurable timeout."
msgstr ""

#: ../../java/persistence.rst:605
msgid ""
"The state of the sending actor, including which messages have been sent "
"that have not been confirmed by the recipient must be persistent so that "
"it can survive a crash of the sending actor or JVM. The "
"``UntypedPersistentActorWithAtLeastOnceDelivery`` class does not persist "
"anything by itself. It is your responsibility to persist the intent that "
"a message is sent and that a confirmation has been received."
msgstr ""

#: ../../java/persistence.rst:613
msgid ""
"At-least-once delivery implies that original message sending order is not"
" always preserved, and the destination may receive duplicate messages. "
"Semantics do not match those of a normal :class:`ActorRef` send "
"operation:"
msgstr ""

#: ../../java/persistence.rst:616
msgid "it is not at-most-once delivery"
msgstr ""

#: ../../java/persistence.rst:618
msgid ""
"message order for the same sender–receiver pair is not preserved due to "
"possible resends"
msgstr ""

#: ../../java/persistence.rst:621
msgid ""
"after a crash and restart of the destination messages are still delivered"
" to the new actor incarnation"
msgstr ""

#: ../../java/persistence.rst:624
msgid ""
"These semantics are similar to what an :class:`ActorPath` represents (see"
" :ref:`actor-lifecycle-scala`), therefore you need to supply a path and "
"not a reference when delivering messages. The messages are sent to the "
"path with an actor selection."
msgstr ""

#: ../../java/persistence.rst:629
msgid ""
"Use the ``deliver`` method to send a message to a destination. Call the "
"``confirmDelivery`` method when the destination has replied with a "
"confirmation message."
msgstr ""

#: ../../java/persistence.rst:633
msgid "Relationship between deliver and confirmDelivery"
msgstr ""

#: ../../java/persistence.rst:635
msgid ""
"To send messages to the destination path, use the ``deliver`` method "
"after you have persisted the intent to send the message."
msgstr ""

#: ../../java/persistence.rst:638
msgid ""
"The destination actor must send back a confirmation message. When the "
"sending actor receives this confirmation message you should persist the "
"fact that the message was delivered successfully and then call the "
"``confirmDelivery`` method."
msgstr ""

#: ../../java/persistence.rst:642
msgid ""
"If the persistent actor is not currently recovering, the ``deliver`` "
"method will send the message to the destination actor. When recovering, "
"messages will be buffered until they have been confirmed using "
"``confirmDelivery``. Once recovery has completed, if there are "
"outstanding messages that have not been confirmed (during the message "
"replay), the persistent actor will resend these before sending any other "
"messages."
msgstr ""

#: ../../java/persistence.rst:647
msgid ""
"Deliver requires a ``deliveryIdToMessage`` function to pass the provided "
"``deliveryId`` into the message so that the correlation between "
"``deliver`` and ``confirmDelivery`` is possible. The ``deliveryId`` must "
"do the round trip. Upon receipt of the message, the destination actor "
"will send the same``deliveryId`` wrapped in a confirmation message back "
"to the sender. The sender will then use it to call the "
"``confirmDelivery`` method to complete the delivery routine."
msgstr ""

#: ../../java/persistence.rst:654
msgid ""
"The ``deliveryId`` generated by the persistence module is a strictly "
"monotonically increasing sequence number without gaps. The same sequence "
"is used for all destinations of the actor, i.e. when sending to multiple "
"destinations the destinations will see gaps in the sequence. It is not "
"possible to use custom ``deliveryId``. However, you can send a custom "
"correlation identifier in the message to the destination. You must then "
"retain a mapping between the internal ``deliveryId`` (passed into the "
"``deliveryIdToMessage`` function) and your custom correlation id (passed "
"into the message). You can do this by storing such mapping in a "
"``Map(correlationId -> deliveryId)`` from which you can retrieve the "
"``deliveryId`` to be passed into the ``confirmDelivery`` method once the "
"receiver of your message has replied with your custom correlation id."
msgstr ""

#: ../../java/persistence.rst:663
msgid ""
"The ``UntypedPersistentActorWithAtLeastOnceDelivery`` class has a state "
"consisting of unconfirmed messages and a sequence number. It does not "
"store this state itself. You must persist events corresponding to the "
"``deliver`` and ``confirmDelivery`` invocations from your "
"``PersistentActor`` so that the state can be restored by calling the same"
" methods during the recovery phase of the ``PersistentActor``. Sometimes "
"these events can be derived from other business level events, and "
"sometimes you must create separate events. During recovery, calls to "
"``deliver`` will not send out messages, those will be sent later if no "
"matching ``confirmDelivery`` will have been performed."
msgstr ""

#: ../../java/persistence.rst:671
msgid ""
"Support for snapshots is provided by ``getDeliverySnapshot`` and "
"``setDeliverySnapshot``. The ``AtLeastOnceDeliverySnapshot`` contains the"
" full delivery state, including unconfirmed messages. If you need a "
"custom snapshot for other parts of the actor state you must also include "
"the ``AtLeastOnceDeliverySnapshot``. It is serialized using protobuf with"
" the ordinary Akka serialization mechanism. It is easiest to include the "
"bytes of the ``AtLeastOnceDeliverySnapshot`` as a blob in your custom "
"snapshot."
msgstr ""

#: ../../java/persistence.rst:678
msgid ""
"The interval between redelivery attempts is defined by the "
"``redeliverInterval`` method. The default value can be configured with "
"the ``akka.persistence.at-least-once-delivery.redeliver-interval`` "
"configuration key. The method can be overridden by implementation classes"
" to return non-default values."
msgstr ""

#: ../../java/persistence.rst:682
msgid ""
"The maximum number of messages that will be sent at each redelivery burst"
" is defined by the ``redeliveryBurstLimit`` method (burst frequency is "
"half of the redelivery interval). If there's a lot of unconfirmed "
"messages (e.g. if the destination is not available for a long time), this"
" helps to prevent an overwhelming amount of messages to be sent at once. "
"The default value can be configured with the ``akka.persistence.at-least-"
"once-delivery.redelivery-burst-limit`` configuration key. The method can "
"be overridden by implementation classes to return non-default values."
msgstr ""

#: ../../java/persistence.rst:689
msgid ""
"After a number of delivery attempts a "
"``AtLeastOnceDelivery.UnconfirmedWarning`` message will be sent to "
"``self``. The re-sending will still continue, but you can choose to call "
"``confirmDelivery`` to cancel the re-sending. The number of delivery "
"attempts before emitting the warning is defined by the "
"``warnAfterNumberOfUnconfirmedAttempts`` method. The default value can be"
" configured with the ``akka.persistence.at-least-once-delivery.warn-"
"after-number-of-unconfirmed-attempts`` configuration key. The method can "
"be overridden by implementation classes to return non-default values."
msgstr ""

#: ../../java/persistence.rst:696
msgid ""
"The ``UntypedPersistentActorWithAtLeastOnceDelivery`` class holds "
"messages in memory until their successful delivery has been confirmed. "
"The maximum number of unconfirmed messages that the actor is allowed to "
"hold in memory is defined by the ``maxUnconfirmedMessages`` method. If "
"this limit is exceed the ``deliver`` method will not accept more messages"
" and it will throw "
"``AtLeastOnceDelivery.MaxUnconfirmedMessagesExceededException``. The "
"default value can be configured with the ``akka.persistence.at-least-"
"once-delivery.max-unconfirmed-messages`` configuration key. The method "
"can be overridden by implementation classes to return non-default values."
msgstr ""

#: ../../java/persistence.rst:706
msgid "Event Adapters"
msgstr ""

#: ../../java/persistence.rst:708
msgid ""
"In long running projects using event sourcing sometimes the need arises "
"to detach the data model from the domain model completely."
msgstr ""

#: ../../java/persistence.rst:711
msgid "Event Adapters help in situations where:"
msgstr ""

#: ../../java/persistence.rst:713
msgid ""
"**Version Migrations** – existing events stored in *Version 1* should be "
"\"upcasted\" to a new *Version 2* representation, and the process of "
"doing so involves actual code, not just changes on the serialization "
"layer. For these scenarios the ``toJournal`` function is usually an "
"identity function, however the ``fromJournal`` is implemented as "
"``v1.Event=>v2.Event``, performing the neccessary mapping inside the "
"fromJournal method. This technique is sometimes refered to as "
"\"upcasting\" in other CQRS libraries."
msgstr ""

#: ../../java/persistence.rst:718
msgid ""
"**Separating Domain and Data models** – thanks to EventAdapters it is "
"possible to completely separate the domain model from the model used to "
"persist data in the Journals. For example one may want to use case "
"classes in the domain model, however persist their protocol-buffer (or "
"any other binary serialization format) counter-parts to the Journal. A "
"simple ``toJournal:MyModel=>MyDataModel`` and "
"``fromJournal:MyDataModel=>MyModel`` adapter can be used to implement "
"this feature."
msgstr ""

#: ../../java/persistence.rst:722
msgid ""
"**Journal Specialized Data Types** – exposing data types understood by "
"the underlying Journal, for example for data stores which understand JSON"
" it is possible to write an EventAdapter ``toJournal:Any=>JSON`` such "
"that the Journal can *directly* store the json instead of serializing the"
" object to its binary representation."
msgstr ""

#: ../../java/persistence.rst:726
msgid "Implementing an EventAdapter is rather stright forward:"
msgstr ""

#: ../../java/persistence.rst:730
msgid ""
"Then in order for it to be used on events coming to and from the journal "
"you must bind it using the below configuration syntax:"
msgstr ""

#: ../../java/persistence.rst:734
msgid ""
"It is possible to bind multiple adapters to one class *for recovery*, in "
"which case the ``fromJournal`` methods of all bound adapters will be "
"applied to a given matching event (in order of definition in the "
"configuration). Since each adapter may return from ``0`` to ``n`` adapted"
" events (called as ``EventSeq``), each adapter can investigate the event "
"and if it should indeed adapt it return the adapted event(s) for it. "
"Other adapters which do not have anything to contribute during this "
"adaptation simply return ``EventSeq.empty``. The adapted events are then "
"delivered in-order to the ``PersistentActor`` during replay."
msgstr ""

#: ../../java/persistence.rst:741 ../../java/persistence.rst:1015
msgid ""
"For more advanced schema evolution techniques refer to the :ref"
":`persistence-schema-evolution-scala` documentation."
msgstr ""

#: ../../java/persistence.rst:744
msgid "Storage plugins"
msgstr ""

#: ../../java/persistence.rst:746
msgid ""
"Storage backends for journals and snapshot stores are pluggable in the "
"Akka persistence extension."
msgstr ""

#: ../../java/persistence.rst:748
msgid ""
"A directory of persistence journal and snapshot store plugins is "
"available at the Akka Community Projects page, see `Community plugins`_"
msgstr ""

#: ../../java/persistence.rst:750
msgid ""
"Plugins can be selected either by \"default\", for all persistent actors "
"and views, or \"individually\", when a persistent actor or view defines "
"its own set of plugins."
msgstr ""

#: ../../java/persistence.rst:753
msgid ""
"When a persistent actor or view does NOT override the ``journalPluginId``"
" and ``snapshotPluginId`` methods, the persistence extension will use the"
" \"default\" journal and snapshot-store plugins configured in the "
"``reference.conf``::"
msgstr ""

#: ../../java/persistence.rst:759
msgid ""
"However, these entries are provided as empty \"\", and require explicit "
"user configuration via override in the user ``application.conf``. For an "
"example of a journal plugin which writes messages to LevelDB see :ref"
":`local-leveldb-journal-java`. For an example of a snapshot store plugin "
"which writes snapshots as individual files to the local filesystem see "
":ref:`local-snapshot-store-java`."
msgstr ""

#: ../../java/persistence.rst:763
msgid ""
"Applications can provide their own plugins by implementing a plugin API "
"and activating them by configuration. Plugin development requires the "
"following imports:"
msgstr ""

#: ../../java/persistence.rst:769
msgid "Eager initialization of persistence plugin"
msgstr ""

#: ../../java/persistence.rst:771
msgid ""
"By default, persistence plugins are started on-demand, as they are used. "
"In some case, however, it might be beneficial to start a certain plugin "
"eagerly. In order to do that, you should first add the "
"``akka.persistence.Persistence`` under the ``akka.extensions`` key. Then,"
" specify the IDs of plugins you wish to start automatically under "
"``akka.persistence.journal.auto-start-journals`` and ``akka.persistence"
".snapshot-store.auto-start-snapshot-stores``."
msgstr ""

#: ../../java/persistence.rst:779
msgid "Journal plugin API"
msgstr ""

#: ../../java/persistence.rst:781
msgid "A journal plugin extends ``AsyncWriteJournal``."
msgstr ""

#: ../../java/persistence.rst:783
msgid "``AsyncWriteJournal`` is an actor and the methods to be implemented are:"
msgstr ""

#: ../../java/persistence.rst:787
msgid ""
"If the storage backend API only supports synchronous, blocking writes, "
"the methods should be implemented as:"
msgstr ""

#: ../../java/persistence.rst:791
msgid ""
"A journal plugin must also implement the methods defined in "
"``AsyncRecovery`` for replays and sequence number recovery:"
msgstr ""

#: ../../java/persistence.rst:795
msgid ""
"A journal plugin can be activated with the following minimal "
"configuration:"
msgstr ""

#: ../../java/persistence.rst:799 ../../java/persistence.rst:822
msgid ""
"The specified plugin ``class`` must have a no-arg constructor. The "
"``plugin-dispatcher`` is the dispatcher used for the plugin actor. If not"
" specified, it defaults to ``akka.persistence.dispatchers.default-plugin-"
"dispatcher``."
msgstr ""

#: ../../java/persistence.rst:802
msgid ""
"The journal plugin instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may "
"delegate to asynchronous libraries, spawn futures, or delegate to other "
"actors to achive parallelism."
msgstr ""

#: ../../java/persistence.rst:806
msgid ""
"The journal plugin class must have a constructor without parameters or a "
"constructor with one ``com.typesafe.config.Config`` parameter. The plugin"
" section of the actor system's config will be passed in the config "
"constructor parameter."
msgstr ""

#: ../../java/persistence.rst:809
msgid ""
"Don't run journal tasks/futures on the system default dispatcher, since "
"that might starve other tasks."
msgstr ""

#: ../../java/persistence.rst:812
msgid "Snapshot store plugin API"
msgstr ""

#: ../../java/persistence.rst:814
msgid ""
"A snapshot store plugin must extend the ``SnapshotStore`` actor and "
"implement the following methods:"
msgstr ""

#: ../../java/persistence.rst:818
msgid ""
"A snapshot store plugin can be activated with the following minimal "
"configuration:"
msgstr ""

#: ../../java/persistence.rst:825
msgid ""
"The snapshot store instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may "
"delegate to asynchronous libraries, spawn futures, or delegate to other "
"actors to achive parallelism."
msgstr ""

#: ../../java/persistence.rst:829
msgid ""
"The snapshot store plugin class must have a constructor without "
"parameters or constructor with one ``com.typesafe.config.Config`` "
"parameter. The plugin section of the actor system's config will be passed"
" in the config constructor parameter."
msgstr ""

#: ../../java/persistence.rst:832
msgid ""
"Don't run snapshot store tasks/futures on the system default dispatcher, "
"since that might starve other tasks."
msgstr ""

#: ../../java/persistence.rst:835
msgid "Plugin TCK"
msgstr ""

#: ../../java/persistence.rst:836
msgid ""
"In order to help developers build correct and high quality storage "
"plugins, we provide a Technology Compatibility Kit (`TCK "
"<http://en.wikipedia.org/wiki/Technology_Compatibility_Kit>`_ for short)."
msgstr ""

#: ../../java/persistence.rst:838
msgid ""
"The TCK is usable from Java as well as Scala projects. For Java you need "
"to include the akka-persistence-tck dependency::"
msgstr ""

#: ../../java/persistence.rst:847
msgid ""
"To include the Journal TCK tests in your test suite simply extend the "
"provided ``JavaJournalSpec``:"
msgstr ""

#: ../../java/persistence.rst:851
msgid ""
"Please note that some of the tests are optional, and by overriding the "
"``supports...`` methods you give the TCK the needed information about "
"which tests to run. You can implement these methods using  the provided "
"``CapabilityFlag.on`` / ``CapabilityFlag.off`` values."
msgstr ""

#: ../../java/persistence.rst:855
msgid ""
"We also provide a simple benchmarking class ``JavaJournalPerfSpec`` which"
" includes all the tests that ``JavaJournalSpec`` has, and also performs "
"some longer operations on the Journal while printing its performance "
"stats. While it is NOT aimed to provide a proper benchmarking environment"
" it can be used to get a rough feel about your journal's performance in "
"the most typical scenarios."
msgstr ""

#: ../../java/persistence.rst:860
msgid ""
"In order to include the ``SnapshotStore`` TCK tests in your test suite "
"simply extend the ``SnapshotStoreSpec``:"
msgstr ""

#: ../../java/persistence.rst:864
msgid ""
"In case your plugin requires some setting up (starting a mock database, "
"removing temporary files etc.) you can override the ``beforeAll`` and "
"``afterAll`` methods to hook into the tests lifecycle:"
msgstr ""

#: ../../java/persistence.rst:869
msgid ""
"We *highly recommend* including these specifications in your test suite, "
"as they cover a broad range of cases you might have otherwise forgotten "
"to test for when writing a plugin from scratch."
msgstr ""

#: ../../java/persistence.rst:873
msgid "Pre-packaged plugins"
msgstr ""

#: ../../java/persistence.rst:878
msgid "Local LevelDB journal"
msgstr ""

#: ../../java/persistence.rst:880
msgid ""
"The LevelDB journal plugin config entry is "
"``akka.persistence.journal.leveldb``. It writes messages to a local "
"LevelDB instance. Enable this plugin by defining config property:"
msgstr ""

#: ../../java/persistence.rst:885
msgid ""
"LevelDB based plugins will also require the following additional "
"dependency declaration::"
msgstr ""

#: ../../java/persistence.rst:898
msgid ""
"The default location of the LevelDB files is a directory named "
"``journal`` in the current working directory. This location can be "
"changed by configuration where the specified path can be relative or "
"absolute:"
msgstr ""

#: ../../java/persistence.rst:903
msgid "With this plugin, each actor system runs its own private LevelDB instance."
msgstr ""

#: ../../java/persistence.rst:908
msgid "Shared LevelDB journal"
msgstr ""

#: ../../java/persistence.rst:910
msgid ""
"A LevelDB instance can also be shared by multiple actor systems (on the "
"same or on different nodes). This, for example, allows persistent actors "
"to failover to a backup node and continue using the shared journal "
"instance from the backup node."
msgstr ""

#: ../../java/persistence.rst:916
msgid ""
"A shared LevelDB instance is a single point of failure and should "
"therefore only be used for testing purposes. Highly-available, replicated"
" journals are available as `Community plugins`_."
msgstr ""

#: ../../java/persistence.rst:921
msgid ""
"This plugin has been supplanted by :ref:`Persistence Plugin Proxy"
"<persistence-plugin-proxy-java>`."
msgstr ""

#: ../../java/persistence.rst:923
msgid ""
"A shared LevelDB instance is started by instantiating the "
"``SharedLeveldbStore`` actor."
msgstr ""

#: ../../java/persistence.rst:927
msgid ""
"By default, the shared instance writes journaled messages to a local "
"directory named ``journal`` in the current working directory. The storage"
" location can be changed by configuration:"
msgstr ""

#: ../../java/persistence.rst:932
msgid ""
"Actor systems that use a shared LevelDB store must activate the "
"``akka.persistence.journal.leveldb-shared`` plugin."
msgstr ""

#: ../../java/persistence.rst:937
msgid ""
"This plugin must be initialized by injecting the (remote) "
"``SharedLeveldbStore`` actor reference. Injection is done by calling the "
"``SharedLeveldbJournal.setStore`` method with the actor reference as "
"argument."
msgstr ""

#: ../../java/persistence.rst:942
msgid ""
"Internal journal commands (sent by persistent actors) are buffered until "
"injection completes. Injection is idempotent i.e. only the first "
"injection is used."
msgstr ""

#: ../../java/persistence.rst:948
msgid "Local snapshot store"
msgstr ""

#: ../../java/persistence.rst:950
msgid ""
"The local snapshot store plugin config entry is ``akka.persistence"
".snapshot-store.local``. It writes snapshot files to the local "
"filesystem. Enable this plugin by defining config property:"
msgstr ""

#: ../../java/persistence.rst:955
msgid ""
"The default storage location is a directory named ``snapshots`` in the "
"current working directory. This can be changed by configuration where the"
" specified path can be relative or absolute:"
msgstr ""

#: ../../java/persistence.rst:960
msgid ""
"Note that it is not mandatory to specify a snapshot store plugin. If you "
"don't use snapshots you don't have to configure it."
msgstr ""

#: ../../java/persistence.rst:966
msgid "Persistence Plugin Proxy"
msgstr ""

#: ../../java/persistence.rst:968
msgid ""
"A persistence plugin proxy allows sharing of journals and snapshot stores"
" across multiple actor systems (on the same or on different nodes). This,"
" for example, allows persistent actors to failover to a backup node and "
"continue using the shared journal instance from the backup node. The "
"proxy works by forwarding all the journal/snapshot store messages to a "
"single, shared, persistence plugin instance, and therefor supports any "
"use case supported by the proxied plugin."
msgstr ""

#: ../../java/persistence.rst:975
msgid ""
"A shared journal/snapshot store is a single point of failure and should "
"therefore only be used for testing purposes. Highly-available, replicated"
" persistence plugins are available as `Community plugins`_."
msgstr ""

#: ../../java/persistence.rst:978
msgid ""
"The journal and snapshot store proxies are controlled via the "
"``akka.persistence.journal.proxy`` and ``akka.persistence.snapshot-"
"store.proxy`` configuration entries, respectively. Set the ``target-"
"journal-plugin`` or ``target-snapshot-store-plugin`` keys to the "
"underlying plugin you wish to use (for example: "
"``akka.persistence.journal.leveldb``). The ``start-target-journal`` and "
"``start-target-snapshot-store`` keys should be set to ``on`` in exactly "
"one actor system - this is the system that will instantiate the shared "
"persistence plugin. Next, the proxy needs to be told how to find the "
"shared plugin. This can be done by setting the ``target-journal-address``"
" and ``target-snapshot-store-address`` configuration keys, or "
"programmatically by calling the "
"``PersistencePluginProxy.setTargetLocation`` method."
msgstr ""

#: ../../java/persistence.rst:989
msgid ""
"Akka starts extensions lazily when they are required, and this includes "
"the proxy. This means that in order for the proxy to work, the "
"persistence plugin on the target node must be instantiated. This can be "
"done by instantiating the ``PersistencePluginProxyExtension`` "
":ref:`extension<extending-akka-java>`, or by calling the "
"``PersistencePluginProxy.start`` method."
msgstr ""

#: ../../java/persistence.rst:995
msgid ""
"The proxied persistence plugin can (and should) be configured using its "
"original configuration keys."
msgstr ""

#: ../../java/persistence.rst:1001
msgid "Custom serialization"
msgstr ""

#: ../../java/persistence.rst:1003
msgid ""
"Serialization of snapshots and payloads of ``Persistent`` messages is "
"configurable with Akka's :ref:`serialization-java` infrastructure. For "
"example, if an application wants to serialize"
msgstr ""

#: ../../java/persistence.rst:1006
msgid "payloads of type ``MyPayload`` with a custom ``MyPayloadSerializer`` and"
msgstr ""

#: ../../java/persistence.rst:1007
msgid "snapshots of type ``MySnapshot`` with a custom ``MySnapshotSerializer``"
msgstr ""

#: ../../java/persistence.rst:1009
msgid "it must add"
msgstr ""

#: ../../java/persistence.rst:1013
msgid ""
"to the application configuration. If not specified, a default serializer "
"is used."
msgstr ""

#: ../../java/persistence.rst:1018
msgid "Testing"
msgstr ""

#: ../../java/persistence.rst:1020
msgid ""
"When running tests with LevelDB default settings in ``sbt``, make sure to"
" set ``fork := true`` in your sbt project. Otherwise, you'll see an "
"``UnsatisfiedLinkError``. Alternatively, you can switch to a LevelDB Java"
" port by setting"
msgstr ""

#: ../../java/persistence.rst:1025
msgid "or"
msgstr ""

#: ../../java/persistence.rst:1029
msgid ""
"in your Akka configuration. The LevelDB Java port is for testing purposes"
" only."
msgstr ""

#: ../../java/persistence.rst:1032
msgid ""
"It is not possible to test persistence provided classes (i.e. "
":ref:`PersistentActor <event-sourcing-java>` and "
":ref:`AtLeastOnceDelivery <at-least-once-delivery-java>`) using "
"``TestActorRef`` due to its *synchronous* nature. These traits need to be"
" able to perform asynchronous tasks in the background in order to handle "
"internal persistence related events."
msgstr ""

#: ../../java/persistence.rst:1037
msgid ""
"When testing Persistence based projects always rely on :ref:`asynchronous"
" messaging using the TestKit <async-integration-testing-java>`."
msgstr ""

#: ../../java/persistence.rst:1040
msgid "Configuration"
msgstr ""

#: ../../java/persistence.rst:1042
msgid ""
"There are several configuration properties for the persistence module, "
"please refer to the :ref:`reference configuration <config-akka-"
"persistence>`."
msgstr ""

#: ../../java/persistence.rst:1046
msgid "Multiple persistence plugin configurations"
msgstr ""

#: ../../java/persistence.rst:1048
msgid ""
"By default, a persistent actor or view will use the \"default\" journal "
"and snapshot store plugins configured in the following sections of the "
"``reference.conf`` configuration resource:"
msgstr ""

#: ../../java/persistence.rst:1053
msgid ""
"Note that in this case the actor or view overrides only ``persistenceId``"
" method:"
msgstr ""

#: ../../java/persistence.rst:1057
msgid ""
"When a persistent actor or view overrides the ``journalPluginId`` and "
"``snapshotPluginId`` methods, the actor or view will be serviced by these"
" specific persistence plugins instead of the defaults:"
msgstr ""

#: ../../java/persistence.rst:1062
msgid ""
"Note that ``journalPluginId`` and ``snapshotPluginId`` must refer to "
"properly configured ``reference.conf`` plugin entries with a standard "
"``class`` property as well as settings which are specific for those "
"plugins, i.e.:"
msgstr ""

