# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kentaro Maeda <many.front@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../java/persistence.rst:5
msgid "Persistence"
msgstr "永続化"

#: ../../java/persistence.rst:7
msgid ""
"Akka persistence enables stateful actors to persist their internal state so "
"that it can be recovered when an actor is started, restarted after a JVM "
"crash or by a supervisor, or migrated in a cluster. The key concept behind "
"Akka persistence is that only changes to an actor's internal state are "
"persisted but never its current state directly (except for optional "
"snapshots). These changes are only ever appended to storage, nothing is ever"
" mutated, which allows for very high transaction rates and efficient "
"replication. Stateful actors are recovered by replaying stored changes to "
"these actors from which they can rebuild internal state. This can be either "
"the full history of changes or starting from a snapshot which can "
"dramatically reduce recovery times. Akka persistence also provides point-to-"
"point communication with at-least-once message delivery semantics."
msgstr ""

#: ../../java/persistence.rst:18
msgid ""
"Java 8 lambda expressions are also supported. (See section :ref"
":`persistence-lambda-java`)"
msgstr ""

#: ../../java/persistence.rst:20
msgid ""
"Akka persistence is inspired by and the official replacement of the "
"`eventsourced`_ library. It follows the same concepts and architecture of "
"`eventsourced`_ but significantly differs on API and implementation level. "
"See also :ref:`migration-eventsourced-2.3`"
msgstr ""

#: ../../java/persistence.rst:27
msgid "Dependencies"
msgstr ""

#: ../../java/persistence.rst:29
msgid ""
"Akka persistence is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

#: ../../java/persistence.rst:37
msgid ""
"The Akka persistence extension comes with few built-in persistence plugins, "
"including in-memory heap based journal, local file-system based snapshot-"
"store and LevelDB based journal."
msgstr ""

#: ../../java/persistence.rst:40
msgid ""
"LevelDB based plugins will require the following additional dependency "
"declaration::"
msgstr ""

#: ../../java/persistence.rst:54
msgid "Architecture"
msgstr ""

#: ../../java/persistence.rst:56
msgid ""
"*UntypedPersistentActor*: Is a persistent, stateful actor. It is able to "
"persist events to a journal and can react to them in a thread-safe manner. "
"It can be used to implement both *command* as well as *event sourced* "
"actors. When a persistent actor is started or restarted, journaled messages "
"are replayed to that actor so that it can recover internal state from these "
"messages."
msgstr ""

#: ../../java/persistence.rst:61
msgid ""
"*UntypedPersistentView*: A view is a persistent, stateful actor that "
"receives journaled messages that have been written by another persistent "
"actor. A view itself does not journal new messages, instead, it updates "
"internal state only from a persistent actor's replicated message stream."
msgstr ""

#: ../../java/persistence.rst:65
msgid ""
"*UntypedPersistentActorAtLeastOnceDelivery*: To send messages with at-least-"
"once delivery semantics to destinations, also in case of sender and receiver"
" JVM crashes."
msgstr ""

#: ../../java/persistence.rst:68
msgid ""
"*AsyncWriteJournal*: A journal stores the sequence of messages sent to a "
"persistent actor. An application can control which messages are journaled "
"and which are received by the persistent actor without being journaled. "
"Journal maintains *highestSequenceNr* that is increased on each message. The"
" storage backend of a journal is pluggable. The persistence extension comes "
"with a \"leveldb\" journal plugin, which writes to the local filesystem. "
"Replicated journals are available as `Community plugins`_."
msgstr ""

#: ../../java/persistence.rst:73
msgid ""
"*Snapshot store*: A snapshot store persists snapshots of a persistent "
"actor's or a view's internal state. Snapshots are used for optimizing "
"recovery times. The storage backend of a snapshot store is pluggable. The "
"persistence extension comes with a \"local\" snapshot storage plugin, which "
"writes to the local filesystem. Replicated snapshot stores are available as "
"`Community plugins`_."
msgstr ""

#: ../../java/persistence.rst:83
msgid "Event sourcing"
msgstr ""

#: ../../java/persistence.rst:85
msgid ""
"The basic idea behind `Event Sourcing`_ is quite simple. A persistent actor "
"receives a (non-persistent) command which is first validated if it can be "
"applied to the current state. Here validation can mean anything from simple "
"inspection of a command message's fields up to a conversation with several "
"external services, for example. If validation succeeds, events are generated"
" from the command, representing the effect of the command. These events are "
"then persisted and, after successful persistence, used to change the actor's"
" state. When the persistent actor needs to be recovered, only the persisted "
"events are replayed of which we know that they can be successfully applied. "
"In other words, events cannot fail when being replayed to a persistent "
"actor, in contrast to commands. Event sourced actors may of course also "
"process commands that do not change application state such as query commands"
" for example."
msgstr ""

#: ../../java/persistence.rst:96
msgid ""
"Akka persistence supports event sourcing with the ``UntypedPersistentActor``"
" abstract class. An actor that extends this class uses the ``persist`` "
"method to persist and handle events. The behavior of an "
"``UntypedPersistentActor`` is defined by implementing ``receiveRecover`` and"
" ``receiveCommand``. This is demonstrated in the following example."
msgstr ""

#: ../../java/persistence.rst:102
msgid ""
"The example defines two data types, ``Cmd`` and ``Evt`` to represent "
"commands and events, respectively. The ``state`` of the "
"``ExamplePersistentActor`` is a list of persisted event data contained in "
"``ExampleState``."
msgstr ""

#: ../../java/persistence.rst:105
msgid ""
"The persistent actor's ``onReceiveRecover`` method defines how ``state`` is "
"updated during recovery by handling ``Evt`` and ``SnapshotOffer`` messages. "
"The persistent actor's ``onReceiveCommand`` method is a command handler. In "
"this example, a command is handled by generating two events which are then "
"persisted and handled. Events are persisted by calling ``persist`` with an "
"event (or a sequence of events) as first argument and an event handler as "
"second argument."
msgstr ""

#: ../../java/persistence.rst:110
msgid ""
"The ``persist`` method persists events asynchronously and the event handler "
"is executed for successfully persisted events. Successfully persisted events"
" are internally sent back to the persistent actor as individual messages "
"that trigger event handler executions. An event handler may close over "
"persistent actor state and mutate it. The sender of a persisted event is the"
" sender of the corresponding command. This allows event handlers to reply to"
" the sender of a command (not shown)."
msgstr ""

#: ../../java/persistence.rst:116
msgid ""
"The main responsibility of an event handler is changing persistent actor "
"state using event data and notifying others about successful state changes "
"by publishing events."
msgstr ""

#: ../../java/persistence.rst:119
msgid ""
"When persisting events with ``persist`` it is guaranteed that the persistent"
" actor will not receive further commands between the ``persist`` call and "
"the execution(s) of the associated event handler. This also holds for "
"multiple ``persist`` calls in context of a single command. Incoming messages"
" are :ref:`stashed <internal-stash-java>` until the ``persist`` is "
"completed."
msgstr ""

#: ../../java/persistence.rst:124
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped. If persistence of an event is rejected before it is stored, e.g. "
"due to serialization error, ``onPersistRejected`` will be invoked (logging a"
" warning by default), and the actor continues with the next message."
msgstr ""

#: ../../java/persistence.rst:129
msgid ""
"The easiest way to run this example yourself is to download `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_ and open the "
"tutorial named `Akka Persistence Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-persistence-"
"java>`_. It contains instructions on how to run the "
"``PersistentActorExample``."
msgstr ""

#: ../../java/persistence.rst:135
msgid ""
"It's also possible to switch between different command handlers during "
"normal processing and recovery with ``getContext().become()`` and "
"``getContext().unbecome()``. To get the actor into the same state after "
"recovery you need to take special care to perform the same state transitions"
" with ``become`` and ``unbecome`` in the ``receiveRecover`` method as you "
"would have done in the command handler. Note that when using ``become`` from"
" ``receiveRecover`` it will still only use the ``receiveRecover`` behavior "
"when replaying the events. When replay is completed it will use the new "
"behavior."
msgstr ""

#: ../../java/persistence.rst:143 ../../java/persistence.rst:564
msgid "Identifiers"
msgstr ""

#: ../../java/persistence.rst:145
msgid ""
"A persistent actor must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``persistenceId`` method."
msgstr ""

#: ../../java/persistence.rst:152
msgid ""
"``persistenceId`` must be unique to a given entity in the journal (database "
"table/keyspace). When replaying messages persisted to the journal, you query"
" messages with a ``persistenceId``. So, if two different entities share the "
"same ``persistenceId``, message-replaying behavior is corrupted."
msgstr ""

#: ../../java/persistence.rst:160 ../../java/persistence.rst:555
msgid "Recovery"
msgstr ""

#: ../../java/persistence.rst:162
msgid ""
"By default, a persistent actor is automatically recovered on start and on "
"restart by replaying journaled messages. New messages sent to a persistent "
"actor during recovery do not interfere with replayed messages. They are "
"cached and received by a persistent actor after recovery phase completes."
msgstr ""

#: ../../java/persistence.rst:167
msgid ""
"Accessing the ``sender()`` for replayed messages will always result in a "
"``deadLetters`` reference, as the original sender is presumed to be long "
"gone. If you indeed have to notify an actor during recovery in the future, "
"store its ``ActorPath`` explicitly in your persisted events."
msgstr ""

#: ../../java/persistence.rst:172
msgid "Recovery customization"
msgstr ""

#: ../../java/persistence.rst:174
msgid ""
"Applications may also customise how recovery is performed by returning a "
"customised ``Recovery`` object in the ``recovery`` method of a "
"``UntypedPersistentActor``, for example setting an upper bound to the replay"
" which allows the actor to be replayed to a certain point \"in the past\" "
"instead to its most up to date state:"
msgstr ""

#: ../../java/persistence.rst:180
msgid ""
"Recovery can be disabled by returning ``Recovery.none()`` in the "
"``recovery`` method of a ``PersistentActor``:"
msgstr ""

#: ../../java/persistence.rst:185
msgid "Recovery status"
msgstr ""

#: ../../java/persistence.rst:187
msgid "A persistent actor can query its own recovery status via the methods"
msgstr ""

#: ../../java/persistence.rst:191
msgid ""
"Sometimes there is a need for performing additional initialization when the "
"recovery has completed before processing any other message sent to the "
"persistent actor. The persistent actor will receive a special "
":class:`RecoveryCompleted` message right after recovery and before any other"
" received messages."
msgstr ""

#: ../../java/persistence.rst:198
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal, ``onRecoveryFailure`` is called (logging the error by default) and "
"the actor will be stopped."
msgstr ""

#: ../../java/persistence.rst:204
msgid "Internal stash"
msgstr ""

#: ../../java/persistence.rst:206
msgid ""
"The persistent actor has a private :ref:`stash <stash-java>` for internally "
"caching incoming messages during :ref:`recovery <recovery-java>` or the "
"``persist\\persistAll`` method persisting events. You can still use/inherit "
"from the ``Stash`` interface. The internal stash cooperates with the normal "
"stash by hooking into ``unstashAll`` method and making sure messages are "
"unstashed properly to the internal stash to maintain ordering guarantees."
msgstr ""

#: ../../java/persistence.rst:211
msgid ""
"You should be careful to not send more messages to a persistent actor than "
"it can keep up with, otherwise the number of stashed messages will grow "
"without bounds. It can be wise to protect against ``OutOfMemoryError`` by "
"defining a maximum stash capacity in the mailbox configuration::"
msgstr ""

#: ../../java/persistence.rst:217
msgid ""
"Note that the stash capacity is per actor. If you have many persistent "
"actors, e.g. when using cluster sharding, you may need to define a small "
"stash capacity to ensure that the total number of stashed messages in the "
"system don't consume too much memory. Additionally, The persistent actor "
"defines three strategies to handle failure when the internal stash capacity "
"is exceeded. The default overflow strategy is the "
"``ThrowOverflowExceptionStrategy``, which discards the current received "
"message and throws a ``StashOverflowException``, causing actor restart if "
"default supervision strategy is used. you can override the "
"``internalStashOverflowStrategy`` method to return "
"``DiscardToDeadLetterStrategy`` or ``ReplyToStrategy`` for any "
"\"individual\" persistent actor, or define the \"default\" for all "
"persistent actors by providing FQCN, which must be a subclass of "
"``StashOverflowStrategyConfigurator``, in the persistence configuration::"
msgstr ""

#: ../../java/persistence.rst:230
msgid ""
"The ``DiscardToDeadLetterStrategy`` strategy also has a pre-packaged "
"companion configurator ``akka.persistence.DiscardConfigurator``."
msgstr ""

#: ../../java/persistence.rst:233
msgid ""
"You can also query default strategy via the Akka persistence extension "
"singleton::"
msgstr ""

#: ../../java/persistence.rst:238
msgid ""
"The bounded mailbox should be avoided in the persistent actor, by which the "
"messages come from storage backends may be discarded. You can use bounded "
"stash instead of it."
msgstr ""

#: ../../java/persistence.rst:245
msgid "Relaxed local consistency requirements and high throughput use-cases"
msgstr ""

#: ../../java/persistence.rst:247
msgid ""
"If faced with relaxed local consistency requirements and high throughput "
"demands sometimes ``PersistentActor`` and its ``persist`` may not be enough "
"in terms of consuming incoming Commands at a high rate, because it has to "
"wait until all Events related to a given Command are processed in order to "
"start processing the next Command. While this abstraction is very useful for"
" most cases, sometimes you may be faced with relaxed requirements about "
"consistency – for example you may want to process commands as fast as you "
"can, assuming that the Event will eventually be persisted and handled "
"properly in the background, retroactively reacting to persistence failures "
"if needed."
msgstr ""

#: ../../java/persistence.rst:254
msgid ""
"The ``persistAsync`` method provides a tool for implementing high-throughput"
" persistent actors. It will *not* stash incoming Commands while the Journal "
"is still working on persisting and/or user code is executing event "
"callbacks."
msgstr ""

#: ../../java/persistence.rst:257
msgid ""
"In the below example, the event callbacks may be called \"at any time\", "
"even after the next Command has been processed. The ordering between events "
"is still guaranteed (\"evt-b-1\" will be sent after \"evt-a-2\", which will "
"be sent after \"evt-a-1\" etc.)."
msgstr ""

#: ../../java/persistence.rst:263
msgid ""
"In order to implement the pattern known as \"*command sourcing*\" simply "
"``persistAsync`` all incoming messages right away and handle them in the "
"callback."
msgstr ""

#: ../../java/persistence.rst:267
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) in "
"between the call to ``persistAsync`` and the journal has confirmed the "
"write."
msgstr ""

#: ../../java/persistence.rst:273
msgid "Deferring actions until preceding persist handlers have executed"
msgstr ""

#: ../../java/persistence.rst:275
msgid ""
"Sometimes when working with ``persistAsync`` you may find that it would be "
"nice to define some actions in terms of ''happens-after the previous "
"``persistAsync`` handlers have been invoked''. ``PersistentActor`` provides "
"an utility method called ``deferAsync``, which works similarly to "
"``persistAsync`` yet does not persist the passed in event. It is recommended"
" to use it for *read* operations, and actions which do not have "
"corresponding events in your domain model."
msgstr ""

#: ../../java/persistence.rst:280
msgid ""
"Using this method is very similar to the persist family of methods, yet it "
"does **not** persist the passed in event. It will be kept in memory and used"
" when invoking the handler."
msgstr ""

#: ../../java/persistence.rst:285
msgid ""
"Notice that the ``sender()`` is **safe** to access in the handler callback, "
"and will be pointing to the original sender of the command for which this "
"``deferAsync`` handler was called."
msgstr ""

#: ../../java/persistence.rst:291
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) in "
"between the call to ``deferAsync`` and the journal has processed and "
"confirmed all preceding writes."
msgstr ""

#: ../../java/persistence.rst:297
msgid "Nested persist calls"
msgstr ""

#: ../../java/persistence.rst:298
msgid ""
"It is possible to call ``persist`` and ``persistAsync`` inside their "
"respective callback blocks and they will properly retain both the thread "
"safety (including the right value of ``sender()``) as well as stashing "
"guarantees."
msgstr ""

#: ../../java/persistence.rst:301
msgid ""
"In general it is encouraged to create command handlers which do not need to "
"resort to nested event persisting, however there are situations where it may"
" be useful. It is important to understand the ordering of callback execution"
" in those situations, as well as their implication on the stashing behaviour"
" (that ``persist()`` enforces). In the following example two persist calls "
"are issued, and each of them issues another persist inside its callback:"
msgstr ""

#: ../../java/persistence.rst:308
msgid ""
"When sending two commands to this ``PersistentActor``, the persist handlers "
"will be executed in the following order:"
msgstr ""

#: ../../java/persistence.rst:312
msgid ""
"First the \"outer layer\" of persist calls is issued and their callbacks are"
" applied. After these have successfully completed, the inner callbacks will "
"be invoked (once the events they are persisting have been confirmed to be "
"persisted by the journal). Only after all these handlers have been "
"successfully invoked will the next command be delivered to the persistent "
"Actor. In other words, the stashing of incoming commands that is guaranteed "
"by initially calling ``persist()`` on the outer layer is extended until all "
"nested ``persist`` callbacks have been handled."
msgstr ""

#: ../../java/persistence.rst:318
msgid ""
"It is also possible to nest ``persistAsync`` calls, using the same pattern:"
msgstr ""

#: ../../java/persistence.rst:322
msgid ""
"In this case no stashing is happening, yet events are still persisted and "
"callbacks are executed in the expected order:"
msgstr ""

#: ../../java/persistence.rst:326
msgid ""
"While it is possible to nest mixed ``persist`` and ``persistAsync`` with "
"keeping their respective semantics it is not a recommended practice, as it "
"may lead to overly complex nesting."
msgstr ""

#: ../../java/persistence.rst:332
msgid "Failures"
msgstr ""

#: ../../java/persistence.rst:334
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped."
msgstr ""

#: ../../java/persistence.rst:337
msgid ""
"The reason that it cannot resume when persist fails is that it is unknown if"
" the event was actually persisted or not, and therefore it is in an "
"inconsistent state. Restarting on persistent failures will most likely fail "
"anyway since the journal is probably unavailable. It is better to stop the "
"actor and after a back-off timeout start it again. The "
"``akka.pattern.BackoffSupervisor`` actor is provided to support such "
"restarts."
msgstr ""

#: ../../java/persistence.rst:345
msgid ""
"If persistence of an event is rejected before it is stored, e.g. due to "
"serialization error, ``onPersistRejected`` will be invoked (logging a "
"warning by default), and the actor continues with next message."
msgstr ""

#: ../../java/persistence.rst:349
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal when the actor is started, ``onRecoveryFailure`` is called (logging "
"the error by default), and the actor will be stopped."
msgstr ""

#: ../../java/persistence.rst:353
msgid "Atomic writes"
msgstr ""

#: ../../java/persistence.rst:355
msgid ""
"Each event is of course stored atomically, but it is also possible to store "
"several events atomically by using the ``persistAll`` or ``persistAllAsync``"
" method. That means that all events passed to that method are stored or none"
" of them are stored if there is an error."
msgstr ""

#: ../../java/persistence.rst:359
msgid ""
"The recovery of a persistent actor will therefore never be done partially "
"with only a subset of events persisted by `persistAll`."
msgstr ""

#: ../../java/persistence.rst:362
msgid ""
"Some journals may not support atomic writes of several events and they will "
"then reject the ``persistAll`` command, i.e. ``onPersistRejected`` is called"
" with an exception (typically ``UnsupportedOperationException``)."
msgstr ""

#: ../../java/persistence.rst:366
msgid "Batch writes"
msgstr ""

#: ../../java/persistence.rst:368
msgid ""
"In order to optimize throughput when using ``persistAsync``, a persistent "
"actor internally batches events to be stored under high load before writing "
"them to the journal (as a single batch). The batch size is dynamically "
"determined by how many events are emitted during the time of a journal "
"round-trip: after sending a batch to the journal no further batch can be "
"sent before confirmation has been received that the previous batch has been "
"written. Batch writes are never timer-based which keeps latencies at a "
"minimum."
msgstr ""

#: ../../java/persistence.rst:377
msgid "Message deletion"
msgstr ""

#: ../../java/persistence.rst:379
msgid ""
"It is possible to delete all messages (journaled by a single persistent "
"actor) up to a specified sequence number; Persistent actors may call the "
"``deleteMessages`` method to this end."
msgstr ""

#: ../../java/persistence.rst:382
msgid ""
"Deleting messages in event sourcing based applications is typically either "
"not used at all, or used in conjunction with :ref:`snapshotting "
"<snapshots>`, i.e. after a snapshot has been successfully stored, a "
"``deleteMessages(toSequenceNr)`` up until the sequence number of the data "
"held by that snapshot can be issued to safely delete the previous events "
"while still having access to the accumulated state during replays - by "
"loading the snapshot."
msgstr ""

#: ../../java/persistence.rst:387
msgid ""
"The result of the ``deleteMessages`` request is signaled to the persistent "
"actor with a ``DeleteMessagesSuccess`` message if the delete was successful "
"or a ``DeleteMessagesFailure`` message if it failed."
msgstr ""

#: ../../java/persistence.rst:390
msgid ""
"Message deletion doesn't affect the highest sequence number of the journal, "
"even if all messages were deleted from it after ``deleteMessages`` "
"invocation."
msgstr ""

#: ../../java/persistence.rst:393
msgid "Persistence status handling"
msgstr ""

#: ../../java/persistence.rst:394
msgid ""
"Persisting, deleting, and replaying messages can either succeed or fail."
msgstr ""

#: ../../java/persistence.rst:397 ../../java/persistence.rst:628
msgid "**Method**"
msgstr ""

#: ../../java/persistence.rst:397 ../../java/persistence.rst:628
msgid "**Success**"
msgstr ""

#: ../../java/persistence.rst:397
msgid "**Failure / Rejection**"
msgstr ""

#: ../../java/persistence.rst:397
msgid "**After failure handler invoked**"
msgstr ""

#: ../../java/persistence.rst:399
msgid "``persist`` / ``persistAsync``"
msgstr ""

#: ../../java/persistence.rst:399
msgid "persist handler invoked"
msgstr ""

#: ../../java/persistence.rst:399
msgid "``onPersistFailure``"
msgstr ""

#: ../../java/persistence.rst:399 ../../java/persistence.rst:403
msgid "Actor is stopped."
msgstr ""

#: ../../java/persistence.rst:401
msgid "``onPersistRejected``"
msgstr ""

#: ../../java/persistence.rst:401 ../../java/persistence.rst:405
msgid "No automatic actions."
msgstr ""

#: ../../java/persistence.rst:403
msgid "``recovery``"
msgstr ""

#: ../../java/persistence.rst:403
msgid "``RecoverySuccess``"
msgstr ""

#: ../../java/persistence.rst:403
msgid "``onRecoveryFailure``"
msgstr ""

#: ../../java/persistence.rst:405
msgid "``deleteMessages``"
msgstr ""

#: ../../java/persistence.rst:405
msgid "``DeleteMessagesSuccess``"
msgstr ""

#: ../../java/persistence.rst:405
msgid "``DeleteMessagesFailure``"
msgstr ""

#: ../../java/persistence.rst:408
msgid ""
"The most important operations (``persist`` and ``recovery``) have failure "
"handlers modelled as explicit callbacks which the user can override in the "
"``PersistentActor``. The default implementations of these handlers emit a "
"log message (``error`` for persist/recovery failures, and ``warning`` for "
"others), logging the failure cause and information about which message "
"caused the failure."
msgstr ""

#: ../../java/persistence.rst:413
msgid ""
"For critical failures such as recovery or persisting events failing the "
"persistent actor will be stopped after the failure handler is invoked. This "
"is because if the underlying journal implementation is signalling "
"persistence failures it is most likely either failing completely or "
"overloaded and restarting right-away and trying to persist the event again "
"will most likely not help the journal recover – as it would likely cause a "
"`Thundering herd problem`_, as many persistent actors would restart and try "
"to persist their events again. Instead, using a ``BackoffSupervisor`` (as "
"described in :ref:`failures-java`) which implements an exponential-backoff "
"strategy which allows for more breathing room for the journal to recover "
"between restarts of the persistent actor."
msgstr ""

#: ../../java/persistence.rst:422
msgid ""
"Journal implementations may choose to implement a retry mechanism, e.g. such"
" that only after a write fails N number of times a persistence failure is "
"signalled back to the user. In other words, once a journal returns a "
"failure, it is considered *fatal* by Akka Persistence, and the persistent "
"actor which caused the failure will be stopped."
msgstr ""

#: ../../java/persistence.rst:426
msgid ""
"Check the documentation of the journal implementation you are using for "
"details if/how it is using this technique."
msgstr ""

#: ../../java/persistence.rst:433
msgid "Safely shutting down persistent actors"
msgstr ""

#: ../../java/persistence.rst:435
msgid ""
"Special care should be given when shutting down persistent actors from the "
"outside. With normal Actors it is often acceptable to use the special "
":ref:`PoisonPill <poison-pill-java>` message to signal to an Actor that it "
"should stop itself once it receives this message – in fact this message is "
"handled automatically by Akka, leaving the target actor no way to refuse "
"stopping itself when given a poison pill."
msgstr ""

#: ../../java/persistence.rst:440
msgid ""
"This can be dangerous when used with :class:`PersistentActor` due to the "
"fact that incoming commands are *stashed* while the persistent actor is "
"awaiting confirmation from the Journal that events have been written when "
"``persist()`` was used. Since the incoming commands will be drained from the"
" Actor's mailbox and put into its internal stash while awaiting the "
"confirmation (thus, before calling the persist handlers) the Actor **may "
"receive and (auto)handle the PoisonPill before it processes the other "
"messages which have been put into its stash**, causing a pre-mature shutdown"
" of the Actor."
msgstr ""

#: ../../java/persistence.rst:447
msgid ""
"Consider using explicit shut-down messages instead of :class:`PoisonPill` "
"when working with persistent actors."
msgstr ""

#: ../../java/persistence.rst:449
msgid ""
"The example below highlights how messages arrive in the Actor's mailbox and "
"how they interact with its internal stashing mechanism when ``persist()`` is"
" used. Notice the early stop behaviour that occurs when ``PoisonPill`` is "
"used:"
msgstr ""

#: ../../java/persistence.rst:460
msgid "Replay Filter"
msgstr ""

#: ../../java/persistence.rst:461
msgid ""
"There could be cases where event streams are corrupted and multiple writers "
"(i.e. multiple persistent actor instances) journaled different messages with"
" the same sequence number. In such a case, you can configure how you filter "
"replayed messages from multiple writers, upon recovery."
msgstr ""

#: ../../java/persistence.rst:465
msgid ""
"In your configuration, under the ``akka.persistence.journal.xxx.replay-"
"filter`` section (where ``xxx`` is your journal plugin id), you can select "
"the replay filter ``mode`` from one of the following values:"
msgstr ""

#: ../../java/persistence.rst:468
msgid "repair-by-discard-old"
msgstr ""

#: ../../java/persistence.rst:469
msgid "fail"
msgstr ""

#: ../../java/persistence.rst:470
msgid "warn"
msgstr ""

#: ../../java/persistence.rst:471
msgid "off"
msgstr ""

#: ../../java/persistence.rst:473
msgid ""
"For example, if you configure the replay filter for leveldb plugin, it looks"
" like this::"
msgstr ""

#: ../../java/persistence.rst:492
msgid "Persistent Views"
msgstr ""

#: ../../java/persistence.rst:496
msgid ""
"``UntypedPersistentView`` is deprecated. Use :ref:`persistence-query-java` "
"instead. The corresponding query type is ``EventsByPersistenceId``. There "
"are several alternatives for connecting the ``Source`` to an actor "
"corresponding to a previous ``UntypedPersistentView`` actor:"
msgstr ""

#: ../../java/persistence.rst:500
msgid ""
"`Sink.actorRef`_ is simple, but has the disadvantage that there is no back-"
"pressure signal from the destination actor, i.e. if the actor is not "
"consuming the messages fast enough the mailbox of the actor will grow"
msgstr ""

#: ../../java/persistence.rst:502
msgid ""
"`mapAsync`_ combined with :ref:`actors-ask-lambda` is almost as simple with "
"the advantage of back-pressure being propagated all the way"
msgstr ""

#: ../../java/persistence.rst:504
msgid "`ActorSubscriber`_ in case you need more fine grained control"
msgstr ""

#: ../../java/persistence.rst:506
msgid ""
"The consuming actor may be a plain ``UntypedActor`` or an "
"``UntypedPersistentActor`` if it needs to store its own state (e.g. "
"fromSequenceNr offset)."
msgstr ""

#: ../../java/persistence.rst:513
msgid ""
"Persistent views can be implemented by extending the "
"``UntypedPersistentView`` trait  and implementing the ``onReceive`` and the "
"``persistenceId`` methods."
msgstr ""

#: ../../java/persistence.rst:518
msgid ""
"The ``persistenceId`` identifies the persistent actor from which the view "
"receives journaled messages. It is not necessary that the referenced "
"persistent actor is actually running. Views read messages from a persistent "
"actor's journal directly. When a persistent actor is started later and "
"begins to write new messages, by default the corresponding view is updated "
"automatically."
msgstr ""

#: ../../java/persistence.rst:523
msgid ""
"It is possible to determine if a message was sent from the Journal or from "
"another actor in user-land by calling the ``isPersistent`` method. Having "
"that said, very often you don't need this information at all and can simply "
"apply the same logic to both cases (skip the ``if isPersistent`` check)."
msgstr ""

#: ../../java/persistence.rst:528
msgid "Updates"
msgstr ""

#: ../../java/persistence.rst:530
msgid ""
"The default update interval of all persistent views of an actor system is "
"configurable:"
msgstr ""

#: ../../java/persistence.rst:534
msgid ""
"``UntypedPersistentView`` implementation classes may also override the "
"``autoUpdateInterval`` method to return a custom update interval for a "
"specific view class or view instance. Applications may also trigger "
"additional updates at any time by sending a view an ``Update`` message."
msgstr ""

#: ../../java/persistence.rst:540
msgid ""
"If the ``await`` parameter is set to ``true``, messages that follow the "
"``Update`` request are processed when the incremental message replay, "
"triggered by that update request, completed. If set to ``false`` (default), "
"messages following the update request may interleave with the replayed "
"message stream. Automated updates always run with ``await = false``."
msgstr ""

#: ../../java/persistence.rst:545
msgid ""
"Automated updates of all persistent views of an actor system can be turned "
"off by configuration:"
msgstr ""

#: ../../java/persistence.rst:549
msgid ""
"Implementation classes may override the configured default value by "
"overriding the ``autoUpdate`` method. To limit the number of replayed "
"messages per update request, applications can configure a custom "
"``akka.persistence.view.auto-update-replay-max`` value or override the "
"``autoUpdateReplayMax`` method. The number of replayed messages for manual "
"updates can be limited with the ``replayMax`` parameter of the ``Update`` "
"message."
msgstr ""

#: ../../java/persistence.rst:557
msgid ""
"Initial recovery of persistent views works the very same way as for "
"persistent actors (i.e. by sending a ``Recover`` message to self). The "
"maximum number of replayed messages during initial recovery is determined by"
" ``autoUpdateReplayMax``. Further possibilities to customize initial "
"recovery are explained in section :ref:`recovery-java`."
msgstr ""

#: ../../java/persistence.rst:566
msgid ""
"A persistent view must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``viewId`` method."
msgstr ""

#: ../../java/persistence.rst:569
msgid ""
"The ``viewId`` must differ from the referenced ``persistenceId``, unless "
":ref:`snapshots-java` of a view and its persistent actor should be shared "
"(which is what applications usually do not want)."
msgstr ""

#: ../../java/persistence.rst:575
msgid "Snapshots"
msgstr ""

#: ../../java/persistence.rst:577
msgid ""
"Snapshots can dramatically reduce recovery times of persistent actors and "
"views. The following discusses snapshots in context of persistent actors but"
" this is also applicable to persistent views."
msgstr ""

#: ../../java/persistence.rst:580
msgid ""
"Persistent actors can save snapshots of internal state by calling the  "
"``saveSnapshot`` method. If saving of a snapshot succeeds, the persistent "
"actor receives a ``SaveSnapshotSuccess`` message, otherwise a "
"``SaveSnapshotFailure`` message."
msgstr ""

#: ../../java/persistence.rst:585
msgid ""
"During recovery, the persistent actor is offered a previously saved snapshot"
" via a ``SnapshotOffer`` message from which it can initialize internal "
"state."
msgstr ""

#: ../../java/persistence.rst:590
msgid ""
"The replayed messages that follow the ``SnapshotOffer`` message, if any, are"
" younger than the offered snapshot. They finally recover the persistent "
"actor to its current (i.e. latest) state."
msgstr ""

#: ../../java/persistence.rst:593
msgid ""
"In general, a persistent actor is only offered a snapshot if that persistent"
" actor has previously saved one or more snapshots and at least one of these "
"snapshots matches the ``SnapshotSelectionCriteria`` that can be specified "
"for recovery."
msgstr ""

#: ../../java/persistence.rst:598
msgid ""
"If not specified, they default to ``SnapshotSelectionCriteria.latest()`` "
"which selects the latest (= youngest) snapshot. To disable snapshot-based "
"recovery, applications should use ``SnapshotSelectionCriteria.none()``. A "
"recovery where no saved snapshot matches the specified "
"``SnapshotSelectionCriteria`` will replay all journaled messages."
msgstr ""

#: ../../java/persistence.rst:603
msgid ""
"In order to use snapshots, a default snapshot-store (``akka.persistence"
".snapshot-store.plugin``) must be configured, or the persistent actor can "
"pick a snapshot store explicitly by overriding ``String "
"snapshotPluginId()``."
msgstr ""

#: ../../java/persistence.rst:606
msgid ""
"Since it is acceptable for some applications to not use any snapshotting, it"
" is legal to not configure a snapshot store. However, Akka will log a "
"warning message when this situation is detected and then continue to operate"
" until an actor tries to store a snapshot, at which point the operation will"
" fail (by replying with an ``SaveSnapshotFailure`` for example)."
msgstr ""

#: ../../java/persistence.rst:610
msgid ""
"Note that :ref:`cluster_sharding_java` is using snapshots, so if you use "
"Cluster Sharding you need to define a snapshot store plugin."
msgstr ""

#: ../../java/persistence.rst:613
msgid "Snapshot deletion"
msgstr ""

#: ../../java/persistence.rst:615
msgid ""
"A persistent actor can delete individual snapshots by calling the "
"``deleteSnapshot`` method with the sequence number of when the snapshot was "
"taken."
msgstr ""

#: ../../java/persistence.rst:618
msgid ""
"To bulk-delete a range of snapshots matching ``SnapshotSelectionCriteria``, "
"persistent actors should use the ``deleteSnapshots`` method."
msgstr ""

#: ../../java/persistence.rst:622
msgid "Snapshot status handling"
msgstr ""

#: ../../java/persistence.rst:624
msgid ""
"Saving or deleting snapshots can either succeed or fail – this information "
"is reported back to the persistent actor via status messages as illustrated "
"in the following table."
msgstr ""

#: ../../java/persistence.rst:628
msgid "**Failure message**"
msgstr ""

#: ../../java/persistence.rst:630
msgid "``saveSnapshot(Any)``"
msgstr ""

#: ../../java/persistence.rst:630
msgid "``SaveSnapshotSuccess``"
msgstr ""

#: ../../java/persistence.rst:630
msgid "``SaveSnapshotFailure``"
msgstr ""

#: ../../java/persistence.rst:631
msgid "``deleteSnapshot(Long)``"
msgstr ""

#: ../../java/persistence.rst:631
msgid "``DeleteSnapshotSuccess``"
msgstr ""

#: ../../java/persistence.rst:631
msgid "``DeleteSnapshotFailure``"
msgstr ""

#: ../../java/persistence.rst:632
msgid "``deleteSnapshots(SnapshotSelectionCriteria)``"
msgstr ""

#: ../../java/persistence.rst:632
msgid "``DeleteSnapshotsSuccess``"
msgstr ""

#: ../../java/persistence.rst:632
msgid "``DeleteSnapshotsFailure``"
msgstr ""

#: ../../java/persistence.rst:638
msgid "At-Least-Once Delivery"
msgstr ""

#: ../../java/persistence.rst:640
msgid ""
"To send messages with at-least-once delivery semantics to destinations you "
"can extend the ``UntypedPersistentActorWithAtLeastOnceDelivery`` class "
"instead of ``UntypedPersistentActor`` on the sending side.  It takes care of"
" re-sending messages when they have not been confirmed within a configurable"
" timeout."
msgstr ""

#: ../../java/persistence.rst:644
msgid ""
"The state of the sending actor, including which messages have been sent that"
" have not been confirmed by the recipient must be persistent so that it can "
"survive a crash of the sending actor or JVM. The "
"``UntypedPersistentActorWithAtLeastOnceDelivery`` class does not persist "
"anything by itself. It is your responsibility to persist the intent that a "
"message is sent and that a confirmation has been received."
msgstr ""

#: ../../java/persistence.rst:652
msgid ""
"At-least-once delivery implies that original message sending order is not "
"always preserved, and the destination may receive duplicate messages. "
"Semantics do not match those of a normal :class:`ActorRef` send operation:"
msgstr ""

#: ../../java/persistence.rst:655
msgid "it is not at-most-once delivery"
msgstr ""

#: ../../java/persistence.rst:657
msgid ""
"message order for the same sender–receiver pair is not preserved due to "
"possible resends"
msgstr ""

#: ../../java/persistence.rst:660
msgid ""
"after a crash and restart of the destination messages are still delivered to"
" the new actor incarnation"
msgstr ""

#: ../../java/persistence.rst:663
msgid ""
"These semantics are similar to what an :class:`ActorPath` represents (see "
":ref:`actor-lifecycle-scala`), therefore you need to supply a path and not a"
" reference when delivering messages. The messages are sent to the path with "
"an actor selection."
msgstr ""

#: ../../java/persistence.rst:668
msgid ""
"Use the ``deliver`` method to send a message to a destination. Call the "
"``confirmDelivery`` method when the destination has replied with a "
"confirmation message."
msgstr ""

#: ../../java/persistence.rst:672
msgid "Relationship between deliver and confirmDelivery"
msgstr ""

#: ../../java/persistence.rst:674
msgid ""
"To send messages to the destination path, use the ``deliver`` method after "
"you have persisted the intent to send the message."
msgstr ""

#: ../../java/persistence.rst:677
msgid ""
"The destination actor must send back a confirmation message. When the "
"sending actor receives this confirmation message you should persist the fact"
" that the message was delivered successfully and then call the "
"``confirmDelivery`` method."
msgstr ""

#: ../../java/persistence.rst:681
msgid ""
"If the persistent actor is not currently recovering, the ``deliver`` method "
"will send the message to the destination actor. When recovering, messages "
"will be buffered until they have been confirmed using ``confirmDelivery``. "
"Once recovery has completed, if there are outstanding messages that have not"
" been confirmed (during the message replay), the persistent actor will "
"resend these before sending any other messages."
msgstr ""

#: ../../java/persistence.rst:686
msgid ""
"Deliver requires a ``deliveryIdToMessage`` function to pass the provided "
"``deliveryId`` into the message so that the correlation between ``deliver`` "
"and ``confirmDelivery`` is possible. The ``deliveryId`` must do the round "
"trip. Upon receipt of the message, the destination actor will send the "
"same``deliveryId`` wrapped in a confirmation message back to the sender. The"
" sender will then use it to call the ``confirmDelivery`` method to complete "
"the delivery routine."
msgstr ""

#: ../../java/persistence.rst:693
msgid ""
"The ``deliveryId`` generated by the persistence module is a strictly "
"monotonically increasing sequence number without gaps. The same sequence is "
"used for all destinations of the actor, i.e. when sending to multiple "
"destinations the destinations will see gaps in the sequence. It is not "
"possible to use custom ``deliveryId``. However, you can send a custom "
"correlation identifier in the message to the destination. You must then "
"retain a mapping between the internal ``deliveryId`` (passed into the "
"``deliveryIdToMessage`` function) and your custom correlation id (passed "
"into the message). You can do this by storing such mapping in a "
"``Map(correlationId -> deliveryId)`` from which you can retrieve the "
"``deliveryId`` to be passed into the ``confirmDelivery`` method once the "
"receiver of your message has replied with your custom correlation id."
msgstr ""

#: ../../java/persistence.rst:702
msgid ""
"The ``UntypedPersistentActorWithAtLeastOnceDelivery`` class has a state "
"consisting of unconfirmed messages and a sequence number. It does not store "
"this state itself. You must persist events corresponding to the ``deliver`` "
"and ``confirmDelivery`` invocations from your ``PersistentActor`` so that "
"the state can be restored by calling the same methods during the recovery "
"phase of the ``PersistentActor``. Sometimes these events can be derived from"
" other business level events, and sometimes you must create separate events."
" During recovery, calls to ``deliver`` will not send out messages, those "
"will be sent later if no matching ``confirmDelivery`` will have been "
"performed."
msgstr ""

#: ../../java/persistence.rst:710
msgid ""
"Support for snapshots is provided by ``getDeliverySnapshot`` and "
"``setDeliverySnapshot``. The ``AtLeastOnceDeliverySnapshot`` contains the "
"full delivery state, including unconfirmed messages. If you need a custom "
"snapshot for other parts of the actor state you must also include the "
"``AtLeastOnceDeliverySnapshot``. It is serialized using protobuf with the "
"ordinary Akka serialization mechanism. It is easiest to include the bytes of"
" the ``AtLeastOnceDeliverySnapshot`` as a blob in your custom snapshot."
msgstr ""

#: ../../java/persistence.rst:717
msgid ""
"The interval between redelivery attempts is defined by the "
"``redeliverInterval`` method. The default value can be configured with the "
"``akka.persistence.at-least-once-delivery.redeliver-interval`` configuration"
" key. The method can be overridden by implementation classes to return non-"
"default values."
msgstr ""

#: ../../java/persistence.rst:721
msgid ""
"The maximum number of messages that will be sent at each redelivery burst is"
" defined by the ``redeliveryBurstLimit`` method (burst frequency is half of "
"the redelivery interval). If there's a lot of unconfirmed messages (e.g. if "
"the destination is not available for a long time), this helps to prevent an "
"overwhelming amount of messages to be sent at once. The default value can be"
" configured with the ``akka.persistence.at-least-once-delivery.redelivery-"
"burst-limit`` configuration key. The method can be overridden by "
"implementation classes to return non-default values."
msgstr ""

#: ../../java/persistence.rst:728
msgid ""
"After a number of delivery attempts a "
"``AtLeastOnceDelivery.UnconfirmedWarning`` message will be sent to ``self``."
" The re-sending will still continue, but you can choose to call "
"``confirmDelivery`` to cancel the re-sending. The number of delivery "
"attempts before emitting the warning is defined by the "
"``warnAfterNumberOfUnconfirmedAttempts`` method. The default value can be "
"configured with the ``akka.persistence.at-least-once-delivery.warn-after-"
"number-of-unconfirmed-attempts`` configuration key. The method can be "
"overridden by implementation classes to return non-default values."
msgstr ""

#: ../../java/persistence.rst:735
msgid ""
"The ``UntypedPersistentActorWithAtLeastOnceDelivery`` class holds messages "
"in memory until their successful delivery has been confirmed. The maximum "
"number of unconfirmed messages that the actor is allowed to hold in memory "
"is defined by the ``maxUnconfirmedMessages`` method. If this limit is exceed"
" the ``deliver`` method will not accept more messages and it will throw "
"``AtLeastOnceDelivery.MaxUnconfirmedMessagesExceededException``. The default"
" value can be configured with the ``akka.persistence.at-least-once-delivery"
".max-unconfirmed-messages`` configuration key. The method can be overridden "
"by implementation classes to return non-default values."
msgstr ""

#: ../../java/persistence.rst:745
msgid "Event Adapters"
msgstr ""

#: ../../java/persistence.rst:747
msgid ""
"In long running projects using event sourcing sometimes the need arises to "
"detach the data model from the domain model completely."
msgstr ""

#: ../../java/persistence.rst:750
msgid "Event Adapters help in situations where:"
msgstr ""

#: ../../java/persistence.rst:752
msgid ""
"**Version Migrations** – existing events stored in *Version 1* should be "
"\"upcasted\" to a new *Version 2* representation, and the process of doing "
"so involves actual code, not just changes on the serialization layer. For "
"these scenarios the ``toJournal`` function is usually an identity function, "
"however the ``fromJournal`` is implemented as ``v1.Event=>v2.Event``, "
"performing the neccessary mapping inside the fromJournal method. This "
"technique is sometimes refered to as \"upcasting\" in other CQRS libraries."
msgstr ""

#: ../../java/persistence.rst:757
msgid ""
"**Separating Domain and Data models** – thanks to EventAdapters it is "
"possible to completely separate the domain model from the model used to "
"persist data in the Journals. For example one may want to use case classes "
"in the domain model, however persist their protocol-buffer (or any other "
"binary serialization format) counter-parts to the Journal. A simple "
"``toJournal:MyModel=>MyDataModel`` and ``fromJournal:MyDataModel=>MyModel`` "
"adapter can be used to implement this feature."
msgstr ""

#: ../../java/persistence.rst:761
msgid ""
"**Journal Specialized Data Types** – exposing data types understood by the "
"underlying Journal, for example for data stores which understand JSON it is "
"possible to write an EventAdapter ``toJournal:Any=>JSON`` such that the "
"Journal can *directly* store the json instead of serializing the object to "
"its binary representation."
msgstr ""

#: ../../java/persistence.rst:765
msgid "Implementing an EventAdapter is rather stright forward:"
msgstr ""

#: ../../java/persistence.rst:769
msgid ""
"Then in order for it to be used on events coming to and from the journal you"
" must bind it using the below configuration syntax:"
msgstr ""

#: ../../java/persistence.rst:773
msgid ""
"It is possible to bind multiple adapters to one class *for recovery*, in "
"which case the ``fromJournal`` methods of all bound adapters will be applied"
" to a given matching event (in order of definition in the configuration). "
"Since each adapter may return from ``0`` to ``n`` adapted events (called as "
"``EventSeq``), each adapter can investigate the event and if it should "
"indeed adapt it return the adapted event(s) for it. Other adapters which do "
"not have anything to contribute during this adaptation simply return "
"``EventSeq.empty``. The adapted events are then delivered in-order to the "
"``PersistentActor`` during replay."
msgstr ""

#: ../../java/persistence.rst:780 ../../java/persistence.rst:1054
msgid ""
"For more advanced schema evolution techniques refer to the :ref"
":`persistence-schema-evolution-scala` documentation."
msgstr ""

#: ../../java/persistence.rst:783
msgid "Storage plugins"
msgstr ""

#: ../../java/persistence.rst:785
msgid ""
"Storage backends for journals and snapshot stores are pluggable in the Akka "
"persistence extension."
msgstr ""

#: ../../java/persistence.rst:787
msgid ""
"A directory of persistence journal and snapshot store plugins is available "
"at the Akka Community Projects page, see `Community plugins`_"
msgstr ""

#: ../../java/persistence.rst:789
msgid ""
"Plugins can be selected either by \"default\", for all persistent actors and"
" views, or \"individually\", when a persistent actor or view defines its own"
" set of plugins."
msgstr ""

#: ../../java/persistence.rst:792
msgid ""
"When a persistent actor or view does NOT override the ``journalPluginId`` "
"and ``snapshotPluginId`` methods, the persistence extension will use the "
"\"default\" journal and snapshot-store plugins configured in the "
"``reference.conf``::"
msgstr ""

#: ../../java/persistence.rst:798
msgid ""
"However, these entries are provided as empty \"\", and require explicit user"
" configuration via override in the user ``application.conf``. For an example"
" of a journal plugin which writes messages to LevelDB see :ref:`local-"
"leveldb-journal-java`. For an example of a snapshot store plugin which "
"writes snapshots as individual files to the local filesystem see :ref"
":`local-snapshot-store-java`."
msgstr ""

#: ../../java/persistence.rst:802
msgid ""
"Applications can provide their own plugins by implementing a plugin API and "
"activating them by configuration. Plugin development requires the following "
"imports:"
msgstr ""

#: ../../java/persistence.rst:808
msgid "Eager initialization of persistence plugin"
msgstr ""

#: ../../java/persistence.rst:810
msgid ""
"By default, persistence plugins are started on-demand, as they are used. In "
"some case, however, it might be beneficial to start a certain plugin "
"eagerly. In order to do that, you should first add the "
"``akka.persistence.Persistence`` under the ``akka.extensions`` key. Then, "
"specify the IDs of plugins you wish to start automatically under "
"``akka.persistence.journal.auto-start-journals`` and ``akka.persistence"
".snapshot-store.auto-start-snapshot-stores``."
msgstr ""

#: ../../java/persistence.rst:818
msgid "Journal plugin API"
msgstr ""

#: ../../java/persistence.rst:820
msgid "A journal plugin extends ``AsyncWriteJournal``."
msgstr ""

#: ../../java/persistence.rst:822
msgid ""
"``AsyncWriteJournal`` is an actor and the methods to be implemented are:"
msgstr ""

#: ../../java/persistence.rst:826
msgid ""
"If the storage backend API only supports synchronous, blocking writes, the "
"methods should be implemented as:"
msgstr ""

#: ../../java/persistence.rst:830
msgid ""
"A journal plugin must also implement the methods defined in "
"``AsyncRecovery`` for replays and sequence number recovery:"
msgstr ""

#: ../../java/persistence.rst:834
msgid ""
"A journal plugin can be activated with the following minimal configuration:"
msgstr ""

#: ../../java/persistence.rst:838 ../../java/persistence.rst:861
msgid ""
"The specified plugin ``class`` must have a no-arg constructor. The ``plugin-"
"dispatcher`` is the dispatcher used for the plugin actor. If not specified, "
"it defaults to ``akka.persistence.dispatchers.default-plugin-dispatcher``."
msgstr ""

#: ../../java/persistence.rst:841
msgid ""
"The journal plugin instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may delegate "
"to asynchronous libraries, spawn futures, or delegate to other actors to "
"achive parallelism."
msgstr ""

#: ../../java/persistence.rst:845
msgid ""
"The journal plugin class must have a constructor without parameters or a "
"constructor with one ``com.typesafe.config.Config`` parameter. The plugin "
"section of the actor system's config will be passed in the config "
"constructor parameter."
msgstr ""

#: ../../java/persistence.rst:848
msgid ""
"Don't run journal tasks/futures on the system default dispatcher, since that"
" might starve other tasks."
msgstr ""

#: ../../java/persistence.rst:851
msgid "Snapshot store plugin API"
msgstr ""

#: ../../java/persistence.rst:853
msgid ""
"A snapshot store plugin must extend the ``SnapshotStore`` actor and "
"implement the following methods:"
msgstr ""

#: ../../java/persistence.rst:857
msgid ""
"A snapshot store plugin can be activated with the following minimal "
"configuration:"
msgstr ""

#: ../../java/persistence.rst:864
msgid ""
"The snapshot store instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may delegate "
"to asynchronous libraries, spawn futures, or delegate to other actors to "
"achive parallelism."
msgstr ""

#: ../../java/persistence.rst:868
msgid ""
"The snapshot store plugin class must have a constructor without parameters "
"or constructor with one ``com.typesafe.config.Config`` parameter. The plugin"
" section of the actor system's config will be passed in the config "
"constructor parameter."
msgstr ""

#: ../../java/persistence.rst:871
msgid ""
"Don't run snapshot store tasks/futures on the system default dispatcher, "
"since that might starve other tasks."
msgstr ""

#: ../../java/persistence.rst:874
msgid "Plugin TCK"
msgstr ""

#: ../../java/persistence.rst:875
msgid ""
"In order to help developers build correct and high quality storage plugins, "
"we provide a Technology Compatibility Kit (`TCK "
"<http://en.wikipedia.org/wiki/Technology_Compatibility_Kit>`_ for short)."
msgstr ""

#: ../../java/persistence.rst:877
msgid ""
"The TCK is usable from Java as well as Scala projects. For Java you need to "
"include the akka-persistence-tck dependency::"
msgstr ""

#: ../../java/persistence.rst:886
msgid ""
"To include the Journal TCK tests in your test suite simply extend the "
"provided ``JavaJournalSpec``:"
msgstr ""

#: ../../java/persistence.rst:890
msgid ""
"Please note that some of the tests are optional, and by overriding the "
"``supports...`` methods you give the TCK the needed information about which "
"tests to run. You can implement these methods using  the provided "
"``CapabilityFlag.on`` / ``CapabilityFlag.off`` values."
msgstr ""

#: ../../java/persistence.rst:894
msgid ""
"We also provide a simple benchmarking class ``JavaJournalPerfSpec`` which "
"includes all the tests that ``JavaJournalSpec`` has, and also performs some "
"longer operations on the Journal while printing its performance stats. While"
" it is NOT aimed to provide a proper benchmarking environment it can be used"
" to get a rough feel about your journal's performance in the most typical "
"scenarios."
msgstr ""

#: ../../java/persistence.rst:899
msgid ""
"In order to include the ``SnapshotStore`` TCK tests in your test suite "
"simply extend the ``SnapshotStoreSpec``:"
msgstr ""

#: ../../java/persistence.rst:903
msgid ""
"In case your plugin requires some setting up (starting a mock database, "
"removing temporary files etc.) you can override the ``beforeAll`` and "
"``afterAll`` methods to hook into the tests lifecycle:"
msgstr ""

#: ../../java/persistence.rst:908
msgid ""
"We *highly recommend* including these specifications in your test suite, as "
"they cover a broad range of cases you might have otherwise forgotten to test"
" for when writing a plugin from scratch."
msgstr ""

#: ../../java/persistence.rst:912
msgid "Pre-packaged plugins"
msgstr ""

#: ../../java/persistence.rst:917
msgid "Local LevelDB journal"
msgstr ""

#: ../../java/persistence.rst:919
msgid ""
"The LevelDB journal plugin config entry is "
"``akka.persistence.journal.leveldb``. It writes messages to a local LevelDB "
"instance. Enable this plugin by defining config property:"
msgstr ""

#: ../../java/persistence.rst:924
msgid ""
"LevelDB based plugins will also require the following additional dependency "
"declaration::"
msgstr ""

#: ../../java/persistence.rst:937
msgid ""
"The default location of the LevelDB files is a directory named ``journal`` "
"in the current working directory. This location can be changed by "
"configuration where the specified path can be relative or absolute:"
msgstr ""

#: ../../java/persistence.rst:942
msgid ""
"With this plugin, each actor system runs its own private LevelDB instance."
msgstr ""

#: ../../java/persistence.rst:947
msgid "Shared LevelDB journal"
msgstr ""

#: ../../java/persistence.rst:949
msgid ""
"A LevelDB instance can also be shared by multiple actor systems (on the same"
" or on different nodes). This, for example, allows persistent actors to "
"failover to a backup node and continue using the shared journal instance "
"from the backup node."
msgstr ""

#: ../../java/persistence.rst:955
msgid ""
"A shared LevelDB instance is a single point of failure and should therefore "
"only be used for testing purposes. Highly-available, replicated journals are"
" available as `Community plugins`_."
msgstr ""

#: ../../java/persistence.rst:960
msgid ""
"This plugin has been supplanted by :ref:`Persistence Plugin Proxy"
"<persistence-plugin-proxy-java>`."
msgstr ""

#: ../../java/persistence.rst:962
msgid ""
"A shared LevelDB instance is started by instantiating the "
"``SharedLeveldbStore`` actor."
msgstr ""

#: ../../java/persistence.rst:966
msgid ""
"By default, the shared instance writes journaled messages to a local "
"directory named ``journal`` in the current working directory. The storage "
"location can be changed by configuration:"
msgstr ""

#: ../../java/persistence.rst:971
msgid ""
"Actor systems that use a shared LevelDB store must activate the "
"``akka.persistence.journal.leveldb-shared`` plugin."
msgstr ""

#: ../../java/persistence.rst:976
msgid ""
"This plugin must be initialized by injecting the (remote) "
"``SharedLeveldbStore`` actor reference. Injection is done by calling the "
"``SharedLeveldbJournal.setStore`` method with the actor reference as "
"argument."
msgstr ""

#: ../../java/persistence.rst:981
msgid ""
"Internal journal commands (sent by persistent actors) are buffered until "
"injection completes. Injection is idempotent i.e. only the first injection "
"is used."
msgstr ""

#: ../../java/persistence.rst:987
msgid "Local snapshot store"
msgstr ""

#: ../../java/persistence.rst:989
msgid ""
"The local snapshot store plugin config entry is ``akka.persistence.snapshot-"
"store.local``. It writes snapshot files to the local filesystem. Enable this"
" plugin by defining config property:"
msgstr ""

#: ../../java/persistence.rst:994
msgid ""
"The default storage location is a directory named ``snapshots`` in the "
"current working directory. This can be changed by configuration where the "
"specified path can be relative or absolute:"
msgstr ""

#: ../../java/persistence.rst:999
msgid ""
"Note that it is not mandatory to specify a snapshot store plugin. If you "
"don't use snapshots you don't have to configure it."
msgstr ""

#: ../../java/persistence.rst:1005
msgid "Persistence Plugin Proxy"
msgstr ""

#: ../../java/persistence.rst:1007
msgid ""
"A persistence plugin proxy allows sharing of journals and snapshot stores "
"across multiple actor systems (on the same or on different nodes). This, for"
" example, allows persistent actors to failover to a backup node and continue"
" using the shared journal instance from the backup node. The proxy works by "
"forwarding all the journal/snapshot store messages to a single, shared, "
"persistence plugin instance, and therefor supports any use case supported by"
" the proxied plugin."
msgstr ""

#: ../../java/persistence.rst:1014
msgid ""
"A shared journal/snapshot store is a single point of failure and should "
"therefore only be used for testing purposes. Highly-available, replicated "
"persistence plugins are available as `Community plugins`_."
msgstr ""

#: ../../java/persistence.rst:1017
msgid ""
"The journal and snapshot store proxies are controlled via the "
"``akka.persistence.journal.proxy`` and ``akka.persistence.snapshot-"
"store.proxy`` configuration entries, respectively. Set the ``target-journal-"
"plugin`` or ``target-snapshot-store-plugin`` keys to the underlying plugin "
"you wish to use (for example: ``akka.persistence.journal.leveldb``). The "
"``start-target-journal`` and ``start-target-snapshot-store`` keys should be "
"set to ``on`` in exactly one actor system - this is the system that will "
"instantiate the shared persistence plugin. Next, the proxy needs to be told "
"how to find the shared plugin. This can be done by setting the ``target-"
"journal-address`` and ``target-snapshot-store-address`` configuration keys, "
"or programmatically by calling the "
"``PersistencePluginProxy.setTargetLocation`` method."
msgstr ""

#: ../../java/persistence.rst:1028
msgid ""
"Akka starts extensions lazily when they are required, and this includes the "
"proxy. This means that in order for the proxy to work, the persistence "
"plugin on the target node must be instantiated. This can be done by "
"instantiating the ``PersistencePluginProxyExtension`` :ref:`extension"
"<extending-akka-java>`, or by calling the ``PersistencePluginProxy.start`` "
"method."
msgstr ""

#: ../../java/persistence.rst:1034
msgid ""
"The proxied persistence plugin can (and should) be configured using its "
"original configuration keys."
msgstr ""

#: ../../java/persistence.rst:1040
msgid "Custom serialization"
msgstr ""

#: ../../java/persistence.rst:1042
msgid ""
"Serialization of snapshots and payloads of ``Persistent`` messages is "
"configurable with Akka's :ref:`serialization-java` infrastructure. For "
"example, if an application wants to serialize"
msgstr ""

#: ../../java/persistence.rst:1045
msgid ""
"payloads of type ``MyPayload`` with a custom ``MyPayloadSerializer`` and"
msgstr ""

#: ../../java/persistence.rst:1046
msgid ""
"snapshots of type ``MySnapshot`` with a custom ``MySnapshotSerializer``"
msgstr ""

#: ../../java/persistence.rst:1048
msgid "it must add"
msgstr ""

#: ../../java/persistence.rst:1052
msgid ""
"to the application configuration. If not specified, a default serializer is "
"used."
msgstr ""

#: ../../java/persistence.rst:1057
msgid "Testing"
msgstr ""

#: ../../java/persistence.rst:1059
msgid ""
"When running tests with LevelDB default settings in ``sbt``, make sure to "
"set ``fork := true`` in your sbt project. Otherwise, you'll see an "
"``UnsatisfiedLinkError``. Alternatively, you can switch to a LevelDB Java "
"port by setting"
msgstr ""

#: ../../java/persistence.rst:1064
msgid "or"
msgstr ""

#: ../../java/persistence.rst:1068
msgid ""
"in your Akka configuration. The LevelDB Java port is for testing purposes "
"only."
msgstr ""

#: ../../java/persistence.rst:1071
msgid ""
"It is not possible to test persistence provided classes (i.e. "
":ref:`PersistentActor <event-sourcing-java>` and :ref:`AtLeastOnceDelivery "
"<at-least-once-delivery-java>`) using ``TestActorRef`` due to its "
"*synchronous* nature. These traits need to be able to perform asynchronous "
"tasks in the background in order to handle internal persistence related "
"events."
msgstr ""

#: ../../java/persistence.rst:1076
msgid ""
"When testing Persistence based projects always rely on :ref:`asynchronous "
"messaging using the TestKit <async-integration-testing-java>`."
msgstr ""

#: ../../java/persistence.rst:1079
msgid "Configuration"
msgstr ""

#: ../../java/persistence.rst:1081
msgid ""
"There are several configuration properties for the persistence module, "
"please refer to the :ref:`reference configuration <config-akka-"
"persistence>`."
msgstr ""

#: ../../java/persistence.rst:1085
msgid "Multiple persistence plugin configurations"
msgstr ""

#: ../../java/persistence.rst:1087
msgid ""
"By default, a persistent actor or view will use the \"default\" journal and "
"snapshot store plugins configured in the following sections of the "
"``reference.conf`` configuration resource:"
msgstr ""

#: ../../java/persistence.rst:1092
msgid ""
"Note that in this case the actor or view overrides only ``persistenceId`` "
"method:"
msgstr ""

#: ../../java/persistence.rst:1096
msgid ""
"When a persistent actor or view overrides the ``journalPluginId`` and "
"``snapshotPluginId`` methods, the actor or view will be serviced by these "
"specific persistence plugins instead of the defaults:"
msgstr ""

#: ../../java/persistence.rst:1101
msgid ""
"Note that ``journalPluginId`` and ``snapshotPluginId`` must refer to "
"properly configured ``reference.conf`` plugin entries with a standard "
"``class`` property as well as settings which are specific for those plugins,"
" i.e.:"
msgstr ""
