# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Takaichi Kubo <tk.qubo@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../java/stream/stream-introduction.rst:5
msgid "Introduction"
msgstr "イントロダクション"

#: ../../java/stream/stream-introduction.rst:8
msgid "Motivation"
msgstr "モチベーション"

#: ../../java/stream/stream-introduction.rst:10
msgid ""
"The way we consume services from the Internet today includes many instances "
"of streaming data, both downloading from a service as well as uploading to "
"it or peer-to-peer data transfers. Regarding data as a stream of elements "
"instead of in its entirety is very useful because it matches the way "
"computers send and receive them (for example via TCP), but it is often also "
"a necessity because data sets frequently become too large to be handled as a"
" whole. We spread computations or analyses over large clusters and call it "
"“big data”, where the whole principle of processing them is by feeding those"
" data sequentially—as a stream—through some CPUs."
msgstr ""
"今日わたしたちがインターネット上のサービスを利用する際、連続的なデータのダウンロードやアップロード、そしてピアツーピアのデータ通信を扱うことが増えてきています。データを全体としてではなく、連続した要素(ストリーム)として捉えることは非常に有用です。これはコンピュータが"
" TCP "
"などを経由してデータの送受信を行うやり方と一致しています。さらにデータセットがあまりにも巨大になり、それをひとかたまりのものとして処理できない場合、ストリームという考え方は欠かせなくなります。我々は計算処理や分析を巨大なクラスタ上に展開しそれを「ビッグデータ」と呼んでいます。ここでは複数の"
" CPU を通して、データをシーケンシャルに、ストリームとして流しこむことがデータ処理の基本原則となっています。"

#: ../../java/stream/stream-introduction.rst:20
msgid ""
"Actors can be seen as dealing with streams as well: they send and receive "
"series of messages in order to transfer knowledge (or data) from one place "
"to another. We have found it tedious and error-prone to implement all the "
"proper measures in order to achieve stable streaming between actors, since "
"in addition to sending and receiving we also need to take care to not "
"overflow any buffers or mailboxes in the process. Another pitfall is that "
"Actor messages can be lost and must be retransmitted in that case lest the "
"stream have holes on the receiving side. When dealing with streams of "
"elements of a fixed given type, Actors also do not currently offer good "
"static guarantees that no wiring errors are made: type-safety could be "
"improved in this case."
msgstr ""
"アクターも同様にストリームを扱うものとして捉えることができます。何故ならアクターは知識(あるいはデータ)をある場所から別の場所へ移すために、一連のメッセージを送受信しているからです。しかしアクター間のストリーミングの安定化を実現するには、メッセージの送受信に加えて処理中のバッファやメールボックスがオーバーフローを起こさないよう対処しなければいけません。その実装は厄介で、エラーを引き起こしがちなものとなってしまいます。それに加えて、アクターのメッセージは消失することがあるため、受信側に穴あきのストリームが発生しないような再送信の仕組みが必要です。さらに、決められた型をもつ要素のストリームを扱う場合、アクターは現在のところ、正しい型でメッセージの送受信が行われているかを静的に保証する術を持っていないのです。ここではより厳密な型安全が求められます。"

#: ../../java/stream/stream-introduction.rst:31
msgid ""
"For these reasons we decided to bundle up a solution to these problems as an"
" Akka Streams API. The purpose is to offer an intuitive and safe way to "
"formulate stream processing setups such that we can then execute them "
"efficiently and with bounded resource usage—no more OutOfMemoryErrors. In "
"order to achieve this our streams need to be able to limit the buffering "
"that they employ, they need to be able to slow down producers if the "
"consumers cannot keep up. This feature is called back-pressure and is at the"
" core of the `Reactive Streams`_ initiative of which Akka is a founding "
"member. For you this means that the hard problem of propagating and reacting"
" to back-pressure has been incorporated in the design of Akka Streams "
"already, so you have one less thing to worry about; it also means that Akka "
"Streams interoperate seamlessly with all other Reactive Streams "
"implementations (where Reactive Streams interfaces define the "
"interoperability SPI while implementations like Akka Streams offer a nice "
"user API)."
msgstr ""
"そういったわけで、我々はこれらの問題に対するソリューションを Akka Stream API として統合することにしました。Akka Stream "
"API "
"は、ストリーム処理に必要な機構を、直感的かつ安全なやり方で構築する仕組みを提供します。この仕組みのもとで、ストリーム処理を効率的に、そして限られたリソースのもとで実行することができるのです。もはや"
" OutOfMemoryErrors "
"の心配をする必要はありません。これを実現するために、ストリームはそのバッファリングを制御する必要があります。つまり消費者側が処理しきれないような場合に生産者側がスピードを落とすことができないといけないのです。この仕組みはバックプレッシャーと呼ばれ、Akka"
" が設立メンバーである `Reactive Streams` "
"イニシアチブの核ともなっています。そういった意味では、バックプレッシャーをどう伝播しそれに応答するかという困難な問題は、Akka Stream "
"の設計の中にすでに組み込まれているため、課題は一つクリアされたとも言えるでしょう。また、Reactive Stream "
"のインターフェースがインターオペラビリティをもった SPI である一方で、その実装の一つとして Akka Stream が使い勝手の良いユーザー API"
" を提供しています。つまり Akka Stream は他の全ての Reactive Stream 実装とシームレスに相互運用が可能なのです。"

#: ../../java/stream/stream-introduction.rst:49
msgid "Relationship with Reactive Streams"
msgstr "Reactive Stream との関連について"

#: ../../java/stream/stream-introduction.rst:51
msgid ""
"The Akka Streams API is completely decoupled from the Reactive Streams "
"interfaces. While Akka Streams focus on the formulation of transformations "
"on data streams the scope of Reactive Streams is just to define a common "
"mechanism of how to move data across an asynchronous boundary without "
"losses, buffering or resource exhaustion."
msgstr ""
"Akka Stream API は Reactive Stream のインターフェースとは完全に切り離されています。Akka Stream "
"がデータストリームにおける変換処理の定式化を重視する一方で、Reactive Stream "
"のスコープは、データの消失、バッファリング、リソース枯渇を引き起こさずに、非同期境界をまたがってデータを移動させるための共通のメカニズムを定義しているにとどまっています。"

#: ../../java/stream/stream-introduction.rst:57
msgid ""
"The relationship between these two is that the Akka Streams API is geared "
"towards end-users while the Akka Streams implementation uses the Reactive "
"Streams interfaces internally to pass data between the different processing "
"stages. For this reason you will not find any resemblance between the "
"Reactive Streams interfaces and the Akka Streams API. This is in line with "
"the expectations of the Reactive Streams project, whose primary purpose is "
"to define interfaces such that different streaming implementation can "
"interoperate; it is not the purpose of Reactive Streams to describe an end-"
"user API."
msgstr ""
"この二者は、Akka Stream API がエンドユーザーを対象としているのに対して、 Akka Stream "
"実装が異なるプロセシングステージへデータを渡すために内部的に Reactive Stream "
"のインターフェースを利用しているという関係になっています。そのため、Reactive Stream のインターフェースと Akka Stream API"
" の間には、何の類似性も見いだせないことでしょう。しかしこれは Reactive Stream "
"プロジェクトの意図に反するものではありません。Reactive Stream "
"の第一の目的は異なるストリーミング実装でも相互運用できるようなインターフェースを定義することであり、エンドユーザー API "
"を記述することではないのです。"

#: ../../java/stream/stream-introduction.rst:68
msgid "How to read these docs"
msgstr "ドキュメンテーションの読み方"

#: ../../java/stream/stream-introduction.rst:70
msgid ""
"Stream processing is a different paradigm to the Actor Model or to Future "
"composition, therefore it may take some careful study of this subject until "
"you feel familiar with the tools and techniques. The documentation is here "
"to help and for best results we recommend the following approach:"
msgstr ""
"ストリーミング処理はアクターモデルや Future "
"合成とは異なったパラダイムであり、その道具立てや技術に慣れるまでは、ある程度の学習を要することになると思われます。そのための手助けとしてドキュメンテーションを用意していますが、こを十二分に役立てるためには、以下の指針を参考にされると良いでしょう。"

#: ../../java/stream/stream-introduction.rst:75
msgid ""
"Read the :ref:`stream-quickstart-java` to get a feel for how streams look "
"like and what they can do."
msgstr ""

#: ../../java/stream/stream-introduction.rst:77
msgid ""
"The top-down learners may want to peruse the :ref:`stream-design` at this "
"point."
msgstr "順番に物事を理解してゆきたい方には、:ref:`stream-design` を精読することをお勧めします。"

#: ../../java/stream/stream-introduction.rst:79
msgid ""
"The bottom-up learners may feel more at home rummaging through the :ref"
":`stream-cookbook-java`."
msgstr ""

#: ../../java/stream/stream-introduction.rst:81
msgid ""
"For a complete overview of the built-in processing stages you can look at "
"the table in :ref:`stages-overview_java`"
msgstr ""

#: ../../java/stream/stream-introduction.rst:83
msgid ""
"The other sections can be read sequentially or as needed during the previous"
" steps, each digging deeper into specific topics."
msgstr ""
"その他のセクションは順番に読んでも、必要に応じて読んでいってもどちらでも構いません。各セクションでは特定のトピックについて掘り下げてゆきます。"
