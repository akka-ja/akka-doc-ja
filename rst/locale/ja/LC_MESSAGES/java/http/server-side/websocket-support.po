# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-04 02:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../java/http/server-side/websocket-support.rst:4
msgid "Server-Side WebSocket Support"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:6
msgid ""
"WebSocket is a protocol that provides a bi-directional channel between "
"browser and webserver usually run over an upgraded HTTP(S) connection. Data "
"is exchanged in messages whereby a message can either be binary data or "
"unicode text."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:9
msgid ""
"Akka HTTP provides a stream-based implementation of the WebSocket protocol "
"that hides the low-level details of the underlying binary framing wire-"
"protocol and provides a simple API to implement services using WebSocket."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:14
msgid "Model"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:16
msgid ""
"The basic unit of data exchange in the WebSocket protocol is a message. A "
"message can either be binary message, i.e. a sequence of octets or a text "
"message, i.e. a sequence of unicode code points."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:19
msgid ""
"In the data model the two kinds of messages, binary and text messages, are "
"represented by the two classes ``BinaryMessage`` and ``TextMessage`` "
"deriving from a common superclass ``Message``. The superclass ``Message`` "
"contains ``isText`` and ``isBinary`` methods to distinguish a message and "
"``asBinaryMessage`` and ``asTextMessage`` methods to cast a message."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:24
msgid ""
"The subclasses ``BinaryMessage`` and ``TextMessage`` contain methods to "
"access the data. Take the API of ``TextMessage`` as an example "
"(``BinaryMessage`` is very similar with ``String`` replaced by "
"``ByteString``):"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:30
msgid ""
"The data of a message is provided as a stream because WebSocket messages do "
"not have a predefined size and could (in theory) be infinitely long. "
"However, only one message can be open per direction of the WebSocket "
"connection, so that many application level protocols will want to make use "
"of the delineation into (small) messages to transport single application-"
"level data units like \"one event\" or \"one chat message\"."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:35
msgid ""
"Many messages are small enough to be sent or received in one go. As an "
"opportunity for optimization, the model provides the notion of a \"strict\" "
"message to represent cases where a whole message was received in one go. If "
"``TextMessage.isStrict`` returns true, the complete data is already "
"available and can be accessed with ``TextMessage.getStrictText`` "
"(analogously for ``BinaryMessage``)."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:40
msgid ""
"When receiving data from the network connection the WebSocket implementation"
" tries to create a strict message whenever possible, i.e. when the complete "
"data was received in one chunk. However, the actual chunking of messages "
"over a network connection and through the various streaming abstraction "
"layers is not deterministic from the perspective of the application. "
"Therefore, application code must be able to handle both streamed and strict "
"messages and not expect certain messages to be strict. (Particularly, note "
"that tests against ``localhost`` will behave differently than tests against "
"remote peers where data is received over a physical network connection.)"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:47
msgid ""
"For sending data, you can use the static ``TextMessage.create(String)`` "
"method to create a strict message if the complete message has already been "
"assembled. Otherwise, use ``TextMessage.create(Source<String, ?>)`` to "
"create a streaming message from an Akka Stream source."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:53
msgid "Server API"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:55
msgid ""
"The entrypoint for the WebSocket API is the synthetic ``UpgradeToWebSocket``"
" header which is added to a request if Akka HTTP encounters a WebSocket "
"upgrade request."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:58
msgid ""
"The WebSocket specification mandates that details of the WebSocket "
"connection are negotiated by placing special-purpose HTTP-headers into "
"request and response of the HTTP upgrade. In Akka HTTP these HTTP-level "
"details of the WebSocket handshake are hidden from the application and don't"
" need to be managed manually."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:62
msgid ""
"Instead, the synthetic ``UpgradeToWebSocket`` represents a valid WebSocket "
"upgrade request. An application can detect a WebSocket upgrade request by "
"looking for the ``UpgradeToWebSocket`` header. It can choose to accept the "
"upgrade and start a WebSocket connection by responding to that request with "
"an ``HttpResponse`` generated by one of the "
"``UpgradeToWebSocket.handleMessagesWith`` methods. In its most general form "
"this method expects two arguments: first, a handler ``Flow<Message, Message,"
" ?>`` that will be used to handle WebSocket messages on this connection. "
"Second, the application can optionally choose one of the proposed "
"application-level sub-protocols by inspecting the values of "
"``UpgradeToWebSocket.getRequestedProtocols`` and pass the chosen protocol "
"value to ``handleMessagesWith``."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:71
msgid "Handling Messages"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:73
msgid ""
"A message handler is expected to be implemented as a ``Flow<Message, "
"Message, ?>``. For typical request-response scenarios this fits very well "
"and such a ``Flow`` can be constructed from a simple function by using "
"``Flow.<Message>create().map`` or ``Flow.<Message>create().mapAsync``."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:77
msgid ""
"There are other use-cases, e.g. in a server-push model, where a server "
"message is sent spontaneously, or in a true bi-directional scenario where "
"input and output aren't logically connected. Providing the handler as a "
"``Flow`` in these cases may not fit. An overload of "
"``UpgradeToWebSocket.handleMessagesWith`` is provided, instead, which allows"
" to pass an output-generating ``Source<Message, ?>`` and an input-receiving "
"``Sink<Message, ?>`` independently."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:82
msgid ""
"Note that a handler is required to consume the data stream of each message "
"to make place for new messages. Otherwise, subsequent messages may be stuck "
"and message traffic in this direction will stall."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:86
msgid "Example"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:88
msgid "Let's look at an example_."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:90
msgid ""
"WebSocket requests come in like any other requests. In the example, requests"
" to ``/greeter`` are expected to be WebSocket requests:"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:96
msgid ""
"It uses a helper method "
"``akka.http.javadsl.model.ws.WebSocket.handleWebSocketRequestWith`` which "
"can be used if only WebSocket requests are expected. The method looks for "
"the ``UpgradeToWebSocket`` header and returns a response that will install "
"the passed WebSocket handler if the header is found. If the request is no "
"WebSocket request it will return a ``400 Bad Request`` error response."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:101
msgid ""
"In the example, the passed handler expects text messages where each message "
"is expected to contain (a person's) name and then responds with another text"
" message that contains a greeting:"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:108
msgid ""
"Inactive WebSocket connections will be dropped according to the :ref:`idle-"
"timeout settings <idle-timeouts-java>`. In case you need to keep inactive "
"connections alive, you can either tweak your idle-timeout or inject 'keep-"
"alive' messages regularly."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:113
msgid "Routing support"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:115
msgid ""
"The routing DSL provides the ``handleWebSocketMessages`` directive to "
"install a WebSocket handler if a request is a WebSocket request. Otherwise, "
"the directive rejects the request."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:118
msgid ""
"Let's look at how the above example can be rewritten using the high-level "
"routing DSL."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:120
msgid ""
"Instead of writing the request handler manually, the routing behavior of the"
" app is defined by a route that uses the ``handleWebSocketRequests`` "
"directive in place of the ``WebSocket.handleWebSocketRequestWith``:"
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:126
msgid ""
"The handling code itself will be the same as with using the low-level API."
msgstr ""

#: ../../java/http/server-side/websocket-support.rst:128
msgid "See the `full routing example`_."
msgstr ""
