# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2016, Lightbend Inc
# This file is distributed under the same license as the Akka package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Akka @version@\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-16 19:40\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Atsushi Araki <senalove2007@gmail.com>, 2016\n"
"Language-Team: Japanese (https://www.transifex.com/akka-ja/teams/67802/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

# cb0276fb3ea340cb8fac36860a84c63c
#: ../../java.rst:4
msgid "Java Documentation"
msgstr ""

# 3b7aec8fa5df4887a249f45a414ca1d5
#: ../../java/agents.rst:5
msgid "Agents"
msgstr ""

# 7a97032e89e64b95a01cb5c9a2bb1d4c
#: ../../java/agents.rst:7
msgid "Agents in Akka are inspired by `agents in Clojure`_."
msgstr ""

# 34cb253f64d54128b2cfaa47dd04da1c
#: ../../java/agents.rst:11
msgid ""
"Agents provide asynchronous change of individual locations. Agents are bound"
" to a single storage location for their lifetime, and only allow mutation of"
" that location (to a new state) to occur as a result of an action. Update "
"actions are functions that are asynchronously applied to the Agent's state "
"and whose return value becomes the Agent's new state. The state of an Agent "
"should be immutable."
msgstr ""

# 6372847e402149769352fbe267280840
#: ../../java/agents.rst:17
msgid ""
"While updates to Agents are asynchronous, the state of an Agent is always "
"immediately available for reading by any thread (using ``get``) without any "
"messages."
msgstr ""

# 1858499fbeb340df8f10e3d3ab01c063
#: ../../java/agents.rst:20
msgid ""
"Agents are reactive. The update actions of all Agents get interleaved "
"amongst threads in an ``ExecutionContext``. At any point in time, at most "
"one ``send`` action for each Agent is being executed. Actions dispatched to "
"an agent from another thread will occur in the order they were sent, "
"potentially interleaved with actions dispatched to the same agent from other"
" threads."
msgstr ""

# 50a2004ffe9e41b0a5bfc29c53d05abe
#: ../../java/agents.rst:29
msgid "Creating Agents"
msgstr ""

# 96da0b4aab7343ba950b56391101bf3b
#: ../../java/agents.rst:31
msgid ""
"Agents are created by invoking ``new Agent<ValueType>(value, "
"executionContext)`` – passing in the Agent's initial value and providing an "
"``ExecutionContext`` to be used for it:"
msgstr ""

# f3b0ea4680584f7bb29d6ffcb5bfe4a1
#: ../../java/agents.rst:39
msgid "Reading an Agent's value"
msgstr ""

# c021642eb3ca46dd81a5ba1c572e106d
#: ../../java/agents.rst:41
msgid ""
"Agents can be dereferenced (you can get an Agent's value) by invoking the "
"Agent with ``get()`` like this:"
msgstr ""

# c5cb04d9e6264b9e9043a7b1d70ba43c
#: ../../java/agents.rst:47
msgid ""
"Reading an Agent's current value does not involve any message passing and "
"happens immediately. So while updates to an Agent are asynchronous, reading "
"the state of an Agent is synchronous."
msgstr ""

# 814ebb2a40364f0187073fbbcb575896
#: ../../java/agents.rst:51
msgid ""
"You can also get a ``Future`` to the Agents value, that will be completed "
"after the currently queued updates have completed:"
msgstr ""

# f87fcd3178f9449f9c04d1a2febd7f4b
#: ../../java/agents.rst:58
msgid "See :ref:`futures-java` for more information on ``Futures``."
msgstr ""

# b008a373e0e34045a880402ef5030e24
#: ../../java/agents.rst:61
msgid "Updating Agents (send & alter)"
msgstr ""

# ce1c16429f334b8bad4ad30a764df4cc
#: ../../java/agents.rst:63
msgid ""
"You update an Agent by sending a function (``akka.dispatch.Mapper``) that "
"transforms the current value or by sending just a new value. The Agent will "
"apply the new value or function atomically and asynchronously. The update is"
" done in a fire-forget manner and you are only guaranteed that it will be "
"applied. There is no guarantee of when the update will be applied but "
"dispatches to an Agent from a single thread will occur in order. You apply a"
" value or a function by invoking the ``send`` function."
msgstr ""

# 8d66150a3a4947b59c72a50d23ce022c
#: ../../java/agents.rst:75
msgid ""
"You can also dispatch a function to update the internal state but on its own"
" thread. This does not use the reactive thread pool and can be used for "
"long-running or blocking operations. You do this with the ``sendOff`` "
"method. Dispatches using either ``sendOff`` or ``send`` will still be "
"executed in order."
msgstr ""

# f674653ab8844f0cbeb95f586e03e521
#: ../../java/agents.rst:85
msgid ""
"All ``send`` methods also have a corresponding ``alter`` method that returns"
" a ``Future``. See :ref:`futures-java` for more information on ``Futures``."
msgstr ""

# d1ab8e08422d4f74966359d49db24ddc
# 2be16143c8cc4be189a1f60d779858dd
# bd2cd30980824b29b1f8c1a00dfdda1a
# 053d74c4d19340c8970b67ab06f26b71
# ef8c61fe3f9c4503b5a47b24345988aa
# 1c2ccbb4f19440f6a2a11b79f0d8af55
# 770c6730226a4f97bcb2ea8ea0b9ab28
# 5eb0cfc49897431c880bfc7821a9d2ce
# cf0e8b4e742346c9bc95c7481ef96308
# c0b77c393caa4f1f97673a2e45d69ced
# e12a8b67a4594a59becfbcadea24382b
# 3ec69dc0cc944fd39cc58f757a0aa794
# 02ae2168392b4863bfe5201314dd890f
#: ../../java/agents.rst:97 ../../java/camel.rst:492
#: ../../java/cluster-client.rst:158 ../../java/cluster-metrics.rst:176
#: ../../java/cluster-sharding.rst:343 ../../java/cluster-singleton.rst:128
#: ../../java/cluster-usage.rst:703 ../../java/distributed-data.rst:516
#: ../../java/http/configuration.rst:4 ../../java/persistence.rst:1040
#: ../../java/persistence-query-leveldb.rst:138
#: ../../java/serialization.rst:18 ../../java/testing.rst:693
msgid "Configuration"
msgstr ""

# 8229663b2d364a66a18073ec9b609c58
#: ../../java/agents.rst:99
msgid ""
"There are several configuration properties for the agents module, please "
"refer to the :ref:`reference configuration <config-akka-agent>`."
msgstr ""

# 38bfbb3220c9490592577aab83b1101a
#: ../../java/agents.rst:103
msgid "Deprecated Transactional Agents"
msgstr ""

# 965df2d1627841a5992ce1c96166a6e2
#: ../../java/agents.rst:105
msgid ""
"Agents participating in enclosing STM transaction is a deprecated feature in"
" 2.3."
msgstr ""

# d11f007b8a7e4147a41a8d00464273f6
#: ../../java/agents.rst:107
msgid ""
"If an Agent is used within an enclosing ``Scala STM transaction``, then it "
"will participate in that transaction. If you send to an Agent within a "
"transaction then the dispatch to the Agent will be held until that "
"transaction commits, and discarded if the transaction is aborted."
msgstr ""

# 665c22de7f6c44eab2882c00c980b453
#: ../../java/camel.rst:6
msgid "Camel"
msgstr ""

# 50dfa4cc1d4c483faa387fd35628a725
# 695c6b51dd7148f0b3c75b6884f92487
# a5eee67038d84a8e8c42128a68d80690
# 0f400bd028a5483e8213aeb821037d72
# 9c25fd3dac2445c0bd167d3751bccaf8
# c683da16b1274bfabc310dca522067f0
#: ../../java/camel.rst:9 ../../java/cluster-metrics.rst:8
#: ../../java/futures.rst:7 ../../java/io.rst:7
#: ../../java/stream/stream-cookbook.rst:8
#: ../../java/stream/stream-introduction.rst:5
msgid "Introduction"
msgstr "イントロダクション"

# 3da82f3db573478db1a5ba79f42d12b3
#: ../../java/camel.rst:11
msgid ""
"The akka-camel module allows Untyped Actors to receive and send messages "
"over a great variety of protocols and APIs. In addition to the native Scala "
"and Java actor API, actors can now exchange messages with other systems over"
" large number of protocols and APIs such as HTTP, SOAP, TCP, FTP, SMTP or "
"JMS, to mention a few. At the moment, approximately 80 protocols and APIs "
"are supported."
msgstr ""

# 6727cbb662f24d0aa1c54be0ec3693e0
#: ../../java/camel.rst:18
msgid "Apache Camel"
msgstr ""

# 92b9c847a1b840beb35bad1df87e41ca
#: ../../java/camel.rst:19
msgid ""
"The akka-camel module is based on `Apache Camel`_, a powerful and light-"
"weight integration framework for the JVM. For an introduction to Apache "
"Camel you may want to read this `Apache Camel article`_. Camel comes with a "
"large number of `components`_ that provide bindings to different protocols "
"and APIs. The `camel-extra`_ project provides further components."
msgstr ""

# 6f6b07786c90417e8638c29b4dea9695
#: ../../java/camel.rst:31
msgid "Consumer"
msgstr ""

# 4c83606ea5dd456e9043034bf86a74b4
#: ../../java/camel.rst:32
msgid "Here's an example of using Camel's integration components in Akka."
msgstr ""

# 73ea305492d64e50a44e4d7ace883798
#: ../../java/camel.rst:36
msgid ""
"The above example exposes an actor over a TCP endpoint via Apache Camel's "
"`Mina component`_. The actor implements the `getEndpointUri` method to "
"define an endpoint from which it can receive messages. After starting the "
"actor, TCP clients can immediately send messages to and receive responses "
"from that actor. If the message exchange should go over HTTP (via Camel's "
"`Jetty component`_), the actor's `getEndpointUri` method should return a "
"different URI, for instance \"jetty:http://localhost:8877/example\". In the "
"above case an extra constructor is added that can set the endpoint URI, "
"which would result in the `getEndpointUri` returning the URI that was set "
"using this constructor."
msgstr ""

# 96f14094cdb442f7bd7eabc0799753c4
#: ../../java/camel.rst:49
msgid "Producer"
msgstr ""

# df92c3e179c048bf94b6133916c6c565
#: ../../java/camel.rst:50
msgid ""
"Actors can also trigger message exchanges with external systems i.e. produce"
" to Camel endpoints."
msgstr ""

# 5546c23fcafb4541a52b7e74309c1153
#: ../../java/camel.rst:55
msgid ""
"In the above example, any message sent to this actor will be sent to the JMS"
" queue ``Orders``. Producer actors may choose from the same set of Camel "
"components as Consumer actors do. Below an example of how to send a message "
"to the Orders producer."
msgstr ""

# 364d0a8514364b8b911e56740eeab7ee
#: ../../java/camel.rst:63
msgid "CamelMessage"
msgstr ""

# 3eeeacb11aae44da9dded81883740bd6
#: ../../java/camel.rst:64
msgid ""
"The number of Camel components is constantly increasing. The akka-camel "
"module can support these in a plug-and-play manner. Just add them to your "
"application's classpath, define a component-specific endpoint URI and use it"
" to exchange messages over the component-specific protocols or APIs. This is"
" possible because Camel components bind protocol-specific message formats to"
" a Camel-specific `normalized message format`__. The normalized message "
"format hides protocol-specific details from Akka and makes it therefore very"
" easy to support a large number of protocols through a uniform Camel "
"component interface. The akka-camel module further converts mutable Camel "
"messages into immutable representations which are used by Consumer and "
"Producer actors for pattern matching, transformation, serialization or "
"storage. In the above example of the Orders Producer, the XML message is put"
" in the body of a newly created Camel Message with an empty set of headers. "
"You can also create a CamelMessage yourself with the appropriate body and "
"headers as you see fit."
msgstr ""

# 1667d597fda148d884a89bafc875c71d
#: ../../java/camel.rst:81
msgid "CamelExtension"
msgstr ""

# f63922c8f661442fad92ce1139dfdb4c
#: ../../java/camel.rst:82
msgid ""
"The akka-camel module is implemented as an Akka Extension, the "
"``CamelExtension`` object. Extensions will only be loaded once per "
"``ActorSystem``, which will be managed by Akka. The ``CamelExtension`` "
"object provides access to the `Camel`_ interface. The `Camel`_ interface in "
"turn provides access to two important Apache Camel objects, the "
"`CamelContext`_ and the `ProducerTemplate`_. Below you can see how you can "
"get access to these Apache Camel objects."
msgstr ""

# 7dc77c34291e48e9ab9d75eac786d30c
#: ../../java/camel.rst:90
msgid ""
"One ``CamelExtension`` is only loaded once for every one ``ActorSystem``, "
"which makes it safe to call the ``CamelExtension`` at any point in your code"
" to get to the Apache Camel objects associated with it. There is one "
"`CamelContext`_ and one `ProducerTemplate`_ for every one ``ActorSystem`` "
"that uses a ``CamelExtension``. By Default, a new `CamelContext`_ is created"
" when the ``CamelExtension`` starts. If you want to inject your own context "
"instead, you can implement the `ContextProvider`_ interface and add the FQCN"
" of your implementation in the config, as the value of the \"akka.camel"
".context-provider\". This interface define a single method ``getContext()`` "
"used to load the `CamelContext`_."
msgstr ""

# 6a260fa6755f41eda641104d687e6441
#: ../../java/camel.rst:98
msgid ""
"Below an example on how to add the ActiveMQ component to the "
"`CamelContext`_, which is required when you would like to use the ActiveMQ "
"component."
msgstr ""

# 8496ad52cdfe443ba9cd54a073d88d1e
#: ../../java/camel.rst:102
msgid ""
"The `CamelContext`_ joins the lifecycle of the ``ActorSystem`` and "
"``CamelExtension`` it is associated with; the `CamelContext`_ is started "
"when the ``CamelExtension`` is created, and it is shut down when the "
"associated ``ActorSystem`` is shut down. The same is true for the "
"`ProducerTemplate`_."
msgstr ""

# b9e50bfff34a4168babc676372c15be6
#: ../../java/camel.rst:105
msgid ""
"The ``CamelExtension`` is used by both `Producer` and `Consumer` actors to "
"interact with Apache Camel internally. You can access the ``CamelExtension``"
" inside a `Producer` or a `Consumer` using the ``camel`` method, or get "
"straight at the `CamelContext` using the ``getCamelContext`` method or to "
"the `ProducerTemplate` using the `getProducerTemplate` method. Actors are "
"created and started asynchronously. When a `Consumer` actor is created, the "
"`Consumer` is published at its Camel endpoint (more precisely, the route is "
"added to the `CamelContext`_ from the `Endpoint`_ to the actor). When a "
"`Producer` actor is created, a `SendProcessor`_ and `Endpoint`_ are created "
"so that the Producer can send messages to it. Publication is done "
"asynchronously; setting up an endpoint may still be in progress after you "
"have requested the actor to be created. Some Camel components can take a "
"while to startup, and in some cases you might want to know when the "
"endpoints are activated and ready to be used. The `Camel`_ interface allows "
"you to find out when the endpoint is activated or deactivated."
msgstr ""

# 49175fb9e6ca4ea198765e0bf2202234
#: ../../java/camel.rst:117
msgid ""
"The above code shows that you can get a ``Future`` to the activation of the "
"route from the endpoint to the actor, or you can wait in a blocking fashion "
"on the activation of the route. An ``ActivationTimeoutException`` is thrown "
"if the endpoint could not be activated within the specified timeout. "
"Deactivation works in a similar fashion:"
msgstr ""

# ab2b9b31958a4ee28731973701900ea8
#: ../../java/camel.rst:122
msgid ""
"Deactivation of a Consumer or a Producer actor happens when the actor is "
"terminated. For a Consumer, the route to the actor is stopped. For a "
"Producer, the `SendProcessor`_ is stopped. A "
"``DeActivationTimeoutException`` is thrown if the associated camel objects "
"could not be deactivated within the specified timeout."
msgstr ""

# 46f49db134b04911bbe061e78cb20362
#: ../../java/camel.rst:132
msgid "Consumer Actors"
msgstr ""

# cfa273df81e74ac7a895988b5498ac7f
#: ../../java/camel.rst:134
msgid ""
"For objects to receive messages, they must inherit from the "
"`UntypedConsumerActor`_ class. For example, the following actor class "
"(Consumer1) implements the `getEndpointUri` method, which is declared in the"
" `UntypedConsumerActor`_ class, in order to receive messages from the "
"``file:data/input/actor`` Camel endpoint."
msgstr ""

# 5fc971dfe91b465497277a8c3f6edbf2
#: ../../java/camel.rst:143
msgid ""
"Whenever a file is put into the data/input/actor directory, its content is "
"picked up by the Camel `file component`_ and sent as message to the actor. "
"Messages consumed by actors from Camel endpoints are of type "
"`CamelMessage`_. These are immutable representations of Camel messages."
msgstr ""

# a3c427c777814e8f8d0b07db02faa496
#: ../../java/camel.rst:152
msgid ""
"Here's another example that sets the endpointUri to "
"``jetty:http://localhost:8877/camel/default``. It causes Camel's `Jetty "
"component`_ to start an embedded `Jetty`_ server, accepting HTTP connections"
" from localhost on port 8877."
msgstr ""

# 3dff4f473db242b9bd166d6795e4485b
#: ../../java/camel.rst:162
msgid ""
"After starting the actor, clients can send messages to that actor by POSTing"
" to ``http://localhost:8877/camel/default``. The actor sends a response by "
"using the getSender().tell method. For returning a message body and headers "
"to the HTTP client the response type should be `CamelMessage`_. For any "
"other response type, a new CamelMessage object is created by akka-camel with"
" the actor response as message body."
msgstr ""

# ab5d218b5d90417f8bba85dd21fabb43
#: ../../java/camel.rst:174
msgid "Delivery acknowledgements"
msgstr ""

# edb6914039e94d738d2d710b90a8a9f9
#: ../../java/camel.rst:176
msgid ""
"With in-out message exchanges, clients usually know that a message exchange "
"is done when they receive a reply from a consumer actor. The reply message "
"can be a CamelMessage (or any object which is then internally converted to a"
" CamelMessage) on success, and a Failure message on failure."
msgstr ""

# e20aef3724e747698136c9050f310385
#: ../../java/camel.rst:181
msgid ""
"With in-only message exchanges, by default, an exchange is done when a "
"message is added to the consumer actor's mailbox. Any failure or exception "
"that occurs during processing of that message by the consumer actor cannot "
"be reported back to the endpoint in this case. To allow consumer actors to "
"positively or negatively acknowledge the receipt of a message from an in-"
"only message exchange, they need to override the ``autoAck`` method to "
"return false. In this case, consumer actors must reply either with a special"
" akka.camel.Ack message (positive acknowledgement) or a "
"akka.actor.Status.Failure (negative acknowledgement)."
msgstr ""

# 4c1485e46b774573bd08088fbe35293e
#: ../../java/camel.rst:196
msgid "Consumer timeout"
msgstr ""

# efc0917c2bc4441aa24cdf6d8c932073
#: ../../java/camel.rst:198
msgid ""
"Camel Exchanges (and their corresponding endpoints) that support two-way "
"communications need to wait for a response from an actor before returning it"
" to the initiating client. For some endpoint types, timeout values can be "
"defined in an endpoint-specific way which is described in the documentation "
"of the individual `Camel components`_. Another option is to configure "
"timeouts on the level of consumer actors."
msgstr ""

# 1ed50f1ff8e7426c991f1d3dc6248f65
#: ../../java/camel.rst:206
msgid ""
"Two-way communications between a Camel endpoint and an actor are initiated "
"by sending the request message to the actor with the `ask`_ pattern and the "
"actor replies to the endpoint when the response is ready. The ask request to"
" the actor can timeout, which will result in the `Exchange`_ failing with a "
"TimeoutException set on the failure of the `Exchange`_. The timeout on the "
"consumer actor can be overridden with the ``replyTimeout``, as shown below."
msgstr ""

# 9d4818ee9df54561a60e1b5f90286d65
#: ../../java/camel.rst:217
msgid "Producer Actors"
msgstr ""

# 9aa5739e01ff4a72845ea026513642bd
#: ../../java/camel.rst:219
msgid ""
"For sending messages to Camel endpoints, actors need to inherit from the "
"`UntypedProducerActor`_ class and implement the getEndpointUri method."
msgstr ""

# 790f2ba3de7c4a468eebb18ef43cc10c
#: ../../java/camel.rst:223
msgid ""
"Producer1 inherits a default implementation of the onReceive method from the"
" `UntypedProducerActor`_ class. To customize a producer actor's default "
"behavior you must override the `UntypedProducerActor`_.onTransformResponse "
"and `UntypedProducerActor`_.onTransformOutgoingMessage methods. This is "
"explained later in more detail. Producer Actors cannot override the "
"`UntypedProducerActor`_.onReceive method."
msgstr ""

# b46f1761354e42c0bec1e0beaee7be8a
#: ../../java/camel.rst:228
msgid ""
"Any message sent to a Producer actor will be sent to the associated Camel "
"endpoint, in the above example to ``http://localhost:8080/news``. The "
"`UntypedProducerActor`_ always sends messages asynchronously. Response "
"messages (if supported by the configured endpoint) will, by default, be "
"returned to the original sender. The following example uses the ask pattern "
"to send a message to a Producer actor and waits for a response."
msgstr ""

# c230af4c359f44cc9747298b45889b7a
#: ../../java/camel.rst:237
msgid ""
"The future contains the response CamelMessage, or an ``AkkaCamelException`` "
"when an error occurred, which contains the headers of the response."
msgstr ""

# d7298348dc954437aac591c7d52fc3e3
#: ../../java/camel.rst:242
msgid "Custom Processing"
msgstr ""

# 776fb4a6a6544a028914a054d94494bf
#: ../../java/camel.rst:244
msgid ""
"Instead of replying to the initial sender, producer actors can implement "
"custom response processing by overriding the onRouteResponse method. In the "
"following example, the response message is forwarded to a target actor "
"instead of being replied to the original sender."
msgstr ""

# d4efe472673b4b67878fa8484317d464
#: ../../java/camel.rst:253
msgid ""
"Before producing messages to endpoints, producer actors can pre-process them"
" by overriding the `UntypedProducerActor`_.onTransformOutgoingMessage "
"method."
msgstr ""

# 8cfb132ff6464c0bb2cc91b2d291dd46
#: ../../java/camel.rst:259
msgid "Producer configuration options"
msgstr ""

# 1d79b07821374318a4e6e1c76122fb24
#: ../../java/camel.rst:261
msgid ""
"The interaction of producer actors with Camel endpoints can be configured to"
" be one-way or two-way (by initiating in-only or in-out message exchanges, "
"respectively). By default, the producer initiates an in-out message exchange"
" with the endpoint. For initiating an in-only exchange, producer actors have"
" to override the isOneway method to return true."
msgstr ""

# 7635b05c968a4d8faee6b4df5226e16d
#: ../../java/camel.rst:269
msgid "Message correlation"
msgstr ""

# 0c69ab3cab9c41c6968704032833651f
#: ../../java/camel.rst:271
msgid ""
"To correlate request with response messages, applications can set the "
"`Message.MessageExchangeId` message header."
msgstr ""

# 78ae9025d70b4e4982834ca216880647
#: ../../java/camel.rst:277
msgid "ProducerTemplate"
msgstr ""

# f2e7290d19be43128e089979c420db32
#: ../../java/camel.rst:279
msgid ""
"The `UntypedProducerActor`_ class is a very convenient way for actors to "
"produce messages to Camel endpoints. Actors may also use a Camel "
"`ProducerTemplate`_ for producing messages to endpoints."
msgstr ""

# 788b24c9ccf94f089eed9b4991ebbec3
#: ../../java/camel.rst:284
msgid ""
"For initiating a two-way message exchange, one of the "
"``ProducerTemplate.request*`` methods must be used."
msgstr ""

# 8b5b82b172484d87ac74564bfa6f335c
#: ../../java/camel.rst:295
msgid "Asynchronous routing"
msgstr ""

# 3191657b476c4c4bba62ed876340d0d1
#: ../../java/camel.rst:297
msgid ""
"In-out message exchanges between endpoints and actors are designed to be "
"asynchronous. This is the case for both, consumer and producer actors."
msgstr ""

# 0f607bfee1f546acbfb68f80f4f22ba7
#: ../../java/camel.rst:301
msgid ""
"A consumer endpoint sends request messages to its consumer actor using the "
"``tell`` method and the actor returns responses with ``getSender().tell`` "
"once they are ready."
msgstr ""

# 668aa4a724c14dee9b14b20df0c62fa2
#: ../../java/camel.rst:305
msgid ""
"A producer actor sends request messages to its endpoint using Camel's "
"asynchronous routing engine. Asynchronous responses are wrapped and added to"
" the producer actor's mailbox for later processing. By default, response "
"messages are returned to the initial sender but this can be overridden by "
"Producer implementations (see also description of the ``onRouteResponse`` "
"method in :ref:`camel-custom-processing-java`)."
msgstr ""

# 22ca8c571a574a01a0d1f0500fffbc83
#: ../../java/camel.rst:312
msgid ""
"However, asynchronous two-way message exchanges, without allocating a thread"
" for the full duration of exchange, cannot be generically supported by "
"Camel's asynchronous routing engine alone. This must be supported by the "
"individual `Camel components`_ (from which endpoints are created) as well. "
"They must be able to suspend any work started for request processing "
"(thereby freeing threads to do other work) and resume processing when the "
"response is ready. This is currently the case for a `subset of components`_ "
"such as the `Jetty component`_. All other Camel components can still be "
"used, of course, but they will cause allocation of a thread for the duration"
" of an in-out message exchange. There's also :ref:`camel-examples-java` that"
" implements both, an asynchronous consumer and an asynchronous producer, "
"with the jetty component."
msgstr ""

# 475fb5d19def4fd28b70cce4b25e5283
#: ../../java/camel.rst:324
msgid ""
"If the used Camel component is blocking it might be necessary to use a "
"separate :ref:`dispatcher <dispatchers-java>` for the producer. The Camel "
"processor is invoked by a child actor of the producer and the dispatcher can"
" be defined in the deployment section of the configuration. For example, if "
"your producer actor has path ``/user/integration/output`` the dispatcher of "
"the child actor can be defined with::"
msgstr ""

# 08890175406140b1b823a2250376e9b3
#: ../../java/camel.rst:342
msgid "Custom Camel routes"
msgstr ""

# 912f3ed4f0f14560b6d4761b8206f222
#: ../../java/camel.rst:344
msgid ""
"In all the examples so far, routes to consumer actors have been "
"automatically constructed by akka-camel, when the actor was started. "
"Although the default route construction templates, used by akka-camel "
"internally, are sufficient for most use cases, some applications may require"
" more specialized routes to actors. The akka-camel module provides two "
"mechanisms for customizing routes to actors, which will be explained in this"
" section. These are:"
msgstr ""

# 2bdaf723e49d4537a6c6759fdc32c3ca
#: ../../java/camel.rst:351
msgid ""
"Usage of :ref:`camel-components-java` to access actors. Any Camel route can "
"use these components to access Akka actors."
msgstr ""

# b57b3a6cf3784cb795280c9b81c2c739
#: ../../java/camel.rst:354
msgid ""
":ref:`camel-intercepting-route-construction-java` to actors. This option "
"gives you the ability to change routes that have already been added to "
"Camel. Consumer actors have a hook into the route definition process which "
"can be used to change the route."
msgstr ""

# 74e749eefc984bb19652a135209e0d6d
#: ../../java/camel.rst:362
msgid "Akka Camel components"
msgstr ""

# 6af0a81e81994ab3847f0d13b4f1b960
#: ../../java/camel.rst:364
msgid ""
"Akka actors can be accessed from Camel routes using the `actor`_ Camel "
"component. This component can be used to access any Akka actor (not only "
"consumer actors) from Camel routes, as described in the following sections."
msgstr ""

# 629900d7ab87409094ddb07641e7564e
#: ../../java/camel.rst:372
msgid "Access to actors"
msgstr ""

# f3798e25e2f3438d96eb0d744d67795c
#: ../../java/camel.rst:374
msgid ""
"To access actors from custom Camel routes, the `actor`_ Camel component "
"should be used. It fully supports Camel's `asynchronous routing engine`_."
msgstr ""

# a007ce978f2a48c8824c2a8bb299081c
#: ../../java/camel.rst:381
msgid "This component accepts the following endpoint URI format:"
msgstr ""

# 8c979c99c5a2485a86d012ea021f8638
#: ../../java/camel.rst:383
msgid "``[<actor-path>]?<options>``"
msgstr ""

# 39304c75d136472ca6faeb931a13c0bd
#: ../../java/camel.rst:385
msgid ""
"where ``<actor-path>`` is the ``ActorPath`` to the actor. The ``<options>`` "
"are name-value pairs separated by ``&`` (i.e. "
"``name1=value1&name2=value2&...``)."
msgstr ""

# 47c76a8c163249e9a350924ffc9020e3
#: ../../java/camel.rst:390
msgid "URI options"
msgstr ""

# 5fe0416dc7f64b2bbbf4c8ff734fe3c4
#: ../../java/camel.rst:392
msgid "The following URI options are supported:"
msgstr ""

# fe9fefa16daf4ca4a0318b98e547409d
#: ../../java/camel.rst:397
msgid "Name"
msgstr ""

# dbbdb1cc054a48d8915163be7c97bd73
#: ../../java/camel.rst:397
msgid "Type"
msgstr ""

# 9aea58a673c74ebcad6b1556429e06e1
#: ../../java/camel.rst:397
msgid "Default"
msgstr ""

# 41e31e76236a410684dbc6c164ccecbe
# a27ccf7e560e469c873e5238760ff9c0
# 1ff80ce2a25c4c658e646a46a3baaaca
# b2798175bcf34e069796516ff490cc22
# d4b4ee9ed01b479cafbda6678bc13f7b
# 3036b8e181674922b881489f42e0923b
# 8de2a7eb9cc64230abed1dee03c08518
# 04da95b47b894f52a1baa3e6ef1f5fb4
# 7e3cdb7f2d864629adee2a7986d64447
# 197caec97f594c37a9667a85725fc755
# 3c49e8ac8de045caa4db26a86b1b225a
# 13f05666ef4a46bebb2f833eccdbc2fb
# 20330dd384004af5938459e91b24b985
# a0e43c4b647d45d5b22a96bc5672771f
# d36b939d6e1141c095109417ffcb2cba
# 461dae1713734bda976335da2cb05564
# 347c84ae74044e7cb4a5888acfd0b943
# bfcf7144442a4ae48ba3aa1d6cd7e074
# 8fa2f06291d5472cad50a566ccf677fe
# 233bd18c58c14fddb28cebd7c2b1d6b7
# b9ceae76b81946098ce22068a167c120
# 847326a52def467f856b5ff8bd8a4208
# 3d7062b0f39b4a8c808f20054477c61a
# 02747dbc09664c8aaed7421d26a95853
# 0b45887f5cba4f5c8b96974c15b97a21
# 322fad8da5f54d71a8ad4ee7139c8805
# 5e602f80dbad467cb8f23f103e66ee05
# 875674500c3443979ca4d44cc5964283
# 2b46807ae110493295e6ebba3e582cca
# 3de168221efb402993e8cb8fe78da466
# 4f892ee7615e4636b47d3a9a40d3bbab
# 11750038ebf54dd991bd5ed19f222b5d
# 353fbbcf5ed94667853476aa5d73bfcf
# a0594392ec804060819b7b121db9a7f8
# 6210c5745feb4b67b52c86f69d82a3af
# 6f32884a5229404999ec8cc5ee3c8041
# 2b52adb3ec364a139ddf4a0392007060
# c0fadbae6b174267ac38d3067a86cd06
# 8e85a6302da747cd919aeac5ce214927
# 665de826aa524d7297bf51aac6e6847c
# a0fb4b423f684f2f8b1b08f2646af2d1
# 8fad4b8ee6d741e4864b9f6a40cc0623
# 2d6d743d417b4c9e8b4d25773f1a2597
# 1352c538e65a40328cdcc39150a1a6fe
# c0040b6afd414e43b59b1ad31584d20e
# 6b61761cc42e42cba32da28c384f44b0
# e82290decb2a470e8490cdb3906dbb71
# 8c8ffcee6e0540c8ade2946a93671073
# 4ae961778e804385834b910988feab07
# 166100b7985f4f7aacd812f6f623997a
# ef0ff79a9671412ea42b5e2439768fed
# d094ec4e801f4053a3e8e549b4292a77
# 3d94dc5e26a341408a5f08d45553d4f5
# 7f8d424e51e947e8972a4598131b9b39
# 636fda20016e4874bae9ac52f6e113c0
# cd5640c4260947f7b6404e5dc681f496
# f6ca3adaa3f04a5093f12dd282e33587
# 889806c0232543b19863aa6d674f3036
# 1936501bc0c245728597c8ad1d1d2ba3
# d7c2f9180dfd419ab336f0938026f6c9
# 0596e0acf023459bafdea082d734b8be
# 10bda7743a8d4172a2af9d835284cfbc
# 15f7de853b2c437a8275338618395c1f
# 1a574eb8d3664300afc1068bf93658fc
# 4656045b53874d738a72f8ae65c041a7
# b6058363c215439db46902a793d358d1
# b75e9e28a5394cf2a571779993f15fa4
# 462c94e2bcfe42f8aa4cc6fa998b0fc0
# 66624a74e85347fe834a32d13a1908e6
# e5cd4ff041294619b70ed1902963d0d9
# 28554443044e485d8001decdb176ac39
# e3ada6e1309e40fdaa832c351433068e
# ca121c11521f4a4aac6109bf7ebd0ff6
# c9bbc347a90e4d2297bd2defdf23c937
# 94d65d23668f46a6ab21fdafbbc4e5c2
# 9d402919336947eb8c5bcab593aae7b4
# 45605f919cb5479998622b9aee88a058
# a2fa327cdcae480cb1f2997142c1cbc8
# 0212a5e0906a4b62a50e022e315c8d2f
# 5a23affcd8894f19b6c0794831ec0bdd
# c425bf84edaa4fa29f259cb8adf99735
# 762532f5cdc7446489c1afee9640da8c
# 22b5f0e7ab9544d58d4c425a43b7a35d
# ade74d4a8bcb46d58ed0e7d662e89449
# 51d5bf1dc2cd4a77a26122344531c45f
# 5c79dc1c7e79485194ec4c48c44c04db
# 06e74698bb5449ce86ff3d9502344a65
# a0cc233b89c3483a9d75e6e026ec73f8
# d2ad776ac309417f9248b14605303b35
# c1fd567085fc4924a57568f27926f46d
# c30febdc1b2d45b18d16e3205c4f0dcf
# 1f009ad42d8f4647a7bcfee6ac905241
# 8d17c4785ac04676ac5a35d0338e9c31
# 3b9d862044d64403853f076f92e31f78
# fc297435db174d88947a4a87ce2f88f6
# e0b9867e8e33479f9cc9c1fa8b5f0db2
# 8fd3097ef49044b880377ecc6c9f5bd7
# a153dc36de0a4c598a634f3e038eaeda
# 5d0b12057c614d89b7f9def85bc52073
# c2f6fbf639b44c0695bc7c53070dc13c
# e4383451bc6b46359ac3fa5bb1615890
# fc54414c0d5645098cc23630f72fa633
# 3112409304954d76a7898dbbf4cb5f7e
# f1f2db46134c41a1a866869a871155eb
# 3652e1331e674f8f8bfbe68ad95f336e
# d097861a2d24436a86d2b9c5fc7d1781
# 3f7e706011e841f0bbbb0a502f1aeef7
# cb4c36c061e1424a80d96d10d8163cae
# a4624a0d021147d8a28ece21554feabb
# d18a9296f103401a92181f2b28287754
# 79e3ab6907684244b298a30c08c141f1
# 505da8a108064a96a34174d258dc4c49
# 23a6c88d1eca4edaaa5889173b542515
# 4c3281ab2d2244a7a561c3b826fa0ea8
# 31a21d86f74e4647b4d3aae7da831288
# 5f8b45258c1447c0be3800fd469311c2
# 19a8200d2c73425aaa6bab5449eb6744
# 9e281cad353a420ab3aa7ea97f803a36
# c336d7778fa94b6a8a8d1d7bd15e0884
# af2a0b96cc4643d18cbfe98485d8ba59
# 3ab078952a114f199999701171034020
# 5928a5174d114aab812632397a502de3
# 8eb8e63a287444599ac0976199aea818
# 8371a3c5878448758e2c9117f49fbf00
# fb57d058f965497bb8d031938f42bd55
# 791d4d8b62eb4c019eaef29f3541abb3
# 147dafc3fdf048b39d0858a702581d72
# 0a49a1551b084d418e54497c2797d54d
# 2bfed43fea074cafa12f7045cfccb1a7
# baa8195ea20841edbcba51e15d68057c
# 43a086e3821047049e748154e0392d85
# 2fdb04a1f3104418baa8c21a95368592
# cd1b037b335844619c98bd3d14ead3e3
# 56e96ae6833f4e5ab3f3a91ebb955fea
# f9ca960ab8114fac9cb96e788a7c4d64
# bad653e0206547ab94af134d9c9c9970
# 4f2d020e42674a22a36836ab7c993482
# 9f864a6d32f54ba4a55ce11dc55bccf1
# d7419986364345f694c4f43335dd23dc
# 8c74272e924e4bf0a6222ea3308c287a
# 4e4982eb78944a58b9e9fc7f6e4bc025
# fa1fa58ac6444acbb4d2f547ae593a7a
# 72b85ef700c74a7e9afe5bce289cb0d5
# 4bc2155c97904261a1b8127d9b5b4fd7
# 7f6c14319673459dafb5c7bc0830a0d1
# aa938bfd06774283a6355c98c00d9491
# 314c05a0634e4d0da2a8e7f93c07ab61
# 183b96ee2c09418ba65b6134e6cc1580
# fcc5729275e347249c0a93aab4f92303
# 22ada492ad6a48d8ba74d28a1c30810d
# 75e96763c90d4084bfa1bdb376842b22
#: ../../java/camel.rst:397 ../../java/fault-tolerance-sample.rst:13
#: ../../java/fault-tolerance-sample.rst:33
#: ../../java/http/routing-dsl/directives/alphabetically.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejection.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejections.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extract.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractActorSystem.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractDataBytes.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractExecutionContext.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractLog.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractMaterializer.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequest.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestContext.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestEntity.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractSettings.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractStrictEntity.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractUnmatchedPath.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/extractUri.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapInnerRoute.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRejections.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequest.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequestContext.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponse.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseEntity.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseHeaders.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResult.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultFuture.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultPF.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWith.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWithPF.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapSettings.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/mapUnmatchedPath.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/pass.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/provide.rst:6
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejections.rst:6
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejectionsWith.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/toStrictEntity.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/withExecutionContext.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/withLog.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/withMaterializer.rst:7
#: ../../java/http/routing-dsl/directives/basic-directives/withSettings.rst:7
#: ../../java/http/routing-dsl/directives/cache-condition-directives/conditional.rst:7
#: ../../java/http/routing-dsl/directives/coding-directives/decodeRequest.rst:7
#: ../../java/http/routing-dsl/directives/coding-directives/decodeRequestWith.rst:7
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponse.rst:7
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponseWith.rst:7
#: ../../java/http/routing-dsl/directives/coding-directives/requestEncodedWith.rst:7
#: ../../java/http/routing-dsl/directives/coding-directives/responseEncodingAccepted.rst:7
#: ../../java/http/routing-dsl/directives/cookie-directives/cookie.rst:7
#: ../../java/http/routing-dsl/directives/cookie-directives/deleteCookie.rst:7
#: ../../java/http/routing-dsl/directives/cookie-directives/optionalCookie.rst:7
#: ../../java/http/routing-dsl/directives/cookie-directives/setCookie.rst:7
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequest.rst:7
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequestResult.rst:7
#: ../../java/http/routing-dsl/directives/debugging-directives/logResult.rst:7
#: ../../java/http/routing-dsl/directives/execution-directives/handleExceptions.rst:7
#: ../../java/http/routing-dsl/directives/execution-directives/handleRejections.rst:7
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.rst:7
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:7
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:7
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:7
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResource.rst:7
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.rst:7
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.rst:7
#: ../../java/http/routing-dsl/directives/file-upload-directives/fileUpload.rst:7
#: ../../java/http/routing-dsl/directives/file-upload-directives/uploadedFile.rst:7
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldList.rst:7
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMap.rst:7
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMultiMap.rst:7
#: ../../java/http/routing-dsl/directives/future-directives/completeOrRecoverWith.rst:7
#: ../../java/http/routing-dsl/directives/future-directives/onComplete.rst:7
#: ../../java/http/routing-dsl/directives/future-directives/onCompleteWithBreaker.rst:7
#: ../../java/http/routing-dsl/directives/future-directives/onSuccess.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/checkSameOrigin.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/headerValue.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByName.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByType.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/headerValuePF.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValue.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByName.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByType.rst:7
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValuePF.rst:7
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:7
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:7
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:7
#: ../../java/http/routing-dsl/directives/method-directives/delete.rst:8
#: ../../java/http/routing-dsl/directives/method-directives/extractMethod.rst:7
#: ../../java/http/routing-dsl/directives/method-directives/get.rst:8
#: ../../java/http/routing-dsl/directives/method-directives/head.rst:8
#: ../../java/http/routing-dsl/directives/method-directives/method.rst:9
#: ../../java/http/routing-dsl/directives/method-directives/options.rst:8
#: ../../java/http/routing-dsl/directives/method-directives/overrideMethodWithParameter.rst:9
#: ../../java/http/routing-dsl/directives/method-directives/patch.rst:9
#: ../../java/http/routing-dsl/directives/method-directives/post.rst:9
#: ../../java/http/routing-dsl/directives/method-directives/put.rst:9
#: ../../java/http/routing-dsl/directives/misc-directives/extractClientIP.rst:7
#: ../../java/http/routing-dsl/directives/misc-directives/rejectEmptyResponse.rst:7
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityEmpty.rst:7
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityPresent.rst:7
#: ../../java/http/routing-dsl/directives/misc-directives/selectPreferredLanguage.rst:7
#: ../../java/http/routing-dsl/directives/misc-directives/validate.rst:8
#: ../../java/http/routing-dsl/directives/misc-directives/withSizeLimit.rst:7
#: ../../java/http/routing-dsl/directives/misc-directives/withoutSizeLimit.rst:7
#: ../../java/http/routing-dsl/directives/parameter-directives/parameter.rst:8
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMap.rst:8
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMultiMap.rst:7
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterSeq.rst:7
#: ../../java/http/routing-dsl/directives/parameter-directives/parameters.rst:8
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/pathEnd.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/pathEndOrSingleSlash.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefix.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefixTest.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/pathSingleSlash.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffix.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffixTest.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefix.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefixTest.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:7
#: ../../java/http/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.rst:7
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:7
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.rst:7
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:7
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeader.rst:7
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeaders.rst:7
#: ../../java/http/routing-dsl/directives/route-directives/complete.rst:7
#: ../../java/http/routing-dsl/directives/route-directives/failWith.rst:7
#: ../../java/http/routing-dsl/directives/route-directives/redirect.rst:7
#: ../../java/http/routing-dsl/directives/route-directives/reject.rst:7
#: ../../java/http/routing-dsl/directives/scheme-directives/extractScheme.rst:7
#: ../../java/http/routing-dsl/directives/scheme-directives/scheme.rst:7
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:8
#: ../../java/http/routing-dsl/directives/security-directives/extractCredentials.rst:7
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:7
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.rst:7
#: ../../java/http/routing-dsl/directives/timeout-directives/withoutRequestTimeout.rst:7
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessages.rst:7
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.rst:7
#: ../../java/lambda-fault-tolerance-sample.rst:13
#: ../../java/lambda-fault-tolerance-sample.rst:33
msgid "Description"
msgstr ""

# 906e80c0633c4f35bea40bd6c5a24daa
#: ../../java/camel.rst:399
msgid "replyTimeout"
msgstr ""

# 02cf4f0afb51414d81cfe1023854d314
#: ../../java/camel.rst:399
msgid "Duration"
msgstr ""

# c1c2bfd0c75142308e6dc9b703b8d26f
#: ../../java/camel.rst:399
msgid "false"
msgstr ""

# 45bfa656de7348d1a3be3fd4ac86776a
#: ../../java/camel.rst:399
msgid ""
"The reply timeout, specified in the same way that you use the duration in "
"akka, for instance ``10 seconds`` except that in the url it is handy to use "
"a + between the amount and the unit, like for example ``200+millis``"
msgstr ""

# 61c10bf4d6a54c7e810dd28e8451562d
#: ../../java/camel.rst:406
msgid "See also :ref:`camel-timeout-java`."
msgstr ""

# f11a41dd1e294c6d97e04440ce39d60d
#: ../../java/camel.rst:408
msgid "autoAck"
msgstr ""

# 127fe36e42c242ea8270af434ce7f0ed
#: ../../java/camel.rst:408
msgid "Boolean"
msgstr ""

# 51412187d4f04a3c908819d6f266f4e4
#: ../../java/camel.rst:408
msgid "true"
msgstr ""

# 7ac26c0784314a15ac086a0c04e22d51
#: ../../java/camel.rst:408
msgid ""
"If set to true, in-only message exchanges are auto-acknowledged when the "
"message is added to the actor's mailbox. If set to false, actors must "
"acknowledge the receipt of the message."
msgstr ""

# cfdb7d772f94414cb8b35133749fae91
#: ../../java/camel.rst:414
msgid "See also :ref:`camel-acknowledgements-java`."
msgstr ""

# f7255d966d7145fba3cfe3357d23988a
#: ../../java/camel.rst:417
msgid "Here's an actor endpoint URI example containing an actor path::"
msgstr ""

# cf916e8eab724a1288db1c48043e21b6
#: ../../java/camel.rst:421
msgid ""
"In the following example, a custom route to an actor is created, using the "
"actor's path."
msgstr ""

# afce052348c94ecda2945649cfaf349c
#: ../../java/camel.rst:428
msgid ""
"The `CamelPath.toCamelUri` converts the `ActorRef` to the Camel actor "
"component URI format which points to the actor endpoint as described above. "
"When a message is received on the jetty endpoint, it is routed to the "
"Responder actor, which in return replies back to the client of the HTTP "
"request."
msgstr ""

# 1541807eeb104c3384ebf6f238fd4150
#: ../../java/camel.rst:436
msgid "Intercepting route construction"
msgstr ""

# 4a44a3d294a5438986065a7e49681060
#: ../../java/camel.rst:438
msgid ""
"The previous section, :ref:`camel-components-java`, explained how to setup a"
" route to an actor manually. It was the application's responsibility to "
"define the route and add it to the current CamelContext. This section "
"explains a more convenient way to define custom routes: akka-camel is still "
"setting up the routes to consumer actors (and adds these routes to the "
"current CamelContext) but applications can define extensions to these "
"routes. Extensions can be defined with Camel's `Java DSL`_ or `Scala DSL`_. "
"For example, an extension could be a custom error handler that redelivers "
"messages from an endpoint to an actor's bounded mailbox when the mailbox was"
" full."
msgstr ""

# ca2f01d9c0154b4aa947e2950f780e46
#: ../../java/camel.rst:448
msgid ""
"The following examples demonstrate how to extend a route to a consumer actor"
" for handling exceptions thrown by that actor."
msgstr ""

# 4e2b50d1ad3c497aba1221aebc1c7581
#: ../../java/camel.rst:453
msgid ""
"The above ErrorThrowingConsumer sends the Failure back to the sender in "
"preRestart because the Exception that is thrown in the actor would otherwise"
" just crash the actor, by default the actor would be restarted, and the "
"response would never reach the client of the Consumer."
msgstr ""

# 1fccf9f4a9174e62ba35bc3ce13058aa
#: ../../java/camel.rst:457
msgid ""
"The akka-camel module creates a RouteDefinition instance by calling "
"from(endpointUri) on a Camel RouteBuilder (where endpointUri is the endpoint"
" URI of the consumer actor) and passes that instance as argument to the "
"route definition handler \\*). The route definition handler then extends the"
" route and returns a ProcessorDefinition (in the above example, the "
"ProcessorDefinition returned by the end method. See the "
"`org.apache.camel.model`__ package for details). After executing the route "
"definition handler, akka-camel finally calls a to(targetActorUri) on the "
"returned ProcessorDefinition to complete the route to the consumer actor "
"(where targetActorUri is the actor component URI as described in :ref"
":`access-to-actors-java`). If the actor cannot be found, a "
"`ActorNotRegisteredException` is thrown."
msgstr ""

# bf6eed651d954d08818fc323044a2073
#: ../../java/camel.rst:468
msgid ""
"\\*) Before passing the RouteDefinition instance to the route definition "
"handler, akka-camel may make some further modifications to it."
msgstr ""

# 158479a8597b4bc6bc055c9c99de9026
# a424322db14344319349fcebf6551338
# 71fb38167c2e4ab3b48fd755bbc28d49
# 0ed1f04d29df471999a130dec372618c
# 956a95c84e424ce896eea40f11ab7fc7
#: ../../java/camel.rst:476
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:22
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:31
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:28
#: ../../java/lambda-fsm.rst:460
msgid "Examples"
msgstr ""

# 20e4b89e247f499691d82e45c16d3948
#: ../../java/camel.rst:478
msgid ""
"The `Lightbend Activator <http://www.lightbend.com/platform/getstarted>`_ "
"tutorial named `Akka Camel Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-camel-java>`_ "
"contains 3 samples:"
msgstr ""

# 2204b4cc1bfe407d8d397b4fd1673c03
#: ../../java/camel.rst:482
msgid ""
"Asynchronous routing and transformation - This example demonstrates how to "
"implement consumer and producer actors that support :ref:`camel-"
"asynchronous-routing-java` with their Camel endpoints."
msgstr ""

# 971c5aaa84424e3790f89554961629fc
#: ../../java/camel.rst:485
msgid ""
"Custom Camel route - Demonstrates the combined usage of a ``Producer`` and a"
" ``Consumer`` actor as well as the inclusion of a custom Camel route."
msgstr ""

# 1e1c0219dccc432e9b9dfb61ed1fef3e
#: ../../java/camel.rst:488
msgid ""
"Quartz Scheduler Example - Showing how simple is to implement a cron-style "
"scheduler by using the Camel Quartz component"
msgstr ""

# c9cca8bc7e69454aa3c42985bb88e111
#: ../../java/camel.rst:494
msgid ""
"There are several configuration properties for the Camel module, please "
"refer to the :ref:`reference configuration <config-akka-camel>`."
msgstr ""

# 05d41f5cfaa644fc8193e3973cc763fd
#: ../../java/camel.rst:498
msgid "Additional Resources"
msgstr ""

# 560728e6a927475088a1fe4d53582778
#: ../../java/camel.rst:499
msgid ""
"For an introduction to akka-camel 2, see also the Peter Gabryanczyk's talk "
"`Migrating akka-camel module to Akka 2.x`_."
msgstr ""

# c244b3688eac44e7998390ff05bff58b
#: ../../java/camel.rst:501
msgid ""
"For an introduction to akka-camel 1, see also the `Appendix E - Akka and "
"Camel`_ (pdf) of the book `Camel in Action`_."
msgstr ""

# 5f0fee11ce2044be85120b468076b9a8
#: ../../java/camel.rst:508
msgid "Other, more advanced external articles (for version 1) are:"
msgstr ""

# d949f7e088b64557af0d086d256e92d4
#: ../../java/camel.rst:510
msgid ""
"`Akka Consumer Actors: New Features and Best Practices "
"<http://krasserm.blogspot.com/2011/02/akka-consumer-actors-new-features-"
"and.html>`_"
msgstr ""

# ff6f78de850b4efd9b79ac5021043de4
#: ../../java/camel.rst:511
msgid ""
"`Akka Producer Actors: New Features and Best Practices "
"<http://krasserm.blogspot.com/2011/02/akka-producer-actor-new-features-"
"and.html>`_"
msgstr ""

# 72c484659436400fb53519f1873becc9
# 6ff712d464174da0b65dd6b565dd903d
#: ../../java/cluster-client.rst:4 ../../java/cluster-usage.rst:398
msgid "Cluster Client"
msgstr ""

# 5c6b48b907424766aa17962c899bc762
#: ../../java/cluster-client.rst:6
msgid ""
"An actor system that is not part of the cluster can communicate with actors "
"somewhere in the cluster via this ``ClusterClient``. The client can of "
"course be part of another cluster. It only needs to know the location of one"
" (or more) nodes to use as initial contact points. It will establish a "
"connection to a ``ClusterReceptionist`` somewhere in the cluster. It will "
"monitor the connection to the receptionist and establish a new connection if"
" the link goes down. When looking for a new receptionist it uses fresh "
"contact points retrieved from previous establishment, or periodically "
"refreshed contacts, i.e. not necessarily the initial contact points."
msgstr ""

# f308fc49657d485e9e71c2a9a4d73fac
#: ../../java/cluster-client.rst:17
msgid ""
"``ClusterClient`` should not be used when sending messages to actors that "
"run within the same cluster. Similar functionality as the ``ClusterClient`` "
"is provided in a more efficient way by :ref:`distributed-pub-sub-java` for "
"actors that belong to the same cluster."
msgstr ""

# 5b4d1a2dd8404db9a68327aad089f45a
#: ../../java/cluster-client.rst:22
msgid ""
"Also, note it's necessary to change ``akka.actor.provider`` from "
"``akka.actor.LocalActorRefProvider`` to "
"``akka.remote.RemoteActorRefProvider`` or "
"``akka.cluster.ClusterActorRefProvider`` when using the cluster client."
msgstr ""

# b567733ca9b647eb9ee9beaf72a4e64b
#: ../../java/cluster-client.rst:26
msgid ""
"The receptionist is supposed to be started on all nodes, or all nodes with "
"specified role, in the cluster. The receptionist can be started with the "
"``ClusterClientReceptionist`` extension or as an ordinary actor."
msgstr ""

# 51d2b2e175584a0c88715dfc6c64a083
#: ../../java/cluster-client.rst:30
msgid ""
"You can send messages via the ``ClusterClient`` to any actor in the cluster "
"that is registered in the ``DistributedPubSubMediator`` used by the "
"``ClusterReceptionist``. The ``ClusterClientReceptionist`` provides methods "
"for registration of actors that should be reachable from the client. "
"Messages are wrapped in ``ClusterClient.Send``, ``ClusterClient.SendToAll`` "
"or ``ClusterClient.Publish``."
msgstr ""

# c2b3c32d8ed74227ab86d301ee4a0ede
#: ../../java/cluster-client.rst:36
msgid ""
"Both the ``ClusterClient`` and the ``ClusterClientReceptionist`` emit events"
" that can be subscribed to. The ``ClusterClient`` sends out notifications in"
" relation to having received a list of contact points from the "
"``ClusterClientReceptionist``. One use of this list might be for the client "
"to record its contact points. A client that is restarted could then use this"
" information to supersede any previously configured contact points."
msgstr ""

# 2c67ed5223ac4f91b3709744047ed56c
#: ../../java/cluster-client.rst:42
msgid ""
"The ``ClusterClientReceptionist`` sends out notifications in relation to "
"having received a contact from a ``ClusterClient``. This notification "
"enables the server containing the receptionist to become aware of what "
"clients are connected."
msgstr ""

# 1843f2fec3f440c7b76dc441d092c7e3
#: ../../java/cluster-client.rst:46
msgid "**1. ClusterClient.Send**"
msgstr ""

# 001cb9ecaa294e01985380f0d5512d2d
#: ../../java/cluster-client.rst:48
msgid ""
"The message will be delivered to one recipient with a matching path, if any "
"such exists. If several entries match the path the message will be delivered"
" to one random destination. The sender() of the message can specify that "
"local affinity is preferred, i.e. the message is sent to an actor in the "
"same local actor system as the used receptionist actor, if any such exists, "
"otherwise random to any other matching entry."
msgstr ""

# 11a74edb0bce4b69aef147e98c6519cc
#: ../../java/cluster-client.rst:55
msgid "**2. ClusterClient.SendToAll**"
msgstr ""

# a7d8367d48574e71885fa20513b8e291
#: ../../java/cluster-client.rst:57
msgid "The message will be delivered to all recipients with a matching path."
msgstr ""

# c493fc40ea3049f986508a471d29a5a4
#: ../../java/cluster-client.rst:59
msgid "**3. ClusterClient.Publish**"
msgstr ""

# 25c6fef486f14bfdbe0d1aea39d1a13e
#: ../../java/cluster-client.rst:61
msgid ""
"The message will be delivered to all recipients Actors that have been "
"registered as subscribers to the named topic."
msgstr ""

# 66f37d6045624cde9fe5da6ae5eb5efb
#: ../../java/cluster-client.rst:64
msgid ""
"Response messages from the destination actor are tunneled via the "
"receptionist to avoid inbound connections from other cluster nodes to the "
"client, i.e. the ``sender()``, as seen by the destination actor, is not the "
"client itself. The ``sender()`` of the response messages, as seen by the "
"client, is ``deadLetters`` since the client should normally send subsequent "
"messages via the ``ClusterClient``. It is possible to pass the original "
"sender inside the reply messages if the client is supposed to communicate "
"directly to the actor in the cluster."
msgstr ""

# f15b8f6759304380811ae58c358e2e76
#: ../../java/cluster-client.rst:72
msgid ""
"While establishing a connection to a receptionist the ``ClusterClient`` will"
" buffer messages and send them when the connection is established. If the "
"buffer is full the ``ClusterClient`` will drop old messages when new "
"messages are sent via the client. The size of the buffer is configurable and"
" it can be disabled by using a buffer size of 0."
msgstr ""

# 1402431d442a454ab9d28d45cd0d8678
#: ../../java/cluster-client.rst:77
msgid ""
"It's worth noting that messages can always be lost because of the "
"distributed nature of these actors. As always, additional logic should be "
"implemented in the destination (acknowledgement) and in the client (retry) "
"actors to ensure at-least-once message delivery."
msgstr ""

# 8d198933128e422ba7f740568fd02c4b
# 99e56843b4eb475d965e4585ce4028a7
# 32db3f0fc6564806b6ab827c096dff9e
#: ../../java/cluster-client.rst:82 ../../java/cluster-sharding.rst:29
#: ../../java/cluster-singleton.rst:81
msgid "An Example"
msgstr "例"

# 829519c1812b4225a45cfd6941cb2ae9
#: ../../java/cluster-client.rst:84
msgid ""
"On the cluster nodes first start the receptionist. Note, it is recommended "
"to load the extension when the actor system is started by defining it in the"
" ``akka.extensions`` configuration property::"
msgstr ""

# 40ed0a77588c48889217ac65fe2723bc
#: ../../java/cluster-client.rst:89
msgid "Next, register the actors that should be available for the client."
msgstr ""

# 7a72470ec6bf459b94b0b79fcd9bf88b
#: ../../java/cluster-client.rst:93
msgid ""
"On the client you create the ``ClusterClient`` actor and use it as a gateway"
" for sending messages to the actors identified by their path (without "
"address information) somewhere in the cluster."
msgstr ""

# 89de157ec836444fa2b66ebefea0e399
#: ../../java/cluster-client.rst:99
msgid ""
"The ``initialContacts`` parameter is a ``Set<ActorPath>``, which can be "
"created like this:"
msgstr ""

# 4a0dfe4cf8674273b778275215494f84
#: ../../java/cluster-client.rst:103
msgid ""
"You will probably define the address information of the initial contact "
"points in configuration or system property. See also :ref:`cluster-client-"
"config-java`."
msgstr ""

# fc668e6cebd747c1ae60d74966364316
# 9f31ace11eca4293a4c72306e7cbb75e
#: ../../java/cluster-client.rst:106 ../../java/cluster-singleton.rst:106
msgid ""
"A more comprehensive sample is available in the `Lightbend Activator "
"<http://www.lightbend.com/platform/getstarted>`_ tutorial named `Distributed"
" workers with Akka and Java! <http://www.lightbend.com/activator/template"
"/akka-distributed-workers-java>`_."
msgstr ""

# e11724d4d45345af9e285552d4e16107
#: ../../java/cluster-client.rst:110
msgid "ClusterClientReceptionist Extension"
msgstr ""

# d716554fe5064faf8f24bf6cf600a407
#: ../../java/cluster-client.rst:112
msgid ""
"In the example above the receptionist is started and accessed with the "
"``akka.cluster.client.ClusterClientReceptionist`` extension. That is "
"convenient and perfectly fine in most cases, but it can be good to know that"
" it is possible to start the ``akka.cluster.client.ClusterReceptionist`` "
"actor as an ordinary actor and you can have several different receptionists "
"at the same time, serving different types of clients."
msgstr ""

# 3651aa1098384c9fa57ef6e4084584b1
#: ../../java/cluster-client.rst:117
msgid ""
"Note that the ``ClusterClientReceptionist`` uses the ``DistributedPubSub`` "
"extension, which is described in :ref:`distributed-pub-sub-java`."
msgstr ""

# 69291d86cfee48128284927518a11289
#: ../../java/cluster-client.rst:120
msgid ""
"It is recommended to load the extension when the actor system is started by "
"defining it in the ``akka.extensions`` configuration property::"
msgstr ""

# 0e856325350b49bc8bf8622ec41342d9
#: ../../java/cluster-client.rst:126
msgid "Events"
msgstr ""

# 9ed27b52f7c1452eaca13fd623279da2
#: ../../java/cluster-client.rst:127
msgid ""
"As mentioned earlier, both the ``ClusterClient`` and "
"``ClusterClientReceptionist`` emit events that can be subscribed to. The "
"following code snippet declares an actor that will receive notifications on "
"contact points (addresses to the available receptionists), as they become "
"available. The code illustrates subscribing to the events and receiving the "
"``ClusterClient`` initial state."
msgstr ""

# 6160a5998cdd46e28c626b88d7fa645c
#: ../../java/cluster-client.rst:134
msgid ""
"Similarly we can have an actor that behaves in a similar fashion for "
"learning what cluster clients contact a ``ClusterClientReceptionist``:"
msgstr ""

# 24a7817c96294280a257fd5bc7df440b
# 325f5b4b1a674902b2aeb36d692020fd
# f92f35eb6d1c47d49100d835fb1103e3
# a9274922d6c24774bbf10d2b5d93edbc
# 02433989711e453cb5f2b92bdcce36df
# 2e96e5109866422b84acac19fc78794d
# 6a14b52a1bcb4103b3af6b901d747065
# 6ad9bc324d454dcbb309cf72a8cf2ce5
# 7b32b85a08c54595997eb555a401ba92
#: ../../java/cluster-client.rst:139 ../../java/cluster-sharding.rst:326
#: ../../java/cluster-singleton.rst:110 ../../java/distributed-data.rst:499
#: ../../java/distributed-pub-sub.rst:183 ../../java/lambda-persistence.rst:23
#: ../../java/persistence.rst:27 ../../java/persistence-query.rst:25
#: ../../java/persistence-query-leveldb.rst:18
msgid "Dependencies"
msgstr ""

# 87aa487838864b81b27475c57368a206
#: ../../java/cluster-client.rst:141
msgid ""
"To use the Cluster Client you must add the following dependency in your "
"project."
msgstr ""

# 5241a8c9690647238af42058131ce632
# 24b847995e544cdc8cd8b3b717a2a446
# 6d17543d05b14e4dbc20a40740e8b3a6
# af54bfed7bb54472a3fb0d84a4a6fdba
# 5c1704e57c50490eb53fc2f027b00a76
#: ../../java/cluster-client.rst:143 ../../java/cluster-sharding.rst:330
#: ../../java/cluster-singleton.rst:114 ../../java/distributed-data.rst:503
#: ../../java/distributed-pub-sub.rst:187
msgid "sbt::"
msgstr ""

# 31aaef074cd94d29b41c485588ceece5
# a97535d4174d4d6387a65c591c26025d
# 652b76353d264a0a9df91aed7a57a716
# 3d941b16f58649f59291496780c62773
# 541b3951b3fa47f9965e8f6d7d6d4b04
#: ../../java/cluster-client.rst:147 ../../java/cluster-sharding.rst:334
#: ../../java/cluster-singleton.rst:118 ../../java/distributed-data.rst:507
#: ../../java/distributed-pub-sub.rst:191
msgid "maven::"
msgstr ""

# 1f1b44732b584887b5a62e618cdc1dfd
#: ../../java/cluster-client.rst:160
msgid ""
"The ``ClusterClientReceptionist`` extension (or "
"``ClusterReceptionistSettings``) can be configured with the following "
"properties:"
msgstr ""

# 3b08091d56d34fb58eb9a3700049096a
#: ../../java/cluster-client.rst:165
msgid ""
"The following configuration properties are read by the "
"``ClusterClientSettings`` when created with a ``ActorSystem`` parameter. It "
"is also possible to amend the ``ClusterClientSettings`` or create it from "
"another config section with the same layout as below. "
"``ClusterClientSettings`` is a parameter to the ``ClusterClient.props`` "
"factory method, i.e. each client can be configured with different settings "
"if needed."
msgstr ""

# 602d0443bc054beca613c41bffd809b9
#: ../../java/cluster-client.rst:174
msgid "Failure handling"
msgstr ""

# 4559e73cd9ad41978b38f51adb88bf24
#: ../../java/cluster-client.rst:175
msgid ""
"When the cluster client is started it must be provided with a list of "
"initial contacts which are cluster nodes where receptionists are running. It"
" will then repeatedly (with an interval configurable by ``establishing-get-"
"contacts-interval``) try to contact those until it gets in contact with one "
"of them. While running, the list of contacts are continuously updated with "
"data from the receptionists (again, with an interval configurable with "
"``refresh-contacts-interval``), so that if there are more receptionists in "
"the cluster than the initial contacts provided to the client the client will"
" learn about them."
msgstr ""

# 54021910529e4016b5e5fa832e0c7343
#: ../../java/cluster-client.rst:182
msgid ""
"While the client is running it will detect failures in its connection to the"
" receptionist by heartbeats if more than a configurable amount of heartbeats"
" are missed the client will try to reconnect to its known set of contacts to"
" find a receptionist it can access."
msgstr ""

# 4a5f382e6bfb44c0b498f35089cd7cfd
#: ../../java/cluster-client.rst:187
msgid "When the cluster cannot be reached at all"
msgstr ""

# 5a26c43708b44c199e124695e41951d9
#: ../../java/cluster-client.rst:188
msgid ""
"It is possible to make the cluster client stop entirely if it cannot find a "
"receptionist it can talk to within a configurable interval. This is "
"configured with the ``reconnect-timeout``, which defaults to ``off``. This "
"can be useful when initial contacts are provided from some kind of service "
"registry, cluster node addresses are entirely dynamic and the entire cluster"
" might shut down or crash, be restarted on new addresses. Since the client "
"will be stopped in that case a monitoring actor can watch it and upon "
"``Terminate`` a new set of initial contacts can be fetched and a new cluster"
" client started."
msgstr ""

# a118350269444c27aef127c751435a8d
#: ../../java/cluster-metrics.rst:5
msgid "Cluster Metrics Extension"
msgstr ""

# 7759c9febdc3433b99366f4ddd98c9b5
#: ../../java/cluster-metrics.rst:10
msgid ""
"The member nodes of the cluster can collect system health metrics and "
"publish that to other cluster nodes and to the registered subscribers on the"
" system event bus with the help of Cluster Metrics Extension."
msgstr ""

# 149197ddc5b54b0fa9f731904657537a
#: ../../java/cluster-metrics.rst:13
msgid ""
"Cluster metrics information is primarily used for load-balancing routers, "
"and can also be used to implement advanced metrics-based node life cycles, "
"such as \"Node Let-it-crash\" when CPU steal time becomes excessive."
msgstr ""

# b91d9729ae354816a6274621366dbc29
#: ../../java/cluster-metrics.rst:17
msgid ""
"Cluster Metrics Extension is a separate Akka module delivered in ``akka-"
"cluster-metrics`` jar."
msgstr ""

# 957b417e717d4f58aa6235e6ed0cee20
#: ../../java/cluster-metrics.rst:19
msgid ""
"To enable usage of the extension you need to add the following dependency to"
" your project: ::"
msgstr ""

# 1588c49d77e74cad9a081084336f627b
#: ../../java/cluster-metrics.rst:28
msgid ""
"and add the following configuration stanza to your ``application.conf`` ::"
msgstr ""

# dcf207a07c6c481d884f20c375e24eb0
#: ../../java/cluster-metrics.rst:33
msgid ""
"Make sure to disable legacy metrics in akka-cluster: "
"``akka.cluster.metrics.enabled=off``, since it is still enabled in akka-"
"cluster by default (for compatibility with past releases)."
msgstr ""

# 9534784c426e423e83c1c7cde5f78856
#: ../../java/cluster-metrics.rst:36
msgid ""
"Cluster members with status :ref:`WeaklyUp <weakly_up_java>`, if that "
"feature is enabled, will participate in Cluster Metrics collection and "
"dissemination."
msgstr ""

# 4822390a1ac04900a59d97697898d609
#: ../../java/cluster-metrics.rst:40
msgid "Metrics Collector"
msgstr ""

# 9693a52b84954cad8e476092ab29e77f
#: ../../java/cluster-metrics.rst:42
msgid ""
"Metrics collection is delegated to an implementation of "
"``akka.cluster.metrics.MetricsCollector``."
msgstr ""

# 43544fc92e73488183d7e8138ee88e1f
#: ../../java/cluster-metrics.rst:44
msgid ""
"Different collector implementations provide different subsets of metrics "
"published to the cluster. Certain message routing and let-it-crash functions"
" may not work when Sigar is not provisioned."
msgstr ""

# aac5288f00d2454c9558a0bf065702a8
#: ../../java/cluster-metrics.rst:47
msgid ""
"Cluster metrics extension comes with two built-in collector implementations:"
msgstr ""

# 5f2c489319b24dcf8163e1797d676b47
#: ../../java/cluster-metrics.rst:49
msgid ""
"``akka.cluster.metrics.SigarMetricsCollector``, which requires Sigar "
"provisioning, and is more rich/precise"
msgstr ""

# 8200bf59211f476badd043615aa542a7
#: ../../java/cluster-metrics.rst:50
msgid ""
"``akka.cluster.metrics.JmxMetricsCollector``, which is used as fall back, "
"and is less rich/precise"
msgstr ""

# 7461a9a5d7ca4d0daa5bfff6763accfa
#: ../../java/cluster-metrics.rst:52
msgid "You can also plug-in your own metrics collector implementation."
msgstr ""

# dbadf87ac74d43c29cbcf1c7abcfa9a2
#: ../../java/cluster-metrics.rst:54
msgid ""
"By default, metrics extension will use collector provider fall back and will"
" try to load them in this order:"
msgstr ""

# b5c03a03100a49ab88b5b7352071dec9
#: ../../java/cluster-metrics.rst:56
msgid "configured user-provided collector"
msgstr ""

# de7584a0cfb14edf9e6ff71ba3a92a8f
#: ../../java/cluster-metrics.rst:57
msgid "built-in ``akka.cluster.metrics.SigarMetricsCollector``"
msgstr ""

# 4620b2e254f8439d926f8086392a6ebe
#: ../../java/cluster-metrics.rst:58
msgid "and finally ``akka.cluster.metrics.JmxMetricsCollector``"
msgstr ""

# 7767c4ee9cb54dd29e78c9c973faf97e
#: ../../java/cluster-metrics.rst:61
msgid "Metrics Events"
msgstr ""

# 1e21d03ab1f545ed87c6a2633d9f4977
#: ../../java/cluster-metrics.rst:63
msgid ""
"Metrics extension periodically publishes current snapshot of the cluster "
"metrics to the node system event bus."
msgstr ""

# 38ba5522840244f5b5e32372a70d102e
#: ../../java/cluster-metrics.rst:65
msgid ""
"The publication period is controlled by the ``akka.cluster.metrics.collector"
".sample-period`` setting."
msgstr ""

# 63d88efd6cfc452dbad1e13b50e777ce
#: ../../java/cluster-metrics.rst:67
msgid ""
"The payload of the ``akka.cluster.metrics.ClusterMetricsChanged`` event will"
" contain latest metrics of the node as well as other cluster member nodes "
"metrics gossip which was received during the collector sample period."
msgstr ""

# d24c0bf202db4c108a0bd5ab24636e8d
#: ../../java/cluster-metrics.rst:71
msgid ""
"You can subscribe your metrics listener actors to these events in order to "
"implement custom node lifecycle ::"
msgstr ""

# ac7fa5efc5014e1dbf5acca9353c3991
#: ../../java/cluster-metrics.rst:77
msgid "Hyperic Sigar Provisioning"
msgstr ""

# 8e8d45f5db1a4aeea2bcf92e66126551
#: ../../java/cluster-metrics.rst:79
msgid ""
"Both user-provided and built-in metrics collectors can optionally use "
"`Hyperic Sigar <http://www.hyperic.com/products/sigar>`_ for a wider and "
"more accurate range of metrics compared to what can be retrieved from "
"ordinary JMX MBeans."
msgstr ""

# f29035ac2c714d49bd23269de9ee69eb
#: ../../java/cluster-metrics.rst:82
msgid ""
"Sigar is using a native o/s library, and requires library provisioning, i.e."
" deployment, extraction and loading of the o/s native library into JVM at "
"runtime."
msgstr ""

# 7fa2127c30414aa395e64994c465dd07
#: ../../java/cluster-metrics.rst:85
msgid ""
"User can provision Sigar classes and native library in one of the following "
"ways:"
msgstr ""

# 30900c0c4fc04b3d945095225161f690
#: ../../java/cluster-metrics.rst:87
msgid ""
"Use `Kamon sigar-loader <https://github.com/kamon-io/sigar-loader>`_ as a "
"project dependency for the user project. Metrics extension will extract and "
"load sigar library on demand with help of Kamon sigar provisioner."
msgstr ""

# f44006700ec243b1a8c4f0d9f6f32de9
#: ../../java/cluster-metrics.rst:89
msgid ""
"Use `Kamon sigar-loader <https://github.com/kamon-io/sigar-loader>`_ as java"
" agent: ``java -javaagent:/path/to/sigar-loader.jar``. Kamon sigar loader "
"agent will extract and load sigar library during JVM start."
msgstr ""

# c7e7df4541144cb399796ef13da47443
#: ../../java/cluster-metrics.rst:91
msgid ""
"Place ``sigar.jar`` on the ``classpath`` and Sigar native library for the "
"o/s on the ``java.library.path``. User is required to manage both project "
"dependency and library deployment manually."
msgstr ""

# 6f2203acfb3c4f5f89f105894245cae7
#: ../../java/cluster-metrics.rst:96
msgid ""
"When using `Kamon sigar-loader <https://github.com/kamon-io/sigar-loader>`_ "
"and running multiple instances of the same application on the same host, you"
" have to make sure that sigar library is extracted to a unique per instance "
"directory. You can control the extract directory with the "
"``akka.cluster.metrics.native-library-extract-folder`` configuration "
"setting."
msgstr ""

# 613cf2673aa147c7b559495240331749
#: ../../java/cluster-metrics.rst:101
msgid ""
"To enable usage of Sigar you can add the following dependency to the user "
"project ::"
msgstr ""

# 03b5e615164b4fd7b44f9509ec5d1915
#: ../../java/cluster-metrics.rst:110
msgid ""
"You can download Kamon sigar-loader from `Maven Central "
"<http://search.maven.org/#search%7Cga%7C1%7Csigar-loader>`_"
msgstr ""

# fb0d63b3dfe94a4ab1ed6d313efcf55f
#: ../../java/cluster-metrics.rst:113
msgid "Adaptive Load Balancing"
msgstr ""

# ba073feaf63d493cb959f3e89f36c183
#: ../../java/cluster-metrics.rst:115
msgid ""
"The ``AdaptiveLoadBalancingPool`` / ``AdaptiveLoadBalancingGroup`` performs "
"load balancing of messages to cluster nodes based on the cluster metrics "
"data. It uses random selection of routees with probabilities derived from "
"the remaining capacity of the corresponding node. It can be configured to "
"use a specific MetricsSelector to produce the probabilities, a.k.a. weights:"
msgstr ""

# 92fbad1b99c2492c9d67770c8610f61d
#: ../../java/cluster-metrics.rst:119
msgid ""
"``heap`` / ``HeapMetricsSelector`` - Used and max JVM heap memory. Weights "
"based on remaining heap capacity; (max - used) / max"
msgstr ""

# 4c9f1f62ab9949e0af49f91f7f33550f
#: ../../java/cluster-metrics.rst:120
msgid ""
"``load`` / ``SystemLoadAverageMetricsSelector`` - System load average for "
"the past 1 minute, corresponding value can be found in ``top`` of Linux "
"systems. The system is possibly nearing a bottleneck if the system load "
"average is nearing number of cpus/cores. Weights based on remaining load "
"capacity; 1 - (load / processors)"
msgstr ""

# 33d8b793cd4d405c9b94348384c08b03
#: ../../java/cluster-metrics.rst:121
msgid ""
"``cpu`` / ``CpuMetricsSelector`` - CPU utilization in percentage, sum of "
"User + Sys + Nice + Wait. Weights based on remaining cpu capacity; 1 - "
"utilization"
msgstr ""

# e9625c7ef9dd41e7b8e373417c86e580
#: ../../java/cluster-metrics.rst:122
msgid ""
"``mix`` / ``MixMetricsSelector`` - Combines heap, cpu and load. Weights "
"based on mean of remaining capacity of the combined selectors."
msgstr ""

# 92743b8eba0b45ae876989c4cfbe6a5f
#: ../../java/cluster-metrics.rst:123
msgid "Any custom implementation of ``akka.cluster.metrics.MetricsSelector``"
msgstr ""

# 2aac42fea0aa45eb8b1efe3048289fde
#: ../../java/cluster-metrics.rst:125
msgid ""
"The collected metrics values are smoothed with `exponential weighted moving "
"average "
"<http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average>`_. "
"In the :ref:`cluster_configuration_java` you can adjust how quickly past "
"data is decayed compared to new data."
msgstr ""

# ab39ec147ed4450ca50264c89b685b51
#: ../../java/cluster-metrics.rst:127
msgid ""
"Let's take a look at this router in action. What can be more demanding than "
"calculating factorials?"
msgstr ""

# 0c1ebc898a6e42019f8229bf0b5f2671
#: ../../java/cluster-metrics.rst:129
msgid "The backend worker that performs the factorial calculation:"
msgstr ""

# 866b1d3e45c446e3970b9494d4b46d16
#: ../../java/cluster-metrics.rst:133
msgid ""
"The frontend that receives user jobs and delegates to the backends via the "
"router:"
msgstr ""

# d7e100d24b8548a1af7e16192a33e084
#: ../../java/cluster-metrics.rst:138
msgid ""
"As you can see, the router is defined in the same way as other routers, and "
"in this case it is configured as follows:"
msgstr ""

# ced44013e5d849f18152343fe010f902
#: ../../java/cluster-metrics.rst:142
msgid ""
"It is only ``router`` type and the ``metrics-selector`` parameter that is "
"specific to this router, other things work in the same way as other routers."
msgstr ""

# d0aec80f283742b8971e14f73f0f13dc
# ded47350e4a44203b093babd262c877d
# c8f098638b5b4ed4acc8a2c09e0ddd9a
#: ../../java/cluster-metrics.rst:145 ../../java/cluster-usage.rst:538
#: ../../java/cluster-usage.rst:601
msgid "The same type of router could also have been defined in code:"
msgstr ""

# 91226a60044e4f7da1ca1edb0faa9fbb
#: ../../java/cluster-metrics.rst:151
msgid ""
"The `Lightbend Activator <http://www.lightbend.com/platform/getstarted>`_ "
"tutorial named `Akka Cluster Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-cluster-java>`_. "
"contains the full source code and instructions of how to run the **Adaptive "
"Load Balancing** sample."
msgstr ""

# 7d6d3a4a39b84b0e825bba9db583b7d6
#: ../../java/cluster-metrics.rst:156
msgid "Subscribe to Metrics Events"
msgstr ""

# f7482906aff248028f9bb4764557b5b2
#: ../../java/cluster-metrics.rst:158
msgid ""
"It is possible to subscribe to the metrics events directly to implement "
"other functionality."
msgstr ""

# e15ded8538a544a393595cef8e25b893
#: ../../java/cluster-metrics.rst:163
msgid "Custom Metrics Collector"
msgstr ""

# 8cae4d01eb4445d9961671ae92f41980
#: ../../java/cluster-metrics.rst:165
msgid ""
"Metrics collection is delegated to the implementation of "
"``akka.cluster.metrics.MetricsCollector``"
msgstr ""

# 650d84f0ec66439da9f4af5349905175
#: ../../java/cluster-metrics.rst:167
msgid ""
"You can plug-in your own metrics collector instead of built-in "
"``akka.cluster.metrics.SigarMetricsCollector`` or "
"``akka.cluster.metrics.JmxMetricsCollector``."
msgstr ""

# 17d040f3c6b34f8593e912a111a1da73
#: ../../java/cluster-metrics.rst:170
msgid "Look at those two implementations for inspiration."
msgstr ""

# f2436bc8173149879c5179853e66fa31
#: ../../java/cluster-metrics.rst:172
msgid ""
"Custom metrics collector implementation class must be specified in the "
"``akka.cluster.metrics.collector.provider`` configuration property."
msgstr ""

# 5ad9e7de83774e37800e85173de8db76
#: ../../java/cluster-metrics.rst:178
msgid ""
"The Cluster metrics extension can be configured with the following "
"properties:"
msgstr ""

# 69b38c7be82b40f092048e52f41fcdf4
# 9be69e6f0f3b4d0c99a9d7989c3d4f32
#: ../../java/cluster-sharding.rst:4 ../../java/cluster-usage.rst:380
msgid "Cluster Sharding"
msgstr "クラスタシャーディング"

# 3ae6f8a393b14bbfb81f89de5e68e991
#: ../../java/cluster-sharding.rst:6
msgid ""
"Cluster sharding is useful when you need to distribute actors across several"
" nodes in the cluster and want to be able to interact with them using their "
"logical identifier, but without having to care about their physical location"
" in the cluster, which might also change over time."
msgstr ""
"クラスタシャーディングはクラスタのいくつかのノードにまたがってアクターを分散させ、時間とともに変化するであろうクラスタでの物理的な位置を気にすることなしに、それらを論理的な識別子を使って相互作用できるようにしたいときに便利です。"

# 7806890b1a394d3a939f7ded60e78a4f
#: ../../java/cluster-sharding.rst:10
msgid ""
"It could for example be actors representing Aggregate Roots in Domain-Driven"
" Design terminology. Here we call these actors \"entities\". These actors "
"typically have persistent (durable) state, but this feature is not limited "
"to actors with persistent state."
msgstr ""
"例として、アクターをドメイン駆動設計の用語で集約ルートとして表すこともできます。ここではアクターのことを\"エンティティ\"と呼びます。これらのアクターは一般的に永続性(耐久性)のある状態を持ちますが、この機能では状態が永続化されたアクターとは限りません。"

# 9032ddcf6d1345a4b8444e9a02d5a845
#: ../../java/cluster-sharding.rst:14
msgid ""
"Cluster sharding is typically used when you have many stateful actors that "
"together consume more resources (e.g. memory) than fit on one machine. If "
"you only have a few stateful actors it might be easier to run them on a :ref"
":`cluster-singleton-java` node."
msgstr ""

# 2c60a9d3b62345e4b5d4daab77978b73
#: ../../java/cluster-sharding.rst:18
msgid ""
"In this context sharding means that actors with an identifier, so called "
"entities, can be automatically distributed across multiple nodes in the "
"cluster. Each entity actor runs only at one place, and messages can be sent "
"to the entity without requiring the sender to know the location of the "
"destination actor. This is achieved by sending the messages via a "
"``ShardRegion`` actor provided by this extension, which knows how to route "
"the message with the entity id to the final destination."
msgstr ""
"この文脈においてシャーディングは識別子を持ったアクターを意味するので、エンティティと呼び、クラスタの復数のノードにまたっがって自動的に分散させることができるようになります。それぞれのエンティティのアクターは一箇所でのみ稼働し、メッセージは送り元が宛先のアクターの居場所を必要とせず送れるようになります。これはこの拡張から提供される、エンティティ"
" ID が含まれているメッセージをどうルートすれば最終的な宛先に届くのかを知っている `ShardRegion` "
"アクターを通じてメッセージを送ることで成し遂げられます。"

# 5fd4a4f81665453aa69c98cf374cb8c7
#: ../../java/cluster-sharding.rst:25
msgid ""
"Cluster sharding will not be active on members with status :ref:`WeaklyUp "
"<weakly_up_java>` if that feature is enabled."
msgstr ""

# 3b35e5d110e84ec0a8b2de7276a19574
#: ../../java/cluster-sharding.rst:31
msgid "This is how an entity actor may look like:"
msgstr "エンティティのアクターがどう見えるか:"

# e3312dad71f64dc59be2a2fee2cd0ee9
#: ../../java/cluster-sharding.rst:35
msgid ""
"The above actor uses event sourcing and the support provided in "
"``UntypedPersistentActor`` to store its state. It does not have to be a "
"persistent actor, but in case of failure or migration of entities between "
"nodes it must be able to recover its state if it is valuable."
msgstr ""

# 6a0cb965b6294f1ead8043b382ebe474
#: ../../java/cluster-sharding.rst:39
msgid ""
"Note how the ``persistenceId`` is defined. The name of the actor is the "
"entity identifier (utf-8 URL-encoded). You may define it another way, but it"
" must be unique."
msgstr ""
"``persistenceId`` がどう定義されているか注目してください。アクターの名前はエンティティの識別子 (URL エンコードされた "
"utf-8) です。あなたは他の方法で定義するかもしれませんが、ユニークになる必要があります。"

# c52864f650fe4fb29a7a0e691565a29c
#: ../../java/cluster-sharding.rst:42
msgid ""
"When using the sharding extension you are first, typically at system startup"
" on each node in the cluster, supposed to register the supported entity "
"types with the ``ClusterSharding.start`` method. ``ClusterSharding.start`` "
"gives you the reference which you can pass along."
msgstr ""
"シャーディングの拡張を使うときはまず、一般的にはクラスタのそれぞれのノードのシステム起動時に、``ClusterSharding.start`` "
"メソッドでサポートされているエンティティの型を登録することになっています。``ClusterSharding.start`` "
"は参照を提供し、その参照を伝って渡すことができます。"

# 7fc26d5486fb4f7395fa7165ff6a4076
#: ../../java/cluster-sharding.rst:48
msgid ""
"The ``messageExtractor`` defines application specific methods to extract the"
" entity identifier and the shard identifier from incoming messages."
msgstr ""

# 5790924de7ae406aacb6e05911164c4d
#: ../../java/cluster-sharding.rst:53
msgid ""
"This example illustrates two different ways to define the entity identifier "
"in the messages:"
msgstr "この例はメッセージにあるエンティティの識別子を定義する 2 つの異なる方法を示しています。"

# 115e420396bc49509ca8b71f8686e713
#: ../../java/cluster-sharding.rst:55
msgid "The ``Get`` message includes the identifier itself."
msgstr "``Get`` メッセージはそれ自身の識別子を含んでいます。"

# a963caf50a484a4ebfd54d0abed828ee
#: ../../java/cluster-sharding.rst:56
msgid ""
"The ``EntityEnvelope`` holds the identifier, and the actual message that is "
"sent to the entity actor is wrapped in the envelope."
msgstr ""
"``EntityEnvelope`` は識別子を保持しており、エンティティのアクターに送られる本当のメッセージはそのエンベロープに包まれています。"

# c385654c92bc4a64b50d9ebc578e7954
#: ../../java/cluster-sharding.rst:59
msgid ""
"Note how these two messages types are handled in the ``entityId`` and "
"``entityMessage`` methods shown above. The message sent to the entity actor "
"is what ``entityMessage`` returns and that makes it possible to unwrap "
"envelopes if needed."
msgstr ""

# a4a7dcb9ad674e929202a544ed66aad4
#: ../../java/cluster-sharding.rst:63
msgid ""
"A shard is a group of entities that will be managed together. The grouping "
"is defined by the ``extractShardId`` function shown above. For a specific "
"entity identifier the shard identifier must always be the same. Otherwise "
"the entity actor might accidentally be started in several places at the same"
" time."
msgstr ""

# 937eccc81d1e42e288b1c5488c609a51
#: ../../java/cluster-sharding.rst:67
msgid ""
"Creating a good sharding algorithm is an interesting challenge in itself. "
"Try to produce a uniform distribution, i.e. same amount of entities in each "
"shard. As a rule of thumb, the number of shards should be a factor ten "
"greater than the planned maximum number of cluster nodes. Less shards than "
"number of nodes will result in that some nodes will not host any shards. Too"
" many shards will result in less efficient management of the shards, e.g. "
"rebalancing overhead, and increased latency because the coordinator is "
"involved in the routing of the first message for each shard. The sharding "
"algorithm must be the same on all nodes in a running cluster. It can be "
"changed after stopping all nodes in the cluster."
msgstr ""
"良いシャーディングアルゴリズムを作ることは、それ自体が興味深い挑戦です。均一な分散、すなわちそれぞれのシャードに同じ量のエンティティになるように作ってみてください。経験則として、シャードの数はクラスタノードの計画された最大数の"
" 10 "
"倍より大きい数にすべきです。ノード数よりも少ないシャードだと、いくつかのノードにはシャードが一つもホストされなくなります。多すぎるシャードはシャードによる管理効率を損ない、例えば、リバランスのオーバーヘッドと、レイテンシの増加に繋がります。コーディネーターがそれぞれのシャードへの最初のメッセージルーティングに関わっているからです。シャーディングのアルゴリズムは稼働しているクラスタの全てのノードで同じである必要があります。クラスタの全てのノードを停止させた後、変更することができるようになります。"

# f2a9607bc6cd410295dff64b6948b2b8
#: ../../java/cluster-sharding.rst:75
msgid ""
"A simple sharding algorithm that works fine in most cases is to take the "
"absolute value of the ``hashCode`` of the entity identifier modulo number of"
" shards. As a convenience this is provided by the "
"``ShardRegion.HashCodeMessageExtractor``."
msgstr ""
"ほとんどのケースにおいて、エンティティの識別子の ``hashCode`` "
"の絶対値をシャードの数で余剰を取るシンプルなシャードのアルゴリズムで上手くいきます。これは利便性のために "
"``ShardRegion.HashCodeMessageExtractor`` で提供されています。"

# 06c6cda6dc9d405a862e89303b8c0674
#: ../../java/cluster-sharding.rst:79
msgid ""
"Messages to the entities are always sent via the local ``ShardRegion``. The "
"``ShardRegion`` actor reference for a named entity type is returned by "
"``ClusterSharding.start`` and it can also be retrieved with "
"``ClusterSharding.shardRegion``. The ``ShardRegion`` will lookup the "
"location of the shard for the entity if it does not already know its "
"location. It will delegate the message to the right node and it will create "
"the entity actor on demand, i.e. when the first message for a specific "
"entity is delivered."
msgstr ""
"エンティティへのメッセージはいつもローカルの ``ShardRegion`` を通じて送信されます。名付けられた、あるエンティティの型のための "
"``ShardRegion`` アクターの参照は ``ClusterSharding.start`` "
"から返され、``ClusterSharding.shardRegion`` "
"でも取り出すことができます。エンティティのシャードの位置をまだ知らないとき、``ShardRegion`` "
"は、その位置を見つけ出します。それはメッセージを正しいノードに委譲し、オンデマンドで、すなわち特定のエンティティに最初のメッセージが送られたときにエンティティのアクターを作ります。"

# cd12e00e1be24528913435d42dc4eeb0
# 5c977f26edb94a228b06590b41033bb5
#: ../../java/cluster-sharding.rst:88 ../../java/testing.rst:540
msgid "How it works"
msgstr ""

# 55002eea468b4f6aa401129790af71e1
#: ../../java/cluster-sharding.rst:90
msgid ""
"The ``ShardRegion`` actor is started on each node in the cluster, or group "
"of nodes tagged with a specific role. The ``ShardRegion`` is created with "
"two application specific functions to extract the entity identifier and the "
"shard identifier from incoming messages. A shard is a group of entities that"
" will be managed together. For the first message in a specific shard the "
"``ShardRegion`` request the location of the shard from a central "
"coordinator, the ``ShardCoordinator``."
msgstr ""

# bdbf2d77d284497c8f04efe2db9e0638
#: ../../java/cluster-sharding.rst:97
msgid ""
"The ``ShardCoordinator`` decides which ``ShardRegion`` shall own the "
"``Shard`` and informs that ``ShardRegion``. The region will confirm this "
"request and create the ``Shard`` supervisor as a child actor. The individual"
" ``Entities`` will then be created when needed by the ``Shard`` actor. "
"Incoming messages thus travel via the ``ShardRegion`` and the ``Shard`` to "
"the target ``Entity``."
msgstr ""

# 991cfff78f344f3a9c6aa0bd1cddc7bf
#: ../../java/cluster-sharding.rst:103
msgid ""
"If the shard home is another ``ShardRegion`` instance messages will be "
"forwarded to that ``ShardRegion`` instance instead. While resolving the "
"location of a shard incoming messages for that shard are buffered and later "
"delivered when the shard home is known. Subsequent messages to the resolved "
"shard can be delivered to the target destination immediately without "
"involving the ``ShardCoordinator``."
msgstr ""

# 504c86ef91e94cf1beb56620f25aedc7
#: ../../java/cluster-sharding.rst:109
msgid "Scenario 1:"
msgstr ""

# e3d3f76b2d1c4deb90d02c85ae93cc95
#: ../../java/cluster-sharding.rst:111
msgid "Incoming message M1 to ``ShardRegion`` instance R1."
msgstr ""

# da0f77d1dd0a49efa5b18eb390200785
#: ../../java/cluster-sharding.rst:112
msgid ""
"M1 is mapped to shard S1. R1 doesn't know about S1, so it asks the "
"coordinator C for the location of S1."
msgstr ""

# 20c0a9e5878a4816aa90d2f81abfd4e7
#: ../../java/cluster-sharding.rst:113
msgid "C answers that the home of S1 is R1."
msgstr ""

# 2c132b7cf5ad40e6b6694528e94b82d4
#: ../../java/cluster-sharding.rst:114
msgid ""
"R1 creates child actor for the entity E1 and sends buffered messages for S1 "
"to E1 child"
msgstr ""

# 41887f7d7016488598abbea71f5bbe85
#: ../../java/cluster-sharding.rst:115
msgid ""
"All incoming messages for S1 which arrive at R1 can be handled by R1 without"
" C. It creates entity children as needed, and forwards messages to them."
msgstr ""

# e97dca48f0684310bb2b4b2a4306577d
#: ../../java/cluster-sharding.rst:117
msgid "Scenario 2:"
msgstr ""

# 286c3f584c76454bb59feb1315058622
#: ../../java/cluster-sharding.rst:119
msgid "Incoming message M2 to R1."
msgstr ""

# fc8d7a5ccadb4d7b88a3a1cb6c13208a
#: ../../java/cluster-sharding.rst:120
msgid ""
"M2 is mapped to S2. R1 doesn't know about S2, so it asks C for the location "
"of S2."
msgstr ""

# 3de52484ad7f4579a0d9ff16a5599418
#: ../../java/cluster-sharding.rst:121
msgid "C answers that the home of S2 is R2."
msgstr ""

# 5735ce77137645c0831f3753e2095ca8
#: ../../java/cluster-sharding.rst:122
msgid "R1 sends buffered messages for S2 to R2"
msgstr ""

# 93b6de11f7274d89b8373b2d59b732d2
#: ../../java/cluster-sharding.rst:123
msgid ""
"All incoming messages for S2 which arrive at R1 can be handled by R1 without"
" C. It forwards messages to R2."
msgstr ""

# a7d0a4ac47434d348cc15ebb832525d9
#: ../../java/cluster-sharding.rst:124
msgid ""
"R2 receives message for S2, ask C, which answers that the home of S2 is R2, "
"and we are in Scenario 1 (but for R2)."
msgstr ""

# a5d7ef245b384b16a3298b7430ee77b6
#: ../../java/cluster-sharding.rst:126
msgid ""
"To make sure that at most one instance of a specific entity actor is running"
" somewhere in the cluster it is important that all nodes have the same view "
"of where the shards are located. Therefore the shard allocation decisions "
"are taken by the central ``ShardCoordinator``, which is running as a cluster"
" singleton, i.e. one instance on the oldest member among all cluster nodes "
"or a group of nodes tagged with a specific role."
msgstr ""

# 99deada860b24240b2eef3f77493f425
#: ../../java/cluster-sharding.rst:133
msgid ""
"The logic that decides where a shard is to be located is defined in a "
"pluggable shard allocation strategy. The default implementation "
"``ShardCoordinator.LeastShardAllocationStrategy`` allocates new shards to "
"the ``ShardRegion`` with least number of previously allocated shards. This "
"strategy can be replaced by an application specific implementation."
msgstr ""

# a77c2550f83846bab3d331737a26a6f9
#: ../../java/cluster-sharding.rst:138
msgid ""
"To be able to use newly added members in the cluster the coordinator "
"facilitates rebalancing of shards, i.e. migrate entities from one node to "
"another. In the rebalance process the coordinator first notifies all "
"``ShardRegion`` actors that a handoff for a shard has started. That means "
"they will start buffering incoming messages for that shard, in the same way "
"as if the shard location is unknown. During the rebalance process the "
"coordinator will not answer any requests for the location of shards that are"
" being rebalanced, i.e. local buffering will continue until the handoff is "
"completed. The ``ShardRegion`` responsible for the rebalanced shard will "
"stop all entities in that shard by sending the specified "
"``handOffStopMessage`` (default ``PoisonPill``) to them. When all entities "
"have been terminated the ``ShardRegion`` owning the entities will "
"acknowledge the handoff as completed to the coordinator. Thereafter the "
"coordinator will reply to requests for the location of the shard and thereby"
" allocate a new home for the shard and then buffered messages in the "
"``ShardRegion`` actors are delivered to the new location. This means that "
"the state of the entities are not transferred or migrated. If the state of "
"the entities are of importance it should be persistent (durable), e.g. with "
":ref:`persistence-java`, so that it can be recovered at the new location."
msgstr ""

# b04184dd64f34e25a795cdc04bdc408c
#: ../../java/cluster-sharding.rst:155
msgid ""
"The logic that decides which shards to rebalance is defined in a pluggable "
"shard allocation strategy. The default implementation "
"``ShardCoordinator.LeastShardAllocationStrategy`` picks shards for handoff "
"from the ``ShardRegion`` with most number of previously allocated shards. "
"They will then be allocated to the ``ShardRegion`` with least number of "
"previously allocated shards, i.e. new members in the cluster. There is a "
"configurable threshold of how large the difference must be to begin the "
"rebalancing. This strategy can be replaced by an application specific "
"implementation."
msgstr ""

# bc020b87cb00406ebca65c1dad6d1699
#: ../../java/cluster-sharding.rst:163
msgid ""
"The state of shard locations in the ``ShardCoordinator`` is persistent "
"(durable) with :ref:`persistence-java` to survive failures. Since it is "
"running in a cluster :ref:`persistence-java` must be configured with a "
"distributed journal. When a crashed or unreachable coordinator node has been"
" removed (via down) from the cluster a new ``ShardCoordinator`` singleton "
"actor will take over and the state is recovered. During such a failure "
"period shards with known location are still available, while messages for "
"new (unknown) shards are buffered until the new ``ShardCoordinator`` becomes"
" available."
msgstr ""

# f60f53acabfa445f85b4af4d1a585e1b
#: ../../java/cluster-sharding.rst:171
msgid ""
"As long as a sender uses the same ``ShardRegion`` actor to deliver messages "
"to an entity actor the order of the messages is preserved. As long as the "
"buffer limit is not reached messages are delivered on a best effort basis, "
"with at-most once delivery semantics, in the same way as ordinary message "
"sending. Reliable end-to-end messaging, with at-least-once semantics can be "
"added by using ``AtLeastOnceDelivery``  in :ref:`persistence-java`."
msgstr ""

# 31e1a7e6950d4f27b71732fbdcc776df
#: ../../java/cluster-sharding.rst:177
msgid ""
"Some additional latency is introduced for messages targeted to new or "
"previously unused shards due to the round-trip to the coordinator. "
"Rebalancing of shards may also add latency. This should be considered when "
"designing the application specific shard resolution, e.g. to avoid too fine "
"grained shards."
msgstr ""

# e30a97460eb048a981812f10d059d0d0
#: ../../java/cluster-sharding.rst:183
msgid "Distributed Data Mode"
msgstr ""

# 6723463180ef487cb32b90d6be1d70dc
#: ../../java/cluster-sharding.rst:185
msgid ""
"Instead of using :ref:`persistence-java` it is possible to use the "
":ref:`distributed_data_java` module as storage for the state of the sharding"
" coordinator. In such case the state of the ``ShardCoordinator`` will be "
"replicated inside a cluster by the :ref:`distributed_data_java` module with "
"``WriteMajority``/``ReadMajority`` consistency."
msgstr ""

# 20f39fc0f3fb482ab00faf5e5621d5af
#: ../../java/cluster-sharding.rst:190
msgid "This mode can be enabled by setting configuration property::"
msgstr ""

# 4454e1c7f10a4b6ebedb0c8fd3861508
#: ../../java/cluster-sharding.rst:194
msgid ""
"It is using the Distributed Data extension that must be running on all nodes"
" in the cluster. Therefore you should add that extension to the "
"configuration to make sure that it is started on all nodes::"
msgstr ""

# 21c14bb496054a338efbcddd3ce522b1
#: ../../java/cluster-sharding.rst:200
msgid ""
"You must explicitly add the ``akka-distributed-data-experimental`` "
"dependency to your build if you use this mode. It is possible to remove "
"``akka-persistence`` dependency from a project if it is not used in user "
"code and ``remember-entities`` is ``off``. Using it together with ``Remember"
" Entities`` shards will be recreated after rebalancing, however will not be "
"recreated after a clean cluster start as the Sharding Coordinator state is "
"empty after a clean cluster start when using ddata mode. When ``Remember "
"Entities`` is ``on`` Sharding Region always keeps data usig persistence, no "
"matter how ``State Store Mode`` is set."
msgstr ""

# 6328b5086fda4a9592ddbc8ac6ccd8f9
#: ../../java/cluster-sharding.rst:210
msgid ""
"The ``ddata`` mode is considered as **“experimental”** as of its "
"introduction in Akka 2.4.0, since it depends on the experimental Distributed"
" Data module."
msgstr ""

# a16dbe335b4a406cbc7e662cb4aaadca
#: ../../java/cluster-sharding.rst:214
msgid "Proxy Only Mode"
msgstr ""

# b5d7f029fdfd4f15b8ecc23de97358c0
#: ../../java/cluster-sharding.rst:216
msgid ""
"The ``ShardRegion`` actor can also be started in proxy only mode, i.e. it "
"will not host any entities itself, but knows how to delegate messages to the"
" right location. A ``ShardRegion`` is started in proxy only mode with the "
"method ``ClusterSharding.startProxy`` method."
msgstr ""

# 960d204cd654495e9f74b44c84c87464
#: ../../java/cluster-sharding.rst:222
msgid "Passivation"
msgstr ""

# 3f7cb38c383a41358e8eddfd32ac1ac4
#: ../../java/cluster-sharding.rst:224
msgid ""
"If the state of the entities are persistent you may stop entities that are "
"not used to reduce memory consumption. This is done by the application "
"specific implementation of the entity actors for example by defining receive"
" timeout (``context.setReceiveTimeout``). If a message is already enqueued "
"to the entity when it stops itself the enqueued message in the mailbox will "
"be dropped. To support graceful passivation without losing such messages the"
" entity actor can send ``ShardRegion.Passivate`` to its parent ``Shard``. "
"The specified wrapped message in ``Passivate`` will be sent back to the "
"entity, which is then supposed to stop itself. Incoming messages will be "
"buffered by the ``Shard`` between reception of ``Passivate`` and termination"
" of the entity. Such buffered messages are thereafter delivered to a new "
"incarnation of the entity."
msgstr ""

# 05a64e1fae334cafbb91c5c6ba7da562
#: ../../java/cluster-sharding.rst:236
msgid "Remembering Entities"
msgstr ""

# 57d08d4820f94078ba52117bcbf460d4
#: ../../java/cluster-sharding.rst:238
msgid ""
"The list of entities in each ``Shard`` can be made persistent (durable) by "
"setting the ``rememberEntities`` flag to true in ``ClusterShardingSettings``"
" when calling ``ClusterSharding.start``. When configured to remember "
"entities, whenever a ``Shard`` is rebalanced onto another node or recovers "
"after a crash it will recreate all the entities which were previously "
"running in that ``Shard``. To permanently stop entities, a ``Passivate`` "
"message must be sent to the parent of the entity actor, otherwise the entity"
" will be automatically restarted after the entity restart backoff specified "
"in the configuration."
msgstr ""

# aa3a11e0fae04b6db9f803c0a3cd4a20
#: ../../java/cluster-sharding.rst:247
msgid ""
"When ``rememberEntities`` is set to false, a ``Shard`` will not "
"automatically restart any entities after a rebalance or recovering from a "
"crash. Entities will only be started once the first message for that entity "
"has been received in the ``Shard``. Entities will not be restarted if they "
"stop without using a ``Passivate``."
msgstr ""

# f6a819ed1e6a47929e6653aec721f95e
#: ../../java/cluster-sharding.rst:252
msgid ""
"Note that the state of the entities themselves will not be restored unless "
"they have been made persistent, e.g. with :ref:`persistence-java`."
msgstr ""

# 492dfb7d4efb4cee80eb7c34fa74b9ee
# 7b85af09a6cf4f6897d29700729786e0
#: ../../java/cluster-sharding.rst:256 ../../java/routing.rst:127
msgid "Supervision"
msgstr ""

# 50627ee88b5b476d90e10d1960622339
#: ../../java/cluster-sharding.rst:258
msgid ""
"If you need to use another ``supervisorStrategy`` for the entity actors than"
" the default (restarting) strategy you need to create an intermediate parent"
" actor that defines the ``supervisorStrategy`` to the child entity actor."
msgstr ""

# cb2341baae7a4a249b65ea74322021b8
#: ../../java/cluster-sharding.rst:264
msgid ""
"You start such a supervisor in the same way as if it was the entity actor."
msgstr ""

# 71809cc926a74688845e1a02f257bc35
#: ../../java/cluster-sharding.rst:268
msgid ""
"Note that stopped entities will be started again when a new message is "
"targeted to the entity."
msgstr ""

# 6a47a246e7f64d448a4429c12a1b14af
#: ../../java/cluster-sharding.rst:271
msgid "Graceful Shutdown"
msgstr ""

# 8cddb1061bf145f58b6f4b2377569ede
#: ../../java/cluster-sharding.rst:273
msgid ""
"You can send the ``ShardRegion.gracefulShutdownInstance`` message to the "
"``ShardRegion`` actor to handoff all shards that are hosted by that "
"``ShardRegion`` and then the ``ShardRegion`` actor will be stopped. You can "
"``watch`` the ``ShardRegion`` actor to know when it is completed. During "
"this period other regions will buffer messages for those shards in the same "
"way as when a rebalance is triggered by the coordinator. When the shards "
"have been stopped the coordinator will allocate these shards elsewhere."
msgstr ""

# 54389e60ae224c259cb25b7d9caa87ec
#: ../../java/cluster-sharding.rst:279
msgid ""
"When the ``ShardRegion`` has terminated you probably want to ``leave`` the "
"cluster, and shut down the ``ActorSystem``."
msgstr ""

# 2868eb1952334b0ea7d05a6303cec9cc
#: ../../java/cluster-sharding.rst:281
msgid "This is how to do that:"
msgstr ""

# 48f419d9bba945b4b1043ed01f906d96
#: ../../java/cluster-sharding.rst:288
msgid "Removal of Internal Cluster Sharding Data"
msgstr ""

# aab276524a284475aea0850244fb174b
#: ../../java/cluster-sharding.rst:290
msgid ""
"The Cluster Sharding coordinator stores the locations of the shards using "
"Akka Persistence. This data can safely be removed when restarting the whole "
"Akka Cluster. Note that this is not application data."
msgstr ""

# e8c140611af54740844c43fcd092b66f
#: ../../java/cluster-sharding.rst:294
msgid ""
"There is a utility program "
"``akka.cluster.sharding.RemoveInternalClusterShardingData`` that removes "
"this data."
msgstr ""

# 01a3e5e5eb404a8697b3b95cd85f34fa
#: ../../java/cluster-sharding.rst:299
msgid ""
"Never use this program while there are running Akka Cluster nodes that are "
"using Cluster Sharding. Stop all Cluster nodes before using this program."
msgstr ""

# 9a49089237dd4c659574d99a7cf18732
#: ../../java/cluster-sharding.rst:302
msgid ""
"It can be needed to remove the data if the Cluster Sharding coordinator "
"cannot startup because of corrupt data, which may happen if accidentally two"
" clusters were running at the same time, e.g. caused by using auto-down and "
"there was a network partition."
msgstr ""

# fa89ee89ab15444096d1066205db53af
#: ../../java/cluster-sharding.rst:307
msgid "Use this program as a standalone Java main program::"
msgstr ""

# dea1784eec4b45b28af57f69ba343711
#: ../../java/cluster-sharding.rst:313
msgid ""
"The program is included in the ``akka-cluster-sharding`` jar file. It is "
"easiest to run it with same classpath and configuration as your ordinary "
"application. It can be run from sbt or maven in similar way."
msgstr ""

# 771de704a370488ca05aefae30b7ff1b
#: ../../java/cluster-sharding.rst:317
msgid ""
"Specify the entity type names (same as you use in the ``start`` method of "
"``ClusterSharding``) as program arguments."
msgstr ""

# 62413caa5f884031b4d9e2e6175727ec
#: ../../java/cluster-sharding.rst:320
msgid ""
"If you specify ``-2.3`` as the first program argument it will also try to "
"remove data that was stored by Cluster Sharding in Akka 2.3.x using "
"different persistenceId."
msgstr ""

# 9c7d5a60ce3c41769dece1755eff6f31
#: ../../java/cluster-sharding.rst:328
msgid ""
"To use the Cluster Sharding you must add the following dependency in your "
"project."
msgstr ""

# 2e81f70469f647b79a50c347ec8d11f2
#: ../../java/cluster-sharding.rst:345
msgid ""
"The ``ClusterSharding`` extension can be configured with the following "
"properties. These configuration properties are read by the "
"``ClusterShardingSettings`` when created with a ``ActorSystem`` parameter. "
"It is also possible to amend the ``ClusterShardingSettings`` or create it "
"from another config section with the same layout as below. "
"``ClusterShardingSettings`` is a parameter to the ``start`` method of the "
"``ClusterSharding`` extension, i.e. each each entity type can be configured "
"with different settings if needed."
msgstr ""

# 30fd2cfad5aa4e588c007ccfeba6bbdc
#: ../../java/cluster-sharding.rst:354
msgid ""
"Custom shard allocation strategy can be defined in an optional parameter to "
"``ClusterSharding.start``. See the API documentation of "
"``AbstractShardAllocationStrategy`` for details of how to implement a custom"
" shard allocation strategy."
msgstr ""

# 197c90acb98547248b0a60fcf3718bc8
#: ../../java/cluster-sharding.rst:360
msgid "Inspecting cluster sharding state"
msgstr ""

# 9394838d54234ce7aba305799870705e
#: ../../java/cluster-sharding.rst:361
msgid "Two requests to inspect the cluster state are available:"
msgstr ""

# 2306b6d8f9474485a959c5252bc156dc
#: ../../java/cluster-sharding.rst:363
msgid ""
"``ShardRegion.getShardRegionStateInstance`` which will return a "
"``ShardRegion.ShardRegionState`` that contains the identifiers of the shards"
" running in a Region and what entities are alive for each of them."
msgstr ""

# 0853e63e8fb24d78b4d070fe0678dd41
#: ../../java/cluster-sharding.rst:366
msgid ""
"``ShardRegion.GetClusterShardingStats`` which will query all the regions in "
"the cluster and return a ``ShardRegion.ClusterShardingStats`` containing the"
" identifiers of the shards running in each region and a count of entities "
"that are alive in each shard."
msgstr ""

# c509f84fa0c8401493fd13c17d248d69
#: ../../java/cluster-sharding.rst:370
msgid ""
"The purpose of these messages is testing and monitoring, they are not "
"provided to give access to directly sending messages to the individual "
"entities."
msgstr ""

# 413c04acda46480e994ba6f021fbee40
# db24d3bc157b40ac8309654878e7c7e1
#: ../../java/cluster-singleton.rst:4 ../../java/cluster-usage.rst:370
msgid "Cluster Singleton"
msgstr ""

# 5d6fd806705749d2894c1025b27ea51d
# ba30670ea47c411e8e422e4dc8b96471
#: ../../java/cluster-singleton.rst:6 ../../java/cluster-usage.rst:372
msgid ""
"For some use cases it is convenient and sometimes also mandatory to ensure "
"that you have exactly one actor of a certain type running somewhere in the "
"cluster."
msgstr ""

# 0aa587890f844e63a9841b8c9d34e1f0
#: ../../java/cluster-singleton.rst:9
msgid "Some examples:"
msgstr ""

# c308b702501c4b6991a7281afe3bbf8f
#: ../../java/cluster-singleton.rst:11
msgid ""
"single point of responsibility for certain cluster-wide consistent "
"decisions, or coordination of actions across the cluster system"
msgstr ""

# bea5812716da42be8e9b0a42d38c0e5e
#: ../../java/cluster-singleton.rst:13
msgid "single entry point to an external system"
msgstr ""

# e32fb32d6a3b4a6f83db9eb72bd23bb3
#: ../../java/cluster-singleton.rst:14
msgid "single master, many workers"
msgstr ""

# fea3187ba3e84f22b844c7e6fa951f63
#: ../../java/cluster-singleton.rst:15
msgid "centralized naming service, or routing logic"
msgstr ""

# 9b2c8285efc74d5b96b3f88e65ca1d49
#: ../../java/cluster-singleton.rst:17
msgid ""
"Using a singleton should not be the first design choice. It has several "
"drawbacks, such as single-point of bottleneck. Single-point of failure is "
"also a relevant concern, but for some cases this feature takes care of that "
"by making sure that another singleton instance will eventually be started."
msgstr ""

# fcccf5c0aa6e49e69dc4dc932d5b0d21
#: ../../java/cluster-singleton.rst:22
msgid ""
"The cluster singleton pattern is implemented by "
"``akka.cluster.singleton.ClusterSingletonManager``. It manages one singleton"
" actor instance among all cluster nodes or a group of nodes tagged with a "
"specific role. ``ClusterSingletonManager`` is an actor that is supposed to "
"be started on all nodes, or all nodes with specified role, in the cluster. "
"The actual singleton actor is started by the ``ClusterSingletonManager`` on "
"the oldest node by creating a child actor from supplied ``Props``. "
"``ClusterSingletonManager`` makes sure that at most one singleton instance "
"is running at any point in time."
msgstr ""

# ac86034fb5ac42b8976cae6964af86da
#: ../../java/cluster-singleton.rst:30
msgid ""
"The singleton actor is always running on the oldest member with specified "
"role. The oldest member is determined by "
"``akka.cluster.Member#isOlderThan``. This can change when removing that "
"member from the cluster. Be aware that there is a short time period when "
"there is no active singleton during the hand-over process."
msgstr ""

# fbfa7d7616ac414d9113503366a0f83c
#: ../../java/cluster-singleton.rst:35
msgid ""
"The cluster failure detector will notice when oldest node becomes "
"unreachable due to things like JVM crash, hard shut down, or network "
"failure. Then a new oldest node will take over and a new singleton actor is "
"created. For these failure scenarios there will not be a graceful hand-over,"
" but more than one active singletons is prevented by all reasonable means. "
"Some corner cases are eventually resolved by configurable timeouts."
msgstr ""

# 1b865d9497d84640a2994e60a16bcfee
#: ../../java/cluster-singleton.rst:41
msgid ""
"You can access the singleton actor by using the provided "
"``akka.cluster.singleton.ClusterSingletonProxy``, which will route all "
"messages to the current instance of the singleton. The proxy will keep track"
" of the oldest node in the cluster and resolve the singleton's ``ActorRef`` "
"by explicitly sending the singleton's ``actorSelection`` the "
"``akka.actor.Identify`` message and waiting for it to reply. This is "
"performed periodically if the singleton doesn't reply within a certain "
"(configurable) time. Given the implementation, there might be periods of "
"time during which the ``ActorRef`` is unavailable, e.g., when a node leaves "
"the cluster. In these cases, the proxy will buffer the messages sent to the "
"singleton and then deliver them when the singleton is finally available. If "
"the buffer is full the ``ClusterSingletonProxy`` will drop old messages when"
" new messages are sent via the proxy. The size of the buffer is configurable"
" and it can be disabled by using a buffer size of 0."
msgstr ""

# 5d7651e5959848b7b4711406d099b45d
#: ../../java/cluster-singleton.rst:52
msgid ""
"It's worth noting that messages can always be lost because of the "
"distributed nature of these actors. As always, additional logic should be "
"implemented in the singleton (acknowledgement) and in the client (retry) "
"actors to ensure at-least-once message delivery."
msgstr ""

# 257ed4e425cc481f9114197f90891dd3
#: ../../java/cluster-singleton.rst:56
msgid ""
"The singleton instance will not run on members with status :ref:`WeaklyUp "
"<weakly_up_java>` if that feature is enabled."
msgstr ""

# 21b004057150496ba85b9a71ff92fb08
#: ../../java/cluster-singleton.rst:60
msgid "Potential problems to be aware of"
msgstr ""

# b29e50f685944c629c8ec29c5eca2f4e
#: ../../java/cluster-singleton.rst:62
msgid ""
"This pattern may seem to be very tempting to use at first, but it has "
"several drawbacks, some of them are listed below:"
msgstr ""

# a62a8e20843f4626806e3cc4038cfb24
#: ../../java/cluster-singleton.rst:64
msgid "the cluster singleton may quickly become a *performance bottleneck*,"
msgstr ""

# 1a957e1a8c4b4a42bb91390a9419c0c7
#: ../../java/cluster-singleton.rst:65
msgid ""
"you can not rely on the cluster singleton to be *non-stop* available — e.g. "
"when the node on which the singleton has been running dies, it will take a "
"few seconds for this to be noticed and the singleton be migrated to another "
"node,"
msgstr ""

# e278805fbde64763b339f9588e714a71
#: ../../java/cluster-singleton.rst:67
msgid ""
"in the case of a *network partition* appearing in a Cluster that is using "
"Automatic Downing  (see docs for :ref:`automatic-vs-manual-downing-java`), "
"it may happen that the isolated clusters each decide to spin up their own "
"singleton, meaning that there might be multiple singletons running in the "
"system, yet the Clusters have no way of finding out about them (because of "
"the partition)."
msgstr ""

# 5aba49e95f634005bb30b3a1d44b82fd
#: ../../java/cluster-singleton.rst:72
msgid ""
"Especially the last point is something you should be aware of — in general "
"when using the Cluster Singleton pattern you should take care of downing "
"nodes yourself and not rely on the timing based auto-down feature."
msgstr ""

# ef648a7f575445c380a4687057c51ff1
#: ../../java/cluster-singleton.rst:76
msgid ""
"**Be very careful when using Cluster Singleton together with Automatic "
"Downing**, since it allows the cluster to split up into two separate "
"clusters, which in turn will result in *multiple Singletons* being started, "
"one in each separate cluster!"
msgstr ""

# 6fd93d2e0a95423d80a490437b8c92cd
#: ../../java/cluster-singleton.rst:83
msgid ""
"Assume that we need one single entry point to an external system. An actor "
"that receives messages from a JMS queue with the strict requirement that "
"only one JMS consumer must exist to be make sure that the messages are "
"processed in order. That is perhaps not how one would like to design things,"
" but a typical real-world scenario when integrating with external systems."
msgstr ""

# b83e038bd8a04133a4e005031a637b7b
#: ../../java/cluster-singleton.rst:89
msgid ""
"On each node in the cluster you need to start the "
"``ClusterSingletonManager`` and supply the ``Props`` of the singleton actor,"
" in this case the JMS queue consumer."
msgstr ""

# 65396a9397d44e4eb9c4b2d0903a7367
#: ../../java/cluster-singleton.rst:94
msgid ""
"Here we limit the singleton to nodes tagged with the ``\"worker\"`` role, "
"but all nodes, independent of role, can be used by not specifying "
"``withRole``."
msgstr ""

# 5c9e49bb2a6f4eeeab9fd4faaecd3ddd
#: ../../java/cluster-singleton.rst:97
msgid ""
"Here we use an application specific ``terminationMessage`` to be able to "
"close the resources before actually stopping the singleton actor. Note that "
"``PoisonPill`` is a perfectly fine ``terminationMessage`` if you only need "
"to stop the actor."
msgstr ""

# 9bf52b75e04b4f0c9d89c2c130b474a4
#: ../../java/cluster-singleton.rst:101
msgid ""
"With the names given above, access to the singleton can be obtained from any"
" cluster node using a properly configured proxy."
msgstr ""

# 65fe172004d14d2aba8101de3700ff0d
#: ../../java/cluster-singleton.rst:112
msgid ""
"To use the Cluster Singleton you must add the following dependency in your "
"project."
msgstr ""

# 96b178f1d60942a787d1e4ab69c96c2a
#: ../../java/cluster-singleton.rst:130
msgid ""
"The following configuration properties are read by the "
"``ClusterSingletonManagerSettings`` when created with a ``ActorSystem`` "
"parameter. It is also possible to amend the "
"``ClusterSingletonManagerSettings`` or create it from another config section"
" with the same layout as below. ``ClusterSingletonManagerSettings`` is a "
"parameter to the ``ClusterSingletonManager.props`` factory method, i.e. each"
" singleton can be configured with different settings if needed."
msgstr ""

# 8c6f6ac87c934df2b2f7f27d6e2d1410
#: ../../java/cluster-singleton.rst:138
msgid ""
"The following configuration properties are read by the "
"``ClusterSingletonProxySettings`` when created with a ``ActorSystem`` "
"parameter. It is also possible to amend the "
"``ClusterSingletonProxySettings`` or create it from another config section "
"with the same layout as below. ``ClusterSingletonProxySettings`` is a "
"parameter to the ``ClusterSingletonProxy.props`` factory method, i.e. each "
"singleton proxy can be configured with different settings if needed."
msgstr ""

# 73b6f7fa5ce741dfba6e4b938ddb09d6
#: ../../java/cluster-usage.rst:6
msgid "Cluster Usage"
msgstr ""

# 33c151d3bcd74a88bfa39734b2cd53ac
#: ../../java/cluster-usage.rst:8
msgid ""
"For introduction to the Akka Cluster concepts please see :ref:`cluster`."
msgstr ""

# 8149f50bc256404f903d988eebb6aeaf
#: ../../java/cluster-usage.rst:11
msgid "Preparing Your Project for Clustering"
msgstr ""

# aeff38b486ac4df290c2880e184c1d75
#: ../../java/cluster-usage.rst:13
msgid ""
"The Akka cluster is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

# 5d24cfdffd954aaeb5bdfc76ada80179
#: ../../java/cluster-usage.rst:24
msgid "A Simple Cluster Example"
msgstr ""

# 7d42b9ae97474e32a3506ad5fc4d48d5
#: ../../java/cluster-usage.rst:26
msgid ""
"The following configuration enables the ``Cluster`` extension to be used. It"
" joins the cluster and an actor subscribes to cluster membership events and "
"logs them."
msgstr ""

# 3ed2dbc265c243b7931c745d775ff073
#: ../../java/cluster-usage.rst:29
msgid "The ``application.conf`` configuration looks like this:"
msgstr ""

# 952a5078dfec476783415c1e8f576d10
#: ../../java/cluster-usage.rst:33
msgid ""
"To enable cluster capabilities in your Akka project you should, at a "
"minimum, add the :ref:`remoting-java` settings, but with "
"``akka.cluster.ClusterActorRefProvider``. The ``akka.cluster.seed-nodes`` "
"should normally also be added to your ``application.conf`` file."
msgstr ""

# 2603ca917c9c480eb8a5b9ee45247f25
#: ../../java/cluster-usage.rst:38
msgid ""
"If you are running Akka in a Docker container or the nodes for some other "
"reason have separate internal and external ip addresses you must configure "
"remoting according to :ref:`remote-configuration-nat-java`"
msgstr ""

# cd4f582ec766448eb8412a44acc4b4d5
#: ../../java/cluster-usage.rst:41
msgid ""
"The seed nodes are configured contact points for initial, automatic, join of"
" the cluster."
msgstr ""

# bc080ff2d13e4e8c993bf908bdd5759d
#: ../../java/cluster-usage.rst:43
msgid ""
"Note that if you are going to start the nodes on different machines you need"
" to specify the ip-addresses or host names of the machines in "
"``application.conf`` instead of ``127.0.0.1``"
msgstr ""

# 01d3573421664e69a6de1586e1df6810
#: ../../java/cluster-usage.rst:46
msgid "An actor that uses the cluster extension may look like this:"
msgstr ""

# e95f109ceea44ae6ac73bb6a028f87df
#: ../../java/cluster-usage.rst:51
msgid ""
"The actor registers itself as subscriber of certain cluster events. It "
"receives events corresponding to the current state of the cluster when the "
"subscription starts and then it receives events for changes that happen in "
"the cluster."
msgstr ""

# ce4d933f4f0b4abc9ca0a9075c2abcf1
#: ../../java/cluster-usage.rst:54
msgid ""
"The easiest way to run this example yourself is to download `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_ and open the "
"tutorial named `Akka Cluster Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-cluster-java>`_. It"
" contains instructions of how to run the ``SimpleClusterApp``."
msgstr ""

# ab08ab65f4de46eaa860e4e7d5998676
#: ../../java/cluster-usage.rst:59
msgid "Joining to Seed Nodes"
msgstr ""

# d9c6bcc20fcb4d278e1dace753bf1f7a
#: ../../java/cluster-usage.rst:61
msgid ""
"You may decide if joining to the cluster should be done manually or "
"automatically to configured initial contact points, so-called seed nodes. "
"When a new node is started it sends a message to all seed nodes and then "
"sends join command to the one that answers first. If no one of the seed "
"nodes replied (might not be started yet) it retries this procedure until "
"successful or shutdown."
msgstr ""

# aa78aa0e98204e8ba77e6796a1455893
#: ../../java/cluster-usage.rst:67
msgid ""
"You define the seed nodes in the :ref:`cluster_configuration_java` file "
"(application.conf)::"
msgstr ""

# bb96b55efd2b45f58e963531adde595f
#: ../../java/cluster-usage.rst:73
msgid ""
"This can also be defined as Java system properties when starting the JVM "
"using the following syntax::"
msgstr ""

# 4dbe3d2a0cf042b5a854ae3a78514fc5
#: ../../java/cluster-usage.rst:78
msgid ""
"The seed nodes can be started in any order and it is not necessary to have "
"all seed nodes running, but the node configured as the first element in the "
"``seed-nodes`` configuration list must be started when initially starting a "
"cluster, otherwise the other seed-nodes will not become initialized and no "
"other node can join the cluster. The reason for the special first seed node "
"is to avoid forming separated islands when starting from an empty cluster. "
"It is quickest to start all configured seed nodes at the same time (order "
"doesn't matter), otherwise it can take up to the configured ``seed-node-"
"timeout`` until the nodes can join."
msgstr ""

# 733c73e7a9324e93be46d714a7ae73c7
#: ../../java/cluster-usage.rst:88
msgid ""
"Once more than two seed nodes have been started it is no problem to shut "
"down the first seed node. If the first seed node is restarted, it will first"
" try to join the other seed nodes in the existing cluster."
msgstr ""

# c8844bf718a84a82bc4a552d1b003f4d
#: ../../java/cluster-usage.rst:92
msgid ""
"If you don't configure seed nodes you need to join the cluster "
"programmatically or manually."
msgstr ""

# 3aa1cf17c0834d0bad9da846d1ff9472
#: ../../java/cluster-usage.rst:94
msgid ""
"Manual joining can be performed by using ref:`cluster_jmx_java` or "
":ref:`cluster_command_line_java`. Joining programmatically can be performed "
"with ``Cluster.get(system).join``. Unsuccessful join attempts are "
"automatically retried after the time period defined in configuration "
"property ``retry-unsuccessful-join-after``. Retries can be disabled by "
"setting the property to ``off``."
msgstr ""

# 0223e44a90f840f592d65061eaa7fbd2
#: ../../java/cluster-usage.rst:99
msgid ""
"You can join to any node in the cluster. It does not have to be configured "
"as a seed node. Note that you can only join to an existing cluster member, "
"which means that for bootstrapping some node must join itself,and then the "
"following nodes could join them to make up a cluster."
msgstr ""

# 59c86d1ef4744940ab1eb4db827defba
#: ../../java/cluster-usage.rst:103
msgid ""
"You may also use ``Cluster.get(system).joinSeedNodes`` to join "
"programmatically, which is attractive when dynamically discovering other "
"nodes at startup by using some external tool or API. When using "
"``joinSeedNodes`` you should not include the node itself except for the node"
" that is supposed to be the first seed node, and that should be placed first"
" in parameter to ``joinSeedNodes``."
msgstr ""

# 72ff78bf3feb4b76af682bb4cc7c95a5
#: ../../java/cluster-usage.rst:108
msgid ""
"Unsuccessful attempts to contact seed nodes are automatically retried after "
"the time period defined in configuration property ``seed-node-timeout``. "
"Unsuccessful attempt to join a specific seed node is automatically retried "
"after the configured ``retry-unsuccessful-join-after``. Retrying means that "
"it tries to contact all seed nodes and then joins the node that answers "
"first. The first node in the list of seed nodes will join itself if it "
"cannot contact any of the other seed nodes within the configured ``seed-"
"node-timeout``."
msgstr ""

# c7cc12847fa14ff3a2416c2cfebfafbf
#: ../../java/cluster-usage.rst:115
msgid ""
"An actor system can only join a cluster once. Additional attempts will be "
"ignored. When it has successfully joined it must be restarted to be able to "
"join another cluster or to join the same cluster again. It can use the same "
"host name and port after the restart, when it come up as new incarnation of "
"existing member in the cluster, trying to join in, then the existing one "
"will be removed from the cluster and then it will be allowed to join."
msgstr ""

# 2ce575d0f57d408e9b7e89a325d758ee
#: ../../java/cluster-usage.rst:124
msgid ""
"The name of the ``ActorSystem`` must be the same for all members of a "
"cluster. The name is given when you start the ``ActorSystem``."
msgstr ""

# ad3e11e29e9445968ab76bb102e24c8e
#: ../../java/cluster-usage.rst:130
msgid "Automatic vs. Manual Downing"
msgstr ""

# 14761e843d774eb9934ca5b4ef826df6
#: ../../java/cluster-usage.rst:132
msgid ""
"When a member is considered by the failure detector to be unreachable the "
"leader is not allowed to perform its duties, such as changing status of new "
"joining members to 'Up'. The node must first become reachable again, or the "
"status of the unreachable member must be changed to 'Down'. Changing status "
"to 'Down' can be performed automatically or manually. By default it must be "
"done manually, using :ref:`cluster_jmx_java` or "
":ref:`cluster_command_line_java`."
msgstr ""

# dd6ddd1a205c47f8ae18b9699b634626
#: ../../java/cluster-usage.rst:139
msgid ""
"It can also be performed programmatically with "
"``Cluster.get(system).down(address)``."
msgstr ""

# a2ad1eba7ee94738a8d637a6acfc3d32
#: ../../java/cluster-usage.rst:141
msgid "You can enable automatic downing with configuration::"
msgstr ""

# 9cad56c1547b433db7b2e2f952d4835a
#: ../../java/cluster-usage.rst:145
msgid ""
"This means that the cluster leader member will change the ``unreachable`` "
"node status to ``down`` automatically after the configured time of "
"unreachability."
msgstr ""

# 886aa2ee13b748fa96f34b1f0ec01f18
#: ../../java/cluster-usage.rst:148
msgid ""
"This is a naïve approach to remove unreachable nodes from the cluster "
"membership. It works great for crashes and short transient network "
"partitions, but not for long network partitions. Both sides of the network "
"partition will see the other side as unreachable and after a while remove it"
" from its cluster membership. Since this happens on both sides the result is"
" that two separate disconnected clusters have been created. This can also "
"happen because of long GC pauses or system overload."
msgstr ""

# 6ac2c24168124927a2f2f20496bfe213
#: ../../java/cluster-usage.rst:157
msgid ""
"We recommend against using the auto-down feature of Akka Cluster in "
"production. This is crucial for correct behavior if you use :ref:`cluster-"
"singleton-java` or :ref:`cluster_sharding_java`, especially together with "
"Akka :ref:`persistence-java`."
msgstr ""

# 2e9e9be089ec43c891e1b623f5e6c037
#: ../../java/cluster-usage.rst:161
msgid ""
"A pre-packaged solution for the downing problem is provided by `Split Brain "
"Resolver <http://doc.akka.io/docs/akka/rp-16s01p03/java/split-brain-"
"resolver.html>`_, which is part of the Lightbend Reactive Platform. If you "
"don’t use RP, you should anyway carefully read the `documentation "
"<http://doc.akka.io/docs/akka/rp-16s01p03/java/split-brain-resolver.html>`_ "
"of the Split Brain Resolver and make sure that the solution you are using "
"handles the concerns described there."
msgstr ""

# 25540571c3df4011a964e76d221483da
#: ../../java/cluster-usage.rst:168
msgid ""
"If you have *auto-down* enabled and the failure detector triggers, you can "
"over time end up with a lot of single node clusters if you don't put "
"measures in place to shut down nodes that have become ``unreachable``. This "
"follows from the fact that the ``unreachable`` node will likely see the rest"
" of the cluster as ``unreachable``, become its own leader and form its own "
"cluster."
msgstr ""

# 94b83edbfc5f46329aec60cecd34c2cc
#: ../../java/cluster-usage.rst:175
msgid "Leaving"
msgstr ""

# 9e64224b9abb4ca9b85a402d88aebd34
#: ../../java/cluster-usage.rst:177
msgid "There are two ways to remove a member from the cluster."
msgstr ""

# 7b9aec9dda314fc2af5fc209875c81b0
#: ../../java/cluster-usage.rst:179
msgid ""
"You can just stop the actor system (or the JVM process). It will be detected"
" as unreachable and removed after the automatic or manual downing as "
"described above."
msgstr ""

# f86631124ce44883afd79adcc495661b
#: ../../java/cluster-usage.rst:183
msgid ""
"A more graceful exit can be performed if you tell the cluster that a node "
"shall leave. This can be performed using :ref:`cluster_jmx_java` or "
":ref:`cluster_command_line_java`. It can also be performed programmatically "
"with:"
msgstr ""

# 56a093da167342bda528717c27e21da8
#: ../../java/cluster-usage.rst:189
msgid ""
"Note that this command can be issued to any member in the cluster, not "
"necessarily the one that is leaving. The cluster extension, but not the "
"actor system or JVM, of the leaving member will be shutdown after the leader"
" has changed status of the member to `Exiting`. Thereafter the member will "
"be removed from the cluster. Normally this is handled automatically, but in "
"case of network failures during this process it might still be necessary to "
"set the node’s status to ``Down`` in order to complete the removal."
msgstr ""

# b7cd266a2e4b43628961bc1f71d918a0
#: ../../java/cluster-usage.rst:199
msgid "WeaklyUp Members"
msgstr ""

# 291bfebc8ea6437db2a6abe77c484743
#: ../../java/cluster-usage.rst:201
msgid ""
"If a node is ``unreachable`` then gossip convergence is not possible and "
"therefore any ``leader`` actions are also not possible. However, we still "
"might want new nodes to join the cluster in this scenario."
msgstr ""

# 9aa1c2e5cc114f0ea9e4acabfd9f658a
#: ../../java/cluster-usage.rst:207
msgid ""
"The WeaklyUp feature is marked as **“experimental”** as of its introduction "
"in Akka 2.4.0. We will continue to improve this feature based on our users’ "
"feedback, which implies that while we try to keep incompatible changes to a "
"minimum the binary compatibility guarantee for maintenance releases does not"
" apply this feature."
msgstr ""

# 9300e2e53672456eada8ba04c6717c8e
#: ../../java/cluster-usage.rst:211
msgid ""
"This feature is disabled by default. With a configuration option you can "
"allow this behavior::"
msgstr ""

# 37a42cb6be3d4c4794551f495ae6fa87
#: ../../java/cluster-usage.rst:215
msgid ""
"When ``allow-weakly-up-members`` is enabled and there is no gossip "
"convergence, ``Joining`` members will be promoted to ``WeaklyUp`` and they "
"will become part of the cluster. Once gossip convergence is reached, the "
"leader will move ``WeaklyUp`` members to ``Up``."
msgstr ""

# 9d7f45446f8d4a11b7af3c9aaff3cc1b
#: ../../java/cluster-usage.rst:220
msgid ""
"You can subscribe to the ``WeaklyUp`` membership event to make use of the "
"members that are in this state, but you should be aware of that members on "
"the other side of a network partition have no knowledge about the existence "
"of the new members. You should for example not count ``WeaklyUp`` members in"
" quorum decisions."
msgstr ""

# 60d18337bad34e4eb1e77659da301bdc
#: ../../java/cluster-usage.rst:227
msgid ""
"This feature is only available from Akka 2.4.0 and cannot be used if some of"
" your cluster members are running an older version of Akka."
msgstr ""

# f0b99ea6222f4c078e9c545a51dc5e48
#: ../../java/cluster-usage.rst:234
msgid "Subscribe to Cluster Events"
msgstr ""

# fd3379d05f584478b3b87ddbbeaa22a7
#: ../../java/cluster-usage.rst:236
msgid ""
"You can subscribe to change notifications of the cluster membership by using"
" ``Cluster.get(system).subscribe``."
msgstr ""

# c3831e06d37f45db99fefe2114c6ba4d
#: ../../java/cluster-usage.rst:241
msgid ""
"A snapshot of the full state, "
"``akka.cluster.ClusterEvent.CurrentClusterState``, is sent to the subscriber"
" as the first message, followed by events for incremental updates."
msgstr ""

# ce202a3c001d48c7aa840e8262803bbb
#: ../../java/cluster-usage.rst:244
msgid ""
"Note that you may receive an empty ``CurrentClusterState``, containing no "
"members, if you start the subscription before the initial join procedure has"
" completed. This is expected behavior. When the node has been accepted in "
"the cluster you will receive ``MemberUp`` for that node, and other nodes."
msgstr ""

# 7f2de68d7796430e90d38ec18b62d18f
#: ../../java/cluster-usage.rst:249
msgid ""
"If you find it inconvenient to handle the ``CurrentClusterState`` you can "
"use ``ClusterEvent.initialStateAsEvents()`` as parameter to ``subscribe``. "
"That means that instead of receiving ``CurrentClusterState`` as the first "
"message you will receive the events corresponding to the current state to "
"mimic what you would have seen if you were listening to the events when they"
" occurred in the past. Note that those initial events only correspond to the"
" current state and it is not the full history of all changes that actually "
"has occurred in the cluster."
msgstr ""

# 175ece4bcadb4e7bbb82d1ff25b700e4
#: ../../java/cluster-usage.rst:258
msgid "The events to track the life-cycle of members are:"
msgstr ""

# eb7d3dfa3fa94c9ca15ea92f23228f91
#: ../../java/cluster-usage.rst:260
msgid ""
"``ClusterEvent.MemberJoined`` - A new member has joined the cluster and its "
"status has been changed to ``Joining``."
msgstr ""

# 8ebf57bba5a94bc8826de5939ea24aa8
#: ../../java/cluster-usage.rst:261
msgid ""
"``ClusterEvent.MemberUp`` - A new member has joined the cluster and its "
"status has been changed to ``Up``."
msgstr ""

# 2b867df7075f47e881dd5449e102dae0
#: ../../java/cluster-usage.rst:262
msgid ""
"``ClusterEvent.MemberExited`` - A member is leaving the cluster and its "
"status has been changed to ``Exiting`` Note that the node might already have"
" been shutdown when this event is published on another node."
msgstr ""

# bd828a04cd3c4a0b9194a0aaa53643f6
#: ../../java/cluster-usage.rst:264
msgid ""
"``ClusterEvent.MemberRemoved`` - Member completely removed from the cluster."
msgstr ""

# 2d092349c4e8466994bcc4bdaa6c391e
#: ../../java/cluster-usage.rst:265
msgid ""
"``ClusterEvent.UnreachableMember`` - A member is considered as unreachable, "
"detected by the failure detector of at least one other node."
msgstr ""

# bf280a429b914410b95d63a3c9a3fd72
#: ../../java/cluster-usage.rst:267
msgid ""
"``ClusterEvent.ReachableMember`` - A member is considered as reachable "
"again, after having been unreachable. All nodes that previously detected it "
"as unreachable has detected it as reachable again."
msgstr ""

# a91c9a4535094e71b2c84854715ab3a7
#: ../../java/cluster-usage.rst:270
msgid ""
"There are more types of change events, consult the API documentation of "
"classes that extends ``akka.cluster.ClusterEvent.ClusterDomainEvent`` for "
"details about the events."
msgstr ""

# 73ccb318553745b8ada54466969ba052
#: ../../java/cluster-usage.rst:274
msgid ""
"Instead of subscribing to cluster events it can sometimes be convenient to "
"only get the full membership state with ``Cluster.get(system).state()``. "
"Note that this state is not necessarily in sync with the events published to"
" a cluster subscription."
msgstr ""

# ab147ee9c4924e3099d5ac3c6863cc66
#: ../../java/cluster-usage.rst:279
msgid "Worker Dial-in Example"
msgstr ""

# 7a4a993c177f42aab45d2776060b860b
#: ../../java/cluster-usage.rst:281
msgid ""
"Let's take a look at an example that illustrates how workers, here named "
"*backend*, can detect and register to new master nodes, here named "
"*frontend*."
msgstr ""

# 1cc2ed904fd7493f953af631375bc050
#: ../../java/cluster-usage.rst:284
msgid ""
"The example application provides a service to transform text. When some text"
" is sent to one of the frontend services, it will be delegated to one of the"
" backend workers, which performs the transformation job, and sends the "
"result back to the original client. New backend nodes, as well as new "
"frontend nodes, can be added or removed to the cluster dynamically."
msgstr ""

# 8ec578cc07a14102ac5af1696b1039ec
# 52eeddf89b9c4a0d844a14b82b79c81e
#: ../../java/cluster-usage.rst:290 ../../java/cluster-usage.rst:556
msgid "Messages:"
msgstr ""

# e84f6952f4ff48129115ca047d01f513
#: ../../java/cluster-usage.rst:294
msgid "The backend worker that performs the transformation job:"
msgstr ""

# 3fc8baa1fba34b6e9b860c54ec4e3250
#: ../../java/cluster-usage.rst:298
msgid ""
"Note that the ``TransformationBackend`` actor subscribes to cluster events "
"to detect new, potential, frontend nodes, and send them a registration "
"message so that they know that they can use the backend worker."
msgstr ""

# c2d8c037f384485f939ca27f1b2f4cc3
#: ../../java/cluster-usage.rst:302
msgid ""
"The frontend that receives user jobs and delegates to one of the registered "
"backend workers:"
msgstr ""

# af891b77a9514f138d91464d1293189a
#: ../../java/cluster-usage.rst:306
msgid ""
"Note that the ``TransformationFrontend`` actor watch the registered backend "
"to be able to remove it from its list of available backend workers. Death "
"watch uses the cluster failure detector for nodes in the cluster, i.e. it "
"detects network failures and JVM crashes, in addition to graceful "
"termination of watched actor. Death watch generates the ``Terminated`` "
"message to the watching actor when the unreachable cluster node has been "
"downed and removed."
msgstr ""

# 93da910b871f49b1976939f69b1cd612
#: ../../java/cluster-usage.rst:313
msgid ""
"The `Lightbend Activator <http://www.lightbend.com/platform/getstarted>`_ "
"tutorial named `Akka Cluster Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-cluster-java>`_. "
"contains the full source code and instructions of how to run the **Worker "
"Dial-in Example**."
msgstr ""

# 6fb27bb9e5504b969b0990d663bce50d
#: ../../java/cluster-usage.rst:318
msgid "Node Roles"
msgstr ""

# 3e65bb4644324e948dace833f0fcab91
#: ../../java/cluster-usage.rst:320
msgid ""
"Not all nodes of a cluster need to perform the same function: there might be"
" one sub-set which runs the web front-end, one which runs the data access "
"layer and one for the number-crunching. Deployment of actors—for example by "
"cluster-aware routers—can take node roles into account to achieve this "
"distribution of responsibilities."
msgstr ""

# d2b6b48ef1d941eba39dccda13fcdac2
#: ../../java/cluster-usage.rst:324
msgid ""
"The roles of a node is defined in the configuration property named "
"``akka.cluster.roles`` and it is typically defined in the start script as a "
"system property or environment variable."
msgstr ""

# 9a3857152cec413b9458933db794a101
#: ../../java/cluster-usage.rst:327
msgid ""
"The roles of the nodes is part of the membership information in "
"``MemberEvent`` that you can subscribe to."
msgstr ""

# aaa2e778157b4ae7a896b669c6a6d66a
#: ../../java/cluster-usage.rst:330
msgid "How To Startup when Cluster Size Reached"
msgstr ""

# 7c43ac1ae84f42be84302bb7e1ca7542
#: ../../java/cluster-usage.rst:332
msgid ""
"A common use case is to start actors after the cluster has been initialized,"
" members have joined, and the cluster has reached a certain size."
msgstr ""

# 3a42a1f9243d47b597fb4f1598c89049
#: ../../java/cluster-usage.rst:335
msgid ""
"With a configuration option you can define required number of members before"
" the leader changes member status of 'Joining' members to 'Up'."
msgstr ""

# 54b2dbdd9c3e48459d475d9ec8d3ccaf
#: ../../java/cluster-usage.rst:340
msgid ""
"In a similar way you can define required number of members of a certain role"
" before the leader changes member status of 'Joining' members to 'Up'."
msgstr ""

# a8af3415e8e3499bb22d611c6614d7d3
#: ../../java/cluster-usage.rst:345
msgid ""
"You can start the actors in a ``registerOnMemberUp`` callback, which will be"
" invoked when the current member status is changed to 'Up', i.e. the cluster"
" has at least the defined number of members."
msgstr ""

# ad8b6e6f8b7e42679b00e2cfdb66340a
#: ../../java/cluster-usage.rst:351
msgid "This callback can be used for other things than starting actors."
msgstr ""

# 21dae87bbbc44bb5bce825f7483ba947
#: ../../java/cluster-usage.rst:354
msgid "How To Cleanup when Member is Removed"
msgstr ""

# 41de660928864d4faa0c0188ce5161ae
#: ../../java/cluster-usage.rst:356
msgid ""
"You can do some clean up in a ``registerOnMemberRemoved`` callback, which "
"will be invoked when the current member status is changed to 'Removed' or "
"the cluster have been shutdown."
msgstr ""

# 54c1224792c9430f80a33d71b0cca4cb
#: ../../java/cluster-usage.rst:359
msgid ""
"For example, this is how to shut down the ``ActorSystem`` and thereafter "
"exit the JVM:"
msgstr ""

# 0ad81bee2ee5455e89351cafb23bd194
#: ../../java/cluster-usage.rst:364
msgid ""
"Register a OnMemberRemoved callback on a cluster that have been shutdown, "
"the callback will be invoked immediately on the caller thread, otherwise it "
"will be invoked later when the current member status changed to 'Removed'. "
"You may want to install some cleanup handling after the cluster was started "
"up, but the cluster might already be shutting down when you installing, and "
"depending on the race is not healthy."
msgstr ""

# 7a87a3473c6041c6906a4935ecab5a0f
#: ../../java/cluster-usage.rst:375
msgid ""
"This can be implemented by subscribing to member events, but there are "
"several corner cases to consider. Therefore, this specific use case is made "
"easily accessible by the :ref:`cluster-singleton-java`."
msgstr ""

# 27fab6e15c60408a82cc70d8890b86c8
#: ../../java/cluster-usage.rst:382
msgid ""
"Distributes actors across several nodes in the cluster and supports "
"interaction with the actors using their logical identifier, but without "
"having to care about their physical location in the cluster."
msgstr ""

# b66dcc97aeed49b4a7119325bc4c2097
#: ../../java/cluster-usage.rst:386
msgid "See :ref:`cluster_sharding_java`."
msgstr ""

# 8bae24561508458d83eea8f38047fa48
#: ../../java/cluster-usage.rst:389
msgid "Distributed Publish Subscribe"
msgstr ""

# c89888bdddfc4f8dbc07d66b6c2a12f3
#: ../../java/cluster-usage.rst:391
msgid ""
"Publish-subscribe messaging between actors in the cluster, and point-to-"
"point messaging using the logical path of the actors, i.e. the sender does "
"not have to know on which node the destination actor is running."
msgstr ""

# 1537414bb5c14e779ac76879f3fccb3d
#: ../../java/cluster-usage.rst:395
msgid "See :ref:`distributed-pub-sub-java`."
msgstr ""

# 6617e460a5de455d91d0ac7f7fe1eed4
#: ../../java/cluster-usage.rst:400
msgid ""
"Communication from an actor system that is not part of the cluster to actors"
" running somewhere in the cluster. The client does not have to know on which"
" node the destination actor is running."
msgstr ""

# 71b46cc345cb45a7b438b6005125b17d
#: ../../java/cluster-usage.rst:404
msgid "See :ref:`cluster-client-java`."
msgstr ""

# e0c5c997be31413da0ba97a13b43a123
# 6244842d21a844fe8e42395f96a6ed40
#: ../../java/cluster-usage.rst:407 ../../java/distributed-data.rst:6
msgid "Distributed Data"
msgstr ""

# 0e9cde1a4f424c64a8e11435f8da07b1
#: ../../java/cluster-usage.rst:409
msgid ""
"*Akka Distributed Data* is useful when you need to share data between nodes "
"in an Akka Cluster. The data is accessed with an actor providing a key-value"
" store like API."
msgstr ""

# 2cbb9669fa4b4e9892ebb609d01d2b71
#: ../../java/cluster-usage.rst:412
msgid "See :ref:`distributed_data_java`."
msgstr ""

# 26d0a09a4b9242858ad2802a6987ae0a
# 6dc4e576a3f74c2db119988b206cd4f0
#: ../../java/cluster-usage.rst:415 ../../java/remoting.rst:203
msgid "Failure Detector"
msgstr ""

# 041a6e7f95a447bc920ea584db766cb6
#: ../../java/cluster-usage.rst:417
msgid ""
"In a cluster each node is monitored by a few (default maximum 5) other "
"nodes, and when any of these detects the node as ``unreachable`` that "
"information will spread to the rest of the cluster through the gossip. In "
"other words, only one node needs to mark a node ``unreachable`` to have the "
"rest of the cluster mark that node ``unreachable``."
msgstr ""

# 9dd40847266a473a8629bac334fdc062
#: ../../java/cluster-usage.rst:422
msgid ""
"The failure detector will also detect if the node becomes ``reachable`` "
"again. When all nodes that monitored the ``unreachable`` node detects it as "
"``reachable`` again the cluster, after gossip dissemination, will consider "
"it as ``reachable``."
msgstr ""

# 300646e535424c7ebac090634e2fc51c
#: ../../java/cluster-usage.rst:426
msgid ""
"If system messages cannot be delivered to a node it will be quarantined and "
"then it cannot come back from ``unreachable``. This can happen if the there "
"are too many unacknowledged system messages (e.g. watch, Terminated, remote "
"actor deployment, failures of actors supervised by remote parent). Then the "
"node needs to be moved to the ``down`` or ``removed`` states and the actor "
"system of the quarantined node must be restarted before it can join the "
"cluster again."
msgstr ""

# c76281775c9c4ae786a9de40e4c7c62b
#: ../../java/cluster-usage.rst:433
msgid ""
"The nodes in the cluster monitor each other by sending heartbeats to detect "
"if a node is unreachable from the rest of the cluster. The heartbeat arrival"
" times is interpreted by an implementation of `The Phi Accrual Failure "
"Detector <http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf>`_."
msgstr ""

# 28e56fc5577947a589ac4d1118653bcd
# 81dd5681178448e8b47998000316337e
#: ../../java/cluster-usage.rst:438 ../../java/remoting.rst:212
msgid ""
"The suspicion level of failure is given by a value called *phi*. The basic "
"idea of the phi failure detector is to express the value of *phi* on a scale"
" that is dynamically adjusted to reflect current network conditions."
msgstr ""

# 63a8c7441f6f4c0881d8cec8ca0a5a3c
# ffa06903787e40b4bf038067c1ee564e
#: ../../java/cluster-usage.rst:442 ../../java/remoting.rst:216
msgid "The value of *phi* is calculated as::"
msgstr ""

# cb3ead7e8d6e4319984b9639806d393a
# 35ba6dc73d6c45f29b2ee67194732de3
#: ../../java/cluster-usage.rst:446 ../../java/remoting.rst:220
msgid ""
"where F is the cumulative distribution function of a normal distribution "
"with mean and standard deviation estimated from historical heartbeat inter-"
"arrival times."
msgstr ""

# 86ad05e9e53c4e759dcbded9149b4e7d
#: ../../java/cluster-usage.rst:449
msgid ""
"In the :ref:`cluster_configuration_java` you can adjust the ``akka.cluster"
".failure-detector.threshold`` to define when a *phi* value is considered to "
"be a failure."
msgstr ""

# d150533ded274bfe9219ff4e1818e63e
#: ../../java/cluster-usage.rst:452
msgid ""
"A low ``threshold`` is prone to generate many false positives but ensures a "
"quick detection in the event of a real crash. Conversely, a high "
"``threshold`` generates fewer mistakes but needs more time to detect actual "
"crashes. The default ``threshold`` is 8 and is appropriate for most "
"situations. However in cloud environments, such as Amazon EC2, the value "
"could be increased to 12 in order to account for network issues that "
"sometimes occur on such platforms."
msgstr ""

# d7216162c170492e9db5d141c5481685
# c36d272663d04982b1f01eae8ae20fa3
#: ../../java/cluster-usage.rst:459 ../../java/remoting.rst:233
msgid ""
"The following chart illustrates how *phi* increase with increasing time "
"since the previous heartbeat."
msgstr ""

# b41c11e34af942f5874a6d49a82831ac
# 630258cccbd64aeea3c64bf57ac5e589
#: ../../java/cluster-usage.rst:464 ../../java/remoting.rst:238
msgid ""
"Phi is calculated from the mean and standard deviation of historical inter "
"arrival times. The previous chart is an example for standard deviation of "
"200 ms. If the heartbeats arrive with less deviation the curve becomes "
"steeper, i.e. it is possible to determine failure more quickly. The curve "
"looks like this for a standard deviation of 100 ms."
msgstr ""

# 8d9f540ec8fd4dd1a4a0b4121ad455b3
#: ../../java/cluster-usage.rst:472
msgid ""
"To be able to survive sudden abnormalities, such as garbage collection "
"pauses and transient network failures the failure detector is configured "
"with a margin, ``akka.cluster.failure-detector.acceptable-heartbeat-pause``."
" You may want to adjust the :ref:`cluster_configuration_java` of this "
"depending on you environment. This is how the curve looks like for "
"``acceptable-heartbeat-pause`` configured to 3 seconds."
msgstr ""

# 7e40b85c04fa49b38cc06da7fc14a929
#: ../../java/cluster-usage.rst:481
msgid ""
"Death watch uses the cluster failure detector for nodes in the cluster, i.e."
" it detects network failures and JVM crashes, in addition to graceful "
"termination of watched actor. Death watch generates the ``Terminated`` "
"message to the watching actor when the unreachable cluster node has been "
"downed and removed."
msgstr ""

# e18528b5b7de4ab9a31d78f40ce5f99b
#: ../../java/cluster-usage.rst:486
msgid ""
"If you encounter suspicious false positives when the system is under load "
"you should define a separate dispatcher for the cluster actors as described "
"in :ref:`cluster_dispatcher_java`."
msgstr ""

# 55120d42b0b4429c86a0db8e03eeaac6
#: ../../java/cluster-usage.rst:490
msgid "Cluster Aware Routers"
msgstr ""

# ecf68bdbe5484ea8a1f33705d6f24b41
#: ../../java/cluster-usage.rst:492
msgid ""
"All :ref:`routers <routing-java>` can be made aware of member nodes in the "
"cluster, i.e. deploying new routees or looking up routees on nodes in the "
"cluster. When a node becomes unreachable or leaves the cluster the routees "
"of that node are automatically unregistered from the router. When new nodes "
"join the cluster additional routees are added to the router, according to "
"the configuration. Routees are also added when a node becomes reachable "
"again, after having been unreachable."
msgstr ""

# ef16593dee634b80842157e215c9bb82
#: ../../java/cluster-usage.rst:499
msgid ""
"Cluster aware routers make use of members with status :ref:`WeaklyUp "
"<weakly_up_java>` if that feature is enabled."
msgstr ""

# 9339bdfabb3f476c92d82552ac82ec63
#: ../../java/cluster-usage.rst:502
msgid "There are two distinct types of routers."
msgstr ""

# bb2ef32b2b6d494ab009c5aa110278c0
#: ../../java/cluster-usage.rst:504
msgid ""
"**Group - router that sends messages to the specified path using actor "
"selection** The routees can be shared between routers running on different "
"nodes in the cluster. One example of a use case for this type of router is a"
" service running on some backend nodes in the cluster and used by routers "
"running on front-end nodes in the cluster."
msgstr ""

# 324557d4929e44b8b25f34e68a565764
#: ../../java/cluster-usage.rst:509
msgid ""
"**Pool - router that creates routees as child actors and deploys them on "
"remote nodes.** Each router will have its own routee instances. For example,"
" if you start a router on 3 nodes in a 10 nodes cluster you will have 30 "
"routee actors in total if the router is configured to use one instance per "
"node. The routees created by the different routers will not be shared "
"between the routers. One example of a use case for this type of router is a "
"single master that coordinate jobs and delegates the actual work to routees "
"running on other nodes in the cluster."
msgstr ""

# d92b97760caa4a0a8320ade935e80a16
#: ../../java/cluster-usage.rst:518
msgid "Router with Group of Routees"
msgstr ""

# 26e81d8fc8984fc29c9e5ef33598e445
#: ../../java/cluster-usage.rst:520
msgid ""
"When using a ``Group`` you must start the routee actors on the cluster "
"member nodes. That is not done by the router. The configuration for a group "
"looks like this:"
msgstr ""

# 21fb523254484b71a110669c89f09ad6
#: ../../java/cluster-usage.rst:526
msgid ""
"The routee actors should be started as early as possible when starting the "
"actor system, because the router will try to use them as soon as the member "
"status is changed to 'Up'."
msgstr ""

# 8221cd16f7934759abce1c552e9c5c9e
#: ../../java/cluster-usage.rst:529
msgid ""
"The actor paths without address information that are defined in "
"``routees.paths`` are used for selecting the actors to which the messages "
"will be forwarded to by the router. Messages will be forwarded to the "
"routees using :ref:`ActorSelection <actorSelection-java>`, so the same "
"delivery semantics should be expected. It is possible to limit the lookup of"
" routees to member nodes tagged with a certain role by specifying ``use-"
"role``."
msgstr ""

# e1cc3a7bc99641cd909feab1e35b2228
#: ../../java/cluster-usage.rst:534
msgid ""
"``max-total-nr-of-instances`` defines total number of routees in the "
"cluster. By default ``max-total-nr-of-instances`` is set to a high value "
"(10000) that will result in new routees added to the router when nodes join "
"the cluster. Set it to a lower value if you want to limit total number of "
"routees."
msgstr ""

# 32b9c88aaaaf419ba9cfb03f5bcb94ce
# 71a2504f19a9465ab5af7a97ffc49916
#: ../../java/cluster-usage.rst:542 ../../java/cluster-usage.rst:605
msgid ""
"See :ref:`cluster_configuration_java` section for further descriptions of "
"the settings."
msgstr ""

# e7dbb4e69ea4452bad851ccbe918dfd9
#: ../../java/cluster-usage.rst:545
msgid "Router Example with Group of Routees"
msgstr ""

# 4e3a7be5cd07472c9cbbb2e6bee29e9d
#: ../../java/cluster-usage.rst:547
msgid ""
"Let's take a look at how to use a cluster aware router with a group of "
"routees, i.e. router sending to the paths of the routees."
msgstr ""

# c54a77005c9b402baea1ab4d85d52ddf
#: ../../java/cluster-usage.rst:550
msgid ""
"The example application provides a service to calculate statistics for a "
"text. When some text is sent to the service it splits it into words, and "
"delegates the task to count number of characters in each word to a separate "
"worker, a routee of a router. The character count for each word is sent back"
" to an aggregator that calculates the average number of characters per word "
"when all results have been collected."
msgstr ""

# 78bad275ce124372919d66a2cefe9bf3
#: ../../java/cluster-usage.rst:560
msgid "The worker that counts number of characters in each word:"
msgstr ""

# 9c4bb6a549754cf08563398448dce8a9
#: ../../java/cluster-usage.rst:564
msgid ""
"The service that receives text from users and splits it up into words, "
"delegates to workers and aggregates:"
msgstr ""

# c4afef0ce171412293b187be1ef9dc33
#: ../../java/cluster-usage.rst:571
msgid "Note, nothing cluster specific so far, just plain actors."
msgstr ""

# 50c019af55b141d1be6e34614c1dfc15
#: ../../java/cluster-usage.rst:573
msgid ""
"All nodes start ``StatsService`` and ``StatsWorker`` actors. Remember, "
"routees are the workers in this case. The router is configured with "
"``routees.paths``:"
msgstr ""

# 3cdd1ee9186a4b629ab4895ef6fcd6c1
#: ../../java/cluster-usage.rst:578
msgid ""
"This means that user requests can be sent to ``StatsService`` on any node "
"and it will use ``StatsWorker`` on all nodes."
msgstr ""

# 6e9c9122d3454653a0ac063e272a4b47
#: ../../java/cluster-usage.rst:581
msgid ""
"The `Lightbend Activator <http://www.lightbend.com/platform/getstarted>`_ "
"tutorial named `Akka Cluster Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-cluster-java>`_. "
"contains the full source code and instructions of how to run the **Router "
"Example with Group of Routees**."
msgstr ""

# affbae45fdf940a7902fb80adebb978e
#: ../../java/cluster-usage.rst:586
msgid "Router with Pool of Remote Deployed Routees"
msgstr ""

# 3b36228062634a36b70c82aa1fab0cf4
#: ../../java/cluster-usage.rst:588
msgid ""
"When using a ``Pool`` with routees created and deployed on the cluster "
"member nodes the configuration for a router looks like this:"
msgstr ""

# ba796da29bc549f4a4e3fac1ec25c24b
#: ../../java/cluster-usage.rst:593
msgid ""
"It is possible to limit the deployment of routees to member nodes tagged "
"with a certain role by specifying ``use-role``."
msgstr ""

# c4232e3e8ec8425289dc358c67a20b3e
#: ../../java/cluster-usage.rst:596
msgid ""
"``max-total-nr-of-instances`` defines total number of routees in the "
"cluster, but the number of routees per node, ``max-nr-of-instances-per-"
"node``, will not be exceeded. By default ``max-total-nr-of-instances`` is "
"set to a high value (10000) that will result in new routees added to the "
"router when nodes join the cluster. Set it to a lower value if you want to "
"limit total number of routees."
msgstr ""

# d5dd8dceba2c4a1ead757a053c7af2e6
#: ../../java/cluster-usage.rst:608
msgid "Router Example with Pool of Remote Deployed Routees"
msgstr ""

# 22d2db5b17ea40ebbf06d5bc93710c33
#: ../../java/cluster-usage.rst:610
msgid ""
"Let's take a look at how to use a cluster aware router on single master node"
" that creates and deploys workers. To keep track of a single master we use "
"the :ref:`cluster-singleton-java` in the contrib module. The "
"``ClusterSingletonManager`` is started on each node."
msgstr ""

# 722c315d59124421ac7df99a44a68fc9
#: ../../java/cluster-usage.rst:616
msgid ""
"We also need an actor on each node that keeps track of where current single "
"master exists and delegates jobs to the ``StatsService``. That is provided "
"by the ``ClusterSingletonProxy``."
msgstr ""

# 175a811f02c242978079ec127489f65d
#: ../../java/cluster-usage.rst:621
msgid ""
"The ``ClusterSingletonProxy`` receives text from users and delegates to the "
"current ``StatsService``, the single master. It listens to cluster events to"
" lookup the ``StatsService`` on the oldest node."
msgstr ""

# 526d221aaaed4e3096c632bb0c9ef9e9
#: ../../java/cluster-usage.rst:624
msgid ""
"All nodes start ``ClusterSingletonProxy`` and the "
"``ClusterSingletonManager``. The router is now configured like this:"
msgstr ""

# 3fd821c4f7ce4ffeb8e0f005a6228196
#: ../../java/cluster-usage.rst:628
msgid ""
"The `Lightbend Activator <http://www.lightbend.com/platform/getstarted>`_ "
"tutorial named `Akka Cluster Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-cluster-java>`_. "
"contains the full source code and instructions of how to run the **Router "
"Example with Pool of Remote Deployed Routees**."
msgstr ""

# c3d38497fcd64d2fa4d8d0572c976f1a
#: ../../java/cluster-usage.rst:633
msgid "Cluster Metrics"
msgstr ""

# fc80bf6cfa8e41be8d41adf48dba5cec
#: ../../java/cluster-usage.rst:635
msgid ""
"The member nodes of the cluster can collect system health metrics and "
"publish that to other cluster nodes and to the registered subscribers on the"
" system event bus with the help of :doc:`cluster-metrics`."
msgstr ""

# d6cd0bfc636041209e4f579a9a713bf1
#: ../../java/cluster-usage.rst:642
msgid "JMX"
msgstr ""

# a2250af5c9e54749b379459f8276ee70
#: ../../java/cluster-usage.rst:644
msgid ""
"Information and management of the cluster is available as JMX MBeans with "
"the root name ``akka.Cluster``. The JMX information can be displayed with an"
" ordinary JMX console such as JConsole or JVisualVM."
msgstr ""

# 88a7a134c3974c11abe12651e7404fa2
#: ../../java/cluster-usage.rst:647
msgid "From JMX you can:"
msgstr ""

# a131767fdd074b03bc8731d43d9e124d
#: ../../java/cluster-usage.rst:649
msgid "see what members that are part of the cluster"
msgstr ""

# 62b5894ab60c40afa2af47eb6e398d94
#: ../../java/cluster-usage.rst:650
msgid "see status of this node"
msgstr ""

# f5465d7da39b4226a630d28a55690b7b
#: ../../java/cluster-usage.rst:651
msgid "see roles of each member"
msgstr ""

# c659f2f8b33e4949af2c1335a848f203
#: ../../java/cluster-usage.rst:652
msgid "join this node to another node in cluster"
msgstr ""

# c06808d8d7af43e1a581cd4588dc242b
#: ../../java/cluster-usage.rst:653
msgid "mark any node in the cluster as down"
msgstr ""

# 16ab65fabcfc45a2bbb3052089491532
#: ../../java/cluster-usage.rst:654
msgid "tell any node in the cluster to leave"
msgstr ""

# af009c9c36b54058b916890547cf0687
#: ../../java/cluster-usage.rst:656
msgid ""
"Member nodes are identified by their address, in format `akka.<protocol"
">://<actor-system-name>@<hostname>:<port>`."
msgstr ""

# 0fdd1609351c421eaeb3c77dc466ac85
#: ../../java/cluster-usage.rst:661
msgid "Command Line Management"
msgstr ""

# 12b87d0e11be47938cacee773afd6159
#: ../../java/cluster-usage.rst:663
msgid ""
"The cluster can be managed with the script `bin/akka-cluster` provided in "
"the Akka distribution."
msgstr ""

# 57939ed2fa6b40a08fb8c108ad0d75d2
#: ../../java/cluster-usage.rst:666
msgid ""
"Run it without parameters to see instructions about how to use the script::"
msgstr ""

# 9996ebc70a524d66a87bb41d22744d70
#: ../../java/cluster-usage.rst:691
msgid ""
"To be able to use the script you must enable remote monitoring and "
"management when starting the JVMs of the cluster nodes, as described in "
"`Monitoring and Management Using JMX Technology "
"<http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html>`_"
msgstr ""

# 083485e240764aacbaad48b288dc8c8c
#: ../../java/cluster-usage.rst:694
msgid ""
"Example of system properties to enable remote monitoring and management::"
msgstr ""

# 9374325241ad48889af55bc610892961
#: ../../java/cluster-usage.rst:705
msgid ""
"There are several configuration properties for the cluster. We refer to the "
":ref:`reference configuration <config-akka-cluster>` for more information."
msgstr ""

# 20e3507a7d844e8891fa8dc28388c166
#: ../../java/cluster-usage.rst:709
msgid "Cluster Info Logging"
msgstr ""

# 69693781d6a64aa78ab98f011d3e4993
#: ../../java/cluster-usage.rst:711
msgid ""
"You can silence the logging of cluster events at info level with "
"configuration property::"
msgstr ""

# 653a5b3da913426cb76c8242ad860634
#: ../../java/cluster-usage.rst:718
msgid "Cluster Dispatcher"
msgstr ""

# b813d16ac74b46218affa535090c9bfd
#: ../../java/cluster-usage.rst:720
msgid ""
"Under the hood the cluster extension is implemented with actors and it can "
"be necessary to create a bulkhead for those actors to avoid disturbance from"
" other actors. Especially the heartbeating actors that is used for failure "
"detection can generate false positives if they are not given a chance to run"
" at regular intervals. For this purpose you can define a separate dispatcher"
" to be used for the cluster actors::"
msgstr ""

# cd02da7e476f47738b82448a6217c5b4
#: ../../java/cluster-usage.rst:738
msgid ""
"Normally it should not be necessary to configure a separate dispatcher for "
"the Cluster. The default-dispatcher should be sufficient for performing the "
"Cluster tasks, i.e. ``akka.cluster.use-dispatcher`` should not be changed. "
"If you have Cluster related problems when using the default-dispatcher that "
"is typically an indication that you are running blocking or CPU intensive "
"actors/tasks on the default-dispatcher. Use dedicated dispatchers for such "
"actors/tasks instead of running them on the default-dispatcher, because that"
" may starve system internal tasks. Related config properties: ``akka.cluster"
".use-dispatcher = akka.cluster.cluster-dispatcher``. Corresponding default "
"values: ``akka.cluster.use-dispatcher =``."
msgstr ""

# 03d39b8ffd1142cbae58574d352f4cdc
#: ../../java/dispatchers.rst:4
msgid "Dispatchers"
msgstr ""

# 811f3859ea854e7ead35f19e302ab70a
#: ../../java/dispatchers.rst:6
msgid ""
"An Akka ``MessageDispatcher`` is what makes Akka Actors \"tick\", it is the "
"engine of the machine so to speak. All ``MessageDispatcher`` implementations"
" are also an ``ExecutionContext``, which means that they can be used to "
"execute arbitrary code, for instance :ref:`futures-java`."
msgstr ""

# f2018f4c39a14b2187856c3589fc6195
#: ../../java/dispatchers.rst:11
msgid "Default dispatcher"
msgstr ""

# df29dad332a942aaad6610a9b1f8396f
#: ../../java/dispatchers.rst:13
msgid ""
"Every ``ActorSystem`` will have a default dispatcher that will be used in "
"case nothing else is configured for an ``Actor``. The default dispatcher can"
" be configured, and is by default a ``Dispatcher`` with the specified "
"``default-executor``. If an ActorSystem is created with an ExecutionContext "
"passed in, this ExecutionContext will be used as the default executor for "
"all dispatchers in this ActorSystem. If no ExecutionContext is given, it "
"will fallback to the executor specified in ``akka.actor.default-dispatcher"
".default-executor.fallback``. By default this is a \"fork-join-executor\", "
"which gives excellent performance in most cases."
msgstr ""

# 855e7f7f057d4664b5c167f887343b49
#: ../../java/dispatchers.rst:23
msgid "Looking up a Dispatcher"
msgstr ""

# c7e0354e7dcc48dda156f04b291432bd
#: ../../java/dispatchers.rst:25
msgid ""
"Dispatchers implement the :class:`ExecutionContext` interface and can thus "
"be used to run :class:`Future` invocations etc."
msgstr ""

# 10c089003fab4cc2b1dc742976ca56a5
#: ../../java/dispatchers.rst:30
msgid "Setting the dispatcher for an Actor"
msgstr ""

# f7b462678c7a41cbadc2cb8bd2380be9
#: ../../java/dispatchers.rst:32
msgid ""
"So in case you want to give your ``Actor`` a different dispatcher than the "
"default, you need to do two things, of which the first is is to configure "
"the dispatcher:"
msgstr ""

# 13f44cd5429d4e77aa7440a097d090ae
#: ../../java/dispatchers.rst:38
msgid ""
"Note that the ``parallelism-max`` does not set the upper bound on the total "
"number of threads allocated by the ForkJoinPool. It is a setting "
"specifically talking about the number of *hot* threads the pool keep running"
" in order to reduce the latency of handling a new incoming task. You can "
"read more about parallelism in the JDK's `ForkJoinPool documentation`_."
msgstr ""

# 2b781e44f2c94c98abfdf271e99426cc
#: ../../java/dispatchers.rst:43
msgid "And here's another example that uses the \"thread-pool-executor\":"
msgstr ""

# abee285cfaf74f2ea014f3dc6c262c8a
#: ../../java/dispatchers.rst:48
msgid ""
"The thread pool executor dispatcher is implemented using by a "
"``java.util.concurrent.ThreadPoolExecutor``. You can read more about it in "
"the JDK's `ThreadPoolExecutor documentation`_."
msgstr ""

# 26e8d473efc142ee8096e26f384e1ec3
#: ../../java/dispatchers.rst:51
msgid ""
"For more options, see the default-dispatcher section of the "
":ref:`configuration`."
msgstr ""

# ae4cabe52ad941958c878cd88cd7a7db
#: ../../java/dispatchers.rst:53
msgid ""
"Then you create the actor as usual and define the dispatcher in the "
"deployment configuration."
msgstr ""

# ed0e00c5b70b4efbb8ce9bdac442ea11
#: ../../java/dispatchers.rst:59
msgid ""
"An alternative to the deployment configuration is to define the dispatcher "
"in code. If you define the ``dispatcher`` in the deployment configuration "
"then this value will be used instead of programmatically provided parameter."
msgstr ""

# 9df0ec23e5df4268a0eb6ff2d1738a41
#: ../../java/dispatchers.rst:66
msgid ""
"The dispatcher you specify in ``withDispatcher`` and the ``dispatcher`` "
"property in the deployment configuration is in fact a path into your "
"configuration. So in this example it's a top-level section, but you could "
"for instance put it as a sub-section, where you'd use periods to denote sub-"
"sections, like this: ``\"foo.bar.my-dispatcher\"``"
msgstr ""

# f5e16c262436465fa74da01c2f617b43
#: ../../java/dispatchers.rst:75
msgid "Types of dispatchers"
msgstr ""

# 8adc656723814a64b25949ea4ecf6f79
#: ../../java/dispatchers.rst:77
msgid "There are 3 different types of message dispatchers:"
msgstr ""

# 93d1aa5ecd5d4666983533a51ca06674
#: ../../java/dispatchers.rst:79
msgid "Dispatcher"
msgstr ""

# db760839619b4c8caf45d0b4d810a8cf
#: ../../java/dispatchers.rst:81
msgid ""
"This is an event-based dispatcher that binds a set of Actors to a thread "
"pool. It is the default dispatcher used if one is not specified."
msgstr ""

# b4c8bcd63ccc4ebe94744aca90cf0297
# cffe097940194b6d97cea338b22dc340
#: ../../java/dispatchers.rst:83 ../../java/dispatchers.rst:113
msgid "Sharability: Unlimited"
msgstr ""

# 8b066ba473ab4832a34ffea7a6d2efbc
# 973dcf7e0cb641d697a6cba7701b1538
#: ../../java/dispatchers.rst:85 ../../java/dispatchers.rst:100
msgid "Mailboxes: Any, creates one per Actor"
msgstr ""

# 4d48c3ab67584029ad9233b41ccc6a60
#: ../../java/dispatchers.rst:87
msgid "Use cases: Default dispatcher, Bulkheading"
msgstr ""

# 06f8fbf748f6416d8a91dc54fa7947d1
#: ../../java/dispatchers.rst:90
msgid ""
"specify using \"executor\" using \"fork-join-executor\", \"thread-pool-"
"executor\" or the FQCN of an ``akka.dispatcher.ExecutorServiceConfigurator``"
msgstr ""

# 94d5bdcc2213458e81b59439348d0498
#: ../../java/dispatchers.rst:94
msgid "PinnedDispatcher"
msgstr ""

# 02f8f29e976040a681bfe205e00553f2
#: ../../java/dispatchers.rst:96
msgid ""
"This dispatcher dedicates a unique thread for each actor using it; i.e. each"
" actor will have its own thread pool with only one thread in the pool."
msgstr ""

# e8131baec52b454cbc6bbe242ab680a2
#: ../../java/dispatchers.rst:98
msgid "Sharability: None"
msgstr ""

# fd22fd0205a142c9960398ff72e87a2a
#: ../../java/dispatchers.rst:102
msgid "Use cases: Bulkheading"
msgstr ""

# aa3d3e809dc7469db079f25e46a1372f
#: ../../java/dispatchers.rst:105
msgid "by default a \"thread-pool-executor\""
msgstr ""

# 7ba26d649fbf4700a371c15dbc57eb12
# 44333b4076c84a2baf0ef322e68fc86c
#: ../../java/dispatchers.rst:107 ../../java/testing.rst:523
msgid "CallingThreadDispatcher"
msgstr ""

# d15c388bd79049f9b013b3387d8ba001
#: ../../java/dispatchers.rst:109
msgid ""
"This dispatcher runs invocations on the current thread only. This dispatcher"
" does not create any new threads, but it can be used from different threads "
"concurrently for the same actor. See :ref:`Java-CallingThreadDispatcher` for"
" details and restrictions."
msgstr ""

# 7f406f05d23e4ef2b1a068ddbb526717
#: ../../java/dispatchers.rst:115
msgid "Mailboxes: Any, creates one per Actor per Thread (on demand)"
msgstr ""

# 51a30fb7d83d40ad949579a45bbf2303
#: ../../java/dispatchers.rst:117
msgid "Use cases: Testing"
msgstr ""

# e65699502edf4f70b8da1dc33aae18a2
#: ../../java/dispatchers.rst:119
msgid "Driven by: The calling thread (duh)"
msgstr ""

# 43c1ed2754f44d27a57c6d77aff9d7c7
#: ../../java/dispatchers.rst:122
msgid "More dispatcher configuration examples"
msgstr ""

# 511b3f23449c4b41aaddd659a34fde1b
#: ../../java/dispatchers.rst:124
msgid ""
"Configuring a dispatcher with fixed thread pool size, e.g. for actors that "
"perform blocking IO:"
msgstr ""

# deb2eca58ce84f36a714cc5c675237ee
# 02103d0876664fa387c66edeae0b3a71
#: ../../java/dispatchers.rst:128 ../../java/dispatchers.rst:137
msgid "And then using it:"
msgstr ""

# bca7ba5332c44504bb50870fdc7d7d5a
#: ../../java/dispatchers.rst:133
msgid "Configuring a ``PinnedDispatcher``:"
msgstr ""

# bb4f370480624680b975bf6cba9e7449
#: ../../java/dispatchers.rst:141
msgid ""
"Note that ``thread-pool-executor`` configuration as per the above ``my-"
"thread-pool-dispatcher`` example is NOT applicable. This is because every "
"actor will have its own thread pool when using ``PinnedDispatcher``, and "
"that pool will have only one thread."
msgstr ""

# f18929d7f854467ba5ebc9f28fd409c6
#: ../../java/dispatchers.rst:145
msgid ""
"Note that it's not guaranteed that the *same* thread is used over time, "
"since the core pool timeout is used for ``PinnedDispatcher`` to keep "
"resource usage down in case of idle actors. To use the same thread all the "
"time you need to add ``thread-pool-executor.allow-core-timeout=off`` to the "
"configuration of the ``PinnedDispatcher``."
msgstr ""

# e8e8632115eb4088a346380f840ff5af
#: ../../java/distributed-data.rst:8
msgid ""
"*Akka Distributed Data* is useful when you need to share data between nodes "
"in an Akka Cluster. The data is accessed with an actor providing a key-value"
" store like API. The keys are unique identifiers with type information of "
"the data values. The values are *Conflict Free Replicated Data Types* "
"(CRDTs)."
msgstr ""

# 24f3357375b044499a3a1b23666f2177
#: ../../java/distributed-data.rst:13
msgid ""
"All data entries are spread to all nodes, or nodes with a certain role, in "
"the cluster via direct replication and gossip based dissemination. You have "
"fine grained control of the consistency level for reads and writes."
msgstr ""

# 8fa47bb9d79d40eb9f9dbbcc0b28544a
#: ../../java/distributed-data.rst:17
msgid ""
"The nature CRDTs makes it possible to perform updates from any node without "
"coordination. Concurrent updates from different nodes will automatically be "
"resolved by the monotonic merge function, which all data types must provide."
" The state changes always converge. Several useful data types for counters, "
"sets, maps and registers are provided and you can also implement your own "
"custom data types."
msgstr ""

# 488b5bc85acb4958903e327ea8291cf9
#: ../../java/distributed-data.rst:23
msgid ""
"It is eventually consistent and geared toward providing high read and write "
"availability (partition tolerance), with low latency. Note that in an "
"eventually consistent system a read may return an out-of-date value."
msgstr ""

# aef2cc93d3a34b018b4404b548c661f8
#: ../../java/distributed-data.rst:29
msgid ""
"This module is marked as **“experimental”** as of its introduction in Akka "
"2.4.0. We will continue to improve this API based on our users’ feedback, "
"which implies that while we try to keep incompatible changes to a minimum "
"the binary compatibility guarantee for maintenance releases does not apply "
"to the contents of the ``akka.persistence`` package."
msgstr ""

# c4586258b1164038a53a7b02c675be66
#: ../../java/distributed-data.rst:35
msgid "Using the Replicator"
msgstr ""

# c8e4c16ec6be4c689fe741844bc68c2b
#: ../../java/distributed-data.rst:37
msgid ""
"The ``akka.cluster.ddata.Replicator`` actor provides the API for interacting"
" with the data. The ``Replicator`` actor must be started on each node in the"
" cluster, or group of nodes tagged with a specific role. It communicates "
"with other ``Replicator`` instances with the same path (without address) "
"that are running on other nodes . For convenience it can be used with the "
"``akka.cluster.ddata.DistributedData`` extension."
msgstr ""

# e2c179602cf44856a3641bec32237591
#: ../../java/distributed-data.rst:43
msgid ""
"Cluster members with status :ref:`WeaklyUp <weakly_up_java>`, if that "
"feature is enabled, will currently not participate in Distributed Data, but "
"that is something that should be possible to add in a future release."
msgstr ""

# c30dafc20bdb4ac0b552f106cd962ba4
#: ../../java/distributed-data.rst:47
msgid ""
"Below is an example of an actor that schedules tick messages to itself and "
"for each tick adds or removes elements from a ``ORSet`` (observed-remove "
"set). It also subscribes to changes of this."
msgstr ""

# 32651201ac524569b4ce3168a220e8ea
#: ../../java/distributed-data.rst:56
msgid "Update"
msgstr ""

# 1754e66cf80b426e9cfb6bd615b50789
#: ../../java/distributed-data.rst:58
msgid ""
"To modify and replicate a data value you send a ``Replicator.Update`` "
"message to the local ``Replicator``."
msgstr ""

# a022a23c56dd467cbb884dcfee902def
#: ../../java/distributed-data.rst:61
msgid ""
"The current data value for the ``key`` of the ``Update`` is passed as "
"parameter to the ``modify`` function of the ``Update``. The function is "
"supposed to return the new value of the data, which will then be replicated "
"according to the given consistency level."
msgstr ""

# 2653a5c618dc4cd294be9adb920c3753
#: ../../java/distributed-data.rst:65
msgid ""
"The ``modify`` function is called by the ``Replicator`` actor and must "
"therefore be a pure function that only uses the data parameter and stable "
"fields from enclosing scope. It must for example not access ``sender()`` "
"reference of an enclosing actor."
msgstr ""

# 679cbc9ecf9543e29c895a7636213a18
#: ../../java/distributed-data.rst:70
msgid ""
"the `Replicator`, because the `modify` function is typically not "
"serializable."
msgstr ""

# e2d725c35e574de8bdcd1540cd4e3593
#: ../../java/distributed-data.rst:72
msgid "You supply a write consistency level which has the following meaning:"
msgstr ""

# ba30a33d85384d67bab41e06c50d0655
#: ../../java/distributed-data.rst:74
msgid ""
"``writeLocal`` the value will immediately only be written to the local "
"replica, and later disseminated with gossip"
msgstr ""

# 2a6ebe6d917a438abd40b0ec6d5c4728
#: ../../java/distributed-data.rst:76
msgid ""
"``writeTo(n)`` the value will immediately be written to at least ``n`` "
"replicas, including the local replica"
msgstr ""

# 177716a31d9143fb88e44303746afb7e
#: ../../java/distributed-data.rst:78
msgid ""
"``writeMajority`` the value will immediately be written to a majority of "
"replicas, i.e. at least **N/2 + 1** replicas, where N is the number of nodes"
" in the cluster (or cluster role group)"
msgstr ""

# 540d0845ca5d44998b7c4200d0242eb2
#: ../../java/distributed-data.rst:81
msgid ""
"``writeAll`` the value will immediately be written to all nodes in the "
"cluster (or all nodes in the cluster role group)"
msgstr ""

# ba286d9df00e4f989b14cc86a24a30d9
#: ../../java/distributed-data.rst:86
msgid ""
"As reply of the ``Update`` a ``Replicator.UpdateSuccess`` is sent to the "
"sender of the ``Update`` if the value was successfully replicated according "
"to the supplied consistency level within the supplied timeout. Otherwise a "
"``Replicator.UpdateFailure`` subclass is sent back. Note that a "
"``Replicator.UpdateTimeout`` reply does not mean that the update completely "
"failed or was rolled back. It may still have been replicated to some nodes, "
"and will eventually be replicated to all nodes with the gossip protocol."
msgstr ""

# 06b73c0511cf4c0083b49d6b11662a1e
#: ../../java/distributed-data.rst:97
msgid ""
"You will always see your own writes. For example if you send two ``Update`` "
"messages changing the value of the same ``key``, the ``modify`` function of "
"the second message will see the change that was performed by the first "
"``Update`` message."
msgstr ""

# 26dd88cae92b466b93d1ef35acc91c9a
#: ../../java/distributed-data.rst:101
msgid ""
"In the ``Update`` message you can pass an optional request context, which "
"the ``Replicator`` does not care about, but is included in the reply "
"messages. This is a convenient way to pass contextual information (e.g. "
"original sender) without having to use ``ask`` or maintain local correlation"
" data structures."
msgstr ""

# e96ddb3f6b804376b765c61b974455e2
#: ../../java/distributed-data.rst:111
msgid "Get"
msgstr ""

# 5554c1fad7e84f86a97dfead5b152d32
#: ../../java/distributed-data.rst:113
msgid ""
"To retrieve the current value of a data you send ``Replicator.Get`` message "
"to the ``Replicator``. You supply a consistency level which has the "
"following meaning:"
msgstr ""

# b7438da3fb1e4676b29acadef7086474
#: ../../java/distributed-data.rst:116
msgid "``readLocal`` the value will only be read from the local replica"
msgstr ""

# f299a67a67ef4e518132184b5d25d81f
#: ../../java/distributed-data.rst:117
msgid ""
"``readFrom(n)`` the value will be read and merged from ``n`` replicas, "
"including the local replica"
msgstr ""

# a806fcb23efb40eb9aecbf9a725fe94d
#: ../../java/distributed-data.rst:119
msgid ""
"``readMajority`` the value will be read and merged from a majority of "
"replicas, i.e. at least **N/2 + 1** replicas, where N is the number of nodes"
" in the cluster (or cluster role group)"
msgstr ""

# 7a23928786ea49969f18d54db9b175cf
#: ../../java/distributed-data.rst:122
msgid ""
"``readAll`` the value will be read and merged from all nodes in the cluster "
"(or all nodes in the cluster role group)"
msgstr ""

# e39fc853e57f45c39c4332735f46aef4
#: ../../java/distributed-data.rst:128
msgid ""
"As reply of the ``Get`` a ``Replicator.GetSuccess`` is sent to the sender of"
" the ``Get`` if the value was successfully retrieved according to the "
"supplied consistency level within the supplied timeout. Otherwise a "
"``Replicator.GetFailure`` is sent. If the key does not exist the reply will "
"be ``Replicator.NotFound``."
msgstr ""

# d0e2ac79b8204fd2a0f9112ea8db2386
#: ../../java/distributed-data.rst:137
msgid ""
"You will always read your own writes. For example if you send a ``Update`` "
"message followed by a ``Get`` of the same ``key`` the ``Get`` will retrieve "
"the change that was performed by the preceding ``Update`` message. However, "
"the order of the reply messages are not defined, i.e. in the previous "
"example you may receive the ``GetSuccess`` before the ``UpdateSuccess``."
msgstr ""

# 8bfcb5efe075423fb926ab2ee9b15cfc
#: ../../java/distributed-data.rst:143
msgid ""
"In the ``Get`` message you can pass an optional request context in the same "
"way as for the ``Update`` message, described above. For example the original"
" sender can be passed and replied to after receiving and transforming "
"``GetSuccess``."
msgstr ""

# de4a1ff823ad42d6837c2f83135fb2ab
#: ../../java/distributed-data.rst:150
msgid "Consistency"
msgstr ""

# fbc2a8271d4742e380da66a1e2f78028
#: ../../java/distributed-data.rst:152
msgid ""
"The consistency level that is supplied in the :ref:`replicator_update_java` "
"and :ref:`replicator_get_java` specifies per request how many replicas that "
"must respond successfully to a write and read request."
msgstr ""

# 01de84e3c9da45db9fcfbac01d14357f
#: ../../java/distributed-data.rst:155
msgid ""
"For low latency reads you use ``ReadLocal`` with the risk of retrieving "
"stale data, i.e. updates from other nodes might not be visible yet."
msgstr ""

# fe300e172cb14403938ca6abd4669653
#: ../../java/distributed-data.rst:158
msgid ""
"When using ``writeLocal`` the update is only written to the local replica "
"and then disseminated in the background with the gossip protocol, which can "
"take few seconds to spread to all nodes."
msgstr ""

# bd315b3cc37b49e5b72fddd2b33368de
#: ../../java/distributed-data.rst:161
msgid ""
"``writeAll`` and ``readAll`` is the strongest consistency level, but also "
"the slowest and with lowest availability. For example, it is enough that one"
" node is unavailable for a ``Get`` request and you will not receive the "
"value."
msgstr ""

# 881aeb17a1bf4ce7813434f4aafc4c6a
#: ../../java/distributed-data.rst:165
msgid ""
"If consistency is important, you can ensure that a read always reflects the "
"most recent write by using the following formula::"
msgstr ""

# 68f7a975f7b94e52987b0b1cb7a43425
#: ../../java/distributed-data.rst:170
msgid ""
"where N is the total number of nodes in the cluster, or the number of nodes "
"with the role that is used for the ``Replicator``."
msgstr ""

# 1b43fbb1fca0452a9d0d1a1474e4e512
#: ../../java/distributed-data.rst:173
msgid ""
"For example, in a 7 node cluster this these consistency properties are "
"achieved by writing to 4 nodes and reading from 4 nodes, or writing to 5 "
"nodes and reading from 3 nodes."
msgstr ""

# 322c628f1a304f7bb6a611ba746ff4a8
#: ../../java/distributed-data.rst:176
msgid ""
"By combining ``writeMajority`` and ``readMajority`` levels a read always "
"reflects the most recent write. The ``Replicator`` writes and reads to a "
"majority of replicas, i.e. **N / 2 + 1**. For example, in a 5 node cluster "
"it writes to 3 nodes and reads from 3 nodes. In a 6 node cluster it writes "
"to 4 nodes and reads from 4 nodes."
msgstr ""

# 57bb2ac97c6945d1a29e6104a109d60f
#: ../../java/distributed-data.rst:181
msgid "Here is an example of using ``writeMajority`` and ``readMajority``:"
msgstr ""

# 6345f33f49cf4a448d60c566cc0fbf5b
#: ../../java/distributed-data.rst:189
msgid ""
"In some rare cases, when performing an ``Update`` it is needed to first try "
"to fetch latest data from other nodes. That can be done by first sending a "
"``Get`` with ``ReadMajority`` and then continue with the ``Update`` when the"
" ``GetSuccess``, ``GetFailure`` or ``NotFound`` reply is received. This "
"might be needed when you need to base a decision on latest information or "
"when removing entries from ``ORSet`` or ``ORMap``. If an entry is added to "
"an ``ORSet`` or ``ORMap`` from one node and removed from another node the "
"entry will only be removed if the added entry is visible on the node where "
"the removal is performed (hence the name observed-removed set)."
msgstr ""

# 9fac9dff8bcc4386993d296b68e0ae0f
#: ../../java/distributed-data.rst:197
msgid "The following example illustrates how to do that:"
msgstr ""

# 804f6b51dff241aeb00824024de96266
#: ../../java/distributed-data.rst:203
msgid ""
"*Caveat:* Even if you use ``writeMajority`` and ``readMajority`` there is "
"small risk that you may read stale data if the cluster membership has "
"changed between the ``Update`` and the ``Get``. For example, in cluster of 5"
" nodes when you ``Update`` and that change is written to 3 nodes: n1, n2, "
"n3. Then 2 more nodes are added and a ``Get`` request is reading from 4 "
"nodes, which happens to be n4, n5, n6, n7, i.e. the value on n1, n2, n3 is "
"not seen in the response of the ``Get`` request."
msgstr ""

# fda3a248fb57483aa3a3f3690d298394
#: ../../java/distributed-data.rst:211
msgid "Subscribe"
msgstr ""

# 116446acd3824aa09c4e82fccde8aef9
#: ../../java/distributed-data.rst:213
msgid ""
"You may also register interest in change notifications by sending "
"``Replicator.Subscribe`` message to the ``Replicator``. It will send "
"``Replicator.Changed`` messages to the registered subscriber when the data "
"for the subscribed key is updated. Subscribers will be notified periodically"
" with the configured ``notify-subscribers-interval``, and it is also "
"possible to send an explicit ``Replicator.FlushChanges`` message to the "
"``Replicator`` to notify the subscribers immediately."
msgstr ""

# 861340535f3949e7a99ac8c3aeb37690
#: ../../java/distributed-data.rst:220
msgid ""
"The subscriber is automatically removed if the subscriber is terminated. A "
"subscriber can also be deregistered with the ``Replicator.Unsubscribe`` "
"message."
msgstr ""

# 0b61a7383dda465cb2096f9f0e84de54
#: ../../java/distributed-data.rst:226
msgid "Delete"
msgstr ""

# c5050870129641969d101f3baf854ad2
#: ../../java/distributed-data.rst:228
msgid ""
"A data entry can be deleted by sending a ``Replicator.Delete`` message to "
"the local local ``Replicator``. As reply of the ``Delete`` a "
"``Replicator.DeleteSuccess`` is sent to the sender of the ``Delete`` if the "
"value was successfully deleted according to the supplied consistency level "
"within the supplied timeout. Otherwise a "
"``Replicator.ReplicationDeleteFailure`` is sent. Note that "
"``ReplicationDeleteFailure`` does not mean that the delete completely failed"
" or was rolled back. It may still have been replicated to some nodes, and "
"may eventually be replicated to all nodes."
msgstr ""

# 8d1b585fbc22454bb9a673f9a49a3aac
#: ../../java/distributed-data.rst:236
msgid ""
"A deleted key cannot be reused again, but it is still recommended to delete "
"unused data entries because that reduces the replication overhead when new "
"nodes join the cluster. Subsequent ``Delete``, ``Update`` and ``Get`` "
"requests will be replied with ``Replicator.DataDeleted``. Subscribers will "
"receive ``Replicator.DataDeleted``."
msgstr ""

# 0c64678114614fc9a003c4806f789b50
#: ../../java/distributed-data.rst:244
msgid "Data Types"
msgstr ""

# 30769d25a68a4ef790a6dc10b89545ae
#: ../../java/distributed-data.rst:246
msgid ""
"The data types must be convergent (stateful) CRDTs and implement the "
"``ReplicatedData`` trait, i.e. they provide a monotonic merge function and "
"the state changes always converge."
msgstr ""

# 5c03ff70235a4fc6a720d89f0ef02276
#: ../../java/distributed-data.rst:249
msgid ""
"You can use your own custom ``ReplicatedData`` types, and several types are "
"provided by this package, such as:"
msgstr ""

# 90e625bc4f65451e9f641f3aa7ceb5f4
#: ../../java/distributed-data.rst:252
msgid "Counters: ``GCounter``, ``PNCounter``"
msgstr ""

# 03a1897909a54f51975e729b5542368d
#: ../../java/distributed-data.rst:253
msgid "Sets: ``GSet``, ``ORSet``"
msgstr ""

# b5d59b7a17ad4a23bd78cdd7f68e353e
#: ../../java/distributed-data.rst:254
msgid "Maps: ``ORMap``, ``ORMultiMap``, ``LWWMap``, ``PNCounterMap``"
msgstr ""

# 06f56166b32d4d878faf7f3ddcdb28ea
#: ../../java/distributed-data.rst:255
msgid "Registers: ``LWWRegister``, ``Flag``"
msgstr ""

# 267e0e375286499e9a2bf3f90329a8d4
#: ../../java/distributed-data.rst:258
msgid "Counters"
msgstr ""

# 4d8df68a0f5f46beb70edfc9b1689537
#: ../../java/distributed-data.rst:260
msgid ""
"``GCounter`` is a \"grow only counter\". It only supports increments, no "
"decrements."
msgstr ""

# a9c5509164c74818aceeedbfe152d470
#: ../../java/distributed-data.rst:262
msgid ""
"It works in a similar way as a vector clock. It keeps track of one counter "
"per node and the total value is the sum of these counters. The ``merge`` is "
"implemented by taking the maximum count for each node."
msgstr ""

# e36c54d60f7d4a9ca587b110f7a4bf3b
#: ../../java/distributed-data.rst:266
msgid ""
"If you need both increments and decrements you can use the ``PNCounter`` "
"(positive/negative counter)."
msgstr ""

# 1f2895c0575a410ebd0a848969c6b4ea
#: ../../java/distributed-data.rst:268
msgid ""
"It is tracking the increments (P) separate from the decrements (N). Both P "
"and N are represented as two internal ``GCounter``. Merge is handled by "
"merging the internal P and N counters. The value of the counter is the value"
" of the P counter minus the value of the N counter."
msgstr ""

# 6da1018d7b9c4348a908fb29fcf2d62a
#: ../../java/distributed-data.rst:274
msgid ""
"Several related counters can be managed in a map with the ``PNCounterMap`` "
"data type. When the counters are placed in a ``PNCounterMap`` as opposed to "
"placing them as separate top level values they are guaranteed to be "
"replicated together as one unit, which is sometimes necessary for related "
"data."
msgstr ""

# a352ed229db04f6d8ad2e4b064d40359
#: ../../java/distributed-data.rst:282
msgid "Sets"
msgstr ""

# e3667e06e98c479d8c383a907edd7dca
#: ../../java/distributed-data.rst:284
msgid ""
"If you only need to add elements to a set and not remove elements the "
"``GSet`` (grow-only set) is the data type to use. The elements can be any "
"type of values that can be serialized. Merge is simply the union of the two "
"sets."
msgstr ""

# e768b4cd1b884668aff7f247cbfa7cf4
#: ../../java/distributed-data.rst:290
msgid ""
"If you need add and remove operations you should use the ``ORSet`` "
"(observed-remove set). Elements can be added and removed any number of "
"times. If an element is concurrently added and removed, the add will win. "
"You cannot remove an element that you have not seen."
msgstr ""

# 397456d2baa74df09a3ade3bb90a6bed
#: ../../java/distributed-data.rst:294
msgid ""
"The ``ORSet`` has a version vector that is incremented when an element is "
"added to the set. The version for the node that added the element is also "
"tracked for each element in a so called \"birth dot\". The version vector "
"and the dots are used by the ``merge`` function to track causality of the "
"operations and resolve concurrent updates."
msgstr ""

# e59f061deb98487e860154c7aa5622ca
#: ../../java/distributed-data.rst:302
msgid "Maps"
msgstr ""

# c78765a9dc18429f972e162861560752
#: ../../java/distributed-data.rst:304
msgid ""
"``ORMap`` (observed-remove map) is a map with ``String`` keys and the values"
" are ``ReplicatedData`` types themselves. It supports add, remove and delete"
" any number of times for a map entry."
msgstr ""

# 046cef0cbc274a7fb7f09d24dcd4893c
#: ../../java/distributed-data.rst:307
msgid ""
"If an entry is concurrently added and removed, the add will win. You cannot "
"remove an entry that you have not seen. This is the same semantics as for "
"the ``ORSet``."
msgstr ""

# d3502ded4adf4bb68ea5a20839392bcf
#: ../../java/distributed-data.rst:310
msgid ""
"If an entry is concurrently updated to different values the values will be "
"merged, hence the requirement that the values must be ``ReplicatedData`` "
"types."
msgstr ""

# afbe5a520b444086b49b41d8b1b33c9d
#: ../../java/distributed-data.rst:313
msgid ""
"It is rather inconvenient to use the ``ORMap`` directly since it does not "
"expose specific types of the values. The ``ORMap`` is intended as a low "
"level tool for building more specific maps, such as the following "
"specialized maps."
msgstr ""

# 11a33770759b41e59b949cad6f88a264
#: ../../java/distributed-data.rst:317
msgid ""
"``ORMultiMap`` (observed-remove multi-map) is a multi-map implementation "
"that wraps an ``ORMap`` with an ``ORSet`` for the map's value."
msgstr ""

# bf282ae23bfa48d38aa9a9e49bec31ac
#: ../../java/distributed-data.rst:320
msgid ""
"``PNCounterMap`` (positive negative counter map) is a map of named counters."
" It is a specialized ``ORMap`` with ``PNCounter`` values."
msgstr ""

# 1b24d46b16f74b9c90e5b39a828f0a98
#: ../../java/distributed-data.rst:323
msgid ""
"``LWWMap`` (last writer wins map) is a specialized ``ORMap`` with "
"``LWWRegister`` (last writer wins register) values."
msgstr ""

# bf1fac71f7a84ca3bd0edc16a95c4aa7
#: ../../java/distributed-data.rst:328
msgid ""
"Note that ``LWWRegister`` and therefore ``LWWMap`` relies on synchronized "
"clocks and should only be used when the choice of value is not important for"
" concurrent updates occurring within the clock skew."
msgstr ""

# 16386cf352da4c8795c5af1835aae6ee
# 448c22b2330e4eb78f63850ee2e6a348
#: ../../java/distributed-data.rst:331 ../../java/distributed-data.rst:362
msgid ""
"Instead of using timestamps based on ``System.currentTimeMillis()`` time it "
"is possible to use a timestamp value based on something else, for example an"
" increasing version number from a database record that is used for "
"optimistic concurrency control."
msgstr ""

# 8144478d299e4cf0b3673ff0f4ef434e
#: ../../java/distributed-data.rst:335
msgid ""
"When a data entry is changed the full state of that entry is replicated to "
"other nodes, i.e. when you update a map the whole map is replicated. "
"Therefore, instead of using one ``ORMap`` with 1000 elements it is more "
"efficient to split that up in 10 top level ``ORMap`` entries with 100 "
"elements each. Top level entries are replicated individually, which has the "
"trade-off that different entries may not be replicated at the same time and "
"you may see inconsistencies between related entries. Separate top level "
"entries cannot be updated atomically together."
msgstr ""

# 9ab37bf8c87e4c3dbf7e1f577da9510a
#: ../../java/distributed-data.rst:344
msgid "Flags and Registers"
msgstr ""

# c13222dcd3ea4816bf150eb266043d31
#: ../../java/distributed-data.rst:346
msgid ""
"``Flag`` is a data type for a boolean value that is initialized to ``false``"
" and can be switched to ``true``. Thereafter it cannot be changed. ``true`` "
"wins over ``false`` in merge."
msgstr ""

# 377c3033b6d84a51890f73edfde37ac7
#: ../../java/distributed-data.rst:351
msgid ""
"``LWWRegister`` (last writer wins register) can hold any (serializable) "
"value."
msgstr ""

# 3af7513220434e978fb145666af7c123
#: ../../java/distributed-data.rst:353
msgid ""
"Merge of a ``LWWRegister`` takes the register with highest timestamp. Note "
"that this relies on synchronized clocks. `LWWRegister` should only be used "
"when the choice of value is not important for concurrent updates occurring "
"within the clock skew."
msgstr ""

# 498a61de39fe45c2bae6a98b3d7be6f8
#: ../../java/distributed-data.rst:357
msgid ""
"Merge takes the register updated by the node with lowest address "
"(``UniqueAddress`` is ordered) if the timestamps are exactly the same."
msgstr ""

# e87a026b978f430d9411f4cb3dffeb7d
#: ../../java/distributed-data.rst:368
msgid ""
"For first-write-wins semantics you can use the ``LWWRegister#reverseClock`` "
"instead of the ``LWWRegister#defaultClock``."
msgstr ""

# e4590fba0957400fa9d521d548adf4e6
#: ../../java/distributed-data.rst:372
msgid "Custom Data Type"
msgstr ""

# 8e69b03dc89e4919b696351a8a91c0fa
#: ../../java/distributed-data.rst:374
msgid ""
"You can rather easily implement your own data types. The only requirement is"
" that it implements the ``mergeData`` function of the "
"``AbstractReplicatedData`` class."
msgstr ""

# d8579c2644a543049d200db0efdd21f9
#: ../../java/distributed-data.rst:377
msgid ""
"A nice property of stateful CRDTs is that they typically compose nicely, "
"i.e. you can combine several smaller data types to build richer data "
"structures. For example, the ``PNCounter`` is composed of two internal "
"``GCounter`` instances to keep track of increments and decrements "
"separately."
msgstr ""

# ffbfd4a3b3f84719bbf9e9c96caaaeb6
#: ../../java/distributed-data.rst:381
msgid ""
"Here is s simple implementation of a custom ``TwoPhaseSet`` that is using "
"two internal ``GSet`` types to keep track of addition and removals.  A "
"``TwoPhaseSet`` is a set where an element may be added and removed, but "
"never added again thereafter."
msgstr ""

# 8cf86f13440240b88981f1af01c80f66
#: ../../java/distributed-data.rst:387
msgid ""
"Data types should be immutable, i.e. \"modifying\" methods should return a "
"new instance."
msgstr ""

# f5d717b0418447849e149548d46db0e4
# 14aa12514e9d4d1798d7c0cc35a749ec
# f300118eed17414896b21c78cdb90536
#: ../../java/distributed-data.rst:390 ../../java/remoting.rst:256
#: ../../java/serialization.rst:6
msgid "Serialization"
msgstr ""

# 8a3f92a84626417b9c169a24dbc630f7
#: ../../java/distributed-data.rst:392
msgid ""
"The data types must be serializable with an :ref:`Akka Serializer "
"<serialization-java>`. It is highly recommended that you implement  "
"efficient serialization with Protobuf or similar for your custom data types."
" The built in data types are marked with ``ReplicatedDataSerialization`` and"
" serialized with ``akka.cluster.ddata.protobuf.ReplicatedDataSerializer``."
msgstr ""

# 038e1584a12f4542846b33dee1eca139
#: ../../java/distributed-data.rst:397
msgid ""
"Serialization of the data types are used in remote messages and also for "
"creating message digests (SHA-1) to detect changes. Therefore it is "
"important that the serialization is efficient and produce the same bytes for"
" the same content. For example sets and maps should be sorted "
"deterministically in the serialization."
msgstr ""

# c98ac07a46c4447da966e69cd949ceda
#: ../../java/distributed-data.rst:402
msgid "This is a protobuf representation of the above ``TwoPhaseSet``:"
msgstr ""

# 9b53d5f5b57540e79fd8c04ee46d36ed
#: ../../java/distributed-data.rst:406
msgid "The serializer for the ``TwoPhaseSet``:"
msgstr ""

# e13408ce03af4790a5b6c817a57ba1ed
#: ../../java/distributed-data.rst:410
msgid ""
"Note that the elements of the sets are sorted so the SHA-1 digests are the "
"same for the same elements."
msgstr ""

# 7967a313bd7e4868b8b96074ed911565
#: ../../java/distributed-data.rst:413
msgid "You register the serializer in configuration:"
msgstr ""

# 1349e0a29ff544ef81be79cdb4e2381c
#: ../../java/distributed-data.rst:417
msgid ""
"Using compression can sometimes be a good idea to reduce the data size. Gzip"
" compression is provided by the "
"``akka.cluster.ddata.protobuf.SerializationSupport`` trait:"
msgstr ""

# 76b0e37ad3f74767ac1ae79aeed4ccd0
#: ../../java/distributed-data.rst:422
msgid ""
"The two embedded ``GSet`` can be serialized as illustrated above, but in "
"general when composing new data types from the existing built in types it is"
" better to make use of the existing serializer for those types. This can be "
"done by declaring those as bytes fields in protobuf:"
msgstr ""

# 4f566442c16a4569bae35e33faa60188
#: ../../java/distributed-data.rst:428
msgid ""
"and use the methods ``otherMessageToProto`` and ``otherMessageFromBinary`` "
"that are provided by the ``SerializationSupport`` trait to serialize and "
"deserialize the ``GSet`` instances. This works with any type that has a "
"registered Akka serializer. This is how such an serializer would look like "
"for the ``TwoPhaseSet``:"
msgstr ""

# 84fe0af7847f4a94aeb35d2a49e94fcd
#: ../../java/distributed-data.rst:437
msgid "CRDT Garbage"
msgstr ""

# 3ad0bec88949454fb40b5ecf5c1ebe3d
#: ../../java/distributed-data.rst:439
msgid ""
"One thing that can be problematic with CRDTs is that some data types "
"accumulate history (garbage). For example a ``GCounter`` keeps track of one "
"counter per node. If a ``GCounter`` has been updated from one node it will "
"associate the identifier of that node forever. That can become a problem for"
" long running systems with many cluster nodes being added and removed. To "
"solve this problem the ``Replicator`` performs pruning of data associated "
"with nodes that have been removed from the cluster. Data types that need "
"pruning have to implement the ``RemovedNodePruning`` trait."
msgstr ""

# 4373aabf5af94461a3cb6aa3643dacbf
#: ../../java/distributed-data.rst:447
msgid "Samples"
msgstr ""

# 4c459cd6dfdb4a2c82e03dc91dac3684
#: ../../java/distributed-data.rst:449
msgid ""
"Several interesting samples are included and described in the `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_ tutorial named "
"`Akka Distributed Data Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-distributed-data-"
"java>`_."
msgstr ""

# 4bd8ea58ace147b795f03622fe30b6f1
#: ../../java/distributed-data.rst:452
msgid "Low Latency Voting Service"
msgstr ""

# 695cd224ff2b4fb389f1d6150746ec90
#: ../../java/distributed-data.rst:453
msgid "Highly Available Shopping Cart"
msgstr ""

# 776f82abdb9746ad8d7b164ce3d16db3
#: ../../java/distributed-data.rst:454
msgid "Distributed Service Registry"
msgstr ""

# 03cd9357fdcb46748158c0c2b76c6839
#: ../../java/distributed-data.rst:455
msgid "Replicated Cache"
msgstr ""

# db7d9e0f73be4f23ac225a93869f2e52
#: ../../java/distributed-data.rst:456
msgid "Replicated Metrics"
msgstr ""

# d372b7adb0974ea59d378fb898f3c941
# bad4239bf3cb4784b35456d62df99be1
#: ../../java/distributed-data.rst:459 ../../java/testing.rst:574
msgid "Limitations"
msgstr ""

# 4cd13b1a59bf49ddb036cab53dda5b00
#: ../../java/distributed-data.rst:461
msgid "There are some limitations that you should be aware of."
msgstr ""

# 4de622298836461691590a27b4650144
#: ../../java/distributed-data.rst:463
msgid ""
"CRDTs cannot be used for all types of problems, and eventual consistency "
"does not fit all domains. Sometimes you need strong consistency."
msgstr ""

# 3b8756909f094f2489ef6288cb4616a6
#: ../../java/distributed-data.rst:466
msgid ""
"It is not intended for *Big Data*. The number of top level entries should "
"not exceed 100000. When a new node is added to the cluster all these entries"
" are transferred (gossiped) to the new node. The entries are split up in "
"chunks and all existing nodes collaborate in the gossip, but it will take a "
"while (tens of seconds) to transfer all entries and this means that you "
"cannot have too many top level entries. The current recommended limit is "
"100000. We will be able to improve this if needed, but the design is still "
"not intended for billions of entries."
msgstr ""

# 70f8e99532154e8abbac4d298c393529
#: ../../java/distributed-data.rst:473
msgid ""
"All data is held in memory, which is another reason why it is not intended "
"for *Big Data*."
msgstr ""

# 699260853e9a42e2b1d81ec46b6180ae
#: ../../java/distributed-data.rst:475
msgid ""
"When a data entry is changed the full state of that entry is replicated to "
"other nodes. For example, if you add one element to a Set with 100 existing "
"elements, all 101 elements are transferred to other nodes. This means that "
"you cannot have too large data entries, because then the remote message size"
" will be too large. We might be able to make this more efficient by "
"implementing `Efficient State-based CRDTs by Delta-Mutation "
"<http://gsd.di.uminho.pt/members/cbm/ps/delta-crdt-draft16may2014.pdf>`_."
msgstr ""

# 8f5f0a52c7754440b4c0ec1da3b786ec
#: ../../java/distributed-data.rst:481
msgid ""
"The data is only kept in memory. It is redundant since it is replicated to "
"other nodes in the cluster, but if you stop all nodes the data is lost, "
"unless you have saved it elsewhere. Making the data durable is a possible "
"future feature, but even if we implement that it is not intended to be a "
"full featured database."
msgstr ""

# 70d7169d0d3840f2bde7d88886500da9
#: ../../java/distributed-data.rst:487
msgid "Learn More about CRDTs"
msgstr ""

# 0fe08d0b57c6478e93da56f99cf09350
#: ../../java/distributed-data.rst:489
msgid ""
"`The Final Causal Frontier <http://www.ustream.tv/recorded/61448875>`_ talk "
"by Sean Cribbs"
msgstr ""

# cac5b078af6d441c8b8e5c16139b843e
#: ../../java/distributed-data.rst:491
msgid ""
"`Eventually Consistent Data Structures <https://vimeo.com/43903960>`_ talk "
"by Sean Cribbs"
msgstr ""

# 2999f52751dd4a7b9a54fe89646a0601
#: ../../java/distributed-data.rst:493
msgid ""
"`Strong Eventual Consistency and Conflict-free Replicated Data Types "
"<http://research.microsoft.com/apps/video/default.aspx?id=153540&r=1>`_ talk"
" by Mark Shapiro"
msgstr ""

# a59e9839cec84278b921b8204cbb4abd
#: ../../java/distributed-data.rst:495
msgid ""
"`A comprehensive study of Convergent and Commutative Replicated Data Types "
"<http://hal.upmc.fr/file/index/docid/555588/filename/techreport.pdf>`_ paper"
" by Mark Shapiro et. al."
msgstr ""

# 7f77eb4216514d00bbc95b2bba15b6a7
#: ../../java/distributed-data.rst:501
msgid ""
"To use Distributed Data you must add the following dependency in your "
"project."
msgstr ""

# ad331c96e10c4f179e6dcd64a96765df
#: ../../java/distributed-data.rst:518
msgid ""
"The ``DistributedData`` extension can be configured with the following "
"properties:"
msgstr ""

# ff200a0f11184bc493db48d948a86f56
#: ../../java/distributed-pub-sub.rst:4
msgid "Distributed Publish Subscribe in Cluster"
msgstr ""

# 3a965558492441f1b3b2f0020ba55453
#: ../../java/distributed-pub-sub.rst:6
msgid ""
"How do I send a message to an actor without knowing which node it is running"
" on?"
msgstr ""

# a2c87d24c28943aea703a2a3886f0d8e
#: ../../java/distributed-pub-sub.rst:8
msgid ""
"How do I send messages to all actors in the cluster that have registered "
"interest in a named topic?"
msgstr ""

# bb2e112c2e86489ca0f3d614f8d0430d
#: ../../java/distributed-pub-sub.rst:11
msgid ""
"This pattern provides a mediator actor, "
"``akka.cluster.pubsub.DistributedPubSubMediator``, that manages a registry "
"of actor references and replicates the entries to peer actors among all "
"cluster nodes or a group of nodes tagged with a specific role."
msgstr ""

# 214e1cb8e5464ae0b75a02231cf91df2
#: ../../java/distributed-pub-sub.rst:15
msgid ""
"The ``DistributedPubSubMediator`` actor is supposed to be started on all "
"nodes, or all nodes with specified role, in the cluster. The mediator can be"
" started with the ``DistributedPubSub`` extension or as an ordinary actor."
msgstr ""

# 49fcd9d8adf140a48f642ce0e534e173
#: ../../java/distributed-pub-sub.rst:19
msgid ""
"The registry is eventually consistent, i.e. changes are not immediately "
"visible at other nodes, but typically they will be fully replicated to all "
"other nodes after a few seconds. Changes are only performed in the own part "
"of the registry and those changes are versioned. Deltas are disseminated in "
"a scalable way to other nodes with a gossip protocol."
msgstr ""

# 3d143d233109464f8ba383a6b8cfdb25
#: ../../java/distributed-pub-sub.rst:25
msgid ""
"Cluster members with status :ref:`WeaklyUp <weakly_up_java>`, if that "
"feature is enabled, will participate in Distributed Publish Subscribe, i.e. "
"subscribers on nodes with ``WeaklyUp`` status will receive published "
"messages if the publisher and subscriber are on same side of a network "
"partition."
msgstr ""

# c8a8a57da7fc40d2a5c4b8e652538bff
#: ../../java/distributed-pub-sub.rst:30
msgid ""
"You can send messages via the mediator on any node to registered actors on "
"any other node."
msgstr ""

# 34d184188a2349719428d0daf7c9feec
#: ../../java/distributed-pub-sub.rst:33
msgid ""
"There a two different modes of message delivery, explained in the sections "
":ref:`distributed-pub-sub-publish-java` and :ref:`distributed-pub-sub-send-"
"java` below."
msgstr ""

# 9a1b3ad57c6048de9433608e9e4d685a
#: ../../java/distributed-pub-sub.rst:39
msgid "Publish"
msgstr ""

# 99885976c08a4057b809908f16b944d3
#: ../../java/distributed-pub-sub.rst:41
msgid ""
"This is the true pub/sub mode. A typical usage of this mode is a chat room "
"in an instant messaging application."
msgstr ""

# 75a0b475351f4beca1a9afcff8e42a5e
#: ../../java/distributed-pub-sub.rst:44
msgid ""
"Actors are registered to a named topic. This enables many subscribers on "
"each node. The message will be delivered to all subscribers of the topic."
msgstr ""

# bbe9847f937f4c5aac79445c1474c0e0
#: ../../java/distributed-pub-sub.rst:47
msgid ""
"For efficiency the message is sent over the wire only once per node (that "
"has a matching topic), and then delivered to all subscribers of the local "
"topic representation."
msgstr ""

# 044413a335204ac2a009a8193c6a61eb
#: ../../java/distributed-pub-sub.rst:50
msgid ""
"You register actors to the local mediator with "
"``DistributedPubSubMediator.Subscribe``. Successful ``Subscribe`` and "
"``Unsubscribe`` is acknowledged with "
"``DistributedPubSubMediator.SubscribeAck`` and "
"``DistributedPubSubMediator.UnsubscribeAck`` replies. The acknowledgment "
"means that the subscription is registered, but it can still take some time "
"until it is replicated to other nodes."
msgstr ""

# 37dc1b7ee67a4b8b90fb30abcfd64dd6
#: ../../java/distributed-pub-sub.rst:56
msgid ""
"You publish messages by sending ``DistributedPubSubMediator.Publish`` "
"message to the local mediator."
msgstr ""

# 594065a065a547a197a03a4e61072436
#: ../../java/distributed-pub-sub.rst:59
msgid ""
"Actors are automatically removed from the registry when they are terminated,"
" or you can explicitly remove entries with "
"``DistributedPubSubMediator.Unsubscribe``."
msgstr ""

# ecbf3b820ec142408577d53402a01ac5
#: ../../java/distributed-pub-sub.rst:62
msgid "An example of a subscriber actor:"
msgstr ""

# e7515e5318d54dacb98307057a4bc20a
# b30ba6a7f91543b49ac43c4002e29a6f
#: ../../java/distributed-pub-sub.rst:66
#: ../../java/distributed-pub-sub.rst:136
msgid ""
"Subscriber actors can be started on several nodes in the cluster, and all "
"will receive messages published to the \"content\" topic."
msgstr ""

# f638b56ab3054a868e89d1a16f8b0cb4
# 788bd98b434f4ada8cf5a30c29e28b7a
#: ../../java/distributed-pub-sub.rst:71
#: ../../java/distributed-pub-sub.rst:141
msgid "A simple actor that publishes to this \"content\" topic:"
msgstr ""

# e90459b3f30c48ec94106b918e5283c1
# b0efd382d7634595bd7f4470268a04c6
#: ../../java/distributed-pub-sub.rst:75
#: ../../java/distributed-pub-sub.rst:145
msgid "It can publish messages to the topic from anywhere in the cluster:"
msgstr ""

# 09f2de400452411cbad74f7271d22b85
#: ../../java/distributed-pub-sub.rst:80
msgid "Topic Groups"
msgstr ""

# 7d4878cc67174a86817841ce90f6e436
#: ../../java/distributed-pub-sub.rst:82
msgid ""
"Actors may also be subscribed to a named topic with a ``group`` id. If "
"subscribing with a group id, each message published to a topic with the "
"``sendOneMessageToEachGroup`` flag set to ``true`` is delivered via the "
"supplied ``RoutingLogic`` (default random) to one actor within each "
"subscribing group."
msgstr ""

# 0899e6e1d1d44c608fba6ef116b8e2ad
#: ../../java/distributed-pub-sub.rst:87
msgid ""
"If all the subscribed actors have the same group id, then this works just "
"like ``Send`` and each message is only delivered to one subscriber."
msgstr ""

# 03b54e4c119e4412954e9a83d5acb1e8
#: ../../java/distributed-pub-sub.rst:90
msgid ""
"If all the subscribed actors have different group names, then this works "
"like normal ``Publish`` and each message is broadcasted to all subscribers."
msgstr ""

# b48b59dd44ee40acbb238ff230517c4b
#: ../../java/distributed-pub-sub.rst:95
msgid ""
"Note that if the group id is used it is part of the topic identifier. "
"Messages published with ``sendOneMessageToEachGroup=false`` will not be "
"delivered to subscribers that subscribed with a group id. Messages published"
" with ``sendOneMessageToEachGroup=true`` will not be delivered to "
"subscribers that subscribed without a group id."
msgstr ""

# bbbe26e8340d49d489da3a1b4b3c810c
#: ../../java/distributed-pub-sub.rst:104
msgid "Send"
msgstr ""

# ef4d9cb541524b518b267b7b7c1ba0a2
#: ../../java/distributed-pub-sub.rst:106
msgid ""
"This is a point-to-point mode where each message is delivered to one "
"destination, but you still does not have to know where the destination is "
"located. A typical usage of this mode is private chat to one other user in "
"an instant messaging application. It can also be used for distributing tasks"
" to registered workers, like a cluster aware router where the routees "
"dynamically can register themselves."
msgstr ""

# 504c8cf904b5405a80334e1e5c2e8a29
#: ../../java/distributed-pub-sub.rst:112
msgid ""
"The message will be delivered to one recipient with a matching path, if any "
"such exists in the registry. If several entries match the path because it "
"has been registered on several nodes the message will be sent via the "
"supplied ``RoutingLogic`` (default random) to one destination. The sender() "
"of the message can specify that local affinity is preferred, i.e. the "
"message is sent to an actor in the same local actor system as the used "
"mediator actor, if any such exists, otherwise route to any other matching "
"entry."
msgstr ""

# 7a8a919c497345a7b051bf2555da5db3
#: ../../java/distributed-pub-sub.rst:119
msgid ""
"You register actors to the local mediator with "
"``DistributedPubSubMediator.Put``. The ``ActorRef`` in ``Put`` must belong "
"to the same local actor system as the mediator. The path without address "
"information is the key to which you send messages. On each node there can "
"only be one actor for a given path, since the path is unique within one "
"local actor system."
msgstr ""

# 25f05f26211f453188760656b8365152
#: ../../java/distributed-pub-sub.rst:125
msgid ""
"You send messages by sending ``DistributedPubSubMediator.Send`` message to "
"the local mediator with the path (without address information) of the "
"destination actors."
msgstr ""

# e3626595d9ba41ab840c7a832dff5945
#: ../../java/distributed-pub-sub.rst:129
msgid ""
"Actors are automatically removed from the registry when they are terminated,"
" or you can explicitly remove entries with "
"``DistributedPubSubMediator.Remove``."
msgstr ""

# dd5bdb2e4c6049209bb6fe368e77d80b
#: ../../java/distributed-pub-sub.rst:132
msgid "An example of a destination actor:"
msgstr ""

# e253e7aa24da4c8694bf4490f1eb2826
#: ../../java/distributed-pub-sub.rst:149
msgid ""
"It is also possible to broadcast messages to the actors that have been "
"registered with ``Put``. Send ``DistributedPubSubMediator.SendToAll`` "
"message to the local mediator and the wrapped message will then be delivered"
" to all recipients with a matching path. Actors with the same path, without "
"address information, can be registered on different nodes. On each node "
"there can only be one such actor, since the path is unique within one local "
"actor system."
msgstr ""

# 0be435872b774b7e86326b8d3d2cf0de
#: ../../java/distributed-pub-sub.rst:156
msgid ""
"Typical usage of this mode is to broadcast messages to all replicas with the"
" same path, e.g. 3 actors on different nodes that all perform the same "
"actions, for redundancy. You can also optionally specify a property "
"(``allButSelf``) deciding if the message should be sent to a matching path "
"on the self node or not."
msgstr ""

# b09a644db03145d593702ce3c8e55632
#: ../../java/distributed-pub-sub.rst:162
msgid "DistributedPubSub Extension"
msgstr ""

# 89d9f8d05219438caf2964ccb7b629a9
#: ../../java/distributed-pub-sub.rst:164
msgid ""
"In the example above the mediator is started and accessed with the "
"``akka.cluster.pubsub.DistributedPubSub`` extension. That is convenient and "
"perfectly fine in most cases, but it can be good to know that it is possible"
" to start the mediator actor as an ordinary actor and you can have several "
"different mediators at the same time to be able to divide a large number of "
"actors/topics to different mediators. For example you might want to use "
"different cluster roles for different mediators."
msgstr ""

# c2a76fe1b8bd4c2bb05673b73266e7df
#: ../../java/distributed-pub-sub.rst:170
msgid ""
"The ``DistributedPubSub`` extension can be configured with the following "
"properties:"
msgstr ""

# 2a84b6aa61b44f3fafc562310ea3cf56
#: ../../java/distributed-pub-sub.rst:174
msgid ""
"It is recommended to load the extension when the actor system is started by "
"defining it in ``akka.extensions`` configuration property. Otherwise it will"
" be activated when first used and then it takes a while for it to be "
"populated."
msgstr ""

# f1d0a05dfdb848ad9d2fc02f8085312f
#: ../../java/distributed-pub-sub.rst:185
msgid ""
"To use Distributed Publish Subscribe you must add the following dependency "
"in your project."
msgstr ""

# 30cc60b6b7a14ccdb2dc1f756798e690
#: ../../java/event-bus.rst:5
msgid "Event Bus"
msgstr ""

# 3ddf41604e2e4792958506f8adf71388
#: ../../java/event-bus.rst:8
msgid ""
"Originally conceived as a way to send messages to groups of actors, the "
":class:`EventBus` has been generalized into a set of abstract base classes "
"implementing a simple interface:"
msgstr ""

# 32f77d2262294c15bf70351ea339cb98
#: ../../java/event-bus.rst:16
msgid ""
"Please note that the EventBus does not preserve the sender of the published "
"messages. If you need a reference to the original sender you have to provide"
" it inside the message."
msgstr ""

# 9b14f82f83004a1ea155a91f0fa164df
#: ../../java/event-bus.rst:20
msgid ""
"This mechanism is used in different places within Akka, e.g. the `Event "
"Stream`_. Implementations can make use of the specific building blocks "
"presented below."
msgstr ""

# 4da18216f49d4307b1aab34092c2f612
#: ../../java/event-bus.rst:23
msgid "An event bus must define the following three type parameters:"
msgstr ""

# 860652d5e656468489092db10a2ac2cf
#: ../../java/event-bus.rst:25
msgid ":class:`Event` (E) is the type of all events published on that bus"
msgstr ""

# d7575ecef1924d86b7108ade17593325
#: ../../java/event-bus.rst:27
msgid ""
":class:`Subscriber` (S) is the type of subscribers allowed to register on "
"that event bus"
msgstr ""

# b48da02dc9ed4037b1cfaa77e694895a
#: ../../java/event-bus.rst:30
msgid ""
":class:`Classifier` (C) defines the classifier to be used in selecting "
"subscribers for dispatching events"
msgstr ""

# 0317243c9d02460b95b5ee8cbf1a98f6
#: ../../java/event-bus.rst:33
msgid ""
"The traits below are still generic in these types, but they need to be "
"defined for any concrete implementation."
msgstr ""

# 16b79f2750754f369a37096060329cc4
#: ../../java/event-bus.rst:37
msgid "Classifiers"
msgstr ""

# 616693cc1f0449d18a9dd36d59b6658b
#: ../../java/event-bus.rst:39
msgid ""
"The classifiers presented here are part of the Akka distribution, but "
"rolling your own in case you do not find a perfect match is not difficult, "
"check the implementation of the existing ones on `github <@github@/akka-"
"actor/src/main/scala/akka/event/EventBus.scala>`_"
msgstr ""

# 8293fde2a26f43a582bdaf1dda331e25
#: ../../java/event-bus.rst:44
msgid "Lookup Classification"
msgstr ""

# 3a0d9cd4fb9448578ce5419252e39a89
#: ../../java/event-bus.rst:46
msgid ""
"The simplest classification is just to extract an arbitrary classifier from "
"each event and maintaining a set of subscribers for each possible "
"classifier. This can be compared to tuning in on a radio station. The trait "
":class:`LookupClassification` is still generic in that it abstracts over how"
" to compare subscribers and how exactly to classify."
msgstr ""

# c1b3e9d9406d42119662ffbee303a541
# 7b16e867f454421b9944137f972f19b3
# 4f824c5feee8427b9d16634c1b77428d
# 761c9b3ef2dd4e599e0c7baa6ee5596e
#: ../../java/event-bus.rst:52 ../../java/event-bus.rst:73
#: ../../java/event-bus.rst:96 ../../java/event-bus.rst:121
msgid ""
"The necessary methods to be implemented are illustrated with the following "
"example:"
msgstr ""

# 3c7f498b23154c87babbe35b84de9473
# c33f7c459ec643ba88b1577572d97a88
# 31101c46f88d41a99d43ea9bbdfe18ea
# ddb22fe3f9994fa3b32c46898c91afd5
#: ../../java/event-bus.rst:56 ../../java/event-bus.rst:77
#: ../../java/event-bus.rst:100 ../../java/event-bus.rst:125
msgid "A test for this implementation may look like this:"
msgstr ""

# 4ab866d4b0b8448a878bc12b4a358308
#: ../../java/event-bus.rst:60
msgid ""
"This classifier is efficient in case no subscribers exist for a particular "
"event."
msgstr ""

# ded67d65f26d46bcbb43ad8782b63485
#: ../../java/event-bus.rst:63
msgid "Subchannel Classification"
msgstr ""

# 7524aeb88ae7465a982681d720dcac97
#: ../../java/event-bus.rst:65
msgid ""
"If classifiers form a hierarchy and it is desired that subscription be "
"possible not only at the leaf nodes, this classification may be just the "
"right one. It can be compared to tuning in on (possibly multiple) radio "
"channels by genre. This classification has been developed for the case where"
" the classifier is just the JVM class of the event and subscribers may be "
"interested in subscribing to all subclasses of a certain class, but it may "
"be used with any classifier hierarchy."
msgstr ""

# fc3ebab7d3eb4d28853f65556cb2092f
#: ../../java/event-bus.rst:81
msgid ""
"This classifier is also efficient in case no subscribers are found for an "
"event, but it uses conventional locking to synchronize an internal "
"classifier cache, hence it is not well-suited to use cases in which "
"subscriptions change with very high frequency (keep in mind that “opening” a"
" classifier by sending the first message will also have to re-check all "
"previous subscriptions)."
msgstr ""

# 9077231dd602404cab44ea3d31c1a984
#: ../../java/event-bus.rst:88
msgid "Scanning Classification"
msgstr ""

# 72580c2edece4c3baa321cee11d9bcd3
#: ../../java/event-bus.rst:90
msgid ""
"The previous classifier was built for multi-classifier subscriptions which "
"are strictly hierarchical, this classifier is useful if there are "
"overlapping classifiers which cover various parts of the event space without"
" forming a hierarchy. It can be compared to tuning in on (possibly multiple)"
" radio stations by geographical reachability (for old-school radio-wave "
"transmission)."
msgstr ""

# eb09f1e9595e498b920a5e5377d8bac0
#: ../../java/event-bus.rst:104
msgid ""
"This classifier takes always a time which is proportional to the number of "
"subscriptions, independent of how many actually match."
msgstr ""

# 471fa4fbcbcb4275b6ac23c9f43cdf12
#: ../../java/event-bus.rst:110
msgid "Actor Classification"
msgstr ""

# da20f40ee5ac472f9915c352d0c06ba8
#: ../../java/event-bus.rst:112
msgid ""
"This classification was originally developed specifically for implementing "
":ref:`DeathWatch <deathwatch-java>`: subscribers as well as classifiers are "
"of type :class:`ActorRef`."
msgstr ""

# 732256476b704bd8a7e88dca875a6b5c
#: ../../java/event-bus.rst:116
msgid ""
"This classification requires an :class:`ActorSystem` in order to perform "
"book-keeping operations related to the subscribers being Actors, which can "
"terminate without first unsubscribing from the EventBus. "
"ManagedActorClassification maintains a system Actor which takes care of "
"unsubscribing terminated actors automatically."
msgstr ""

# b598054029c240178ca3ba4d5073fba2
#: ../../java/event-bus.rst:129
msgid ""
"This classifier is still is generic in the event type, and it is efficient "
"for all use cases."
msgstr ""

# 121cd6c3a8874126bce53245c5f236a8
#: ../../java/event-bus.rst:135
msgid "Event Stream"
msgstr ""

# a00f0ad92e45428cbaf02e5c75c21a20
#: ../../java/event-bus.rst:137
msgid ""
"The event stream is the main event bus of each actor system: it is used for "
"carrying :ref:`log messages <logging-java>` and `Dead Letters`_ and may be "
"used by the user code for other purposes as well. It uses `Subchannel "
"Classification`_ which enables registering to related sets of channels (as "
"is used for :class:`RemotingLifecycleEvent`). The following example "
"demonstrates how a simple subscription works. Given a simple actor:"
msgstr ""

# 71f6866524cf4280831e7a5b866038ce
#: ../../java/event-bus.rst:147
msgid "it can be subscribed like this:"
msgstr ""

# 062f603988fc44218de6f9fb41aaeb76
#: ../../java/event-bus.rst:151
msgid ""
"It is also worth pointing out that thanks to the way the subchannel "
"classification is implemented in the event stream, it is possible to "
"subscribe to a group of events, by subscribing to their common superclass as"
" demonstrated in the following example:"
msgstr ""

# 3a13b6ff568d4bb1a0e82936cc610372
#: ../../java/event-bus.rst:157
msgid ""
"Similarly to `Actor Classification`_, :class:`EventStream` will "
"automatically remove subscribers when they terminate."
msgstr ""

# 4e3e1140a2d244cdb4e17a42f3a0635f
#: ../../java/event-bus.rst:160
msgid ""
"The event stream is a *local facility*, meaning that it will *not* "
"distribute events to other nodes in a clustered environment (unless you "
"subscribe a Remote Actor to the stream explicitly). If you need to broadcast"
" events in an Akka cluster, *without* knowing your recipients explicitly "
"(i.e. obtaining their ActorRefs), you may want to look into: :ref"
":`distributed-pub-sub-java`."
msgstr ""

# 273cf1dff4b64cfeaf89a73857b45613
#: ../../java/event-bus.rst:164
msgid "Default Handlers"
msgstr ""

# 443f866a9806471a8cbc38cbc6ba3899
#: ../../java/event-bus.rst:166
msgid ""
"Upon start-up the actor system creates and subscribes actors to the event "
"stream for logging: these are the handlers which are configured for example "
"in ``application.conf``:"
msgstr ""

# 5754041ad87b4b14b115bfc4cfcb5755
#: ../../java/event-bus.rst:176
msgid ""
"The handlers listed here by fully-qualified class name will be subscribed to"
" all log event classes with priority higher than or equal to the configured "
"log-level and their subscriptions are kept in sync when changing the log-"
"level at runtime::"
msgstr ""

# e1c0f6c67a4a48e5ae19f3ce089ec1aa
#: ../../java/event-bus.rst:183
msgid ""
"This means that log events for a level which will not be logged are "
"typically not dispatched at all (unless manual subscriptions to the "
"respective event class have been done)"
msgstr ""

# a761275517934a17b3d987506c290841
#: ../../java/event-bus.rst:188
msgid "Dead Letters"
msgstr ""

# a230b37375444c209cb7ed1a81eac7ab
#: ../../java/event-bus.rst:190
msgid ""
"As described at :ref:`stopping-actors-java`, messages queued when an actor "
"terminates or sent after its death are re-routed to the dead letter mailbox,"
" which by default will publish the messages wrapped in :class:`DeadLetter`. "
"This wrapper holds the original sender, receiver and message of the envelope"
" which was redirected."
msgstr ""

# c2078bdc9e704a1e815213ffb819e0a3
#: ../../java/event-bus.rst:196
msgid ""
"Some internal messages (marked with the :class:`DeadLetterSuppression` "
"trait) will not end up as dead letters like normal messages. These are by "
"design safe and expected to sometimes arrive at a terminated actor and since"
" they are nothing to worry about, they are suppressed from the default dead "
"letters logging mechanism."
msgstr ""

# 77f391436c2c47669f9dd1aa73afb360
#: ../../java/event-bus.rst:200
msgid ""
"However, in case you find yourself in need of debugging these kinds of low "
"level suppressed dead letters, it's still possible to subscribe to them "
"explicitly:"
msgstr ""

# e0df937c51764e9bbafad543a4b5462a
#: ../../java/event-bus.rst:205
msgid "or all dead letters (including the suppressed ones):"
msgstr ""

# 504077947a1843adb6f6aa51cae9ce02
#: ../../java/event-bus.rst:210
msgid "Other Uses"
msgstr ""

# d96252677b684b849f3baaa9b8fef9e3
#: ../../java/event-bus.rst:212
msgid ""
"The event stream is always there and ready to be used, just publish your own"
" events (it accepts ``Object``) and subscribe listeners to the corresponding"
" JVM classes."
msgstr ""

# d816b7a0a81f4954a83ca8eebf9a9b61
#: ../../java/extending-akka.rst:5
msgid "Akka Extensions"
msgstr ""

# d3324dade6e04d3c9738c1ee9316c6b6
#: ../../java/extending-akka.rst:8
msgid ""
"If you want to add features to Akka, there is a very elegant, but powerful "
"mechanism for doing so. It's called Akka Extensions and is comprised of 2 "
"basic components: an ``Extension`` and an ``ExtensionId``."
msgstr ""

# 97ea90e3fbcc4de0a2dfec86a36637a1
#: ../../java/extending-akka.rst:11
msgid ""
"Extensions will only be loaded once per ``ActorSystem``, which will be "
"managed by Akka. You can choose to have your Extension loaded on-demand or "
"at ``ActorSystem`` creation time through the Akka configuration. Details on "
"how to make that happens are below, in the \"Loading from Configuration\" "
"section."
msgstr ""

# 16ad4d96a22144cb8ccbdba45b97057e
#: ../../java/extending-akka.rst:17
msgid ""
"Since an extension is a way to hook into Akka itself, the implementor of the"
" extension needs to ensure the thread safety of his/her extension."
msgstr ""

# d356791000bb4a0d9894f0a667b83c7d
#: ../../java/extending-akka.rst:22
msgid "Building an Extension"
msgstr ""

# ba961b1343ee43658eca59e1e4eef00b
#: ../../java/extending-akka.rst:24
msgid ""
"So let's create a sample extension that just lets us count the number of "
"times something has happened."
msgstr ""

# 6ee9efccd8a74bc2a16eac13905d4c11
#: ../../java/extending-akka.rst:26
msgid "First, we define what our ``Extension`` should do:"
msgstr ""

# ec3b778729f143eb9a0036a2e4024107
#: ../../java/extending-akka.rst:34
msgid ""
"Then we need to create an ``ExtensionId`` for our extension so we can grab a"
" hold of it."
msgstr ""

# 219e7de878ea414584c0707705805f38
#: ../../java/extending-akka.rst:42
msgid "Wicked! Now all we need to do is to actually use it:"
msgstr ""

# 8fb548e1ea5445ff9d764d7e764ff0f6
#: ../../java/extending-akka.rst:47
msgid "Or from inside of an Akka Actor:"
msgstr ""

# 1f94178a1af44226b5a91f6e9002dd5f
#: ../../java/extending-akka.rst:52
msgid "That's all there is to it!"
msgstr ""

# 092bb8d4da374bab96f3aba1fcfa90fe
#: ../../java/extending-akka.rst:55
msgid "Loading from Configuration"
msgstr ""

# 350f8ccac857464db8f3392229d203e2
#: ../../java/extending-akka.rst:57
msgid ""
"To be able to load extensions from your Akka configuration you must add "
"FQCNs of implementations of either ``ExtensionId`` or "
"``ExtensionIdProvider`` in the \"akka.extensions\" section of the config you"
" provide to your ``ActorSystem``."
msgstr ""

# 3460be4bfc5a403b945e2cff084540a1
#: ../../java/extending-akka.rst:67
msgid "Applicability"
msgstr ""

# 902e7ddfbc724f63b49ae9fc0b9058c5
#: ../../java/extending-akka.rst:69
msgid ""
"The sky is the limit! By the way, did you know that Akka's ``Typed Actors``,"
" ``Serialization`` and other features are implemented as Akka Extensions?"
msgstr ""

# 881ba091a33541bf90f55783ec885be8
#: ../../java/extending-akka.rst:75
msgid "Application specific settings"
msgstr ""

# 20a59af61ab04e9fab53b24f499c28c9
#: ../../java/extending-akka.rst:77
msgid ""
"The :ref:`configuration` can be used for application specific settings. A "
"good practice is to place those settings in an Extension."
msgstr ""

# 9517a9df1e174ceb8ec07ed2378cd815
#: ../../java/extending-akka.rst:79
msgid "Sample configuration:"
msgstr ""

# 3bcbf0a02a94478693a0cf5fd8432483
#: ../../java/extending-akka.rst:84
msgid "The ``Extension``:"
msgstr ""

# 49e0a541a6ab417bb21fc4923271efe3
#: ../../java/extending-akka.rst:92
msgid "Use it:"
msgstr ""

# 44144bfeccc945cdadf7ba8af6d28201
#: ../../java/extending-akka.rst:98
msgid "Library extensions"
msgstr ""

# dfe9731f08334b60a754485391d61c8a
#: ../../java/extending-akka.rst:99
msgid ""
"A third part library may register it's extension for auto-loading on actor "
"system startup by appending it to ``akka.library-extensions`` in its "
"``reference.conf``."
msgstr ""

# 747b4888c2e2404cb8bf183b3664b789
#: ../../java/extending-akka.rst:107
msgid ""
"As there is no way to selectively remove such extensions, it should be used "
"with care and only when there is no case where the user would ever want it "
"disabled or have specific support for disabling such sub-features. One "
"example where this could be important is in tests."
msgstr ""

# 5fdb7c2ab02c4d3a89274dff52ddd84b
#: ../../java/extending-akka.rst:112
msgid ""
"The``akka.library-extensions`` must never be assigned (``= "
"[\"Extension\"]``) instead of appending as this will break the library-"
"extension mechanism and make behavior depend on class path ordering."
msgstr ""

# d22635a3d2ac408aa20485efc577f9b3
#: ../../java/fault-tolerance.rst:4
msgid "Fault Tolerance"
msgstr "耐障害性"

# e5c6f8ac3cfe45d98706534ff3fca5d0
# 264bf1c841c04719ad7036eadeaf8c71
#: ../../java/fault-tolerance.rst:6 ../../java/lambda-fault-tolerance.rst:6
msgid ""
"As explained in :ref:`actor-systems` each actor is the supervisor of its "
"children, and as such each actor defines fault handling supervisor strategy."
" This strategy cannot be changed afterwards as it is an integral part of the"
" actor system’s structure."
msgstr ""

# 42d5e806dd134b7dad083d7cc67c1ab3
# e247f29ff921467db192069cfc558449
#: ../../java/fault-tolerance.rst:12 ../../java/lambda-fault-tolerance.rst:12
msgid "Fault Handling in Practice"
msgstr ""

# cba8ef3f5c8b42928ea39cdd1a44d3bc
# 28ca02351b7e47e98dfaf8cfeb3ee24c
#: ../../java/fault-tolerance.rst:14 ../../java/lambda-fault-tolerance.rst:14
msgid ""
"First, let us look at a sample that illustrates one way to handle data store"
" errors, which is a typical source of failure in real world applications. Of"
" course it depends on the actual application what is possible to do when the"
" data store is unavailable, but in this sample we use a best effort re-"
"connect approach."
msgstr ""

# e8d6e0a720fe4279b471c7ac4a1de4a6
#: ../../java/fault-tolerance.rst:19
msgid ""
"Read the following source code. The inlined comments explain the different "
"pieces of the fault handling and why they are added. It is also highly "
"recommended to run this sample as it is easy to follow the log output to "
"understand what is happening at runtime."
msgstr ""

# bde6cb230a594d44908f819dc922d5fc
# d379eed00a254986be1a0629aa7c27e5
#: ../../java/fault-tolerance.rst:28 ../../java/lambda-fault-tolerance.rst:28
msgid "Creating a Supervisor Strategy"
msgstr ""

# 449793c0ee62450b84efc35a28c63a98
# 32ade73f3ea742a58643dac7d332724a
#: ../../java/fault-tolerance.rst:30 ../../java/lambda-fault-tolerance.rst:30
msgid ""
"The following sections explain the fault handling mechanism and alternatives"
" in more depth."
msgstr ""

# 7e1659aaf39d406d8309ef275d54e157
# ca589fa7d584481d94b73b4ffaaf945c
#: ../../java/fault-tolerance.rst:33 ../../java/lambda-fault-tolerance.rst:33
msgid "For the sake of demonstration let us consider the following strategy:"
msgstr ""

# a9ab02f7c1284efd9049390dd591894b
# dc8e72557f1543d791c8ab002b811f40
#: ../../java/fault-tolerance.rst:38 ../../java/lambda-fault-tolerance.rst:38
msgid ""
"I have chosen a few well-known exception types in order to demonstrate the "
"application of the fault handling directives described in "
":ref:`supervision`. First off, it is a one-for-one strategy, meaning that "
"each child is treated separately (an all-for-one strategy works very "
"similarly, the only difference is that any decision is applied to all "
"children of the supervisor, not only the failing one). There are limits set "
"on the restart frequency, namely maximum 10 restarts per minute. ``-1`` and "
"``Duration.Inf()`` means that the respective limit does not apply, leaving "
"the possibility to specify an absolute upper limit on the restarts or to "
"make the restarts work infinitely. The child actor is stopped if the limit "
"is exceeded."
msgstr ""

# c7d5c57ef8324db0bfa0eb054a0d02ce
# d669b0a930e048898ae6b415a38bfe01
#: ../../java/fault-tolerance.rst:51 ../../java/lambda-fault-tolerance.rst:51
msgid ""
"If the strategy is declared inside the supervising actor (as opposed to a "
"separate class) its decider has access to all internal state of the actor in"
" a thread-safe fashion, including obtaining a reference to the currently "
"failed child (available as the ``getSender`` of the failure message)."
msgstr ""

# bae27ba4609d4625a04baf040bccc49f
# 6fe697d06b314d098c3e537faf30fa8e
#: ../../java/fault-tolerance.rst:57 ../../java/lambda-fault-tolerance.rst:57
msgid "Default Supervisor Strategy"
msgstr ""

# 1000146093f046c8864de8fcf8ffeab8
# 12f113f06ec64f338c7cc8beaba839d5
#: ../../java/fault-tolerance.rst:59 ../../java/lambda-fault-tolerance.rst:59
msgid ""
"``Escalate`` is used if the defined strategy doesn't cover the exception "
"that was thrown."
msgstr ""

# 2ce209c3babc4fd9aaa3648c7a6d4deb
# 522c8b84aca240d1bf66a1aef98fedae
#: ../../java/fault-tolerance.rst:61 ../../java/lambda-fault-tolerance.rst:61
msgid ""
"When the supervisor strategy is not defined for an actor the following "
"exceptions are handled by default:"
msgstr ""

# 158ac0af7ab54ce5bf8b2d1c5eac68c1
# 558746a1571946b3afcba6560ed3b278
#: ../../java/fault-tolerance.rst:64 ../../java/lambda-fault-tolerance.rst:64
msgid "``ActorInitializationException`` will stop the failing child actor"
msgstr ""

# eb251dbdb16547e5b5684f9999cd8278
# 25b61e4f87424b5b974d861ca795f619
#: ../../java/fault-tolerance.rst:65 ../../java/lambda-fault-tolerance.rst:65
msgid "``ActorKilledException`` will stop the failing child actor"
msgstr ""

# 159b60b74868421483dc8a50f16a1ac3
# 94ad912d524f4e05802ddce67951ad1d
#: ../../java/fault-tolerance.rst:66 ../../java/lambda-fault-tolerance.rst:66
msgid "``Exception`` will restart the failing child actor"
msgstr ""

# f26ffd5b87bc4535891d4ef79896dab0
# 611e7aa4fe814a079ea142d8c7eb1219
#: ../../java/fault-tolerance.rst:67 ../../java/lambda-fault-tolerance.rst:67
msgid "Other types of ``Throwable`` will be escalated to parent actor"
msgstr ""

# 843e978b81e3427c935794b0ea367305
# 9fc27bf7321b44febfd2ce9a119e841c
#: ../../java/fault-tolerance.rst:69 ../../java/lambda-fault-tolerance.rst:69
msgid ""
"If the exception escalate all the way up to the root guardian it will handle"
" it in the same way as the default strategy defined above."
msgstr ""

# fb7312f148a34e11b42e091b6c10635c
# c981037262614d04b44d70ef058754ac
#: ../../java/fault-tolerance.rst:73 ../../java/lambda-fault-tolerance.rst:73
msgid "Stopping Supervisor Strategy"
msgstr ""

# affb3c10f33747a6818749450e761160
# 578ae155b4b34b65a42a5afc2252fd02
#: ../../java/fault-tolerance.rst:75 ../../java/lambda-fault-tolerance.rst:75
msgid ""
"Closer to the Erlang way is the strategy to just stop children when they "
"fail and then take corrective action in the supervisor when DeathWatch "
"signals the loss of the child. This strategy is also provided pre-packaged "
"as :obj:`SupervisorStrategy.stoppingStrategy` with an accompanying "
":class:`StoppingSupervisorStrategy` configurator to be used when you want "
"the ``\"/user\"`` guardian to apply it."
msgstr ""

# 19fbcdbccc8a4359928f1fcc37ceb24f
# aa78c4c72d764198871a3b8ee1a8b29a
#: ../../java/fault-tolerance.rst:83 ../../java/lambda-fault-tolerance.rst:83
msgid "Logging of Actor Failures"
msgstr ""

# 46ec41df928c45a681876b5bb55ab62b
# c32b10a2910a45f4ab4b8d324484fec0
#: ../../java/fault-tolerance.rst:85 ../../java/lambda-fault-tolerance.rst:85
msgid ""
"By default the ``SupervisorStrategy`` logs failures unless they are "
"escalated. Escalated failures are supposed to be handled, and potentially "
"logged, at a level higher in the hierarchy."
msgstr ""

# de98ffa463954e2ea20ae890d2d0d828
# 58d6264eb1f747c0b4ae4ba2513d513e
#: ../../java/fault-tolerance.rst:89 ../../java/lambda-fault-tolerance.rst:89
msgid ""
"You can mute the default logging of a ``SupervisorStrategy`` by setting "
"``loggingEnabled`` to ``false`` when instantiating it. Customized logging "
"can be done inside the ``Decider``. Note that the reference to the currently"
" failed child is available as the ``getSender`` when the "
"``SupervisorStrategy`` is declared inside the supervising actor."
msgstr ""

# 62b62772c97e46b6870e09129c583ff5
# c30293f45786499287f7d87c9726fa0f
#: ../../java/fault-tolerance.rst:95 ../../java/lambda-fault-tolerance.rst:95
msgid ""
"You may also customize the logging in your own ``SupervisorStrategy`` "
"implementation by overriding the ``logFailure`` method."
msgstr ""

# 1a49ba34696340a6bedaef357bde4cf7
# f69ceea93eb2442183f984a436bfefcf
#: ../../java/fault-tolerance.rst:99 ../../java/lambda-fault-tolerance.rst:99
msgid "Supervision of Top-Level Actors"
msgstr ""

# af0134ccc5e746f7b560a3c3735db0e4
# a51a763130a34f99b9ed792ec1c19723
#: ../../java/fault-tolerance.rst:101
#: ../../java/lambda-fault-tolerance.rst:101
msgid ""
"Toplevel actors means those which are created using ``system.actorOf()``, "
"and they are children of the :ref:`User Guardian <user-guardian>`. There are"
" no special rules applied in this case, the guardian simply applies the "
"configured strategy."
msgstr ""

# 99cb74ca865941d890004377abb4993f
# 5f5b274569a94e76984531b66845f657
#: ../../java/fault-tolerance.rst:107
#: ../../java/lambda-fault-tolerance.rst:107
msgid "Test Application"
msgstr ""

# 5403ab53d1f34d448f5dae48d6959a2e
# 56c5ca84a3b74c9dafead585e20c8aea
#: ../../java/fault-tolerance.rst:109
#: ../../java/lambda-fault-tolerance.rst:109
msgid ""
"The following section shows the effects of the different directives in "
"practice, where a test setup is needed. First off, we need a suitable "
"supervisor:"
msgstr ""

# aa024cf6654a4043a76fc79180bda6e1
# 669a48ffae024c2f9ae75ce957e83d7c
#: ../../java/fault-tolerance.rst:115
#: ../../java/lambda-fault-tolerance.rst:115
msgid ""
"This supervisor will be used to create a child, with which we can "
"experiment:"
msgstr ""

# 3173f935b022439892b21ff5b669f94d
# 924021c9de7f4bb196e793a1eba905f8
#: ../../java/fault-tolerance.rst:120
#: ../../java/lambda-fault-tolerance.rst:120
msgid ""
"The test is easier by using the utilities described in :ref:`akka-testkit`, "
"where ``TestProbe`` provides an actor ref useful for receiving and "
"inspecting replies."
msgstr ""

# eaea902677a44093af1ac5a6df476426
# a8c43a12bd3249e29722512272c8cd20
#: ../../java/fault-tolerance.rst:126
#: ../../java/lambda-fault-tolerance.rst:126
msgid "Let us create actors:"
msgstr ""

# 16fc1da88f1f43509d3b05d821e2aa1d
# b30595532f4146c6afdb2fd5bd633873
#: ../../java/fault-tolerance.rst:131
#: ../../java/lambda-fault-tolerance.rst:131
msgid ""
"The first test shall demonstrate the ``Resume`` directive, so we try it out "
"by setting some non-initial state in the actor and have it fail:"
msgstr ""

# e2192a14478a4ac7a858393308de5f51
# 661654219e8346fb9934c6681b41ab0e
#: ../../java/fault-tolerance.rst:137
#: ../../java/lambda-fault-tolerance.rst:137
msgid ""
"As you can see the value 42 survives the fault handling directive. Now, if "
"we change the failure to a more serious ``NullPointerException``, that will "
"no longer be the case:"
msgstr ""

# 169e7e8e30e94bb6a50b7fd7a0c36704
# 5266372a26754c9195d4f3583fb5465a
#: ../../java/fault-tolerance.rst:144
#: ../../java/lambda-fault-tolerance.rst:144
msgid ""
"And finally in case of the fatal ``IllegalArgumentException`` the child will"
" be terminated by the supervisor:"
msgstr ""

# 703c564f0e034561839e5d98a7012d18
# 3880c3ca23e84c799fa373c2e00a0695
#: ../../java/fault-tolerance.rst:150
#: ../../java/lambda-fault-tolerance.rst:150
msgid ""
"Up to now the supervisor was completely unaffected by the child’s failure, "
"because the directives set did handle it. In case of an ``Exception``, this "
"is not true anymore and the supervisor escalates the failure."
msgstr ""

# 850dad95724842d1a6be1d764c415af4
# 26c908222a8f447ebb001e0bbb2db2bd
#: ../../java/fault-tolerance.rst:157
#: ../../java/lambda-fault-tolerance.rst:157
msgid ""
"The supervisor itself is supervised by the top-level actor provided by the "
":class:`ActorSystem`, which has the default policy to restart in case of all"
" ``Exception`` cases (with the notable exceptions of "
"``ActorInitializationException`` and ``ActorKilledException``). Since the "
"default directive in case of a restart is to kill all children, we expected "
"our poor child not to survive this failure."
msgstr ""

# ce2a8c6050a54032920be34e9373272f
# a7e6a40e9abd445eb04420a824a512d4
#: ../../java/fault-tolerance.rst:164
#: ../../java/lambda-fault-tolerance.rst:164
msgid ""
"In case this is not desired (which depends on the use case), we need to use "
"a different supervisor which overrides this behavior."
msgstr ""

# 95200cec9ce145a8b8d96bcef2276d30
# b60b08e5e5f9440786d78316f3fa4bb9
#: ../../java/fault-tolerance.rst:170
#: ../../java/lambda-fault-tolerance.rst:170
msgid ""
"With this parent, the child survives the escalated restart, as demonstrated "
"in the last test:"
msgstr ""

# 61c3e2275a5e4d5b921cb7cbb13d33e1
# f8c5a89c4cec487787c45dec668a20e2
#: ../../java/fault-tolerance-sample.rst:4
#: ../../java/lambda-fault-tolerance-sample.rst:4
msgid "Diagrams of the Fault Tolerance Sample"
msgstr ""

# 89fcb306633a4f16a4c267e44769f2d4
# a81a478f98be4b22a73ac784cdfaf29e
#: ../../java/fault-tolerance-sample.rst:8
#: ../../java/lambda-fault-tolerance-sample.rst:8
msgid "*The above diagram illustrates the normal message flow.*"
msgstr ""

# 68f8823563b14b7db6d77a1881ef55de
# b0ab1cf6d0d54db4a03dda92db8c87c6
#: ../../java/fault-tolerance-sample.rst:10
#: ../../java/lambda-fault-tolerance-sample.rst:10
msgid "**Normal flow:**"
msgstr ""

# af83e91f4b6e47f5b25ff261b96b068e
# c27c9b9e20d141c28b5373678eb973aa
# d45ad599d56a42fd872354d15e080cfb
# c2690a1cb00749f7a62a5989be123591
#: ../../java/fault-tolerance-sample.rst:13
#: ../../java/fault-tolerance-sample.rst:33
#: ../../java/lambda-fault-tolerance-sample.rst:13
#: ../../java/lambda-fault-tolerance-sample.rst:33
msgid "Step"
msgstr ""

# cae5ca2b571b4872a8c6935f9269b76e
# be158c214a7d4419b44fd70294d3311b
# 92d9556226af4b769d484e00129f2770
# 7f1db94609f645d28abab847e38f4448
#: ../../java/fault-tolerance-sample.rst:15
#: ../../java/fault-tolerance-sample.rst:35
#: ../../java/lambda-fault-tolerance-sample.rst:15
#: ../../java/lambda-fault-tolerance-sample.rst:35
msgid "1"
msgstr ""

# 4826c83403984c9eaa7e2f202801e09f
# 7d436b9fe0c64de3be82d29d7f654dc6
#: ../../java/fault-tolerance-sample.rst:15
#: ../../java/lambda-fault-tolerance-sample.rst:15
msgid "The progress ``Listener`` starts the work."
msgstr ""

# 5ff69f229b594657b81eb9bf89932433
# ea7fd585622846dc936602de26d3844a
# 12466e79667344fe96809f2bb5526deb
# 97d6a1b4c00e4f628112d0f8432ed117
#: ../../java/fault-tolerance-sample.rst:16
#: ../../java/fault-tolerance-sample.rst:36
#: ../../java/lambda-fault-tolerance-sample.rst:16
#: ../../java/lambda-fault-tolerance-sample.rst:36
msgid "2"
msgstr ""

# 5d2f27e0fb3b452bb63c8ba926275967
# 1b9d2c1204f346ff90016a1e506979d2
#: ../../java/fault-tolerance-sample.rst:16
#: ../../java/lambda-fault-tolerance-sample.rst:16
msgid ""
"The ``Worker`` schedules work by sending ``Do`` messages periodically to "
"itself"
msgstr ""

# 724ee28fd71e44debd02481253addb3f
# bd822df15d1647268231b9349a03e434
#: ../../java/fault-tolerance-sample.rst:17
#: ../../java/lambda-fault-tolerance-sample.rst:17
msgid "3, 4, 5"
msgstr ""

# e2c57c1b76484e098b8b17c20d05c52a
# 91d6c120f73547528c64362adc4b97e4
#: ../../java/fault-tolerance-sample.rst:17
#: ../../java/lambda-fault-tolerance-sample.rst:17
msgid ""
"When receiving ``Do`` the ``Worker`` tells the ``CounterService`` to "
"increment the counter, three times. The ``Increment`` message is forwarded "
"to the ``Counter``, which updates its counter variable and sends current "
"value to the ``Storage``."
msgstr ""

# c44c611233724c5ab372a1bb813e61a2
# 6c0b513011984dd8a66e6512ac52a84b
#: ../../java/fault-tolerance-sample.rst:21
#: ../../java/lambda-fault-tolerance-sample.rst:21
msgid "6, 7"
msgstr ""

# eb924a5013f642a39d6b5411a5aaad4f
# 12e38939402a49639ca84a9ae9db832c
#: ../../java/fault-tolerance-sample.rst:21
#: ../../java/lambda-fault-tolerance-sample.rst:21
msgid ""
"The ``Worker`` asks the ``CounterService`` of current value of the counter "
"and pipes the result back to the ``Listener``."
msgstr ""

# bc748f432800436e88ddba0f7929e3a7
# 7c3ebabbab404c109619c1f4b0ae766f
#: ../../java/fault-tolerance-sample.rst:28
#: ../../java/lambda-fault-tolerance-sample.rst:28
msgid ""
"*The above diagram illustrates what happens in case of storage failure.*"
msgstr ""

# a6577c188cc84ef8bf0992324edb9eff
# 64718985081e454a93fb9982a9ceeecd
#: ../../java/fault-tolerance-sample.rst:30
#: ../../java/lambda-fault-tolerance-sample.rst:30
msgid "**Failure flow:**"
msgstr ""

# 528b120b87124b1fb0f9799d6fcc4d3a
# 657f1d6fdd2d4c80851dcc8d365fae2a
#: ../../java/fault-tolerance-sample.rst:35
#: ../../java/lambda-fault-tolerance-sample.rst:35
msgid "The ``Storage`` throws ``StorageException``."
msgstr ""

# 061ecce10ec746b0b0c944e29db29a70
# 84b149af4ebb4b4baf6f38a1818aa45c
#: ../../java/fault-tolerance-sample.rst:36
#: ../../java/lambda-fault-tolerance-sample.rst:36
msgid ""
"The ``CounterService`` is supervisor of the ``Storage`` and restarts the "
"``Storage`` when ``StorageException`` is thrown."
msgstr ""

# e2ba8b7f903540189da1475aec4fd355
# 7641f8d3b3734429b6bed0fcc91ea543
#: ../../java/fault-tolerance-sample.rst:38
#: ../../java/lambda-fault-tolerance-sample.rst:38
msgid "3, 4, 5, 6"
msgstr ""

# dadee90c265d4e348d7a5ea8f91ab559
# 03419586e23b4255a520d2dd207dabb3
#: ../../java/fault-tolerance-sample.rst:38
#: ../../java/lambda-fault-tolerance-sample.rst:38
msgid "The ``Storage`` continues to fail and is restarted."
msgstr ""

# 10dd0b74963243a99b466f69cf421c01
# 6813298bc8a641f7bd87e0bebbe34ae7
#: ../../java/fault-tolerance-sample.rst:39
#: ../../java/lambda-fault-tolerance-sample.rst:39
msgid "7"
msgstr ""

# 0ba9c4e581e4400d813c0ed291ae9236
# 6bf477c43d264b228313f24ee2d76d00
#: ../../java/fault-tolerance-sample.rst:39
#: ../../java/lambda-fault-tolerance-sample.rst:39
msgid ""
"After 3 failures and restarts within 5 seconds the ``Storage`` is stopped by"
" its supervisor, i.e. the ``CounterService``."
msgstr ""

# 4a00a1a33252462c8e3c597edc6f5ae0
# 2e8ae548c29f4446a85714b1fb295d4f
#: ../../java/fault-tolerance-sample.rst:41
#: ../../java/lambda-fault-tolerance-sample.rst:41
msgid "8"
msgstr ""

# c457888f75d046f7bb682b25a903357c
# 6f260a59e0cb429e928abd37599f5df5
#: ../../java/fault-tolerance-sample.rst:41
#: ../../java/lambda-fault-tolerance-sample.rst:41
msgid ""
"The ``CounterService`` is also watching the ``Storage`` for termination and "
"receives the ``Terminated`` message when the ``Storage`` has been stopped "
"..."
msgstr ""

# 752b365073034e1e812bb973101e757a
# 0cf76da064a94f4b8f22f9dac5ce6b0b
#: ../../java/fault-tolerance-sample.rst:43
#: ../../java/lambda-fault-tolerance-sample.rst:43
msgid "9, 10, 11"
msgstr ""

# 914863311f2e4d88aafcd27bf09ecfbc
# e891503ddff4470d9d1f78ad9b76a25e
#: ../../java/fault-tolerance-sample.rst:43
#: ../../java/lambda-fault-tolerance-sample.rst:43
msgid "and tells the ``Counter`` that there is no ``Storage``."
msgstr ""

# d189ccfccf0e4f5fb472999162ea5602
# d0076414c6ef476bb3fdae0b1115ceba
#: ../../java/fault-tolerance-sample.rst:44
#: ../../java/lambda-fault-tolerance-sample.rst:44
msgid "12"
msgstr ""

# 8acc4f223fc54d46a25d8b9c464df1a1
# dc30a53e1d124da2bfbad5e5b5f445f8
#: ../../java/fault-tolerance-sample.rst:44
#: ../../java/lambda-fault-tolerance-sample.rst:44
msgid "The ``CounterService`` schedules a ``Reconnect`` message to itself."
msgstr ""

# 76d3805bd0f54c40b72566bf48c83f7a
# b0da956dfcc346e6ae01490863db8a90
#: ../../java/fault-tolerance-sample.rst:45
#: ../../java/lambda-fault-tolerance-sample.rst:45
msgid "13, 14"
msgstr ""

# 70e3c73f3b1343719f3f4aa91d4204e3
# 186c3f3965b14a16ab90fe0c5382e6c3
#: ../../java/fault-tolerance-sample.rst:45
#: ../../java/lambda-fault-tolerance-sample.rst:45
msgid ""
"When it receives the ``Reconnect`` message it creates a new ``Storage`` ..."
msgstr ""

# 52548e1446714defabd7dd42fca60a36
# dc17ab6475ea4506b66bc838e0e51eae
#: ../../java/fault-tolerance-sample.rst:46
#: ../../java/lambda-fault-tolerance-sample.rst:46
msgid "15, 16"
msgstr ""

# 9f5dfc2c95ff4a17b12033eb564f576d
# cac83642dd904184af39e11af1cc450b
#: ../../java/fault-tolerance-sample.rst:46
#: ../../java/lambda-fault-tolerance-sample.rst:46
msgid "and tells the ``Counter`` to use the new ``Storage``"
msgstr ""

# c8d3c57076a04ef798ae01b747715b94
# 0c59babc474e4d62b6353c84449d015c
#: ../../java/fault-tolerance-sample.rst:50
#: ../../java/lambda-fault-tolerance-sample.rst:50
msgid "Full Source Code of the Fault Tolerance Sample"
msgstr ""

# 5cb749ea3ce548fbbaf90d1b6c95d27c
#: ../../java/fsm.rst:5
msgid "Building Finite State Machine Actors"
msgstr ""

# e0c195f366d340fdbcc8f748c8fcc37b
# 9e80dd0d1d0f4d8a908ecacfb220693e
# 12acf29ca1674de985d635b013dbcbdc
#: ../../java/fsm.rst:9 ../../java/http/http-model.rst:11
#: ../../java/lambda-fsm.rst:9
msgid "Overview"
msgstr ""

# a3c1f6b9df104d3ca7050b9a73aa8e14
#: ../../java/fsm.rst:11
msgid ""
"The FSM (Finite State Machine) pattern is best described in the `Erlang "
"design principles "
"<http://www.erlang.org/documentation/doc-4.8.2/doc/design_principles/fsm.html>`_."
" In short, it can be seen as a set of relations of the form:"
msgstr ""

# 87e6fa6086a147ed853eae33fc7c6607
# 9a8914b5695e465d995608606d11d668
#: ../../java/fsm.rst:16 ../../java/lambda-fsm.rst:17
msgid "**State(S) x Event(E) -> Actions (A), State(S')**"
msgstr ""

# a0a614ea4bf144a0a58027782e10c10f
# 9988329ded1c4bf0831267e6a2a93025
#: ../../java/fsm.rst:18 ../../java/lambda-fsm.rst:19
msgid "These relations are interpreted as meaning:"
msgstr ""

# 519742343e784062ae90ac9089746906
# 9395e8b9c7ae4709ac991f6f1c70711d
#: ../../java/fsm.rst:20 ../../java/lambda-fsm.rst:21
msgid ""
"*If we are in state S and the event E occurs, we should perform the actions "
"A and make a transition to the state S'.*"
msgstr ""

# 77429f0ce89c4f67bff4b71c1449ce6a
#: ../../java/fsm.rst:23
msgid ""
"While the Scala programming language enables the formulation of a nice "
"internal DSL (domain specific language) for formulating finite state "
"machines (see :ref:`fsm-scala`), Java’s verbosity does not lend itself well "
"to the same approach. This chapter describes ways to effectively achieve the"
" same separation of concerns through self-discipline."
msgstr ""

# 00bc1516091b448a8ab69065d61457c5
#: ../../java/fsm.rst:30
msgid "How State should be Handled"
msgstr ""

# 115cde206f9c41798d7b25fff15c114f
#: ../../java/fsm.rst:32
msgid ""
"All mutable fields (or transitively mutable data structures) referenced by "
"the FSM actor’s implementation should be collected in one place and only "
"mutated using a small well-defined set of methods. One way to achieve this "
"is to assemble all mutable state in a superclass which keeps it private and "
"offers protected methods for mutating it."
msgstr ""

# 914474340fd64634a128e718885f7c7b
#: ../../java/fsm.rst:42
msgid ""
"The benefit of this approach is that state changes can be acted upon in one "
"central place, which makes it impossible to forget inserting code for "
"reacting to state transitions when adding to the FSM’s machinery."
msgstr ""

# ac208799fac0480a882120c760936a24
#: ../../java/fsm.rst:47
msgid "Message Buncher Example"
msgstr ""

# 9ac5c1dce4304047b19d82d0ac80cbc9
#: ../../java/fsm.rst:49
msgid ""
"The base class shown above is designed to support a similar example as for "
"the Scala FSM documentation: an actor which receives and queues messages, to"
" be delivered in batches to a configurable target actor. The messages "
"involved are:"
msgstr ""

# ab1321f7c5fb405b9f0878561e35e9d5
#: ../../java/fsm.rst:55
msgid ""
"This actor has only the two states ``IDLE`` and ``ACTIVE``, making their "
"handling quite straight-forward in the concrete actor derived from the base "
"class:"
msgstr ""

# 21106fa76adf4726be7f33956c30e319
#: ../../java/fsm.rst:63
msgid ""
"The trick here is to factor out common functionality like "
":meth:`whenUnhandled` and :meth:`transition` in order to obtain a few well-"
"defined points for reacting to change or insert logging."
msgstr ""

# 0bb025128af6423badee8b93ee157ebc
#: ../../java/fsm.rst:68
msgid "State-Centric vs. Event-Centric"
msgstr ""

# 083248fca3b246a2b4200ffc7ae70bdf
#: ../../java/fsm.rst:70
msgid ""
"In the example above, the subjective complexity of state and events was "
"roughly equal, making it a matter of taste whether to choose primary "
"dispatch on either; in the example a state-based dispatch was chosen. "
"Depending on how evenly the matrix of possible states and events is "
"populated, it may be more practical to handle different events first and "
"distinguish the states in the second tier. An example would be a state "
"machine which has a multitude of internal states but handles only very few "
"distinct events."
msgstr ""

# 5da792d0fe8347f593c8c5160109a40a
#: ../../java/futures.rst:4
msgid "Futures"
msgstr ""

# b475c90c97124d3f976122a81ade7b6c
#: ../../java/futures.rst:9
msgid ""
"In the Scala Standard Library, a `Future "
"<http://en.wikipedia.org/wiki/Futures_and_promises>`_ is a data structure "
"used to retrieve the result of some concurrent operation. This result can be"
" accessed synchronously (blocking) or asynchronously (non-blocking). To be "
"able to use this from Java, Akka provides a java friendly interface in "
"``akka.dispatch.Futures``."
msgstr ""

# ba282a3f90f04c9c82c4fbae989e8ce0
#: ../../java/futures.rst:14
msgid "See also :ref:`actor-java-lambda` for Java compatibility."
msgstr ""

# fac55572583b4fe3ba288e1a28dffcfe
#: ../../java/futures.rst:17
msgid "Execution Contexts"
msgstr ""

# 35dc8a4964934c2ab1d48ef21b362f6e
#: ../../java/futures.rst:19
msgid ""
"In order to execute callbacks and operations, Futures need something called "
"an ``ExecutionContext``, which is very similar to a "
"``java.util.concurrent.Executor``. if you have an ``ActorSystem`` in scope, "
"it will use its default dispatcher as the ``ExecutionContext``, or you can "
"use the factory methods provided by the ``ExecutionContexts`` class to wrap "
"``Executors`` and ``ExecutorServices``, or even create your own."
msgstr ""

# 62796faa81064fff8b966447a1693128
#: ../../java/futures.rst:31
msgid "Use with Actors"
msgstr ""

# 949ac353af8644a5abd8b2545a453592
#: ../../java/futures.rst:33
msgid ""
"There are generally two ways of getting a reply from an ``UntypedActor``: "
"the first is by a sent message (``actorRef.tell(msg, sender)``), which only "
"works if the original sender was an ``UntypedActor``) and the second is "
"through a ``Future``."
msgstr ""

# 87893915f9b440408cb42c9e4654a768
#: ../../java/futures.rst:36
msgid ""
"Using the ``ActorRef``\\'s ``ask`` method to send a message will return a "
"``Future``. To wait for and retrieve the actual result the simplest method "
"is:"
msgstr ""

# 2103c2972ac84d5187e817ffa6aa3b8c
#: ../../java/futures.rst:45
msgid ""
"This will cause the current thread to block and wait for the "
"``UntypedActor`` to 'complete' the ``Future`` with it's reply. Blocking is "
"discouraged though as it can cause performance problem. The blocking "
"operations are located in ``Await.result`` and ``Await.ready`` to make it "
"easy to spot where blocking occurs. Alternatives to blocking are discussed "
"further within this documentation. Also note that the ``Future`` returned by"
" an ``UntypedActor`` is a ``Future<Object>`` since an ``UntypedActor`` is "
"dynamic. That is why the cast to ``String`` is used in the above sample."
msgstr ""

# 4416da08afcb413ea9e72f9ad3cda765
#: ../../java/futures.rst:54
msgid ""
"``Await.result`` and ``Await.ready`` are provided for exceptional situations"
" where you **must** block, a good rule of thumb is to only use them if you "
"know why you **must** block. For all other cases, use asynchronous "
"composition as described below."
msgstr ""

# 50b40316d7784dab922198b6057278bd
#: ../../java/futures.rst:58
msgid ""
"To send the result of a ``Future`` to an ``Actor``, you can use the ``pipe``"
" construct:"
msgstr ""

# a872b4cdcff54f37bceb116a9993688e
#: ../../java/futures.rst:64
msgid "Use Directly"
msgstr ""

# bceadcdea87b4e6295250e678d0cb661
#: ../../java/futures.rst:66
msgid ""
"A common use case within Akka is to have some computation performed "
"concurrently without needing the extra utility of an ``UntypedActor``. If "
"you find yourself creating a pool of ``UntypedActor``\\s for the sole reason"
" of performing a calculation in parallel, there is an easier (and faster) "
"way:"
msgstr ""

# 760502f77b0c4a339070d342425a83d3
#: ../../java/futures.rst:76
msgid ""
"In the above code the block passed to ``future`` will be executed by the "
"default ``Dispatcher``, with the return value of the block used to complete "
"the ``Future`` (in this case, the result would be the string: "
"\"HelloWorld\"). Unlike a ``Future`` that is returned from an "
"``UntypedActor``, this ``Future`` is properly typed, and we also avoid the "
"overhead of managing an ``UntypedActor``."
msgstr ""

# daa95cc9b5ec4d5cafabf483687b0b9f
#: ../../java/futures.rst:81
msgid ""
"You can also create already completed Futures using the ``Futures`` class, "
"which can be either successes:"
msgstr ""

# c8f27ba502044c7c92a3e9e8ab373aec
#: ../../java/futures.rst:86
msgid "Or failures:"
msgstr ""

# c67c95c9d0464718a9c228fdfff928e2
#: ../../java/futures.rst:91
msgid ""
"It is also possible to create an empty ``Promise``, to be filled later, and "
"obtain the corresponding ``Future``:"
msgstr ""

# a1e27ebb38574921a4f2c18225b2c56e
#: ../../java/futures.rst:95
msgid "For these examples ``PrintResult`` is defined as follows:"
msgstr ""

# b5fd28a0f05c4e17b70f99e00750c742
#: ../../java/futures.rst:101
msgid "Functional Futures"
msgstr ""

# e87c0c73e63848958fdd79f73b44923b
#: ../../java/futures.rst:103
msgid ""
"Scala's ``Future`` has several monadic methods that are very similar to the "
"ones used by ``Scala``'s collections. These allow you to create 'pipelines' "
"or 'streams' that the result will travel through."
msgstr ""

# 9b3d93ac095444baa02decd814931a10
#: ../../java/futures.rst:107
msgid "Future is a Monad"
msgstr ""

# 9773ad56cc834329af37ea5805306a09
#: ../../java/futures.rst:109
msgid ""
"The first method for working with ``Future`` functionally is ``map``. This "
"method takes a ``Mapper`` which performs some operation on the result of the"
" ``Future``, and returning a new result. The return value of the ``map`` "
"method is another ``Future`` that will contain the new result:"
msgstr ""

# 49ab4de27a864c998286678bd4856c16
#: ../../java/futures.rst:119
msgid ""
"In this example we are joining two strings together within a ``Future``. "
"Instead of waiting for f1 to complete, we apply our function that calculates"
" the length of the string using the ``map`` method. Now we have a second "
"``Future``, f2, that will eventually contain an ``Integer``. When our "
"original ``Future``, f1, completes, it will also apply our function and "
"complete the second ``Future`` with its result. When we finally ``get`` the "
"result, it will contain the number 10. Our original ``Future`` still "
"contains the string \"HelloWorld\" and is unaffected by the ``map``."
msgstr ""

# 9cf56bb641944d3fa3711f905fa9a744
#: ../../java/futures.rst:126
msgid ""
"Something to note when using these methods: passed work is always dispatched"
" on the provided ``ExecutionContext``. Even if the ``Future`` has already "
"been completed, when one of these methods is called."
msgstr ""

# 5b562ff76eda4f8f8286947821d1679e
#: ../../java/futures.rst:130
msgid "Composing Futures"
msgstr ""

# d83d2babafcf43c7ad69e90df779040e
#: ../../java/futures.rst:132
msgid ""
"It is very often desirable to be able to combine different Futures with each"
" other, below are some examples on how that can be done in a non-blocking "
"fashion."
msgstr ""

# 272190ed9e7a4c23855fc6fe7ebe5070
#: ../../java/futures.rst:141
msgid ""
"To better explain what happened in the example, ``Future.sequence`` is "
"taking the ``Iterable<Future<Integer>>`` and turning it into a "
"``Future<Iterable<Integer>>``. We can then use ``map`` to work with the "
"``Iterable<Integer>`` directly, and we aggregate the sum of the "
"``Iterable``."
msgstr ""

# fefc529dc7e84a2a9f3e765974752b54
#: ../../java/futures.rst:145
msgid ""
"The ``traverse`` method is similar to ``sequence``, but it takes a sequence "
"of ``A`` and applies a function from ``A`` to ``Future<B>`` and returns a "
"``Future<Iterable<B>>``, enabling parallel ``map`` over the sequence, if you"
" use ``Futures.future`` to create the ``Future``."
msgstr ""

# dedd60459b23454898b6c1f14294ec8f
#: ../../java/futures.rst:154
msgid "It's as simple as that!"
msgstr ""

# cbb428c9d3a94744adb3dbc05b647073
#: ../../java/futures.rst:156
msgid ""
"Then there's a method that's called ``fold`` that takes a start-value, a "
"sequence of ``Future``:s and a function from the type of the start-value, a "
"timeout, and the type of the futures and returns something with the same "
"type as the start-value, and then applies the function to all elements in "
"the sequence of futures, non-blockingly, the execution will be started when "
"the last of the Futures is completed."
msgstr ""

# 77effab6fcfe4f5d892a227b3439c057
#: ../../java/futures.rst:168
msgid "That's all it takes!"
msgstr ""

# 18af4ae915fc4646afabbc8d20dc2ba8
#: ../../java/futures.rst:171
msgid ""
"If the sequence passed to ``fold`` is empty, it will return the start-value,"
" in the case above, that will be empty String. In some cases you don't have "
"a start-value and you're able to use the value of the first completing "
"``Future`` in the sequence as the start-value, you can use ``reduce``, it "
"works like this:"
msgstr ""

# 13c0b735974b48f68ccb4e5b31fe877a
#: ../../java/futures.rst:181
msgid ""
"Same as with ``fold``, the execution will be started when the last of the "
"Futures is completed, you can also parallelize it by chunking your futures "
"into sub-sequences and reduce them, and then reduce the reduced results "
"again."
msgstr ""

# 0cfdf3a6e25f428a922ebc315830bb20
#: ../../java/futures.rst:184
msgid "This is just a sample of what can be done."
msgstr ""

# c69bdf3b7bc5454c8e0602c017e8cecc
#: ../../java/futures.rst:187
msgid "Callbacks"
msgstr ""

# c6b6f113e60147ae8e35f12d091df1d6
#: ../../java/futures.rst:189
msgid ""
"Sometimes you just want to listen to a ``Future`` being completed, and react"
" to that not by creating a new Future, but by side-effecting. For this Scala"
" supports ``onComplete``, ``onSuccess`` and ``onFailure``, of which the "
"latter two are specializations of the first."
msgstr ""

# baef5d3ec22b40c89a201414dd84215f
#: ../../java/futures.rst:202
msgid "Ordering"
msgstr ""

# 662c60ea5e2c4747b19f2dc474c74cba
#: ../../java/futures.rst:204
msgid ""
"Since callbacks are executed in any order and potentially in parallel, it "
"can be tricky at the times when you need sequential ordering of operations. "
"But there's a solution! And it's name is ``andThen``, and it creates a new "
"``Future`` with the specified callback, a ``Future`` that will have the same"
" result as the ``Future`` it's called on, which allows for ordering like in "
"the following sample:"
msgstr ""

# 993bb4c63a844d97af4c2026af4269eb
#: ../../java/futures.rst:214
msgid "Auxiliary methods"
msgstr ""

# d3082665270a42e5a0ef6a749134b7da
#: ../../java/futures.rst:216
msgid ""
"``Future`` ``fallbackTo`` combines 2 Futures into a new ``Future``, and will"
" hold the successful value of the second ``Future`` if the first ``Future`` "
"fails."
msgstr ""

# 874e6080c4f745f78f51e4acaec246d7
#: ../../java/futures.rst:222
msgid ""
"You can also combine two Futures into a new ``Future`` that will hold a "
"tuple of the two Futures successful results, using the ``zip`` operation."
msgstr ""

# 7040b2d70d2a42a4b2adb4db983383fd
#: ../../java/futures.rst:229
msgid "Exceptions"
msgstr ""

# d98d2f2fb0ef458d8c7c5a23f23330c1
#: ../../java/futures.rst:231
msgid ""
"Since the result of a ``Future`` is created concurrently to the rest of the "
"program, exceptions must be handled differently. It doesn't matter if an "
"``UntypedActor`` or the dispatcher is completing the ``Future``, if an "
"``Exception`` is caught the ``Future`` will contain it instead of a valid "
"result. If a ``Future`` does contain an ``Exception``, calling "
"``Await.result`` will cause it to be thrown again so it can be handled "
"properly."
msgstr ""

# 3a1486c0ce9b4170966ebae381484402
#: ../../java/futures.rst:236
msgid ""
"It is also possible to handle an ``Exception`` by returning a different "
"result. This is done with the ``recover`` method. For example:"
msgstr ""

# 077a72abf364404082d993479b7be3a7
#: ../../java/futures.rst:242
msgid ""
"In this example, if the actor replied with a ``akka.actor.Status.Failure`` "
"containing the ``ArithmeticException``, our ``Future`` would have a result "
"of 0. The ``recover`` method works very similarly to the standard try/catch "
"blocks, so multiple ``Exception``\\s can be handled in this manner, and if "
"an ``Exception`` is not handled this way it will behave as if we hadn't used"
" the ``recover`` method."
msgstr ""

# 00dbfe722ab9494880ec874c5f9aa32f
#: ../../java/futures.rst:247
msgid ""
"You can also use the ``recoverWith`` method, which has the same relationship"
" to ``recover`` as ``flatMap`` has to ``map``, and is use like this:"
msgstr ""

# 55bc7bfbd75f4fc2894f031832faa36a
#: ../../java/futures.rst:254
msgid "After"
msgstr ""

# c1734b3ac679417b9c84233887801c3f
#: ../../java/futures.rst:256
msgid ""
"``akka.pattern.Patterns.after`` makes it easy to complete a ``Future`` with "
"a value or exception after a timeout."
msgstr ""

# 307a7df2924d4704ab4999682527e2db
#: ../../java/hello-world.rst:3
msgid "The Obligatory Hello World"
msgstr "必須のHello World"

# 17dd1f54872c4b5ba707d3284e82564a
#: ../../java/hello-world.rst:5
msgid ""
"The actor based version of the tough problem of printing a well-known "
"greeting to the console is introduced in a `Lightbend Activator "
"<http://www.lightbend.com/platform/getstarted>`_ tutorial named `Akka Main "
"in Java <http://www.lightbend.com/activator/template/akka-sample-main-"
"java>`_."
msgstr ""

# 9b8302bbd217438e8c05e1e8390865ae
#: ../../java/hello-world.rst:9
msgid ""
"The tutorial illustrates the generic launcher class :class:`akka.Main` which"
" expects only one command line argument: the class name of the application’s"
" main actor. This main method will then create the infrastructure needed for"
" running the actors, start the given main actor and arrange for the whole "
"application to shut down once the main actor terminates."
msgstr ""

# 6fdcad325ba14fbea81b1512fea17aa9
#: ../../java/hello-world.rst:15
msgid ""
"There is also another `Lightbend Activator "
"<http://www.lightbend.com/platform/getstarted>`_ tutorial in the same "
"problem domain that is named `Hello Akka! "
"<http://www.lightbend.com/activator/template/hello-akka>`_. It describes the"
" basics of Akka in more depth."
msgstr ""

# 4a42912c3b4d40c5914511d4be4ee781
#: ../../java/howto.rst:5
msgid "HowTo: Common Patterns"
msgstr ""

# cadcc80126cb4a8fb09d0619c563c9fb
#: ../../java/howto.rst:7
msgid ""
"This section lists common actor patterns which have been found to be useful,"
" elegant or instructive. Anything is welcome, example topics being message "
"routing strategies, supervision patterns, restart handling, etc. As a "
"special bonus, additions to this section are marked with the contributor’s "
"name, and it would be nice if every Akka user who finds a recurring pattern "
"in his or her code could share it for the profit of all. Where applicable it"
" might also make sense to add to the ``akka.pattern`` package for creating "
"an `OTP-like library <http://www.erlang.org/doc/man_index.html>`_."
msgstr ""

# 7a1fb4b31c5f46249ebd72eb79f52ab9
#: ../../java/howto.rst:16
msgid ""
"You might find some of the patterns described in the Scala chapter of :ref"
":`howto-scala` useful even though the example code is written in Scala."
msgstr ""

# 18437453194a4aceac4ff128bea738e9
#: ../../java/howto.rst:20
msgid "Scheduling Periodic Messages"
msgstr ""

# 01d323a5632c4d49910ed896e6a3690a
#: ../../java/howto.rst:22
msgid ""
"This pattern describes how to schedule periodic messages to yourself in two "
"different ways."
msgstr ""

# 633400adbab740469092eafed0112159
#: ../../java/howto.rst:25
msgid ""
"The first way is to set up periodic message scheduling in the constructor of"
" the actor, and cancel that scheduled sending in ``postStop`` or else we "
"might have multiple registered message sends to the same actor."
msgstr ""

# 1ddde11a9cb44199984a321babd1ff22
#: ../../java/howto.rst:31
msgid ""
"With this approach the scheduled periodic message send will be restarted "
"with the actor on restarts. This also means that the time period that "
"elapses between two tick messages during a restart may drift off based on "
"when you restart the scheduled message sends relative to the time that the "
"last message was sent, and how long the initial delay is. Worst case "
"scenario is ``interval`` plus ``initialDelay``."
msgstr ""

# 649aa83c6a3b475d848ed7dfdaf0ec7e
#: ../../java/howto.rst:38
msgid ""
"The second variant sets up an initial one shot message send in the "
"``preStart`` method of the actor, and the then the actor when it receives "
"this message sets up a new one shot message send. You also have to override "
"``postRestart`` so we don't call ``preStart`` and schedule the initial "
"message send again."
msgstr ""

# 652d3939cb9a425e99d8159faf3999fd
#: ../../java/howto.rst:45
msgid ""
"With this approach we won't fill up the mailbox with tick messages if the "
"actor is under pressure, but only schedule a new tick message when we have "
"seen the previous one."
msgstr ""

# 19eb8e34fb9e4195a6cab123e7e6f607
#: ../../java/howto.rst:51
msgid "Single-Use Actor Trees with High-Level Error Reporting"
msgstr ""

# 02d0c780cf60423f885e02119abcf207
#: ../../java/howto.rst:53
msgid "*Contributed by: Rick Latrine*"
msgstr ""

# 092271381f1247f5992e1dbf0882c484
#: ../../java/howto.rst:55
msgid ""
"A nice way to enter the actor world from java is the use of Patterns.ask(). "
"This method starts a temporary actor to forward the message and collect the "
"result from the actor to be \"asked\". In case of errors within the asked "
"actor the default supervision handling will take over. The caller of "
"Patterns.ask() will *not* be notified."
msgstr ""

# 8a59e445424b49fbbc5582707fdb9bfe
#: ../../java/howto.rst:60
msgid ""
"If that caller is interested in such an exception, they must make sure that "
"the asked actor replies with Status.Failure(Throwable). Behind the asked "
"actor a complex actor hierarchy might be spawned to accomplish asynchronous "
"work. Then supervision is the established way to control error handling."
msgstr ""

# 8c66cc7259a649f3aeddcbac8d394070
#: ../../java/howto.rst:64
msgid ""
"Unfortunately the asked actor must know about supervision and must catch the"
" exceptions. Such an actor is unlikely to be reused in a different actor "
"hierarchy and contains crippled try/catch blocks."
msgstr ""

# 118e924d3dc9441eb02640eed2d5ab53
#: ../../java/howto.rst:67
msgid ""
"This pattern provides a way to encapsulate supervision and error propagation"
" to the temporary actor. Finally the promise returned by Patterns.ask() is "
"fulfilled as a failure, including the exception (see also :ref:`actor-java-"
"lambda` for Java compatibility)."
msgstr ""

# f58f20698be644328d8ab60c0a1f70f7
#: ../../java/howto.rst:71
msgid "Let's have a look at the example code:"
msgstr ""

# 932aed174afe453d905308c326656fef
#: ../../java/howto.rst:75
msgid ""
"In the askOf method the SupervisorCreator is sent the user message. The "
"SupervisorCreator creates a SupervisorActor and forwards the message. This "
"prevents the actor system from overloading due to actor creations. The "
"SupervisorActor is responsible to create the user actor, forwards the "
"message, handles actor termination and supervision. Additionally the "
"SupervisorActor stops the user actor if execution time expired."
msgstr ""

# 0387a98954474f648c5f1d2f1e8634b2
#: ../../java/howto.rst:81
msgid ""
"In case of an exception the supervisor tells the temporary actor which "
"exception was thrown. Afterwards the actor hierarchy is stopped."
msgstr ""

# 9a84615343e547aab70d9c24c9c3a133
#: ../../java/howto.rst:84
msgid ""
"Finally we are able to execute an actor and receive the results or "
"exceptions."
msgstr ""

# 65ad8d1ff90d410b91a9e462940c8f29
#: ../../java/howto.rst:89
msgid "Template Pattern"
msgstr ""

# 3050bc90a30c4933871ae1d6a32b54d5
#: ../../java/howto.rst:91
msgid "*Contributed by: N. N.*"
msgstr ""

# 73b2cebb57bc460baebeae34b4b8ebe2
#: ../../java/howto.rst:93
msgid ""
"This is an especially nice pattern, since it does even come with some empty "
"example code:"
msgstr ""

# b13e5aefdd88405fb3b94b0e52ae837f
#: ../../java/howto.rst:101
msgid "Spread the word: this is the easiest way to get famous!"
msgstr ""

# dc47957b0be04c93ac5f38fd19029b90
#: ../../java/howto.rst:103
msgid "Please keep this pattern at the end of this file."
msgstr ""

# 39ef2c82736e4fbca9b1082c96f9bae0
#: ../../java/http/client-side/client-https-support.rst:4
msgid "Client-Side HTTPS Support"
msgstr ""

# 5a96e25c168847e78bda4af8772fb304
#: ../../java/http/client-side/client-https-support.rst:6
msgid ""
"Akka HTTP supports TLS encryption on the client-side as well as on the :ref"
":`server-side <serverSideHTTPS-java>`."
msgstr ""

# de8db58856b64f158d62a4d438582e03
# f838690cfd79418db16067d5778aa709
#: ../../java/http/client-side/client-https-support.rst:13
#: ../../java/http/server-side-https-support.rst:8
msgid ""
"The central vehicle for configuring encryption is the "
"``HttpsConnectionContext``, which can be created using the static method "
"``ConnectionContext.https`` which is defined like this:"
msgstr ""

# f571836dfd054d428932c4a8c18d3b0c
#: ../../java/http/client-side/client-https-support.rst:19
msgid ""
"In addition to the ``outgoingConnection``, ``newHostConnectionPool`` and "
"``cachedHostConnectionPool`` methods the `akka.http.javadsl.Http`_ extension"
" also defines ``outgoingConnectionTls``, ``newHostConnectionPoolTls`` and "
"``cachedHostConnectionPoolTls``. These methods work identically to their "
"counterparts without the ``-Tls`` suffix, with the exception that all "
"connections will always be encrypted."
msgstr ""

# 1e196030b91d4035a2404a0cd02e16a9
#: ../../java/http/client-side/client-https-support.rst:24
msgid ""
"The ``singleRequest`` and ``superPool`` methods determine the encryption "
"state via the scheme of the incoming request, i.e. requests to an \"https\" "
"URI will be encrypted, while requests to an \"http\" URI won't."
msgstr ""

# 86b137be55824cb4a56bae1e6544eaec
#: ../../java/http/client-side/client-https-support.rst:27
msgid ""
"The encryption configuration for all HTTPS connections, i.e. the "
"``HttpsContext`` is determined according to the following logic:"
msgstr ""

# f8846ef1b32b4af3ac70bbac18d17c23
#: ../../java/http/client-side/client-https-support.rst:30
msgid ""
"If the optional ``httpsContext`` method parameter is defined it contains the"
" configuration to be used (and thus takes precedence over any potentially "
"set default client-side ``HttpsContext``)."
msgstr ""

# 6929ae157fbb4532aec3c1c16cd9c6ce
#: ../../java/http/client-side/client-https-support.rst:33
msgid ""
"If the optional ``httpsContext`` method parameter is undefined (which is the"
" default) the default client-side ``HttpsContext`` is used, which can be set"
" via the ``setDefaultClientHttpsContext`` on the ``Http`` extension."
msgstr ""

# 155cab5699ba4eb1895a88087e3df588
#: ../../java/http/client-side/client-https-support.rst:36
msgid ""
"If no default client-side ``HttpsContext`` has been set via the "
"``setDefaultClientHttpsContext`` on the ``Http`` extension the default "
"system configuration is used."
msgstr ""

# d792571a74174c36a7cbfb69355fcc98
#: ../../java/http/client-side/client-https-support.rst:39
msgid ""
"Usually the process is, if the default system TLS configuration is not good "
"enough for your application's needs, that you configure a custom "
"``HttpsContext`` instance and set it via "
"``Http.get(system).setDefaultClientHttpsContext``. Afterwards you simply use"
" ``outgoingConnectionTls``, ``newHostConnectionPoolTls``, "
"``cachedHostConnectionPoolTls``, ``superPool`` or ``singleRequest`` without "
"a specific ``httpsContext`` argument, which causes encrypted connections to "
"rely on the configured default client-side ``HttpsContext``."
msgstr ""

# c3f9f851334840be9904ccdc7cd18653
#: ../../java/http/client-side/client-https-support.rst:45
msgid ""
"If no custom ``HttpsContext`` is defined the default context uses Java's "
"default TLS settings. Customizing the ``HttpsContext`` can make the Https "
"client less secure. Understand what you are doing!"
msgstr ""

# 9100f8e9b6214948adac26eec534eaf4
# 4dd4854a1d444da9b1b4d36d680cf7ad
#: ../../java/http/client-side/client-https-support.rst:49
#: ../../java/http/server-side-https-support.rst:27
msgid "SSL-Config"
msgstr ""

# 1ad13f8c791341c294551ead8385f2c0
# 9279b65ca22a424caab5769559c32b32
#: ../../java/http/client-side/client-https-support.rst:51
#: ../../java/http/server-side-https-support.rst:29
msgid ""
"Akka HTTP heavily relies on, and delegates most configuration of any SSL/TLS"
" related options to `Lightbend SSL-Config`_, which is a library specialized "
"in providing an secure-by-default SSLContext and related options."
msgstr ""

# 2275a562a53d45eaa531af1e79afb5db
# 8c4450442fac4142a6a33f4dbdf18ffd
#: ../../java/http/client-side/client-https-support.rst:55
#: ../../java/http/server-side-https-support.rst:33
msgid ""
"Please refer to the `Lightbend SSL-Config`_ documentation for detailed "
"documentation of all available settings."
msgstr ""

# da6af00fc3aa41778dccd54969dd9e8c
# 2cabccc2e3b543879eee65f7d005b9c3
#: ../../java/http/client-side/client-https-support.rst:57
#: ../../java/http/server-side-https-support.rst:35
msgid ""
"SSL Config settings used by Akka HTTP (as well as Streaming TCP) are located"
" under the `akka.ssl-config` namespace."
msgstr ""

# 314d1c0a5a454fe7a15f17d2c269d72b
#: ../../java/http/client-side/client-https-support.rst:62
msgid "Detailed configuration and workarounds"
msgstr ""

# 54943606e1aa4c73855103d30c8144f5
#: ../../java/http/client-side/client-https-support.rst:64
msgid ""
"Akka HTTP relies on `Typesafe SSL-Config`_ which is a library maintained by "
"Lightbend that makes configuring things related to SSL/TLS much simpler than"
" using the raw SSL APIs provided by the JDK. Please refer to its "
"documentation to learn more about it."
msgstr ""

# 73d11f71cb7f412992a5401d62c5722c
#: ../../java/http/client-side/client-https-support.rst:68
msgid ""
"All configuration options available to this library may be set under the "
"``akka.ssl-context`` configuration for Akka HTTP applications."
msgstr ""

# 2d78e2f2e5c042afaa47110b9353766e
#: ../../java/http/client-side/client-https-support.rst:71
msgid ""
"When encountering problems connecting to HTTPS hosts we highly encourage to "
"reading up on the excellent ssl-config configuration. Especially the quick "
"start sections about `adding certificates to the trust store`_ should prove "
"very useful, for example to easily trust a self-signed certificate that "
"applications might use in development mode."
msgstr ""

# 9e163640f03c449490e1187492d3b8e8
#: ../../java/http/client-side/client-https-support.rst:76
msgid ""
"While it is possible to disable certain checks using the so called \"loose\""
" settings in SSL Config, we **strongly recommend** to instead attempt to "
"solve these issues by properly configuring TLS–for example by adding trusted"
" keys to the keystore."
msgstr ""

# e04d5257685042bda24375a69cbc335a
#: ../../java/http/client-side/client-https-support.rst:79
msgid ""
"If however certain checks really need to be disabled because of "
"misconfigured (or legacy) servers that your application has to speak to, "
"instead of disabling the checks globally (i.e. in ``application.conf``) we "
"suggest configuring the loose settings for *specific connections* that are "
"known to need them disabled (and trusted for some other reason). The pattern"
" of doing so is documented in the folowing sub-sections."
msgstr ""

# 93c077121db24db3bc68459a01e5a28a
#: ../../java/http/client-side/client-https-support.rst:87
msgid "Hostname verification"
msgstr ""

# c8d8a398dccd4a42878fca1bf0617e61
#: ../../java/http/client-side/client-https-support.rst:89
msgid ""
"Hostname verification proves that the Akka HTTP client is actually "
"communicating with the server it intended to communicate with. Without this "
"check a man-in-the-middle attack is possible. In the attack scenario, an "
"alternative certificate would be presented which was issued for another host"
" name. Checking the host name in the certificate against the host name the "
"connection was opened against is therefore vital."
msgstr ""

# 98480d8b57cf479186febfa87e6404c5
#: ../../java/http/client-side/client-https-support.rst:94
msgid ""
"The default ``HttpsContext`` enables hostname verification. Akka HTTP relies"
" on the `Typesafe SSL-Config`_ library to implement this and security "
"options for SSL/TLS. Hostname verification is provided by the JDK and used "
"by Akka HTTP since Java 7, and on Java 6 the verification is implemented by "
"ssl-config manually."
msgstr ""

# 1c33aa2c31ad4e23b945ac6a6a857ccf
#: ../../java/http/client-side/client-https-support.rst:98
msgid ""
"For further recommended reading we would like to highlight the `fixing "
"hostname verification blog post`_ by blog post by Will Sargent."
msgstr ""

# 473d8ff207944cc3a3d71a3c80a9bcb7
#: ../../java/http/client-side/client-https-support.rst:106
msgid "Server Name Indication (SNI)"
msgstr ""

# b8da3e5d7d77456ea0b1ebd8684b919a
#: ../../java/http/client-side/client-https-support.rst:108
msgid ""
"SNI is an TLS extension which aims to guard against man-in-the-middle "
"attacks. It does so by having the client send the name of the virtual domain"
" it is expecting to talk to as part of the TLS handshake."
msgstr ""

# 3c32aa21ae14406b94ecb2bf5ae0abbe
#: ../../java/http/client-side/client-https-support.rst:111
msgid "It is specified as part of `RFC 6066`_."
msgstr ""

# b2061f53b0be4457803ba335b0b7fe2b
#: ../../java/http/client-side/client-https-support.rst:114
msgid "Disabling TLS security features, at your own risk"
msgstr ""

# 9b53aab780ba4cd79b40d04804c2545f
#: ../../java/http/client-side/client-https-support.rst:117
msgid ""
"It is highly discouraged to disable any of the security features of TLS, "
"however do acknowlage that workarounds may sometimes be needed."
msgstr ""

# 47c0306e44a44fcf89393e3aff738d45
#: ../../java/http/client-side/client-https-support.rst:119
msgid ""
"Before disabling any of the features one should consider if they may be "
"solvable *within* the TLS world, for example by `trusting a certificate`_, "
"or `configuring the trusted cipher suites`_. There's also a very important "
"section in the ssl-config docs titled `LooseSSL - Please read this before "
"turning anything off!`_."
msgstr ""

# 851447203fbf4d5dadc9a5175df01742
#: ../../java/http/client-side/client-https-support.rst:123
msgid ""
"If disabling features is indeed desired, we recommend doing so for *specific"
" connections*, instead of globally configuring it via ``application.conf``."
msgstr ""

# c8fa2b048a984aeaa9adc3c719825e0d
#: ../../java/http/client-side/client-https-support.rst:126
msgid ""
"The following shows an example of disabling SNI for a given connection:"
msgstr ""

# 3e9b322f6f38413faf02f8d2b78d84f9
#: ../../java/http/client-side/client-https-support.rst:131
msgid ""
"The ``badSslConfig`` is a copy of the default ``AkkaSSLConfig`` with with "
"the slightly changed configuration to disable SNI. This value can be cached "
"and used for connections which should indeed not use this feature."
msgstr ""

# 82b131315da04002a83362d6cbbd4e81
#: ../../java/http/client-side/connection-level.rst:4
msgid "Connection-Level Client-Side API"
msgstr ""

# dbaa4d9216d7427282ae2c454f158642
#: ../../java/http/client-side/connection-level.rst:6
msgid ""
"The connection-level API is the lowest-level client-side API Akka HTTP "
"provides. It gives you full control over when HTTP connections are opened "
"and closed and how requests are to be send across which connection. As such "
"it offers the highest flexibility at the cost of providing the least "
"convenience."
msgstr ""

# 9a696a928fcf478dbb5459bc92ef7590
#: ../../java/http/client-side/connection-level.rst:12
msgid "Opening HTTP Connections"
msgstr ""

# 429e445fad77408d9e8618ae946f9fb0
#: ../../java/http/client-side/connection-level.rst:13
msgid ""
"With the connection-level API you open a new HTTP connection to a target "
"endpoint by materializing a ``Flow`` returned by the "
"``Http.get(system).outgoingConnection(...)`` method. Here is an example:"
msgstr ""

# e4def8c5b1ac4156bb2ea4e7484bc381
#: ../../java/http/client-side/connection-level.rst:18
msgid ""
"Apart from the host name and port the "
"``Http.get(system).outgoingConnection(...)`` method also allows you to "
"specify socket options and a number of configuration settings for the "
"connection."
msgstr ""

# 7fcd6f8ef40f43f59cbb829ea66ebd1f
#: ../../java/http/client-side/connection-level.rst:21
msgid ""
"Note that no connection is attempted until the returned flow is actually "
"materialized! If the flow is materialized several times then several "
"independent connections will be opened (one per materialization). If the "
"connection attempt fails, for whatever reason, the materialized flow will be"
" immediately terminated with a respective exception."
msgstr ""

# 7e4a8cf83c3f4cdfaef2fe9f3fa286bb
# d3d67a447d564799a16eceda55778579
#: ../../java/http/client-side/connection-level.rst:28
#: ../../java/http/server-side/low-level-server-side-api.rst:88
msgid "Request-Response Cycle"
msgstr ""

# ada1cc4376a742f09326118894e5ba7d
#: ../../java/http/client-side/connection-level.rst:30
msgid ""
"Once the connection flow has been materialized it is ready to consume "
"``HttpRequest`` instances from the source it is attached to. Each request is"
" sent across the connection and incoming responses dispatched to the "
"downstream pipeline. Of course and as always, back-pressure is adequately "
"maintained across all parts of the connection. This means that, if the "
"downstream pipeline consuming the HTTP responses is slow, the request source"
" will eventually be slowed down in sending requests."
msgstr ""

# eb4bef3b20b84828b9c8974391ec6cac
#: ../../java/http/client-side/connection-level.rst:36
msgid ""
"Any errors occurring on the underlying connection are surfaced as exceptions"
" terminating the response stream (and canceling the request source)."
msgstr ""

# 8b2f63aec5b04a0b94fa3ccb6695e317
#: ../../java/http/client-side/connection-level.rst:39
msgid ""
"Note that, if the source produces subsequent requests before the prior "
"responses have arrived, these requests will be pipelined__ across the "
"connection, which is something that is not supported by all HTTP servers. "
"Also, if the server closes the connection before responses to all requests "
"have been received this will result in the response stream being terminated "
"with a truncation error."
msgstr ""

# e794c1009d994cc0909612b6c2a188c0
#: ../../java/http/client-side/connection-level.rst:48
msgid "Closing Connections"
msgstr ""

# b0680f699ac54eddb3fb3a1012cd1362
#: ../../java/http/client-side/connection-level.rst:50
msgid ""
"Akka HTTP actively closes an established connection upon reception of a "
"response containing ``Connection: close`` header. The connection can also be"
" closed by the server."
msgstr ""

# f4933ceec2c54a6584f9f6f9f46a11ae
#: ../../java/http/client-side/connection-level.rst:53
msgid ""
"An application can actively trigger the closing of the connection by "
"completing the request stream. In this case the underlying TCP connection "
"will be closed when the last pending response has been received."
msgstr ""

# 65d542cc9d374f19b82b785647704603
#: ../../java/http/client-side/connection-level.rst:56
msgid ""
"The connection will also be closed if the response entity is cancelled (e.g."
" by attaching it to ``Sink.cancelled()``) or consumed only partially (e.g. "
"by using ``take`` combinator). In order to prevent this behaviour the entity"
" should be explicitly drained by attaching it to ``Sink.ignore()``."
msgstr ""

# 5b4db55867e04aebb27fdc0b07b05a98
#: ../../java/http/client-side/connection-level.rst:62
msgid "Timeouts"
msgstr ""

# 205584f3fd474950a6c00b08887e2f70
#: ../../java/http/client-side/connection-level.rst:64
msgid ""
"Timeouts are configured in the same way for Scala and Akka. See :ref:`http-"
"timeouts-java` ."
msgstr ""

# 18e660dbca384a5988b21ee72090d363
# a5419f9c761b4010a71b33fa67476335
#: ../../java/http/client-side/connection-level.rst:69
#: ../../java/http/server-side/low-level-server-side-api.rst:141
msgid "Stand-Alone HTTP Layer Usage"
msgstr ""

# 8aa2c96c485b4064be108a7e8297d102
# fba2aec2a079431ebedb32aa21904c4e
#: ../../java/http/client-side/connection-level.rst:71
#: ../../java/http/server-side/low-level-server-side-api.rst:143
msgid ""
"Due to its Reactive-Streams-based nature the Akka HTTP layer is fully "
"detachable from the underlying TCP interface. While in most applications "
"this \"feature\" will not be crucial it can be useful in certain cases to be"
" able to \"run\" the HTTP layer (and, potentially, higher-layers) against "
"data that do not come from the network but rather some other source. "
"Potential scenarios where this might be useful include tests, debugging or "
"low-level event-sourcing (e.g by replaying network traffic)."
msgstr ""

# 71b76db9d3bf433fbe243a338e4da41a
#: ../../java/http/client-side/connection-level.rst:77
msgid ""
"On the client-side the stand-alone HTTP layer forms a "
"``BidiFlow<HttpRequest, SslTlsOutbound, SslTlsInbound, HttpResponse, "
"NotUsed>``, that is a stage that \"upgrades\" a potentially encrypted raw "
"connection to the HTTP level."
msgstr ""

# 8083af42c0de4bb980aef823180cda46
#: ../../java/http/client-side/connection-level.rst:80
msgid ""
"You create an instance of the layer by calling one of the two overloads of "
"the ``Http.get(system).clientLayer`` method, which also allows for varying "
"degrees of configuration."
msgstr ""

# 6be5d36a5a6d43ab9c6117ed032aa763
#: ../../java/http/client-side/host-level.rst:4
msgid "Host-Level Client-Side API"
msgstr ""

# fae61ee6580f40f1bbe3eae1c2c6936d
#: ../../java/http/client-side/host-level.rst:6
msgid ""
"As opposed to the :ref:`connection-level-api` the host-level API relieves "
"you from manually managing individual HTTP connections. It autonomously "
"manages a configurable pool of connections to *one particular target "
"endpoint* (i.e. host/port combination)."
msgstr ""

# 0706f6d9f2b7480fa952f39c2b877a00
#: ../../java/http/client-side/host-level.rst:12
msgid "Requesting a Host Connection Pool"
msgstr ""

# 5aeed28f305c419c8c7bb1fb956095cc
#: ../../java/http/client-side/host-level.rst:14
msgid ""
"The best way to get a hold of a connection pool to a given target endpoint "
"is the ``Http.get(system).cachedHostConnectionPool(...)`` method, which "
"returns a ``Flow`` that can be \"baked\" into an application-level stream "
"setup. This flow is also called a \"pool client flow\"."
msgstr ""

# 275245dab3a34c6289d8556f7c228739
#: ../../java/http/client-side/host-level.rst:18
msgid ""
"The connection pool underlying a pool client flow is cached. For every "
"``ActorSystem``, target endpoint and pool configuration there will never be "
"more than a single pool live at any time."
msgstr ""

# 0e4447f0d6ee421fb7a5548e8578bc09
#: ../../java/http/client-side/host-level.rst:21
msgid ""
"Also, the HTTP layer transparently manages idle shutdown and restarting of "
"connection pools as configured. The client flow instances therefore remain "
"valid throughout the lifetime of the application, i.e. they can be "
"materialized as often as required and the time between individual "
"materialization is of no importance."
msgstr ""

# 7f57e13425ad4e1e843f5d4d6c1af8c5
#: ../../java/http/client-side/host-level.rst:25
msgid ""
"When you request a pool client flow with "
"``Http.get(system).cachedHostConnectionPool(...)`` Akka HTTP will "
"immediately start the pool, even before the first client flow "
"materialization. However, this running pool will not actually open the first"
" connection to the target endpoint until the first request has arrived."
msgstr ""

# 75294d5932594bc79835e0b8692f5a80
#: ../../java/http/client-side/host-level.rst:31
msgid "Configuring a Host Connection Pool"
msgstr ""

# d43699fd584444c98fb44b8729ef0793
#: ../../java/http/client-side/host-level.rst:33
msgid ""
"Apart from the connection-level config settings and socket options there are"
" a number of settings that allow you to influence the behavior of the "
"connection pool logic itself. Check out the ``akka.http.host-connection-"
"pool`` section of the Akka HTTP :ref:`akka-http-configuration-java` for more"
" information about which settings are available and what they mean."
msgstr ""

# 739d41c5dc354c39a4c420d5c1276c1c
#: ../../java/http/client-side/host-level.rst:38
msgid ""
"Note that, if you request pools with different configurations for the same "
"target host you will get *independent* pools. This means that, in total, "
"your application might open more concurrent HTTP connections to the target "
"endpoint than any of the individual pool's ``max-connections`` settings "
"allow!"
msgstr ""

# 867d831e2d3f4d06aca6641f88bb521e
#: ../../java/http/client-side/host-level.rst:42
msgid ""
"There is one setting that likely deserves a bit deeper explanation: ``max-"
"open-requests``. This setting limits the maximum number of requests that can"
" be in-flight at any time for a single connection pool. If an application "
"calls ``Http.get(system).cachedHostConnectionPool(...)`` 3 times (with the "
"same endpoint and settings) it will get back ``3`` different client flow "
"instances for the same pool. If each of these client flows is then "
"materialized ``4`` times (concurrently) the application will have 12 "
"concurrently running client flow materializations. All of these share the "
"resources of the single pool."
msgstr ""

# 87b3bb7ab7884a83a15b539c5def8f0f
#: ../../java/http/client-side/host-level.rst:49
msgid ""
"This means that, if the pool's ``pipelining-limit`` is left at ``1`` "
"(effecitvely disabeling pipelining), no more than 12 requests can be open at"
" any time. With a ``pipelining-limit`` of ``8`` and 12 concurrent client "
"flow materializations the theoretical open requests maximum is ``96``."
msgstr ""

# f8c9e65a5e684ca786f91316ca7553e2
#: ../../java/http/client-side/host-level.rst:53
msgid ""
"The ``max-open-requests`` config setting allows for applying a hard limit "
"which serves mainly as a protection against erroneous connection pool use, "
"e.g. because the application is materializing too many client flows that all"
" compete for the same pooled connections."
msgstr ""

# 19f066e91acb48e38c24d699acddee46
#: ../../java/http/client-side/host-level.rst:60
msgid "Using a Host Connection Pool"
msgstr ""

# 0775ef8117a4444a815d14a0ed1c9082
#: ../../java/http/client-side/host-level.rst:62
msgid ""
"The \"pool client flow\" returned by "
"``Http.get(system).cachedHostConnectionPool(...)`` has the following type::"
msgstr ""

# d27cd1b82f0640cf90c923653847d6c6
#: ../../java/http/client-side/host-level.rst:67
msgid ""
"This means it consumes tuples of type ``(HttpRequest, T)`` and produces "
"tuples of type ``(Try[HttpResponse], T)`` which might appear more "
"complicated than necessary on first sight. The reason why the pool API "
"includes objects of custom type ``T`` on both ends lies in the fact that the"
" underlying transport usually comprises more than a single connection and as"
" such the pool client flow often generates responses in an order that "
"doesn't directly match the consumed requests. We could have built the pool "
"logic in a way that reorders responses according to their requests before "
"dispatching them to the application, but this would have meant that a single"
" slow response could block the delivery of potentially many responses that "
"would otherwise be ready for consumption by the application."
msgstr ""

# c7d707c9f9ec4799a2d3405f5275b9db
#: ../../java/http/client-side/host-level.rst:76
msgid ""
"In order to prevent unnecessary head-of-line blocking the pool client-flow "
"is allowed to dispatch responses as soon as they arrive, independently of "
"the request order. Of course this means that there needs to be another way "
"to associate a response with its respective request. The way that this is "
"done is by allowing the application to pass along a custom \"context\" "
"object with the request, which is then passed back to the application with "
"the respective response. This context object of type ``T`` is completely "
"opaque to Akka HTTP, i.e. you can pick whatever works best for your "
"particular application scenario."
msgstr ""

# f1cca548507e49e6b2e7509fff31eb7d
#: ../../java/http/client-side/host-level.rst:84
msgid ""
"A consequence of using a pool is that long-running requests block a "
"connection while running and may starve other requests. Make sure not to use"
" a connection pool for long-running requests like long-polling GET requests."
" Use the :ref:`connection-level-api-java` instead."
msgstr ""

# a5237efd932545748cd83bb099728e3f
#: ../../java/http/client-side/host-level.rst:89
msgid "Connection Allocation Logic"
msgstr ""

# 35b41be9083f4d928bf07e6789675c76
#: ../../java/http/client-side/host-level.rst:91
msgid ""
"This is how Akka HTTP allocates incoming requests to the available "
"connection \"slots\":"
msgstr ""

# 8dcbe107aff34ffe8d25ffd147897599
#: ../../java/http/client-side/host-level.rst:93
msgid ""
"If there is a connection alive and currently idle then schedule the request "
"across this connection."
msgstr ""

# 5ea763c08cce4a7db9a90e8167182d7c
#: ../../java/http/client-side/host-level.rst:94
msgid ""
"If no connection is idle and there is still an unconnected slot then "
"establish a new connection."
msgstr ""

# d03d9600b7c64f769c4fc06164bf7910
#: ../../java/http/client-side/host-level.rst:95
msgid ""
"If all connections are already established and \"loaded\" with other "
"requests then pick the connection with the least open requests (< the "
"configured ``pipelining-limit``) that only has requests with idempotent "
"methods scheduled to it, if there is one."
msgstr ""

# 0c7123ae08274749a17db13b87d38067
#: ../../java/http/client-side/host-level.rst:98
msgid ""
"Otherwise apply back-pressure to the request source, i.e. stop accepting new"
" requests."
msgstr ""

# 532e5e748df94c818a816b0698d2ef4a
#: ../../java/http/client-side/host-level.rst:100
msgid ""
"For more information about scheduling more than one request at a time across"
" a single connection see `this wikipedia entry on HTTP pipelining`__."
msgstr ""

# 4c4343eb147246fe81da49f8c109d950
#: ../../java/http/client-side/host-level.rst:108
msgid "Retrying a Request"
msgstr ""

# 63c000c845674adf9fe2d369701611bc
#: ../../java/http/client-side/host-level.rst:110
msgid ""
"If the ``max-retries`` pool config setting is greater than zero the pool "
"retries idempotent requests for which a response could not be successfully "
"retrieved. Idempotent requests are those whose HTTP method is defined to be "
"idempotent by the HTTP spec, which are all the ones currently modelled by "
"Akka HTTP except for the ``POST``, ``PATCH`` and ``CONNECT`` methods."
msgstr ""

# a2f9ea9a13cc476389694f9938e8480a
#: ../../java/http/client-side/host-level.rst:115
msgid ""
"When a response could not be received for a certain request there are "
"essentially three possible error scenarios:"
msgstr ""

# 6e7dae31b23540b2b95735681da4c45e
#: ../../java/http/client-side/host-level.rst:117
msgid "The request got lost on the way to the server."
msgstr ""

# a4c37501790845a180f9a1c2e631f064
#: ../../java/http/client-side/host-level.rst:118
msgid "The server experiences a problem while processing the request."
msgstr ""

# 56403b2ddae84671ba260b5c6ec04117
#: ../../java/http/client-side/host-level.rst:119
msgid "The response from the server got lost on the way back."
msgstr ""

# 813b0f8ab7394a4287e671351c72eec7
#: ../../java/http/client-side/host-level.rst:121
msgid ""
"Since the host connector cannot know which one of these possible reasons "
"caused the problem and therefore ``PATCH`` and ``POST`` requests could have "
"already triggered a non-idempotent action on the server these requests "
"cannot be retried."
msgstr ""

# 7d9c44c1e8854b12b99f9057c25c3d24
#: ../../java/http/client-side/host-level.rst:124
msgid ""
"In these cases, as well as when all retries have not yielded a proper "
"response, the pool produces a failed ``Try`` (i.e. a ``scala.util.Failure``)"
" together with the custom request context."
msgstr ""

# e19960b16ff44d79875d26fc4c405134
#: ../../java/http/client-side/host-level.rst:129
msgid "Pool Shutdown"
msgstr ""

# 1c8740c29a584f3e8e5c3a439b008bfd
#: ../../java/http/client-side/host-level.rst:131
msgid ""
"Completing a pool client flow will simply detach the flow from the pool. The"
" connection pool itself will continue to run as it may be serving other "
"client flows concurrently or in the future. Only after the configured "
"``idle-timeout`` for the pool has expired will Akka HTTP automatically "
"terminate the pool and free all its resources."
msgstr ""

# 00d6e42d38274c8a989e43b240f8b0f6
#: ../../java/http/client-side/host-level.rst:135
msgid ""
"If a new client flow is requested with "
"``Http.get(system).cachedHostConnectionPool(...)`` or if an already existing"
" client flow is re-materialized the respective pool is automatically and "
"transparently restarted."
msgstr ""

# e69cb2ba5c8c43f19b0b9b5a9dafa8f7
#: ../../java/http/client-side/host-level.rst:138
msgid ""
"In addition to the automatic shutdown via the configured idle timeouts it's "
"also possible to trigger the immediate shutdown of a specific pool by "
"calling ``shutdown()`` on the :class:`HostConnectionPool` instance that the "
"pool client flow materializes into. This ``shutdown()`` call produces a "
"``CompletionStage<Done>`` which is fulfilled when the pool termination has "
"been completed."
msgstr ""

# 92bf4b728e804574aaa1af0ea32dfddf
#: ../../java/http/client-side/host-level.rst:143
msgid ""
"It's also possible to trigger the immediate termination of *all* connection "
"pools in the ``ActorSystem`` at the same time by calling "
"``Http.get(system).shutdownAllConnectionPools()``. This call too produces a "
"``CompletionStage<Done>`` which is fulfilled when all pools have terminated."
msgstr ""

# 1eb917a6aea34cee92f6645729186a53
#: ../../java/http/client-side/host-level.rst:148
msgid ""
"When encoutering unexpected ``akka.stream.AbruptTerminationException`` "
"exceptions during ``ActorSystem`` **shutdown** please make sure that active "
"connections are shut down before shutting down the entire system, this can "
"be done by calling the ``Http.get(system).shutdownAllConnectionPools()`` "
"method, and only once its CompletionStage completes, shutting down the actor"
" system."
msgstr ""

# e208e61994be4cef8d8d23fe95fbf568
# 7b0c85402820406db9710bc6524796fd
# 4134913a3b804895ab333c51c517d816
# 4e6c13fe66de4204b0b48861e2706e90
# 721ebda0afa2443580b884b742251117
# 83bd3ad840ef48adb92e7f5b3b504271
# 98e10ad4164a4d99967b399f79e7e8ab
# 3d4560142e29468abd5958195f0a64bb
# e456b67da227429b97c97cc6e7dc23fb
# 0d73f18245184256afb7f8d343adf41c
# 6a26d23d38c643a8bb2757ad698edd4c
# 720f2bce310b4c119751c5b6ac10f835
# 756a6e00eb874589b0df174ec89353dc
# 60923fab43574aa78518d7a014c51d52
# 4669a1948a5349ce9396566b3951a2ac
# bb0892dd6c3141429d503a1fe449ba1f
# cf2e0a0d92ad401cb6a8f1deafbec07a
# daf16349101b423da37f748fc729286c
# a451d27d822042fcbcd9cebd0c34d95d
# 32bdf8ea6c314477b2e7c3071c8f560c
# 7d57a559c6d14946980adcb8ace116c1
# 595e2f74f17341529f631d3a0d36ae8e
# 0d76a0df5b4a4cb4988475ba727056f8
# e530274d156b4b718068573315fac1a2
# e8049a5f64a44fbfb1ae15625d6c3e41
# 7c53cd03000944ff89f174526d3a3213
# d5d484627a0c4de4b6717bd55fc451a0
# b5c57ab1df16486a9db8c8a5fefd5b98
# 233403e327f64aa19c36c2835e38b343
# 4974d38ad9a14c0796b74d0a7a25b771
# f8db76d1077a421fb6fb3ee7495e0a26
# 3782022bfaf541c29d782353e07c28ed
# 7e9cb7bb73464e3ebd670cc667053d89
# f602b17a82704afbbc3832188a556a3c
# cbf0781d622445ddaf9adfa005ced780
# e8d397c60d3645fab1b4a8865658f202
# 79673e65b5c74ab18f32a2f3a610d457
# 95ceefa0a85b4ff98373c83a3879c6e8
# 79d2d6fea5f1481caff2182a1d719a28
# d0643c2496d2435592ba60d07d5c5cce
# ae659eac6d1c425ab65064413486d282
# d30ac93f0ea14564896bf8cf4078b374
# 0eb5ce750af24a7cbcd89f5cbf9f641f
# bdb6513b0bd0457e8442ebba12bcf45a
# 5fa10630e3d54755b3ac0793f7583924
# fca7158bb8334d8bb3113b71c09519e2
# 7ee77dae561f44f4889d39adae506190
# 34dc53d44bf04f24b268a229f6aad0b1
# 9eac75018e6e4b9d8ef95c1614868dc1
# 2193af6477cc4dad91f5e748da54d818
# d05bbcc4844f4fd3b658bcd13fd3a1cd
# ca64a903d6df4f84a15ac6053296b20c
# 0ec4209bd04342c2994006026f57a711
# fe6f4632ad0e4ca097f4828a1be61d1f
# 5f59085cd813458aa2c6b0612c6ea293
# 38f498b4b7f94020a7fd19137202b2e4
# 6cac4bd45cc04b3d82786a2036a18ebb
# 6012c5581d4f45c8825ceabd3a0e7a7d
# c2718285b6ed4f60a24183c33bf1300d
# f6fadb9f11aa40739f471e69b0f0724b
# e7741ea03e894ec7baa058308da3c154
# 6dbdc5250b944035a9a676a17ba4a56f
# 0a9a405917cc4cdb8e9e0af58c3de757
# f1f52392356645a7be0522ed5bdf7280
# 87287505166f49ab97951cf98e84a17e
# 4f3f551596d2456c8c9df98719284ee5
# 059fb5d683684081a21b211af4b3d92a
# b25607affd674a2a9047b9345135ba65
# aa1cdd454cf9416b842cd96b4026a2d1
# 65f715a9a2ec4d3f95159ca802113d27
# 6ff7050e22904935a9e7e8372a327cc0
# 1bcaf65bfb9f45928aa8fc860023bee3
# 4eeef30318154b8baffc1e52e708a654
# e6c534b46a984ecabf5cc860da3f2ef1
# 9dfb039c8ea7400aaf1ac252457dc6b6
# f69da1a590e54b1aaf61b305141ae75a
# 7eda02dfd400499388263d2163d64ad8
# 5cfbd5952e874caca3e02f405045234c
# bc2337c60fff40f4b06d656ced3aabd3
# 9be85f637dfb4f979ae57b84a767e1af
# 1a940bd87c764b7ba652e46ce4c98b4b
# 634c6d34e48d4bc681f5c315500854e4
# c2067b7817ea4caab95f0f1c27c7758e
# 865e50e95d5941de947436dfbfbc80fc
# a3f9537346b940278475a07fbeeef6d8
# 84bc08a860de4b0dae155f80eed1bd14
# b1946f445e664c13a4e1bab86550463d
# 6e7127d9c6a344399eb9ba3a6f1247c8
# 7d19a578361845d6888c92e041e328ca
# c1a0f9d0585a44dc906d62bb0a19ada9
# 5239e67f2cb94680b8f6f009be221dc4
# d68a841355354cab9beaf432b2124031
# ccdb89e9b4a74583927aac411187a818
# 78f3a3c1fed445e2b235dba91ca99f96
# 1a9df40b88e34bccb72053fc5203b00f
# e42427f419444bdfb2e8287285e9ed9a
# 971f5c9bdc374f36b88a39930522f278
# a62726278e444a69b753f00752f051bd
# 6db34c805be34cdfa1bb25412ac9bd9a
# 7d860d76a0604590b34183fd299aa2af
# e37cd944559143d58494eb84f246edf2
# 22c940a1a1184e8fb54fe5741949b384
# 9d4f754218f74aa499ddd57135b22680
# 0c67fd167f0e462ea15bb04d4f9bebcb
# 39135af16ecb40708c60d374d885c1bb
# e3c767a20db4424f896be035270adc95
# aa1812aa7b1849b7b3835656b5c087dc
# bda222a2112349749d32cd39e65ffd5d
# 4fa0d41cc1994ed4a8705d7467af9f3a
# 259975589ca74faa808988c4bd6bf4b0
# 70a026433cbd4a0c9a8838790d9871ab
# ff6b039e23cb4f189fd246d8d9b4931b
# 3c582cb6701442e19efff0756ee33057
# 38552e9bb5e14c7ebc8e5b88348bdaa4
# de7afacaece64b9b99fdd95972c55e87
# 8a59f57190c0461e94f1af88ef31dcec
# d91f5162c2734b89b3fcbf0b03c5599f
# 1eea652c606f42b39a23fe12e88c2c11
# 7f4b0aa4969449cc9ea5c0ddc86d0649
# bb3ae01f7c2347468cad7ca380ae567a
# 016b013238dd4a55bd95e0a7ade4b5dc
# 1bd6e350082d46d590f010af14e57aa8
# 6138e30e070d48f4957243152c597066
# 84e72257d0604c35b526b3c23626a310
# 56afa79b2393472c9a93f9febd2210ff
# 0fb9133d8a37478e88bcc82dbef1b047
# f2980230073f4e87ba2ffa71e0541576
# 1c439f2df4cd490aa8eeb3714ec4fd3a
# 5226c3035b544cbdb4f9f1bef5ed8bbd
# 83fe034a58ae4ac4acf7d9305b5f87da
# 0fc8e7ec957241ae9968710734256309
# 379032ff0c904b05a104ee472b6675e7
# e851e16fade34af786c6889a486d178e
# 4b8fe6ef8afe43b980cc07ae3871f44c
# fb36fd4657a74486a9d2dde9a69ad213
# e4fadcffd686497faecf1ac17a58ef22
# adea72deb246481ea824ee27db88bf80
# 8c72a9e989bf426dba9e558fd5c7faf1
# 0b5f4b5b86ff451eb0e45184618a26fb
# 980b2100c8ca458086f747f4d39f3be6
# f7c614c0803344788ac6f5676f906016
# 808af4711ddc4f00bebb0164613c651c
# 88dba805324d47c48b7acce63c1e3e1a
# 787fa82ac8c640b3b16784a498996cda
# 410906f59c2e49889ada92508f548822
# b925ba3c6d7f40fc97584a2dbc69d060
#: ../../java/http/client-side/host-level.rst:154
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejection.rst:18
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejections.rst:20
#: ../../java/http/routing-dsl/directives/basic-directives/extract.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/extractActorSystem.rst:17
#: ../../java/http/routing-dsl/directives/basic-directives/extractDataBytes.rst:14
#: ../../java/http/routing-dsl/directives/basic-directives/extractExecutionContext.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/extractLog.rst:17
#: ../../java/http/routing-dsl/directives/basic-directives/extractMaterializer.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequest.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestContext.rst:18
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestEntity.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/extractSettings.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/extractStrictEntity.rst:21
#: ../../java/http/routing-dsl/directives/basic-directives/extractUnmatchedPath.rst:17
#: ../../java/http/routing-dsl/directives/basic-directives/extractUri.rst:14
#: ../../java/http/routing-dsl/directives/basic-directives/mapInnerRoute.rst:14
#: ../../java/http/routing-dsl/directives/basic-directives/mapRejections.rst:18
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequest.rst:18
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequestContext.rst:17
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseEntity.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseHeaders.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResult.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultFuture.rst:19
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultPF.rst:19
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWith.rst:18
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWithPF.rst:19
#: ../../java/http/routing-dsl/directives/basic-directives/mapSettings.rst:14
#: ../../java/http/routing-dsl/directives/basic-directives/mapUnmatchedPath.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/pass.rst:13
#: ../../java/http/routing-dsl/directives/basic-directives/provide.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejections.rst:19
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejectionsWith.rst:22
#: ../../java/http/routing-dsl/directives/basic-directives/toStrictEntity.rst:21
#: ../../java/http/routing-dsl/directives/basic-directives/withExecutionContext.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/withLog.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/withMaterializer.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/withSettings.rst:15
#: ../../java/http/routing-dsl/directives/coding-directives/decodeRequest.rst:12
#: ../../java/http/routing-dsl/directives/coding-directives/decodeRequestWith.rst:12
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponse.rst:16
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponseWith.rst:19
#: ../../java/http/routing-dsl/directives/coding-directives/requestEncodedWith.rst:14
#: ../../java/http/routing-dsl/directives/coding-directives/responseEncodingAccepted.rst:12
#: ../../java/http/routing-dsl/directives/cookie-directives/cookie.rst:15
#: ../../java/http/routing-dsl/directives/cookie-directives/deleteCookie.rst:13
#: ../../java/http/routing-dsl/directives/cookie-directives/optionalCookie.rst:14
#: ../../java/http/routing-dsl/directives/cookie-directives/setCookie.rst:14
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequest.rst:18
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequestResult.rst:15
#: ../../java/http/routing-dsl/directives/debugging-directives/logResult.rst:15
#: ../../java/http/routing-dsl/directives/execution-directives/handleExceptions.rst:16
#: ../../java/http/routing-dsl/directives/execution-directives/handleRejections.rst:15
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.rst:21
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:21
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:29
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:29
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResource.rst:17
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.rst:17
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.rst:22
#: ../../java/http/routing-dsl/directives/file-upload-directives/fileUpload.rst:16
#: ../../java/http/routing-dsl/directives/file-upload-directives/uploadedFile.rst:22
#: ../../java/http/routing-dsl/directives/form-field-directives/formField.rst:10
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldList.rst:19
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMap.rst:18
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMultiMap.rst:21
#: ../../java/http/routing-dsl/directives/future-directives/completeOrRecoverWith.rst:17
#: ../../java/http/routing-dsl/directives/future-directives/onComplete.rst:17
#: ../../java/http/routing-dsl/directives/future-directives/onCompleteWithBreaker.rst:18
#: ../../java/http/routing-dsl/directives/future-directives/onSuccess.rst:16
#: ../../java/http/routing-dsl/directives/header-directives/checkSameOrigin.rst:14
#: ../../java/http/routing-dsl/directives/header-directives/headerValue.rst:21
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByName.rst:16
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByType.rst:21
#: ../../java/http/routing-dsl/directives/header-directives/headerValuePF.rst:18
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValue.rst:15
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByName.rst:14
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByType.rst:20
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValuePF.rst:15
#: ../../java/http/routing-dsl/directives/host-directives/extractHostName.rst:11
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:24
#: ../../java/http/routing-dsl/directives/method-directives/delete.rst:17
#: ../../java/http/routing-dsl/directives/method-directives/extractMethod.rst:12
#: ../../java/http/routing-dsl/directives/method-directives/get.rst:17
#: ../../java/http/routing-dsl/directives/method-directives/head.rst:20
#: ../../java/http/routing-dsl/directives/method-directives/method.rst:17
#: ../../java/http/routing-dsl/directives/method-directives/options.rst:16
#: ../../java/http/routing-dsl/directives/method-directives/overrideMethodWithParameter.rst:21
#: ../../java/http/routing-dsl/directives/method-directives/patch.rst:18
#: ../../java/http/routing-dsl/directives/method-directives/post.rst:18
#: ../../java/http/routing-dsl/directives/method-directives/put.rst:17
#: ../../java/http/routing-dsl/directives/misc-directives/extractClientIP.rst:14
#: ../../java/http/routing-dsl/directives/misc-directives/rejectEmptyResponse.rst:15
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityEmpty.rst:16
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityPresent.rst:15
#: ../../java/http/routing-dsl/directives/misc-directives/selectPreferredLanguage.rst:16
#: ../../java/http/routing-dsl/directives/misc-directives/validate.rst:13
#: ../../java/http/routing-dsl/directives/misc-directives/withSizeLimit.rst:18
#: ../../java/http/routing-dsl/directives/misc-directives/withoutSizeLimit.rst:17
#: ../../java/http/routing-dsl/directives/parameter-directives/parameter.rst:14
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMap.rst:14
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMultiMap.rst:19
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterSeq.rst:15
#: ../../java/http/routing-dsl/directives/parameter-directives/parameters.rst:13
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:33
#: ../../java/http/routing-dsl/directives/path-directives/pathEnd.rst:17
#: ../../java/http/routing-dsl/directives/path-directives/pathEndOrSingleSlash.rst:18
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefix.rst:26
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefixTest.rst:26
#: ../../java/http/routing-dsl/directives/path-directives/pathSingleSlash.rst:16
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffix.rst:26
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffixTest.rst:27
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefix.rst:23
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefixTest.rst:26
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:26
#: ../../java/http/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.rst:22
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:29
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.rst:20
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:21
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeader.rst:16
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeaders.rst:17
#: ../../java/http/routing-dsl/directives/route-directives/complete.rst:19
#: ../../java/http/routing-dsl/directives/route-directives/failWith.rst:26
#: ../../java/http/routing-dsl/directives/route-directives/redirect.rst:15
#: ../../java/http/routing-dsl/directives/route-directives/reject.rst:21
#: ../../java/http/routing-dsl/directives/scheme-directives/extractScheme.rst:13
#: ../../java/http/routing-dsl/directives/scheme-directives/scheme.rst:20
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:29
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:27
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:27
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:24
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:30
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:30
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:31
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:31
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.rst:18
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:26
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:27
#: ../../java/http/routing-dsl/directives/security-directives/extractCredentials.rst:15
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:35
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.rst:25
#: ../../java/http/routing-dsl/directives/timeout-directives/withoutRequestTimeout.rst:22
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessages.rst:18
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.rst:22
#: ../../java/http/routing-dsl/testkit.rst:20
#: ../../java/http/server-side/websocket-support.rst:86
msgid "Example"
msgstr ""

# d707cfdae42449918da6d6963fc001dd
#: ../../java/http/client-side/index.rst:4
msgid "Consuming HTTP-based Services (Client-Side)"
msgstr ""

# a15a63740fc9481db77a3bfa423e5ad7
#: ../../java/http/client-side/index.rst:6
msgid ""
"All client-side functionality of Akka HTTP, for consuming HTTP-based "
"services offered by other endpoints, is currently provided by the ``akka-"
"http-core`` module."
msgstr ""

# fd34805e5da04d11acc81c8577fad31a
#: ../../java/http/client-side/index.rst:9
msgid ""
"Depending on your application's specific needs you can choose from three "
"different API levels:"
msgstr ""

# e1076f42fef241319334e4ac10c4dfc9
#: ../../java/http/client-side/index.rst:12
msgid ""
"for full-control over when HTTP connections are opened/closed and how "
"requests are scheduled across them"
msgstr ""

# af1d24e667704cee8f387c6b184c7920
#: ../../java/http/client-side/index.rst:15
msgid ""
"for letting Akka HTTP manage a connection-pool to *one specific* host/port "
"endpoint"
msgstr ""

# 9e52624feaf04b34bfa3df6cd7144f75
#: ../../java/http/client-side/index.rst:18
msgid "for letting Akka HTTP perform all connection management"
msgstr ""

# 0b325152074e46af9f6278db317e739b
#: ../../java/http/client-side/index.rst:20
msgid ""
"You can interact with different API levels at the same time and, "
"independently of which API level you choose, Akka HTTP will happily handle "
"many thousand concurrent connections to a single or many different hosts."
msgstr ""

# 083fa608871d46148ee4aee2f2c2d7a6
#: ../../java/http/client-side/request-level.rst:4
msgid "Request-Level Client-Side API"
msgstr ""

# 35e569c1b93a407eb3a8dc034fdecb70
#: ../../java/http/client-side/request-level.rst:6
msgid ""
"The request-level API is the most convenient way of using Akka HTTP's "
"client-side functionality. It internally builds upon the :ref:`host-level-"
"api-java` to provide you with a simple and easy-to-use way of retrieving "
"HTTP responses from remote servers. Depending on your preference you can "
"pick the flow-based or the future-based variant."
msgstr ""

# b17c77fd8b10481c881f8ba5bc7005d6
#: ../../java/http/client-side/request-level.rst:11
msgid ""
"The request-level API is implemented on top of a connection pool that is "
"shared inside the ActorSystem. A consequence of using a pool is that long-"
"running requests block a connection while running and starve other requests."
" Make sure not to use the request-level API for long-running requests like "
"long-polling GET requests. Use the :ref:`connection-level-api-java` instead."
msgstr ""

# b40014132c114d9483af7c61d4ad935b
#: ../../java/http/client-side/request-level.rst:16
msgid "Flow-Based Variant"
msgstr ""

# 486ed78bc9ca40548b8846d968b5d23e
#: ../../java/http/client-side/request-level.rst:18
msgid ""
"The flow-based variant of the request-level client-side API is presented by "
"the ``Http().superPool(...)`` method. It creates a new \"super connection "
"pool flow\", which routes incoming requests to a (cached) host connection "
"pool depending on their respective effective URIs."
msgstr ""

# 13ce629752c142baadb23788c0373f6a
#: ../../java/http/client-side/request-level.rst:22
msgid ""
"The ``Flow`` returned by ``Http().superPool(...)`` is very similar to the "
"one from the :ref:`host-level-api-java`, so the :ref:`using-a-host-"
"connection-pool-java` section also applies here."
msgstr ""

# 7fecc42510354730bcc81a711bd3a855
#: ../../java/http/client-side/request-level.rst:25
msgid ""
"However, there is one notable difference between a \"host connection pool "
"client flow\" for the host-level API and a \"super-pool flow\": Since in the"
" former case the flow has an implicit target host context the requests it "
"takes don't need to have absolute URIs or a valid ``Host`` header. The host "
"connection pool will automatically add a ``Host`` header if required."
msgstr ""

# 760277f0f60d41048d1efa010b406ecd
#: ../../java/http/client-side/request-level.rst:30
msgid ""
"For a super-pool flow this is not the case. All requests to a super-pool "
"must either have an absolute URI or a valid ``Host`` header, because "
"otherwise it'd be impossible to find out which target endpoint to direct the"
" request to."
msgstr ""

# 4b389a9ab58b46c5ba6fbe3330e8bf51
#: ../../java/http/client-side/request-level.rst:35
msgid "Future-Based Variant"
msgstr ""

# 2116e5d3bca9484d8d906bf0b0119d5c
#: ../../java/http/client-side/request-level.rst:37
msgid ""
"Sometimes your HTTP client needs are very basic. You simply need the HTTP "
"response for a certain request and don't want to bother with setting up a "
"full-blown streaming infrastructure."
msgstr ""

# 94972ca6479e4bf194c371748087eba2
#: ../../java/http/client-side/request-level.rst:40
msgid ""
"For these cases Akka HTTP offers the ``Http().singleRequest(...)`` method, "
"which simply turns an ``HttpRequest`` instance into "
"``CompletionStage<HttpResponse>``. Internally the request is dispatched "
"across the (cached) host connection pool for the request's effective URI."
msgstr ""

# 1486e5f420db45a6802ba79ab9b22808
#: ../../java/http/client-side/request-level.rst:44
msgid ""
"Just like in the case of the super-pool flow described above the request "
"must have either an absolute URI or a valid ``Host`` header, otherwise the "
"returned future will be completed with an error."
msgstr ""

# 8c3ebdcf0b44484a88e7d51e7e2d27c8
#: ../../java/http/client-side/request-level.rst:50
msgid "Using the Future-Based API in Actors"
msgstr ""

# 2f386d4eef4447d5af15acd15f90ac2f
#: ../../java/http/client-side/request-level.rst:51
msgid ""
"When using the ``CompletionStage`` based API from inside an ``Actor``, all "
"the usual caveats apply to how one should deal with the futures completion. "
"For example you should not access the Actors state from within the "
"CompletionStage's callbacks (such as ``map``, ``onComplete``, ...) and "
"instead you should use the ``pipe`` pattern to pipe the result back to the "
"Actor as a message:"
msgstr ""

# ea65e918b585498585b8f1f8bd9c1b34
#: ../../java/http/client-side/request-level.rst:60
msgid ""
"Be sure to consume the response entities "
"``dataBytes:Source[ByteString,Unit]`` by for example connecting it to a "
"``Sink`` (for example ``response.entity.dataBytes.runWith(Sink.ignore)`` if "
"you don't care about the response entity), since otherwise Akka HTTP (and "
"the underlying Streams infrastructure) will understand the lack of entity "
"consumption as a back-pressure signal and stop reading from the underlying "
"TCP connection!"
msgstr ""

# e85f139782df4cb5889c0cf738c46227
#: ../../java/http/client-side/request-level.rst:65
msgid ""
"This is a feature of Akka HTTP that allows consuming entities (and pulling "
"them through the network) in a streaming fashion, and only *on demand* when "
"the client is ready to consume the bytes - it may be a bit suprising at "
"first though."
msgstr ""

# c4d9e279bc154d33adefc65843ffef70
#: ../../java/http/client-side/request-level.rst:69
msgid ""
"There are tickets open about automatically dropping entities if not consumed"
" (`#18716`_ and `#18540`_), so these may be implemented in the near future."
msgstr ""

# d46ab2f391d740fcb69ea8e87b574d22
#: ../../java/http/client-side/websocket-support.rst:4
msgid "Client-Side WebSocket Support"
msgstr ""

# 2d4c8d3311654cc2bc4b520b3e115308
#: ../../java/http/client-side/websocket-support.rst:6
msgid ""
"Client side WebSocket support is available through "
"``Http.singleWebSocketRequest`` , ``Http.webSocketClientFlow`` and "
"``Http.webSocketClientLayer``."
msgstr ""

# 61dbd67de0244cc3a83a427e001158d1
#: ../../java/http/client-side/websocket-support.rst:9
msgid ""
"A WebSocket consists of two streams of messages, incoming messages (a "
":class:`Sink`) and outgoing messages (a :class:`Source`) where either may be"
" signalled first; or even be the only direction in which messages flow "
"during the lifetime of the connection. Therefore a WebSocket connection is "
"modelled as either something you connect a ``Flow<Message, Message, Mat>`` "
"to or a ``Flow<Message, Message, Mat>`` that you connect a ``Source<Message,"
" Mat>`` and a ``Sink<Message, Mat>`` to."
msgstr ""

# 5bf322091282458e9c83b9e84c6e47eb
#: ../../java/http/client-side/websocket-support.rst:15
msgid ""
"A WebSocket request starts with a regular HTTP request which contains an "
"``Upgrade`` header (and possibly other regular HTTP request properties), so "
"in addition to the flow of messages there also is an initial response from "
"the server, this is modelled with :class:`WebSocketUpgradeResponse`."
msgstr ""

# de00653042e847388ca77ef5d178a131
#: ../../java/http/client-side/websocket-support.rst:19
msgid ""
"The methods of the WebSocket client API handle the upgrade to WebSocket on "
"connection success and materializes the connected WebSocket stream. If the "
"connection fails, for example with a ``404 NotFound`` error, this regular "
"HTTP result can be found in ``WebSocketUpgradeResponse.response``"
msgstr ""

# f5b01f1b41d448abbd416c1bafa9c74d
#: ../../java/http/client-side/websocket-support.rst:25
msgid ""
"Make sure to read and understand the section about :ref:`half-closed-client-"
"websockets-java` as the behavior when using WebSockets for one-way "
"communication may not be what you would expect."
msgstr ""

# a03b0864a083482aaa2933361345f3d9
#: ../../java/http/client-side/websocket-support.rst:29
msgid "Message"
msgstr ""

# 738cb51cf82e4f8687412751f12ad6bd
#: ../../java/http/client-side/websocket-support.rst:30
msgid ""
"Messages sent and received over a WebSocket can be either "
":class:`TextMessage` s or :class:`BinaryMessage` s and each of those can be "
"either strict (all data in one chunk) or streamed. In typical applications "
"messages will be strict as WebSockets are usually deployed to communicate "
"using small messages not stream data, the protocol does however allow this "
"(by not marking the first fragment as final, as described in `rfc 6455 "
"section 5.2`__)."
msgstr ""

# bfd29fe26a2b44049279dfe816559b12
#: ../../java/http/client-side/websocket-support.rst:37
msgid ""
"The strict text is available from ``TextMessage.getStrictText`` and strict "
"binary data from ``BinaryMessage.getStrictData``."
msgstr ""

# f6160f1f9e0b48af9832689c67b8ae16
#: ../../java/http/client-side/websocket-support.rst:40
msgid ""
"For streamed messages ``BinaryMessage.getStreamedData`` and "
"``TextMessage.getStreamedText`` is used to access the data. In these cases "
"the data is provided as a ``Source<ByteString, NotUsed>`` for binary and "
"``Source<String, NotUsed>`` for text messages."
msgstr ""

# f0e993ad563941639d55962f9b8e7a55
#: ../../java/http/client-side/websocket-support.rst:46
msgid "singleWebSocketRequest"
msgstr ""

# c2d6346af2304bcb8dfb61a03c094c2a
#: ../../java/http/client-side/websocket-support.rst:47
msgid ""
"``singleWebSocketRequest`` takes a :class:`WebSocketRequest` and a flow it "
"will connect to the source and sink of the WebSocket connection. It will "
"trigger the request right away and returns a tuple containing a "
"``CompletionStage<WebSocketUpgradeResponse>`` and the materialized value "
"from the flow passed to the method."
msgstr ""

# fa9775d7c8cd498c8c91e7b548183943
#: ../../java/http/client-side/websocket-support.rst:51
msgid ""
"The future will succeed when the WebSocket connection has been established "
"or the server returned a regular HTTP response, or fail if the connection "
"fails with an exception."
msgstr ""

# 72045cd32e064c89a447a702b2c949a5
# 99053aab82bd4af9b182a436af235174
#: ../../java/http/client-side/websocket-support.rst:54
#: ../../java/http/client-side/websocket-support.rst:76
msgid "Simple example sending a message and printing any incoming message:"
msgstr ""

# dc401c45442447b49b2a8d6275841758
#: ../../java/http/client-side/websocket-support.rst:59
msgid ""
"The websocket request may also include additional headers, like in this "
"example, HTTP Basic Auth:"
msgstr ""

# 864c71ecd3cd4ba3846dd90fbd79a998
#: ../../java/http/client-side/websocket-support.rst:66
msgid "webSocketClientFlow"
msgstr ""

# 084a55f37e6c4c94a0c13c28a72cc04c
#: ../../java/http/client-side/websocket-support.rst:67
msgid ""
"``webSocketClientFlow`` takes a request, and returns a ``Flow<Message, "
"Message, CompletionStage<WebSocketUpgradeResponse>>``."
msgstr ""

# a3da4db0d660407887ee304ddf07ff3c
#: ../../java/http/client-side/websocket-support.rst:69
msgid ""
"The future that is materialized from the flow will succeed when the "
"WebSocket connection has been established or the server returned a regular "
"HTTP response, or fail if the connection fails with an exception."
msgstr ""

# e5c62a0900d2497587714b8c02890a0b
#: ../../java/http/client-side/websocket-support.rst:73
msgid ""
"The :class:`Flow` that is returned by this method can only be materialized "
"once. For each request a new flow must be acquired by calling the method "
"again."
msgstr ""

# 8bc45204c33a42c580a0bc0db8f96f07
#: ../../java/http/client-side/websocket-support.rst:84
msgid "webSocketClientLayer"
msgstr ""

# 792a5cd3fb7e4004b739b2041f437c28
#: ../../java/http/client-side/websocket-support.rst:85
msgid ""
"Just like the :ref:`http-client-layer-java` for regular HTTP requests, the "
"WebSocket layer can be used fully detached from the underlying TCP "
"interface. The same scenarios as described for regular HTTP requests apply "
"here."
msgstr ""

# 275a2ec3d699424ea209c454c6446a1f
#: ../../java/http/client-side/websocket-support.rst:88
msgid ""
"The returned layer forms a ``BidiFlow<Message, SslTlsOutbound, "
"SslTlsInbound, Message, CompletionStage<WebSocketUpgradeResponse>>``."
msgstr ""

# 5443fd228ce74689b6bb681098174f7a
#: ../../java/http/client-side/websocket-support.rst:94
msgid "Half-Closed WebSockets"
msgstr ""

# 2ae976f3d1304dd5a95d578961bbf172
#: ../../java/http/client-side/websocket-support.rst:95
msgid ""
"The Akka HTTP WebSocket API does not support half-closed connections which "
"means that if the either stream completes the entire connection is closed "
"(after a \"Closing Handshake\" has been exchanged or a timeout of 3 seconds "
"has passed). This may lead to unexpected behavior, for example if we are "
"trying to only consume messages coming from the server, like this:"
msgstr ""

# 11d057053baf4efb823904b028763c50
#: ../../java/http/client-side/websocket-support.rst:103
msgid ""
"This will in fact quickly close the connection because of the "
"``Source.empty`` being completed immediately when the stream is "
"materialized. To solve this you can make sure to not complete the outgoing "
"source by using for example ``Source.maybe`` like this:"
msgstr ""

# 0cdee771b6094aebb5ffe3b0e10dae3a
#: ../../java/http/client-side/websocket-support.rst:110
msgid ""
"This will keep the outgoing source from completing, but without emitting any"
" elements until the ``CompletableFuture`` is manually completed which makes "
"the ``Source`` complete and the connection to close."
msgstr ""

# b193079126114b7c9ab48256261f0df7
#: ../../java/http/client-side/websocket-support.rst:113
msgid ""
"The same problem holds true if emitting a finite number of elements, as soon"
" as the last element is reached the ``Source`` will close and cause the "
"connection to close. To avoid that you can concatenate ``Source.maybe`` to "
"the finite stream:"
msgstr ""

# cbe6fabe6936483189218bfc8a822d82
#: ../../java/http/client-side/websocket-support.rst:119
msgid ""
"Scenarios that exist with the two streams in a WebSocket and possible ways "
"to deal with it:"
msgstr ""

# 46aacb0a908b4676b7443c4604757dc0
#: ../../java/http/client-side/websocket-support.rst:122
msgid "Scenario"
msgstr ""

# e1fd0d556baf4f58a6d78434a9ea6f8c
#: ../../java/http/client-side/websocket-support.rst:122
msgid "Possible solution"
msgstr ""

# 1a374a8f04f84b34ad284812c9738e2c
#: ../../java/http/client-side/websocket-support.rst:124
msgid "Two-way communication"
msgstr ""

# c51ceb1b28f24aca96e9e37a5ca10a13
#: ../../java/http/client-side/websocket-support.rst:124
msgid ""
"``Flow.fromSinkAndSource``, or ``Flow.map`` for a request-response protocol"
msgstr ""

# ac7034483dd247eba8a934142cbb850e
#: ../../java/http/client-side/websocket-support.rst:125
msgid "Infinite incoming stream, no outgoing"
msgstr ""

# 6d807271b3f64a8f9e862c1558e4ee17
#: ../../java/http/client-side/websocket-support.rst:125
msgid "``Flow.fromSinkAndSource(someSink, Source.maybe())``"
msgstr ""

# 8f1a07fbc6b346f3aa71c219f3ebd950
#: ../../java/http/client-side/websocket-support.rst:126
msgid "Infinite outgoing stream, no incoming"
msgstr ""

# 7c5689dd76d843e6b8812db31faca506
#: ../../java/http/client-side/websocket-support.rst:126
msgid "``Flow.fromSinkAndSource(Sink.ignore(), yourSource)``"
msgstr ""

# 9900b5b0a4eb4cc79939c72517d6fe62
#: ../../java/http/common/de-coding.rst:2
msgid "Encoding / Decoding"
msgstr ""

# ef9ae87ca25f4bd5b4584a3a74624213
#: ../../java/http/common/de-coding.rst:4
msgid ""
"The `HTTP spec`_ defines a ``Content-Encoding`` header, which signifies "
"whether the entity body of an HTTP message is \"encoded\" and, if so, by "
"which algorithm. The only commonly used content encodings are compression "
"algorithms."
msgstr ""

# 4a3281a624914dd4928f290821aa2fa6
#: ../../java/http/common/de-coding.rst:7
msgid ""
"Currently Akka HTTP supports the compression and decompression of HTTP "
"requests and responses with the ``gzip`` or ``deflate`` encodings. The core "
"logic for this lives in the `akka.http.scaladsl.coding`_ package."
msgstr ""

# 03402131606241d28a1b1eed161757a4
#: ../../java/http/common/de-coding.rst:11
msgid ""
"The support is not enabled automatically, but must be explicitly requested. "
"For enabling message encoding/decoding with :ref:`Routing DSL <http-high-"
"level-server-side-api>` see the :ref:`CodingDirectives`."
msgstr ""

# 627cc0d1487b4ed8a6ef35cf0e7fe9f0
#: ../../java/http/common/index.rst:4
msgid "Common Abstractions (Client- and Server-Side)"
msgstr ""

# 22391a3b6a174f578b01640462fe7030
#: ../../java/http/common/index.rst:6
msgid ""
"HTTP and related specifications define a great number of concepts and "
"functionality that is not specific to either HTTP's client- or server-side "
"since they are meaningful on both end of an HTTP connection. The "
"documentation for their counterparts in Akka HTTP lives in this section "
"rather than in the ones for the :ref:`Client-Side API <http-client-side>`, "
":ref:`http-low-level-server-side-api` or :ref:`http-high-level-server-side-"
"api`, which are specific to one side only."
msgstr ""

# 161323ff56b841278effa2bc86ed8d26
#: ../../java/http/common/json-support.rst:4
msgid "Json Support"
msgstr ""

# 84563c63af6c4ce69a164daaa54548dd
#: ../../java/http/common/json-support.rst:6
msgid ""
"akka-http provides support to convert application-domain objects from and to"
" JSON using jackson_ in an extra artifact."
msgstr ""

# b16ac22e3a124efcb6bd8fd0e879092b
#: ../../java/http/common/json-support.rst:9
msgid ""
"Integration with other JSON libraries may be supported by the community. See"
" `the list of current community extensions for Akka HTTP`_."
msgstr ""

# 32cb4b600be94fe29d73efb5cab4bf98
#: ../../java/http/common/json-support.rst:17
msgid "Json Support via Jackson"
msgstr ""

# 0b44c0df1802498389b071f52b60b5a4
#: ../../java/http/common/json-support.rst:19
msgid ""
"To make use of the support module, you need to add a dependency on `akka-"
"http-jackson-experimental`."
msgstr ""

# 338d1765478e42c7855ef88364635f2a
#: ../../java/http/common/json-support.rst:21
msgid ""
"Use ``akka.http.javadsl.marshallers.jackson.Jackson.unmarshaller(T.class)`` "
"to create an ``Unmarshaller<HttpEntity,T>`` which expects the request body "
"(HttpEntity) to be of type ``application/json`` and converts it to ``T`` "
"using Jackson."
msgstr ""

# 69b02fbe20d043ca8cbe0099d19b5d66
#: ../../java/http/common/json-support.rst:24
msgid "See `this example`__ in the sources for an example."
msgstr ""

# d1e9ef2274b248eba0851a52aee1ad87
#: ../../java/http/common/json-support.rst:26
msgid ""
"Use ``akka.http.javadsl.marshallers.jackson.Jackson.marshaller(T.class)`` to"
" create a ``Marshaller<T,RequestEntity>`` which can be used with "
"``RequestContext.complete`` or ``RouteDirectives.complete`` to convert a "
"POJO to an HttpResponse."
msgstr ""

# d2adb2508ab64befaa50c9189ea9ee1c
# f0a8e7b44dc64f2899240d329d4a257f
#: ../../java/http/common/marshalling.rst:4
#: ../../java/http/routing-dsl/marshalling.rst:14
msgid "Marshalling"
msgstr ""

# 8b86f637e9204e5ebedabc44082d0bfc
# dd727c85d25a487985e7676abb47ba56
#: ../../java/http/common/marshalling.rst:5
#: ../../java/http/common/unmarshalling.rst:5
msgid "TODO overhaul for Java"
msgstr ""

# 77e76da8e85e4b84af094f6304bad354
#: ../../java/http/common/marshalling.rst:7
msgid ""
"\"Marshalling\" is the process of converting a higher-level (object) "
"structure into some kind of lower-level representation, often a \"wire "
"format\". Other popular names for it are \"Serialization\" or \"Pickling\"."
msgstr ""

# 13f82d487d3a4cbfa3fff6d93ec93559
#: ../../java/http/common/marshalling.rst:10
msgid ""
"In Akka HTTP \"Marshalling\" means the conversion of an object of type ``T``"
" into a lower-level target type, e.g. a ``MessageEntity`` (which forms the "
"\"entity body\" of an HTTP request or response) or a full ``HttpRequest`` or"
" ``HttpResponse``."
msgstr ""

# 895e0031e7a04406a30db77dbf90e151
# 47522b240b524458a1fec68014e831e0
#: ../../java/http/common/marshalling.rst:16
#: ../../java/http/common/unmarshalling.rst:16
msgid "Basic Design"
msgstr ""

# e0378e1d5e124695b35852a598e485b1
#: ../../java/http/common/marshalling.rst:18
msgid ""
"Marshalling of instances of type ``A`` into instances of type ``B`` is "
"performed by a ``Marshaller[A, B]``. Akka HTTP also predefines a number of "
"helpful aliases for the types of marshallers that you'll likely work with "
"most:"
msgstr ""

# c6bd432acf7e4834af25719131a8631a
#: ../../java/http/common/marshalling.rst:24
msgid ""
"Contrary to what you might initially expect ``Marshaller[A, B]`` is not a "
"plain function ``A => B`` but rather essentially a function ``A => "
"Future[List[Marshalling[B]]]``. Let's dissect this rather complicated "
"looking signature piece by piece to understand what marshallers are designed"
" this way. Given an instance of type ``A`` a ``Marshaller[A, B]`` produces:"
msgstr ""

# d72de92c7859413c86db39aa26dbdda2
#: ../../java/http/common/marshalling.rst:30
msgid ""
"1. A ``Future``: This is probably quite clear. Marshallers are not required "
"to synchronously produce a result, so instead they return a future, which "
"allows for asynchronicity in the marshalling process."
msgstr ""

# 5c79516dcfb445c0a16bac38b5ea815e
#: ../../java/http/common/marshalling.rst:33
msgid ""
"2. of ``List``: Rather than only a single target representation for ``A`` "
"marshallers can offer several ones. Which one will be rendered onto the wire"
" in the end is decided by content negotiation. For example, the "
"``ToEntityMarshaller[OrderConfirmation]`` might offer a JSON as well as an "
"XML representation. The client can decide through the addition of an "
"``Accept`` request header which one is preferred. If the client doesn't "
"express a preference the first representation is picked."
msgstr ""

# cd5c3b92dee5449c9624dfc532cbbedb
#: ../../java/http/common/marshalling.rst:39
msgid ""
"3. of ``Marshalling[B]``: Rather than returning an instance of ``B`` "
"directly marshallers first produce a ``Marshalling[B]``. This allows for "
"querying the ``MediaType`` and potentially the ``HttpCharset`` that the "
"marshaller will produce before the actual marshalling is triggered. Apart "
"from enabling content negotiation this design allows for delaying the actual"
" construction of the marshalling target instance to the very last moment "
"when it is really needed."
msgstr ""

# d9d76641f2734b2ba25a26b704539d92
#: ../../java/http/common/marshalling.rst:44
msgid "This is how ``Marshalling`` is defined:"
msgstr ""

# b7d7f9bddbc245b6ba96d2d44a313ae5
#: ../../java/http/common/marshalling.rst:51
msgid "Predefined Marshallers"
msgstr ""

# f7da4c25401d4088be25a675bf14569a
# 2fcd4e95b694475596ac27a80a8812eb
#: ../../java/http/common/marshalling.rst:53
#: ../../java/http/common/unmarshalling.rst:32
msgid ""
"Akka HTTP already predefines a number of marshallers for the most common "
"types. Specifically these are:"
msgstr ""

# 845b1d1dd75249e0b59423354103de7e
#: ../../java/http/common/marshalling.rst:56
msgid "PredefinedToEntityMarshallers_"
msgstr ""

# c62d5afb3298424ba2232c2fbc5aeab2
# 2085ae76ec694479b34e9a6a5627ab17
#: ../../java/http/common/marshalling.rst:58
#: ../../java/http/common/unmarshalling.rst:47
msgid "``Array[Byte]``"
msgstr ""

# 302fa67eb71b4293938301ae79e0f2f2
# 713e580773a0460ebdb79323e37e7f3a
#: ../../java/http/common/marshalling.rst:59
#: ../../java/http/common/unmarshalling.rst:48
msgid "``ByteString``"
msgstr ""

# cb8cc58580d34275a610e607bc99c0b2
# 9e71931395be4dc4a6daf2695b90e829
#: ../../java/http/common/marshalling.rst:60
#: ../../java/http/common/unmarshalling.rst:49
msgid "``Array[Char]``"
msgstr ""

# f57be71ffd444a188ca46507a9fb6cdd
# 212caf32a35b4eb5a7c7667fb6edacd3
#: ../../java/http/common/marshalling.rst:61
#: ../../java/http/common/unmarshalling.rst:50
msgid "``String``"
msgstr ""

# bfaf1ecfee4a40bb883abd8f549d83ae
# f2222bde429f47ba9a80259c2c3a745a
#: ../../java/http/common/marshalling.rst:62
#: ../../java/http/common/unmarshalling.rst:51
msgid "``akka.http.scaladsl.model.FormData``"
msgstr ""

# d532dd31f26743fc96bfa0c7f58edc33
#: ../../java/http/common/marshalling.rst:63
msgid "``akka.http.scaladsl.model.MessageEntity``"
msgstr ""

# 02f3359b71c44bdaa7eb998c41711cf4
#: ../../java/http/common/marshalling.rst:64
msgid "``T <: akka.http.scaladsl.model.Multipart``"
msgstr ""

# fb94d8018ce84dce9ade493a8f8a7515
#: ../../java/http/common/marshalling.rst:66
msgid "PredefinedToResponseMarshallers_"
msgstr ""

# abba691acc164ba4862d063b56293234
#: ../../java/http/common/marshalling.rst:68
msgid "``T``, if a ``ToEntityMarshaller[T]`` is available"
msgstr ""

# 4d0076392de946ac9fc639774bf07ec3
#: ../../java/http/common/marshalling.rst:69
msgid "``HttpResponse``"
msgstr ""

# e2ed36a3dbaa42778395c6f5008fc22b
#: ../../java/http/common/marshalling.rst:70
msgid "``StatusCode``"
msgstr ""

# b6676ff5ea304c9e942694e87bbf804d
#: ../../java/http/common/marshalling.rst:71
msgid "``(StatusCode, T)``, if a ``ToEntityMarshaller[T]`` is available"
msgstr ""

# d82003c2d9564fff81762c886e9c4cac
#: ../../java/http/common/marshalling.rst:72
msgid "``(Int, T)``, if a ``ToEntityMarshaller[T]`` is available"
msgstr ""

# b589ef7bbfaf4aff9524b81528964ef4
#: ../../java/http/common/marshalling.rst:73
msgid ""
"``(StatusCode, immutable.Seq[HttpHeader], T)``, if a "
"``ToEntityMarshaller[T]`` is available"
msgstr ""

# d6588d146b254886ba5107eaeef0db9a
#: ../../java/http/common/marshalling.rst:74
msgid ""
"``(Int, immutable.Seq[HttpHeader], T)``, if a ``ToEntityMarshaller[T]`` is "
"available"
msgstr ""

# ad861757ed35451ab15eedbd93226396
#: ../../java/http/common/marshalling.rst:76
msgid "PredefinedToRequestMarshallers_"
msgstr ""

# 767a674cd8eb445eb181357a8973f542
#: ../../java/http/common/marshalling.rst:78
msgid "``HttpRequest``"
msgstr ""

# 3317ba7f1c424c90ab867bb45a317fed
#: ../../java/http/common/marshalling.rst:79
msgid "``Uri``"
msgstr ""

# 594da12f85424c4f97c952eaf56b68e7
#: ../../java/http/common/marshalling.rst:80
msgid "``(HttpMethod, Uri, T)``, if a ``ToEntityMarshaller[T]`` is available"
msgstr ""

# 6d92ba7e06f040d3aad17aeb2e97d795
#: ../../java/http/common/marshalling.rst:81
msgid ""
"``(HttpMethod, Uri, immutable.Seq[HttpHeader], T)``, if a "
"``ToEntityMarshaller[T]`` is available"
msgstr ""

# ec3d6137f2204ea3ba6c5486cb65fb18
#: ../../java/http/common/marshalling.rst:83
msgid "GenericMarshallers_"
msgstr ""

# 96b5af93e8744b1f8788ce9a8489d2e9
#: ../../java/http/common/marshalling.rst:85
msgid "``Marshaller[Throwable, T]``"
msgstr ""

# 62774c17a6a14641b28309ce8e0795d1
#: ../../java/http/common/marshalling.rst:86
msgid ""
"``Marshaller[Option[A], B]``, if a ``Marshaller[A, B]`` and an "
"``EmptyValue[B]`` is available"
msgstr ""

# 551bac0620604836b49f22a7ecf1aeac
#: ../../java/http/common/marshalling.rst:87
msgid ""
"``Marshaller[Either[A1, A2], B]``, if a ``Marshaller[A1, B]`` and a "
"``Marshaller[A2, B]`` is available"
msgstr ""

# 48c2dc3b350f42059352a66efa7aae57
#: ../../java/http/common/marshalling.rst:88
msgid "``Marshaller[Future[A], B]``, if a ``Marshaller[A, B]`` is available"
msgstr ""

# 2da37fb1e5804b43973d2477e973b14d
#: ../../java/http/common/marshalling.rst:89
msgid "``Marshaller[Try[A], B]``, if a ``Marshaller[A, B]`` is available"
msgstr ""

# b6734020662c4a0db30d51612b9b1dc2
# 3139dfe10e0942068fea370604c8a29d
#: ../../java/http/common/marshalling.rst:98
#: ../../java/http/common/unmarshalling.rst:65
msgid "Implicit Resolution"
msgstr ""

# d928c51adc914f4aaf4cfa1cd234d9dc
#: ../../java/http/common/marshalling.rst:100
msgid ""
"The marshalling infrastructure of Akka HTTP relies on a type-class based "
"approach, which means that ``Marshaller`` instances from a certain type "
"``A`` to a certain type ``B`` have to be available implicitly."
msgstr ""

# ef65728668ef43418058f2fe9f7c62be
#: ../../java/http/common/marshalling.rst:103
msgid ""
"The implicits for most of the predefined marshallers in Akka HTTP are "
"provided through the companion object of the ``Marshaller`` trait. This "
"means that they are always available and never need to be explicitly "
"imported. Additionally, you can simply \"override\" them by bringing your "
"own custom version into local scope."
msgstr ""

# 699e2ab7a5f149d7ba29f121f9f6948d
#: ../../java/http/common/marshalling.rst:109
msgid "Custom Marshallers"
msgstr ""

# f587bc8f15164dd5969b465902eb1b6d
#: ../../java/http/common/marshalling.rst:111
msgid ""
"Akka HTTP gives you a few convenience tools for constructing marshallers for"
" your own types. Before you do that you need to think about what kind of "
"marshaller you want to create. If all your marshaller needs to produce is a "
"``MessageEntity`` then you should probably provide a "
"``ToEntityMarshaller[T]``. The advantage here is that it will work on both "
"the client- as well as the server-side since a ``ToResponseMarshaller[T]`` "
"as well as a ``ToRequestMarshaller[T]`` can automatically be created if a "
"``ToEntityMarshaller[T]`` is available."
msgstr ""

# 8e6c0478bf3642dd9b2fe09122591584
#: ../../java/http/common/marshalling.rst:118
msgid ""
"If, however, your marshaller also needs to set things like the response "
"status code, the request method, the request URI or any headers then a "
"``ToEntityMarshaller[T]`` won't work. You'll need to fall down to providing "
"a ``ToResponseMarshaller[T]`` or a ``ToRequestMarshaller[T]`` directly."
msgstr ""

# 77b63c0f07b946498dac6e966c1dd65e
#: ../../java/http/common/marshalling.rst:122
msgid ""
"For writing your own marshallers you won't have to \"manually\" implement "
"the ``Marshaller`` trait directly. Rather, it should be possible to use one "
"of the convenience construction helpers defined on the ``Marshaller`` "
"companion:"
msgstr ""

# 090ff08106034daab346e163d376745e
#: ../../java/http/common/marshalling.rst:131
msgid "Deriving Marshallers"
msgstr ""

# 49c3f8a33fc04434a1dc0d2757761794
#: ../../java/http/common/marshalling.rst:133
msgid ""
"Sometimes you can save yourself some work by reusing existing marshallers "
"for your custom ones. The idea is to \"wrap\" an existing marshaller with "
"some logic to \"re-target\" it to your type."
msgstr ""

# e5ffb007dc5744ce9bb2e38eacc2452c
#: ../../java/http/common/marshalling.rst:136
msgid ""
"In this regard wrapping a marshaller can mean one or both of the following "
"two things:"
msgstr ""

# c6253f73c80d48d79f60abc2c8ab5cd5
#: ../../java/http/common/marshalling.rst:138
msgid "Transform the input before it reaches the wrapped marshaller"
msgstr ""

# be123cd5ed174e7eb54bc7d2b6cde77e
#: ../../java/http/common/marshalling.rst:139
msgid "Transform the output of the wrapped marshaller"
msgstr ""

# 01f1daab411944228d8a9407ca895016
#: ../../java/http/common/marshalling.rst:141
msgid ""
"For the latter (transforming the output) you can use ``baseMarshaller.map``,"
" which works exactly as it does for functions. For the former (transforming "
"the input) you have four alternatives:"
msgstr ""

# f5b773184fdb465193cc3fd7fed09660
#: ../../java/http/common/marshalling.rst:144
msgid "``baseMarshaller.compose``"
msgstr ""

# 23fe1180f20048a39cb8fb01b139478a
#: ../../java/http/common/marshalling.rst:145
msgid "``baseMarshaller.composeWithEC``"
msgstr ""

# 9af91bfd71e0456fbe76c7f136dc9447
#: ../../java/http/common/marshalling.rst:146
msgid "``baseMarshaller.wrap``"
msgstr ""

# 72f167abf70f448db886c033d3bbc4d9
#: ../../java/http/common/marshalling.rst:147
msgid "``baseMarshaller.wrapWithEC``"
msgstr ""

# 23dd74c856d74e5b9b95dcec9575e3b7
#: ../../java/http/common/marshalling.rst:149
msgid ""
"``compose`` works just like it does for functions. ``wrap`` is a compose "
"that allows you to also change the ``ContentType`` that the marshaller "
"marshals to. The ``...WithEC`` variants allow you to receive an "
"``ExecutionContext`` internally if you need one, without having to depend on"
" one being available implicitly at the usage site."
msgstr ""

# 077118b737ee4c4b9b8c8d0848b5cc4b
#: ../../java/http/common/marshalling.rst:156
msgid "Using Marshallers"
msgstr ""

# 063f4b65a96c4955ac80caa12fe957e0
#: ../../java/http/common/marshalling.rst:158
msgid ""
"In many places throughput Akka HTTP marshallers are used implicitly, e.g. "
"when you define how to :ref:`-complete-` a request using the :ref:`Routing "
"DSL <http-high-level-server-side-api>`."
msgstr ""

# 09fbf0c8f98848eda1934bf66af7886a
#: ../../java/http/common/marshalling.rst:161
msgid ""
"However, you can also use the marshalling infrastructure directly if you "
"wish, which can be useful for example in tests. The best entry point for "
"this is the ``akka.http.scaladsl.marshalling.Marshal`` object, which you can"
" use like this:"
msgstr ""

# d25eed8b2bba48079f25309e7778ca7e
#: ../../java/http/common/timeouts.rst:4
msgid "Akka HTTP Timeouts"
msgstr ""

# d3f3a224844a410fa82f017580930c7a
#: ../../java/http/common/timeouts.rst:6
msgid ""
"Akka HTTP comes with a variety of built-in timeout mechanisms to protect "
"your servers from malicious attacks or programming mistakes. Some of these "
"are simply configuration options (which may be overriden in code) while "
"others are left to the streaming APIs and are easily implementable as "
"patterns in user-code directly."
msgstr ""

# d89711bdf5e04a5ebd1589481b83a2f4
#: ../../java/http/common/timeouts.rst:11
msgid "Common timeouts"
msgstr ""

# a7f4455f31ca47b4a3e94df1130c7df7
#: ../../java/http/common/timeouts.rst:16
msgid "Idle timeouts"
msgstr ""

# 6587de4056cf4c31aeae7b2617a7e588
#: ../../java/http/common/timeouts.rst:18
msgid ""
"The ``idle-timeout`` is a global setting which sets the maximum inactivity "
"time of a given connection. In other words, if a connection is open but no "
"request/response is being written to it for over ``idle-timeout`` time, the "
"connection will be automatically closed."
msgstr ""

# 2545d9ef389747a28846a3c6b87480ff
#: ../../java/http/common/timeouts.rst:22
msgid ""
"The setting works the same way for all connections, be it server-side or "
"client-side, and it's configurable independently for each of those using the"
" following keys::"
msgstr ""

# 6062c61dbb3143d2b1a5b4e68f3078a4
#: ../../java/http/common/timeouts.rst:31
msgid ""
"For the connection pooled client side the idle period is counted only when "
"the pool has no pending requests waiting."
msgstr ""

# 0b34adabe8cc4f60b2ec109f563c54cf
#: ../../java/http/common/timeouts.rst:35
msgid "Server timeouts"
msgstr ""

# c0fe1212ae1d4ad48b87994936dea727
#: ../../java/http/common/timeouts.rst:40
msgid "Request timeout"
msgstr ""

# efc715cc41504a749caea6adb1cf7a1f
#: ../../java/http/common/timeouts.rst:42
msgid ""
"Request timeouts are a mechanism that limits the maximum time it may take to"
" produce an ``HttpResponse`` from a route. If that deadline is not met the "
"server will automatically inject a Service Unavailable HTTP response and "
"close the connection to prevent it from leaking and staying around "
"indefinitely (for example if by programming error a Future would never "
"complete, never sending the real response otherwise)."
msgstr ""

# 0b6f97a0f033455687a38eeeb3f89f1e
#: ../../java/http/common/timeouts.rst:47
msgid ""
"The default ``HttpResponse`` that is written when a request timeout is "
"exceeded looks like this:"
msgstr ""

# f9849dcfdf504cd0beb7ea0a22ea68c7
#: ../../java/http/common/timeouts.rst:52
msgid ""
"A default request timeout is applied globally to all routes and can be "
"configured using the ``akka.http.server.request-timeout`` setting (which "
"defaults to 20 seconds)."
msgstr ""

# ddc2cb898c12487388f5403dc6804a06
#: ../../java/http/common/timeouts.rst:56
msgid ""
"Please note that if multiple requests (``R1,R2,R3,...``) were sent by a "
"client (see \"HTTP pipelining\") using the same connection and the ``n-th`` "
"request triggers a request timeout the server will reply with an Http "
"Response and close the connection, leaving the ``(n+1)-th`` (and subsequent "
"requests on the same connection) unhandled."
msgstr ""

# ee8805877b5048669597daafa0658dd3
#: ../../java/http/common/timeouts.rst:60
msgid ""
"The request timeout can be configured at run-time for a given route using "
"the any of the :ref:`TimeoutDirectives`."
msgstr ""

# 5daf9525c2254094a8f321f166f022f1
#: ../../java/http/common/timeouts.rst:63
msgid "Bind timeout"
msgstr ""

# 5eaf28dd21004b239d1ca7ecdffc0049
#: ../../java/http/common/timeouts.rst:65
msgid ""
"The bind timeout is the time period within which the TCP binding process "
"must be completed (using any of the ``Http().bind*`` methods). It can be "
"configured using the ``akka.http.server.bind-timeout`` setting."
msgstr ""

# 57239c429353484b93fc7564f99175ea
#: ../../java/http/common/timeouts.rst:69
msgid "Client timeouts"
msgstr ""

# be67e80c0378488fb2f1eecf762af30c
#: ../../java/http/common/timeouts.rst:72
msgid "Connecting timeout"
msgstr ""

# 644e6838be0c45ceaf5e851529e6b09a
#: ../../java/http/common/timeouts.rst:74
msgid ""
"The connecting timeout is the time period within which the TCP connecting "
"process must be completed. Tweaking it should rarely be required, but it "
"allows erroring out the connection in case a connection is unable to be "
"established for a given amount of time."
msgstr ""

# a36479c460c7439b91cf53fe45b31f4d
#: ../../java/http/common/timeouts.rst:78
msgid ""
"it can be configured using the ``akka.http.client.connecting-timeout`` "
"setting."
msgstr ""

# 46e84289d8b94295bc6f4cd541b232b1
# 2953cac612164a348ec72f14ff5611be
#: ../../java/http/common/unmarshalling.rst:4
#: ../../java/http/routing-dsl/marshalling.rst:31
msgid "Unmarshalling"
msgstr ""

# c9f2615e52be4cb083a6986e7093997e
#: ../../java/http/common/unmarshalling.rst:7
msgid ""
"\"Unmarshalling\" is the process of converting some kind of a lower-level "
"representation, often a \"wire format\", into a higher-level (object) "
"structure. Other popular names for it are \"Deserialization\" or "
"\"Unpickling\"."
msgstr ""

# 5f7f5a8e818d47f5a66c636e4ac5ebec
#: ../../java/http/common/unmarshalling.rst:10
msgid ""
"In Akka HTTP \"Unmarshalling\" means the conversion of a lower-level source "
"object, e.g. a ``MessageEntity`` (which forms the \"entity body\" of an HTTP"
" request or response) or a full ``HttpRequest`` or ``HttpResponse``, into an"
" instance of type ``T``."
msgstr ""

# 040958efc77946efb9e816a56f770543
#: ../../java/http/common/unmarshalling.rst:18
msgid ""
"Unmarshalling of instances of type ``A`` into instances of type ``B`` is "
"performed by an ``Unmarshaller[A, B]``. Akka HTTP also predefines a number "
"of helpful aliases for the types of unmarshallers that you'll likely work "
"with most:"
msgstr ""

# 282e9f3a85d84ec18ef40a364c9c654d
#: ../../java/http/common/unmarshalling.rst:24
msgid ""
"At its core an ``Unmarshaller[A, B]`` is very similar to a ``Function<A, "
"CompletionStage<B>>`` and as such quite a bit simpler than its "
":ref:`marshalling <http-marshalling-java>` counterpart. The process of "
"unmarshalling does not have to support content negotiation which saves two "
"additional layers of indirection that are required on the marshalling side."
msgstr ""

# 890d8ddd027d4f3bae3d492ea026b6d7
#: ../../java/http/common/unmarshalling.rst:30
msgid "Predefined Unmarshallers"
msgstr ""

# 634b2623ec274741b90543e38e14f03a
#: ../../java/http/common/unmarshalling.rst:35
msgid "PredefinedFromStringUnmarshallers_"
msgstr ""

# c206ec81fd05440bbd225ad2d768d604
#: ../../java/http/common/unmarshalling.rst:37
msgid "``Byte``"
msgstr ""

# 94a577d0638c42aabc2627ba46165cbc
#: ../../java/http/common/unmarshalling.rst:38
msgid "``Short``"
msgstr ""

# 2cb32782ba2349ae84f3186f84f0d92f
#: ../../java/http/common/unmarshalling.rst:39
msgid "``Int``"
msgstr ""

# 034939d33f5e49059e0754ef0687a157
#: ../../java/http/common/unmarshalling.rst:40
msgid "``Long``"
msgstr ""

# cda8289108714942bf0f0cfad31b9388
#: ../../java/http/common/unmarshalling.rst:41
msgid "``Float``"
msgstr ""

# 5f6ee864da4548aba7487631d0b38225
#: ../../java/http/common/unmarshalling.rst:42
msgid "``Double``"
msgstr ""

# b91d3c8fbbd7436b9736912d6a63d1d1
#: ../../java/http/common/unmarshalling.rst:43
msgid "``Boolean``"
msgstr ""

# 30ce402010d84a25a4c9a7819f174a19
#: ../../java/http/common/unmarshalling.rst:45
msgid "PredefinedFromEntityUnmarshallers_"
msgstr ""

# 0f237376eed14323bf9f9a0b5585959c
#: ../../java/http/common/unmarshalling.rst:53
msgid "GenericUnmarshallers_"
msgstr ""

# f84bef85991741769183cb0010944606
#: ../../java/http/common/unmarshalling.rst:55
msgid "``Unmarshaller[T, T]`` (identity unmarshaller)"
msgstr ""

# f9a90d472c364042985ae0a8641d186b
#: ../../java/http/common/unmarshalling.rst:56
msgid ""
"``Unmarshaller[Option[A], B]``, if an ``Unmarshaller[A, B]`` is available"
msgstr ""

# e64b6af618f44e439b1d7bff4dc67968
#: ../../java/http/common/unmarshalling.rst:57
msgid ""
"``Unmarshaller[A, Option[B]]``, if an ``Unmarshaller[A, B]`` is available"
msgstr ""

# d4a99667fa6f4ceb9ce5d26dfe9d97fe
#: ../../java/http/common/unmarshalling.rst:67
msgid ""
"The unmarshalling infrastructure of Akka HTTP relies on a type-class based "
"approach, which means that ``Unmarshaller`` instances from a certain type "
"``A`` to a certain type ``B`` have to be available implicitly."
msgstr ""

# 4344dd8e01bd4882b95b3e09e8457068
#: ../../java/http/common/unmarshalling.rst:70
msgid ""
"The implicits for most of the predefined unmarshallers in Akka HTTP are "
"provided through the companion object of the ``Unmarshaller`` trait. This "
"means that they are always available and never need to be explicitly "
"imported. Additionally, you can simply \"override\" them by bringing your "
"own custom version into local scope."
msgstr ""

# 6958da3521304612b0e2945e64945579
#: ../../java/http/common/unmarshalling.rst:76
msgid "Custom Unmarshallers"
msgstr ""

# 611228fceb3948af9dcc8da2f1a79e1d
#: ../../java/http/common/unmarshalling.rst:78
msgid ""
"Akka HTTP gives you a few convenience tools for constructing unmarshallers "
"for your own types. Usually you won't have to \"manually\" implement the "
"``Unmarshaller`` trait directly. Rather, it should be possible to use one of"
" the convenience construction helpers defined on the ``Unmarshaller`` "
"companion:"
msgstr ""

# b424024699d544e9ab18996eed66b83c
#: ../../java/http/common/unmarshalling.rst:83
msgid "TODO rewrite sample for Java"
msgstr ""

# d6a12c3485644a878f1dbbebb31178e4
#: ../../java/http/common/unmarshalling.rst:91
msgid "Deriving Unmarshallers"
msgstr ""

# ff88fcfc2e2f4970af5ed493da3e9ded
#: ../../java/http/common/unmarshalling.rst:93
msgid ""
"Sometimes you can save yourself some work by reusing existing unmarshallers "
"for your custom ones. The idea is to \"wrap\" an existing unmarshaller with "
"some logic to \"re-target\" it to your type."
msgstr ""

# ad4352fc590d4f1599d98c229636be84
#: ../../java/http/common/unmarshalling.rst:96
msgid ""
"Usually what you want to do is to transform the output of some existing "
"unmarshaller and convert it to your type. For this type of unmarshaller "
"transformation Akka HTTP defines these methods:"
msgstr ""

# b17b3606c70f48eb8a832b719df303af
#: ../../java/http/common/unmarshalling.rst:99
msgid "``baseUnmarshaller.transform``"
msgstr ""

# d86666df4f804769a518740f1de10398
#: ../../java/http/common/unmarshalling.rst:100
msgid "``baseUnmarshaller.map``"
msgstr ""

# 8569270f07814e6ca8baef4c1beb9804
#: ../../java/http/common/unmarshalling.rst:101
msgid "``baseUnmarshaller.mapWithInput``"
msgstr ""

# d7b3558e73ae43fd8494325bad4ca4f8
#: ../../java/http/common/unmarshalling.rst:102
msgid "``baseUnmarshaller.flatMap``"
msgstr ""

# 31261b25d0e04c2981464f647b38c6ce
#: ../../java/http/common/unmarshalling.rst:103
msgid "``baseUnmarshaller.flatMapWithInput``"
msgstr ""

# 874af32cc69e4731b5dd3fca2f170f61
#: ../../java/http/common/unmarshalling.rst:104
msgid "``baseUnmarshaller.recover``"
msgstr ""

# aae8155ab2d743fd877446f8f0c7d694
#: ../../java/http/common/unmarshalling.rst:105
msgid "``baseUnmarshaller.withDefaultValue``"
msgstr ""

# ff1760a79b1e4cb2aa584ac780c3614f
#: ../../java/http/common/unmarshalling.rst:106
msgid ""
"``baseUnmarshaller.mapWithCharset`` (only available for "
"FromEntityUnmarshallers)"
msgstr ""

# 3d21e8692c8b4ec2a3ef70ebbe66b64f
#: ../../java/http/common/unmarshalling.rst:107
msgid ""
"``baseUnmarshaller.forContentTypes`` (only available for "
"FromEntityUnmarshallers)"
msgstr ""

# 1d8dffd262814900a00ae671b6b7395b
#: ../../java/http/common/unmarshalling.rst:109
msgid "The method signatures should make their semantics relatively clear."
msgstr ""

# e1ad38f0b7da47168d14e96ba268bf6b
#: ../../java/http/common/unmarshalling.rst:113
msgid "Using Unmarshallers"
msgstr ""

# 13e996ac027a4b909f981ff5e74ff308
#: ../../java/http/common/unmarshalling.rst:115
msgid ""
"In many places throughput Akka HTTP unmarshallers are used implicitly, e.g. "
"when you want to access the :ref:`-entity-` of a request using the "
":ref:`Routing DSL <http-high-level-server-side-api>`."
msgstr ""

# 9b466bbbb22f4f3dbf71b2d088c6bc58
#: ../../java/http/common/unmarshalling.rst:118
msgid ""
"However, you can also use the unmarshalling infrastructure directly if you "
"wish, which can be useful for example in tests. The best entry point for "
"this is the ``akka.http.scaladsl.unmarshalling.Unmarshal`` object, which you"
" can use like this:"
msgstr ""

# babfbe0684fc4acaa8b28450a787c4ac
#: ../../java/http/configuration.rst:6
msgid ""
"Just like any other Akka module Akka HTTP is configured via `Typesafe "
"Config`_. Usually this means that you provide an ``application.conf`` which "
"contains all the application-specific settings that differ from the default "
"ones provided by the reference configuration files from the individual Akka "
"modules."
msgstr ""

# 842113b9a5f149b2a42be8a157920817
#: ../../java/http/configuration.rst:10
msgid ""
"These are the relevant default configuration values for the Akka HTTP "
"modules."
msgstr ""

# 5089392c6a7742e6b03f143217ade027
#: ../../java/http/configuration.rst:13
msgid "akka-http-core"
msgstr ""

# d3043ba3974d490f8b713408ce090914
#: ../../java/http/configuration.rst:20
msgid "akka-http"
msgstr ""

# e07301298fe2431593fdcc29010aa5cf
#: ../../java/http/configuration.rst:26
msgid ""
"The other Akka HTTP modules do not offer any configuration via `Typesafe "
"Config`_."
msgstr ""

# fb5037472f6f40c3aa962ec15882f8a7
#: ../../java/http/http-model.rst:4
msgid "HTTP Model"
msgstr ""

# c8bd8369055e4f37a30fffc4adbfe283
#: ../../java/http/http-model.rst:6
msgid ""
"Akka HTTP model contains a deeply structured, fully immutable, case-class "
"based model of all the major HTTP data structures, like HTTP requests, "
"responses and common headers. It lives in the *akka-http-core* module and "
"forms the basis for most of Akka HTTP's APIs."
msgstr ""

# 943905c405c84f3aa03ccd38f9fa0c9f
#: ../../java/http/http-model.rst:13
msgid ""
"Since akka-http-core provides the central HTTP data structures you will find"
" the following import in quite a few places around the code base (and "
"probably your own code as well):"
msgstr ""

# ae51a13056b343fa988c008e288d00d7
#: ../../java/http/http-model.rst:19
msgid "This brings all of the most relevant types in scope, mainly:"
msgstr ""

# c58bcaf0f458483d972bb33950b75243
#: ../../java/http/http-model.rst:21
msgid "``HttpRequest`` and ``HttpResponse``, the central message model"
msgstr ""

# 923cad315127488daeb4464dfc6fecf0
#: ../../java/http/http-model.rst:22
msgid ""
"``headers``, the package containing all the predefined HTTP header models "
"and supporting types"
msgstr ""

# 6c87da7c522a49dbbf5de1b457c7191a
#: ../../java/http/http-model.rst:23
msgid ""
"Supporting types like ``Uri``, ``HttpMethods``, ``MediaTypes``, "
"``StatusCodes``, etc."
msgstr ""

# 3b0a0940ff384b639d41240c71e6ad70
#: ../../java/http/http-model.rst:25
msgid ""
"A common pattern is that the model of a certain entity is represented by an "
"immutable type (class or trait), while the actual instances of the entity "
"defined by the HTTP spec live in an accompanying object carrying the name of"
" the type plus a trailing plural 's'."
msgstr ""

# b690607f00f54a2f851b9c9d588d44a2
#: ../../java/http/http-model.rst:29
msgid "For example:"
msgstr ""

# 32aaa1e96d944b2aab5259f24d2a5e31
#: ../../java/http/http-model.rst:31
msgid ""
"Defined ``HttpMethod`` instances are defined as static fields of the "
"``HttpMethods`` class."
msgstr ""

# d79a04d7783a4441b13d02143239c9bc
#: ../../java/http/http-model.rst:32
msgid ""
"Defined ``HttpCharset`` instances are defined as static fields of the "
"``HttpCharsets`` class."
msgstr ""

# 7f9f73ad0d0349809e687ec9468b1d79
#: ../../java/http/http-model.rst:33
msgid ""
"Defined ``HttpEncoding`` instances are defined as static fields of the "
"``HttpEncodings`` class."
msgstr ""

# ed2c63e5216549b0b245892a66eae5bb
#: ../../java/http/http-model.rst:34
msgid ""
"Defined ``HttpProtocol`` instances are defined as static fields of the "
"``HttpProtocols`` class."
msgstr ""

# fe174eb2fdd7481d95d5d3e217d67132
#: ../../java/http/http-model.rst:35
msgid ""
"Defined ``MediaType`` instances are defined as static fields of the "
"``MediaTypes`` class."
msgstr ""

# a7d0ddd2f7f34704ab88768cad3eca75
#: ../../java/http/http-model.rst:36
msgid ""
"Defined ``StatusCode`` instances are defined as static fields of the "
"``StatusCodes`` class."
msgstr ""

# bbf52066d9414f92afa8f90f3a20650e
#: ../../java/http/http-model.rst:39
msgid "HttpRequest"
msgstr ""

# f5570046845b42869a44c7144e7dd2cf
#: ../../java/http/http-model.rst:41
msgid ""
"``HttpRequest`` and ``HttpResponse`` are the basic immutable classes "
"representing HTTP messages."
msgstr ""

# af85364bdb734a1b9f9766404d192236
#: ../../java/http/http-model.rst:43
msgid "An ``HttpRequest`` consists of"
msgstr ""

# 07aa0cd57479464298a8ae7b21ba8dcc
#: ../../java/http/http-model.rst:45
msgid "a method (GET, POST, etc.)"
msgstr ""

# 03f411f17371452c823bc09c61df24ae
#: ../../java/http/http-model.rst:46
msgid "a URI"
msgstr ""

# 05c1180a5f5845178ea090d8fa74e30c
#: ../../java/http/http-model.rst:47
msgid "a seq of headers"
msgstr ""

# b1efbbdfa74c4f09b3a8c8eaad68c4d1
# 074624478da846babf2676848a7cc1a2
#: ../../java/http/http-model.rst:48 ../../java/http/http-model.rst:69
msgid "an entity (body data)"
msgstr ""

# 5341fda54f864f758992e02a48fd2763
# d8709babe8384af5bdb6ef5d54c6f977
#: ../../java/http/http-model.rst:49 ../../java/http/http-model.rst:70
msgid "a protocol"
msgstr ""

# 67bc87ac48ba434b8191950e54294ce3
#: ../../java/http/http-model.rst:51
msgid "Here are some examples how to construct an ``HttpRequest``:"
msgstr ""

# ec799083af8e4669a4835fa676f164aa
#: ../../java/http/http-model.rst:56
msgid ""
"In its basic form ``HttpRequest.create`` creates an empty default GET "
"request without headers which can then be transformed using one of the "
"``withX`` methods, ``addHeader``, or ``addHeaders``. Each of those will "
"create a new immutable instance, so instances can be shared freely. There "
"exist some overloads for ``HttpRequest.create`` that simplify creating "
"requests for common cases. Also, to aid readability, there are predefined "
"alternatives for ``create`` named after HTTP methods to create a request "
"with a given method and uri directly."
msgstr ""

# 9ee0378d26364ea08083661583c0790d
#: ../../java/http/http-model.rst:63
msgid "HttpResponse"
msgstr ""

# eec9ec9fed224201ab324e16a2e15b26
#: ../../java/http/http-model.rst:65
msgid "An ``HttpResponse`` consists of"
msgstr ""

# cc72e1963f034fbaa0f33c666b7cf455
#: ../../java/http/http-model.rst:67
msgid "a status code"
msgstr ""

# 97ed6b37aaf64097b888e61092b66d06
#: ../../java/http/http-model.rst:68
msgid "a list of headers"
msgstr ""

# 5404b5aef20d4fb2a6674482e973f037
#: ../../java/http/http-model.rst:72
msgid "Here are some examples how to construct an ``HttpResponse``:"
msgstr ""

# c10d4e95f6fc401c8adc22fd7c4cf4a1
#: ../../java/http/http-model.rst:77
msgid ""
"In addition to the simple ``HttpEntities.create`` methods which create an "
"entity from a fixed ``String`` or ``ByteString`` as shown here the Akka HTTP"
" model defines a number of subclasses of ``HttpEntity`` which allow body "
"data to be specified as a stream of bytes. All of these types can be created"
" using the method on ``HttpEntites``."
msgstr ""

# 044be1159eab4c63997984c9689d4d5c
#: ../../java/http/http-model.rst:85
msgid "HttpEntity"
msgstr ""

# 0550b0933a13429495d073a6e4a08432
#: ../../java/http/http-model.rst:87
msgid ""
"An ``HttpEntity`` carries the data bytes of a message together with its "
"Content-Type and, if known, its Content-Length. In Akka HTTP there are five "
"different kinds of entities which model the various ways that message "
"content can be received or sent:"
msgstr ""

# f32cf7732e744ce0bca6b6830728a958
#: ../../java/http/http-model.rst:92
msgid ""
"The simplest entity, which is used when all the entity are already available"
" in memory. It wraps a plain ``ByteString`` and  represents a standard, "
"unchunked entity with a known ``Content-Length``."
msgstr ""

# 5d9b5b9e3a9a4dd2ba3bf182db28968a
#: ../../java/http/http-model.rst:97
msgid ""
"The general, unchunked HTTP/1.1 message entity. It has a known length and "
"presents its data as a ``Source[ByteString]`` which can be only materialized"
" once. It is an error if the provided source doesn't produce exactly as many"
" bytes as specified. The distinction of ``HttpEntityStrict`` and "
"``HttpEntityDefault`` is an API-only one. One the wire, both kinds of "
"entities look the same."
msgstr ""

# 8676585263c040a9a5be32b8ad9aafef
#: ../../java/http/http-model.rst:105
msgid ""
"The model for HTTP/1.1 `chunked content`__ (i.e. sent with ``Transfer-"
"Encoding: chunked``). The content length is unknown and the individual "
"chunks are presented as a ``Source[ChunkStreamPart]``. A ``ChunkStreamPart``"
" is either a non-empty chunk or the empty last chunk containing optional "
"trailer headers. The stream consists of zero or more non-empty chunks parts "
"and can be terminated by an optional last chunk."
msgstr ""

# 204a7f0bb8c54c3e83dee51a45cce831
#: ../../java/http/http-model.rst:112
msgid ""
"An unchunked entity of unknown length that is implicitly delimited by "
"closing the connection (``Connection: close``). Content data is presented as"
" a ``Source[ByteString]``. Since the connection must be closed after sending"
" an entity of this type it can only be used on the server-side for sending a"
" response. Also, the main purpose of ``CloseDelimited`` entities is "
"compatibility with HTTP/1.0 peers, which do not support chunked transfer "
"encoding. If you are building a new application and are not constrained by "
"legacy requirements you shouldn't rely on ``CloseDelimited`` entities, since"
" implicit terminate-by-connection-close is not a robust way of signaling "
"response end, especially in the presence of proxies. Additionally this type "
"of entity prevents connection reuse which can seriously degrade performance."
" Use ``HttpEntityChunked`` instead!"
msgstr ""

# 4ea370199da446b3b640d8f69740724d
#: ../../java/http/http-model.rst:124
msgid ""
"A streaming entity of unspecified length for use in a "
"``Multipart.BodyPart``."
msgstr ""

# 8695d24c1d4a4125bad195b34e6c4723
#: ../../java/http/http-model.rst:128
msgid ""
"Entity types ``HttpEntityStrict``, ``HttpEntityDefault``, and "
"``HttpEntityChunked`` are a subtype of ``RequestEntity`` which allows to use"
" them for requests and responses. In contrast, ``HttpEntityCloseDelimited`` "
"can only be used for responses."
msgstr ""

# 467fbae38c5942f0b2cc129ca36833b3
#: ../../java/http/http-model.rst:131
msgid ""
"Streaming entity types (i.e. all but ``HttpEntityStrict``) cannot be shared "
"or serialized. To create a strict, sharable copy of an entity or message use"
" ``HttpEntity.toStrict`` or ``HttpMessage.toStrict`` which returns a "
"``CompletionStage`` of the object with the body data collected into a "
"``ByteString``."
msgstr ""

# d1d62afed128438f93224204e8ee39ef
#: ../../java/http/http-model.rst:135
msgid ""
"The class ``HttpEntities`` contains static methods to create entities from "
"common types easily."
msgstr ""

# 7e8693389f9144709e921e895b480826
#: ../../java/http/http-model.rst:137
msgid ""
"You can use the ``isX` methods of ``HttpEntity`` to find out of which "
"subclass an entity is if you want to provide special handling for each of "
"the subtypes. However, in many cases a recipient of an ``HttpEntity`` "
"doesn't care about of which subtype an entity is (and how data is "
"transported exactly on the HTTP layer). Therefore, the general method "
"``HttpEntity.getDataBytes()`` is provided which returns a "
"``Source<ByteString, ?>`` that allows access to the data of an entity "
"regardless of its concrete subtype."
msgstr ""

# e3898afda8294a2cb2f77d8fa50d891e
#: ../../java/http/http-model.rst:146
msgid ""
"Use ``HttpEntityStrict`` if the amount of data is \"small\" and already "
"available in memory (e.g. as a ``String`` or ``ByteString``)"
msgstr ""

# 8ea151c7caf046698ed94edb8c5fe350
#: ../../java/http/http-model.rst:147
msgid ""
"Use ``HttpEntityDefault`` if the data is generated by a streaming data "
"source and the size of the data is known"
msgstr ""

# f5d6c14eb8054982a3f03a0f9be2a185
#: ../../java/http/http-model.rst:148
msgid "Use ``HttpEntityChunked`` for an entity of unknown length"
msgstr ""

# 89becbf8be124927a3c40925e59438b0
#: ../../java/http/http-model.rst:149
msgid ""
"Use ``HttpEntityCloseDelimited`` for a response as a legacy alternative to "
"``HttpEntityChunked`` if the client doesn't support chunked transfer "
"encoding. Otherwise use ``HttpEntityChunked``!"
msgstr ""

# 586e4b3d204a4a18b06a69a37af0b88d
#: ../../java/http/http-model.rst:151
msgid ""
"In a ``Multipart.Bodypart`` use ``HttpEntityIndefiniteLength`` for content "
"of unknown length."
msgstr ""

# 7b9bcfba8f4c425896f12013f227c7ed
#: ../../java/http/http-model.rst:155
msgid ""
"When you receive a non-strict message from a connection then additional data"
" is only read from the network when you request it by consuming the entity "
"data stream. This means that, if you *don't* consume the entity stream then "
"the connection will effectively be stalled. In particular, no subsequent "
"message (request or response) will be read from the connection as the entity"
" of the current message \"blocks\" the stream. Therefore you must make sure "
"that you always consume the entity data, even in the case that you are not "
"actually interested in it!"
msgstr ""

# 1fcfc836ac724903a00c89c50ad58159
#: ../../java/http/http-model.rst:163
msgid "Special processing for HEAD requests"
msgstr ""

# 54308c2c3d55474d9994215a6fa191b1
#: ../../java/http/http-model.rst:165
msgid ""
"`RFC 7230`_ defines very clear rules for the entity length of HTTP messages."
msgstr ""

# 7a5d0972161f459b885de110fe5c5a19
#: ../../java/http/http-model.rst:167
msgid "Especially this rule requires special treatment in Akka HTTP:"
msgstr ""

# fd87cfffe99647568a7069c9994af887
#: ../../java/http/http-model.rst:169
msgid ""
"Any response to a HEAD request and any response with a 1xx (Informational), "
"204 (No Content), or 304 (Not Modified) status code is always terminated by "
"the first empty line after the header fields, regardless of the header "
"fields present in the message, and thus cannot contain a message body."
msgstr ""

# 5e904b05c31a42e08f374a3b107baf5e
#: ../../java/http/http-model.rst:175
msgid ""
"Responses to HEAD requests introduce the complexity that `Content-Length` or"
" `Transfer-Encoding` headers can be present but the entity is empty. This is"
" modeled by allowing `HttpEntityDefault` and `HttpEntityChunked` to be used "
"for HEAD responses with an empty data stream."
msgstr ""

# a11993c3c24e445cacc7c3292b9d81ae
#: ../../java/http/http-model.rst:179
msgid ""
"Also, when a HEAD response has an `HttpEntityCloseDelimited` entity the Akka"
" HTTP implementation will *not* close the connection after the response has "
"been sent. This allows the sending of HEAD responses without `Content-"
"Length` header across persistent HTTP connections."
msgstr ""

# 6b5e3cfc3121460fb96635ddb732d390
#: ../../java/http/http-model.rst:187
msgid "Header Model"
msgstr ""

# 7b45649fd9ea4c6ca9651d482b6fec50
#: ../../java/http/http-model.rst:189
msgid ""
"Akka HTTP contains a rich model of the most common HTTP headers. Parsing and"
" rendering is done automatically so that applications don't need to care for"
" the actual syntax of headers. Headers not modelled explicitly are "
"represented as a ``RawHeader`` (which is essentially a String/String "
"name/value pair)."
msgstr ""

# 484ecf90162f44f6922071d3c7c78a3a
#: ../../java/http/http-model.rst:193
msgid "See these examples of how to deal with headers:"
msgstr ""

# 8845e2076ca54d6ba46332347ed1aa9f
#: ../../java/http/http-model.rst:200
msgid "HTTP Headers"
msgstr ""

# 95518fb39fc945c19ef00764a12045ff
#: ../../java/http/http-model.rst:202
msgid ""
"When the Akka HTTP server receives an HTTP request it tries to parse all its"
" headers into their respective model classes. Independently of whether this "
"succeeds or not, the HTTP layer will always pass on all received headers to "
"the application. Unknown headers as well as ones with invalid syntax "
"(according to the header parser) will be made available as ``RawHeader`` "
"instances. For the ones exhibiting parsing errors a warning message is "
"logged depending on the value of the ``illegal-header-warnings`` config "
"setting."
msgstr ""

# dc752efb17de4528a4403c7af39ce2ed
#: ../../java/http/http-model.rst:208
msgid ""
"Some headers have special status in HTTP and are therefore treated "
"differently from \"regular\" headers:"
msgstr ""

# 5e5ac9f3bc7044bea221702e25ea8314
#: ../../java/http/http-model.rst:211
msgid ""
"The Content-Type of an HTTP message is modeled as the ``contentType`` field "
"of the ``HttpEntity``. The ``Content-Type`` header therefore doesn't appear "
"in the ``headers`` sequence of a message. Also, a ``Content-Type`` header "
"instance that is explicitly added to the ``headers`` of a request or "
"response will not be rendered onto the wire and trigger a warning being "
"logged instead!"
msgstr ""

# 6a66488870894e229bf76a036c8ae603
#: ../../java/http/http-model.rst:217
msgid ""
"Messages with ``Transfer-Encoding: chunked`` are represented as a "
"``HttpEntityChunked`` entity. As such chunked messages that do not have "
"another deeper nested transfer encoding will not have a ``Transfer-"
"Encoding`` header in their ``headers`` list. Similarly, a ``Transfer-"
"Encoding`` header instance that is explicitly added to the ``headers`` of a "
"request or response will not be rendered onto the wire and trigger a warning"
" being logged instead!"
msgstr ""

# 4cb84f4694044aab92b92f55a9877ff0
#: ../../java/http/http-model.rst:224
msgid ""
"The content length of a message is modelled via its :ref:`HttpEntity-java`. "
"As such no ``Content-Length`` header will ever be part of a message's "
"``header`` sequence. Similarly, a ``Content-Length`` header instance that is"
" explicitly added to the ``headers`` of a request or response will not be "
"rendered onto the wire and trigger a warning being logged instead!"
msgstr ""

# 5296233ca57647a29f61907ec748612f
#: ../../java/http/http-model.rst:230
msgid ""
"A ``Server`` header is usually added automatically to any response and its "
"value can be configured via the ``akka.http.server.server-header`` setting. "
"Additionally an application can override the configured header with a custom"
" one by adding it to the response's ``header`` sequence."
msgstr ""

# 8c4a1bdf268b4b4480c7be1b9fe76556
#: ../../java/http/http-model.rst:235
msgid ""
"A ``User-Agent`` header is usually added automatically to any request and "
"its value can be configured via the ``akka.http.client.user-agent-header`` "
"setting. Additionally an application can override the configured header with"
" a custom one by adding it to the request's ``header`` sequence."
msgstr ""

# c1ac1a163112481294c3b01b7e34db7d
#: ../../java/http/http-model.rst:240
msgid ""
"The ``Date`` response header is added automatically but can be overridden by"
" supplying it manually."
msgstr ""

# f61bbbb586564b4ca7dceb736dccfb94
#: ../../java/http/http-model.rst:243
msgid ""
"On the server-side Akka HTTP watches for explicitly added ``Connection: "
"close`` response headers and as such honors the potential wish of the "
"application to close the connection after the respective response has been "
"sent out. The actual logic for determining whether to close the connection "
"is quite involved. It takes into account the request's method, protocol and "
"potential ``Connection`` header as well as the response's protocol, entity "
"and potential ``Connection`` header. See `this test`__ for a full table of "
"what happens when."
msgstr ""

# d4666e5bee054f8fabeaa6267254f722
#: ../../java/http/http-model.rst:253
msgid "Parsing / Rendering"
msgstr ""

# 43f8289f61e34ef0b89a8e2eed8971a7
#: ../../java/http/http-model.rst:255
msgid ""
"Parsing and rendering of HTTP data structures is heavily optimized and for "
"most types there's currently no public API provided to parse (or render to) "
"Strings or byte arrays."
msgstr ""

# d9fbf2887ea145eba57d6446e9cce4c4
#: ../../java/http/http-model.rst:259
msgid ""
"Various parsing and rendering settings are available to tweak in the "
"configuration under ``akka.http.client[.parsing]``, "
"``akka.http.server[.parsing]`` and ``akka.http.host-connection-"
"pool[.client.parsing]``, with defaults for all of these being defined in the"
" ``akka.http.parsing`` configuration section."
msgstr ""

# 2c740f5f68c14d8f8717f8dda2946597
#: ../../java/http/http-model.rst:263
msgid ""
"For example, if you want to change a parsing setting for all components, you"
" can set the ``akka.http.parsing.illegal-header-warnings = off`` value. "
"However this setting can be stil overriden by the more specific sections, "
"like for example ``akka.http.server.parsing.illegal-header-warnings = on``. "
"In this case both ``client`` and ``host-connection-pool`` APIs will see the "
"setting ``off``, however the server will see ``on``."
msgstr ""

# 556cfbf692e44c6bac28c9813b6e56cc
#: ../../java/http/http-model.rst:267
msgid ""
"In the case of ``akka.http.host-connection-pool.client`` settings, they "
"default to settings set in ``akka.http.client``, and can override them if "
"needed. This is useful, since both ``client`` and ``host-connection-pool`` "
"APIs, such as the Client API ``Http.get(sys).outgoingConnection`` or the "
"Host Connection Pool APIs ``Http.get(sys).singleRequest`` or "
"``Http.get(sys).superPool``, usually need the same settings, however the "
"``server`` most likely has a very different set of settings."
msgstr ""

# 70d1a7e6ae684195884a0e5ac444a3dc
#: ../../java/http/http-model.rst:273
msgid "The URI model"
msgstr ""

# 50e7605dc3184564bf9da8863ad99685
#: ../../java/http/http-model.rst:275
msgid ""
"Akka HTTP offers its own specialised URI model class which is tuned for both"
" performance and idiomatic usage within other types of the HTTP model. For "
"example, an HTTPRequest's target URI is parsed into this type, where all "
"character escaping and other URI specific semantics are applied."
msgstr ""

# b63fd26e32de40dab94f55175ea0f164
#: ../../java/http/http-model.rst:282
msgid ""
"Sometimes it may be needed to obtain the \"raw\" value of an incoming URI, "
"without applying any escaping or parsing to it. While this use-case is rare,"
" it comes up every once in a while. It is possible to obtain the \"raw\" "
"request URI in Akka HTTP Server side by turning on the ``akka.http.server"
".raw-request-uri-header`` flag. When enabled, a ``Raw-Request-URI`` header "
"will be added to each request. This header will hold the original raw "
"request's URI that was used. For an example check the reference "
"configuration."
msgstr ""

# f5514d682bb94934a349dc3a1d467815
#: ../../java/http/implications-of-streaming-http-entity.rst:4
msgid "Implications of the streaming nature of Request/Response Entities"
msgstr ""

# 3f13956a665d42bfbcecfcb8e0cbeb74
#: ../../java/http/implications-of-streaming-http-entity.rst:6
msgid ""
"Akka HTTP is streaming *all the way through*, which means that the back-"
"pressure mechanisms enabled by Akka Streams are exposed through all "
"layers–from the TCP layer, through the HTTP server, all the way up to the "
"user-facing ``HttpRequest`` and ``HttpResponse`` and their ``HttpEntity`` "
"APIs."
msgstr ""

# 6a40c429cf674c4a82a01b8352762e4b
#: ../../java/http/implications-of-streaming-http-entity.rst:10
msgid ""
"This has suprising implications if you are used to non-streaming / not-"
"reactive HTTP clients. Specifically it means that: \"*lack of consumption of"
" the HTTP Entity, is signaled as back-pressure to the other side of the "
"connection*\". This is a feature, as it allows one only to consume the "
"entity, and back-pressure servers/clients from overwhelming our application,"
" possibly causing un-necessary buffering of the entity in memory."
msgstr ""

# 22792c648da5472e8951370f5c8aaf16
#: ../../java/http/implications-of-streaming-http-entity.rst:16
msgid ""
"Consuming (or discarding) the Entity of a request is mandatory! If "
"*accidentally* left neither consumed or discarded Akka HTTP will asume the "
"incoming data should remain back-pressured, and will stall the incoming data"
" via TCP back-pressure mechanisms."
msgstr ""

# 90936e0f1dcc491ebce1e1d9368279c2
#: ../../java/http/implications-of-streaming-http-entity.rst:21
msgid "Client-Side handling of streaming HTTP Entities"
msgstr ""

# 99bec2244b5141499f64b16929ea8d22
#: ../../java/http/implications-of-streaming-http-entity.rst:24
msgid "Consuming the HTTP Response Entity (Client)"
msgstr ""

# a7f8667d81e144158e2bd4d034837769
#: ../../java/http/implications-of-streaming-http-entity.rst:26
msgid ""
"The most common use-case of course is consuming the response entity, which "
"can be done via running the underlying ``dataBytes`` Source. This is as "
"simple as running the dataBytes source, (or on the server-side using "
"directives such as"
msgstr ""

# 301f700e16154149b687a9528ba1977b
#: ../../java/http/implications-of-streaming-http-entity.rst:30
msgid ""
"It is encouraged to use various streaming techniques to utilise the "
"underlying infrastructure to its fullest, for example by framing the "
"incoming chunks, parsing them line-by-line and then connecting the flow into"
" another destination Sink, such as a File or other Akka Streams connector:"
msgstr ""

# 0d89b326e4d944bcbc5a060a08b4fce0
#: ../../java/http/implications-of-streaming-http-entity.rst:36
msgid ""
"however sometimes the need may arise to consume the entire entity as "
"``Strict`` entity (which means that it is completely loaded into memory). "
"Akka HTTP provides a special ``toStrict(timeout, materializer)`` method "
"which can be used to eagerly consume the entity and make it available in "
"memory:"
msgstr ""

# b051759a1543431eba590c9915da4e6b
#: ../../java/http/implications-of-streaming-http-entity.rst:44
msgid "Discarding the HTTP Response Entity (Client)"
msgstr ""

# c9d3c83a26644d5a90a0ed6d90b546e0
#: ../../java/http/implications-of-streaming-http-entity.rst:45
msgid ""
"Sometimes when calling HTTP services we do not care about their response "
"payload (e.g. all we care about is the response code), yet as explained "
"above entity still has to be consumed in some way, otherwise we'll be "
"exherting back-pressure on the underlying TCP connection."
msgstr ""

# 13507cd397584e1dbe03d9ffc3b165f6
#: ../../java/http/implications-of-streaming-http-entity.rst:49
msgid ""
"The ``discardEntityBytes`` convenience method serves the purpose of easily "
"discarding the entity if it has no purpose for us. It does so by piping the "
"incoming bytes directly into an ``Sink.ignore``."
msgstr ""

# dc469844ddfe4e00bc6436417dd4f0ac
#: ../../java/http/implications-of-streaming-http-entity.rst:52
msgid ""
"The two snippets below are equivalent, and work the same way on the server-"
"side for incoming HTTP Requests:"
msgstr ""

# c0080ad03b4f4adc87745fe0be732745
#: ../../java/http/implications-of-streaming-http-entity.rst:56
msgid "Or the equivalent low-level code achieving the same result:"
msgstr ""

# 32b8da81990445adb28887b45ef27bae
#: ../../java/http/implications-of-streaming-http-entity.rst:61
msgid "Server-Side handling of streaming HTTP Entities"
msgstr ""

# daa5cfd2db7143c4be92c4f074489f47
#: ../../java/http/implications-of-streaming-http-entity.rst:63
msgid ""
"Similarily as with the Client-side, HTTP Entities are directly linked to "
"Streams which are fed by the underlying TCP connection. Thus, if request "
"entities remain not consumed, the server will back-pressure the connection, "
"expecting that the user-code will eventually decide what to do with the "
"incoming data."
msgstr ""

# efc30f4d98bf4687bb5e2449baced406
#: ../../java/http/implications-of-streaming-http-entity.rst:67
msgid ""
"Note that some directives force an implicit ``toStrict`` operation, such as "
"``entity(exampleUnmarshaller, example -> {})`` and similar ones."
msgstr ""

# afc96f941c024707b9c5ddb3ecacfacc
#: ../../java/http/implications-of-streaming-http-entity.rst:70
msgid "Consuming the HTTP Request Entity (Server)"
msgstr ""

# abb3832fc0d14d8aa847bd35d99e21d2
#: ../../java/http/implications-of-streaming-http-entity.rst:72
msgid ""
"The simplest way of consuming the incoming request entity is to simply "
"transform it into an actual domain object, for example by using the :ref"
":`-entity-java-` directive:"
msgstr ""

# 44df8bf2c5e94866a66fb12c2d4fce40
#: ../../java/http/implications-of-streaming-http-entity.rst:77
msgid ""
"Of course you can access the raw dataBytes as well and run the underlying "
"stream, for example piping it into an FileIO Sink, that signals completion "
"via a ``CompletionStage<IoResult>`` once all the data has been written into "
"the file:"
msgstr ""

# a63e9a6a228343afb5830b8b621848c4
#: ../../java/http/implications-of-streaming-http-entity.rst:83
msgid "Discarding the HTTP Request Entity (Server)"
msgstr ""

# d2adac923c584c289c619ba1ad4578ec
#: ../../java/http/implications-of-streaming-http-entity.rst:85
msgid ""
"Sometimes, depending on some validation (e.g. checking if given user is "
"allowed to perform uploads or not) you may want to decide to discard the "
"uploaded entity."
msgstr ""

# 5b96a44d65ad43b59dd36ff347cdd974
#: ../../java/http/implications-of-streaming-http-entity.rst:88
msgid ""
"Please note that discarding means that the entire upload will proceed, even "
"though you are not interested in the data being streamed to the server - "
"this may be useful if you are simply not interested in the given entity, "
"however you don't want to abort the entire connection (which we'll "
"demonstrate as well), since there may be more requests pending on the same "
"connection still."
msgstr ""

# 7111af78977a4c1d8b869eb370739e4c
#: ../../java/http/implications-of-streaming-http-entity.rst:93
msgid ""
"In order to discard the databytes explicitly you can invoke the "
"``discardEntityBytes`` bytes of the incoming ``HTTPRequest``:"
msgstr ""

# ea2c6feabda74ab7868c995f6c8c7c8e
#: ../../java/http/implications-of-streaming-http-entity.rst:97
msgid ""
"A related concept is *cancelling* the incoming ``entity.getDataBytes()`` "
"stream, which results in Akka HTTP *abruptly closing the connection from the"
" Client*. This may be useful when you detect that the given user should not "
"be allowed to make any uploads at all, and you want to drop the connection "
"(instead of reading and ignoring the incoming data). This can be done by "
"attaching the incoming ``entity.getDataBytes()`` to a ``Sink.cancelled`` "
"which will cancel the entity stream, which in turn will cause the underlying"
" connection to be shut-down by the server – effectively hard-aborting the "
"incoming request:"
msgstr ""

# c0edeb8b5c614d5a8805737797b416da
#: ../../java/http/implications-of-streaming-http-entity.rst:106
msgid ""
"Closing connections is also explained in depth in the :ref:`http-closing-"
"connection-low-level-java` section of the docs."
msgstr ""

# dbf7990295504e3e900b265097e03292
#: ../../java/http/implications-of-streaming-http-entity.rst:109
msgid "Pending: Automatic discarding of not used entities"
msgstr ""

# 9c1aff0c9c9b40dcb81cb5bedcc376b2
#: ../../java/http/implications-of-streaming-http-entity.rst:111
msgid ""
"Under certain conditions it is possible to detect an entity is very unlikely"
" to be used by the user for a given request, and issue warnings or discard "
"the entity automatically. This advanced feature has not been implemented "
"yet, see the below note and issues for further discussion and ideas."
msgstr ""

# 009b5ae09bcf4c6d9d95814e04177ee0
#: ../../java/http/implications-of-streaming-http-entity.rst:116
msgid ""
"An advanced feature code named \"auto draining\" has been discussed and "
"proposed for Akka HTTP, and we're hoping to implement or help the community "
"implement it."
msgstr ""

# b3e3c053a5a543b29eb91c63dac2de13
#: ../../java/http/implications-of-streaming-http-entity.rst:119
msgid ""
"You can read more about it in `issue #18716 "
"<https://github.com/akka/akka/issues/18716>`_ as well as `issue #18540 "
"<https://github.com/akka/akka/issues/18540>`_ ; as always, contributions are"
" very welcome!"
msgstr ""

# 22013b5ab3824152ba51fa698089b71b
#: ../../java/http/index.rst:4
msgid "Akka HTTP"
msgstr ""

# e0f9bcebc8ab4bcab214690a6f402b93
#: ../../java/http/index.rst:6
msgid ""
"The Akka HTTP modules implement a full server- and client-side HTTP stack on"
" top of *akka-actor* and *akka-stream*. It's not a web-framework but rather "
"a more general toolkit for providing and consuming HTTP-based services. "
"While interaction with a browser is of course also in scope it is not the "
"primary focus of Akka HTTP."
msgstr ""

# e504579dabd14d5c85450f06fcff0ade
#: ../../java/http/index.rst:10
msgid ""
"Akka HTTP follows a rather open design and many times offers several "
"different API levels for \"doing the same thing\". You get to pick the API "
"level of abstraction that is most suitable for your application. This means "
"that, if you have trouble achieving something using a high-level API, "
"there's a good chance that you can get it done with a low-level API, which "
"offers more flexibility but might require you to write more application "
"code."
msgstr ""

# b472364a071f4954a934f2ff86247870
#: ../../java/http/index.rst:15
msgid "Akka HTTP is structured into several modules:"
msgstr ""

# b8009f6b5a60407c9e62a3cf3d3c8d35
#: ../../java/http/index.rst:18
msgid ""
"A complete, mostly low-level, server- and client-side implementation of HTTP"
" (incl. WebSockets). Includes a model of all things HTTP."
msgstr ""

# f370de003b604aaea173f192ca8ad0cd
#: ../../java/http/index.rst:22
msgid ""
"Higher-level functionality, like (un)marshalling, (de)compression as well as"
" a powerful DSL for defining HTTP-based APIs on the server-side"
msgstr ""

# 470ec46089fe45369655668b7e1198c0
#: ../../java/http/index.rst:26
msgid ""
"A test harness and set of utilities for verifying server-side service "
"implementations"
msgstr ""

# 9fc7940093b74c2b882090cb5790fb7e
#: ../../java/http/index.rst:29
msgid ""
"Predefined glue-code for (de)serializing custom types from/to JSON with "
"jackson_"
msgstr ""

# 454eb3852c794b5686445f24203b5501
#: ../../java/http/routing-dsl/directives/alphabetically.rst:4
msgid "Predefined Directives (alphabetically)"
msgstr ""

# 4c3d142edfe2413abd951f29caf05003
#: ../../java/http/routing-dsl/directives/alphabetically.rst:7
msgid "Directive"
msgstr ""

# 1668ba94430e44879877f2faba0cee67
#: ../../java/http/routing-dsl/directives/alphabetically.rst:9
msgid ":ref:`-authenticateBasic-java-`"
msgstr ""

# 365c141fa7f448789a7fe52cecf9738d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:9
msgid ""
"Wraps the inner route with Http Basic authentication support using a given "
"``Authenticator<T>``"
msgstr ""

# c97559576ebb43798a6143eb75fea984
#: ../../java/http/routing-dsl/directives/alphabetically.rst:10
msgid ":ref:`-authenticateBasicAsync-java-`"
msgstr ""

# 51a57be540c84f8aa03df7f7129b1f29
#: ../../java/http/routing-dsl/directives/alphabetically.rst:10
msgid ""
"Wraps the inner route with Http Basic authentication support using a given "
"``AsyncAuthenticator<T>``"
msgstr ""

# 9b7c49853c94487abaf9249a9ce3fdad
#: ../../java/http/routing-dsl/directives/alphabetically.rst:11
msgid ":ref:`-authenticateBasicPF-java-`"
msgstr ""

# 2442301a4a364467b9d1cd82937b0fe6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:11
msgid ""
"Wraps the inner route with Http Basic authentication support using a given "
"``AuthenticatorPF<T>``"
msgstr ""

# c718a696108d4026926c85a63b0d455d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:12
msgid ":ref:`-authenticateBasicPFAsync-java-`"
msgstr ""

# e634027852a0404e98eff0014d15f1d0
#: ../../java/http/routing-dsl/directives/alphabetically.rst:12
msgid ""
"Wraps the inner route with Http Basic authentication support using a given "
"``AsyncAuthenticatorPF<T>``"
msgstr ""

# 6cfd522bd91944c0bbd53846e1fd6253
#: ../../java/http/routing-dsl/directives/alphabetically.rst:13
msgid ":ref:`-authenticateOAuth2-java-`"
msgstr ""

# c52da00402184f579f654bcf919743e1
# 61deab79077243739b3f8ce48a2c5f37
# 274a1d17e531405ca1030c010554d380
#: ../../java/http/routing-dsl/directives/alphabetically.rst:13
#: ../../java/http/routing-dsl/directives/alphabetically.rst:15
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:5
msgid ""
"Wraps the inner route with OAuth Bearer Token authentication support using a"
" given ``AuthenticatorPF<T>``"
msgstr ""

# 4effec1b5aed4bd4aa02d9ff6aaee1bd
#: ../../java/http/routing-dsl/directives/alphabetically.rst:14
msgid ":ref:`-authenticateOAuth2Async-java-`"
msgstr ""

# dfbd90bf2de9497e961c0edccbe18c75
#: ../../java/http/routing-dsl/directives/alphabetically.rst:14
msgid ""
"Wraps the inner route with OAuth Bearer Token authentication support using a"
" given ``AsyncAuthenticator<T>``"
msgstr ""

# a79dc32f1aed4b86877da499e9240769
#: ../../java/http/routing-dsl/directives/alphabetically.rst:15
msgid ":ref:`-authenticateOAuth2PF-java-`"
msgstr ""

# e114644e733040a282a04ff14afebe00
#: ../../java/http/routing-dsl/directives/alphabetically.rst:16
msgid ":ref:`-authenticateOAuth2PFAsync-java-`"
msgstr ""

# 5341ababb80d425c9b8b4854899529b2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:16
msgid ""
"Wraps the inner route with OAuth Bearer Token authentication support using a"
" given ``AsyncAuthenticatorPF<T>``"
msgstr ""

# ca3e3bf735114bd8be604be98de5c295
#: ../../java/http/routing-dsl/directives/alphabetically.rst:17
msgid ":ref:`-authenticateOrRejectWithChallenge-java-`"
msgstr ""

# 3055812e4a874f9bba3214fc6e7ff869
#: ../../java/http/routing-dsl/directives/alphabetically.rst:17
msgid "Lifts an authenticator function into a directive"
msgstr ""

# 83f29930803d4b8582d8195a03bc96cb
#: ../../java/http/routing-dsl/directives/alphabetically.rst:18
msgid ":ref:`-authorize-java-`"
msgstr ""

# 940922a63e6d47dd80b2a60557479e35
#: ../../java/http/routing-dsl/directives/alphabetically.rst:18
msgid "Applies the given authorization check to the request"
msgstr ""

# 3bbab647ae0742ebaae3639c639d5ce8
#: ../../java/http/routing-dsl/directives/alphabetically.rst:19
msgid ":ref:`-authorizeAsync-java-`"
msgstr ""

# b622c4eaff1541f89a2c1a4f0776a258
#: ../../java/http/routing-dsl/directives/alphabetically.rst:19
msgid "Applies the given asynchronous authorization check to the request"
msgstr ""

# 8c8e0f5c52494e7387816b55b1a8f988
# b8877af7cb4444d7abcfd36021488113
#: ../../java/http/routing-dsl/directives/alphabetically.rst:20
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:71
msgid ":ref:`-cancelRejection-java-`"
msgstr ""

# 44daba1020cf4d51b6bd12486c2f294f
# 41124ac1de3946fe9b6df1c9685a5ea0
#: ../../java/http/routing-dsl/directives/alphabetically.rst:20
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejection.rst:9
msgid ""
"Adds a ``TransformationRejection`` cancelling all rejections equal to the "
"given one to the rejections potentially coming back from the inner route."
msgstr ""

# 4e72e0bc187241f4ba075ac4d21b92c3
# ee65a5d5fddf4ce68992eee49a9914cc
#: ../../java/http/routing-dsl/directives/alphabetically.rst:21
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:72
msgid ":ref:`-cancelRejections-java-`"
msgstr ""

# 2178ac8b47ae450493646e00834d7837
#: ../../java/http/routing-dsl/directives/alphabetically.rst:21
msgid ""
"Adds a ``TransformationRejection`` cancelling all matching rejections to the"
" rejections potentially coming back from the inner route"
msgstr ""

# c74d0985b3c34850b1282fde06f63ad5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:22
msgid ":ref:`-checkSameOrigin-java-`"
msgstr ""

# df57ade8e2b14063953f1305257f2962
#: ../../java/http/routing-dsl/directives/alphabetically.rst:22
msgid "Checks that the request comes from the same origin"
msgstr ""

# 617055f61a954b328043b310e4e567b2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:23
msgid ":ref:`-complete-java-`"
msgstr ""

# 52826bb217f64ce2918773d20817fd7e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:23
msgid "Completes the request using the given arguments"
msgstr ""

# 0ec5cbf31094405eb50ecbe615566074
#: ../../java/http/routing-dsl/directives/alphabetically.rst:24
msgid ":ref:`-completeOrRecoverWith-java-`"
msgstr ""

# 267bfd82a02845b9b00701210d651208
#: ../../java/http/routing-dsl/directives/alphabetically.rst:24
msgid ""
"\"Unwraps\" a ``CompletionStage<T>`` and runs the inner route when the "
"future has failed with the error as an extraction of type ``Throwable``"
msgstr ""

# ced9d558104d4228a77ab469db668261
# 652499755cb6467cba7d13fd8d30b6dc
#: ../../java/http/routing-dsl/directives/alphabetically.rst:25
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:27
msgid ":ref:`-completeWith-java-`"
msgstr ""

# 26ebbce51d744de2b4fdde2958768527
#: ../../java/http/routing-dsl/directives/alphabetically.rst:25
msgid "Uses the marshaller for a given type to extract a completion function"
msgstr ""

# 673729a773204dfea1b5f8ccf5e416b9
#: ../../java/http/routing-dsl/directives/alphabetically.rst:26
msgid ":ref:`-conditional-java-`"
msgstr ""

# 94dca16a8a5a4a26a8bc15d752dc5222
#: ../../java/http/routing-dsl/directives/alphabetically.rst:26
msgid ""
"Wraps its inner route with support for conditional requests as defined by "
"http://tools.ietf.org/html/rfc7232"
msgstr ""

# bdd65bfc984042b483ab1ac9e37e72a2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:27
msgid ":ref:`-cookie-java-`"
msgstr ""

# b39cb61c6d384a7fa27ec54cec0d84f5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:27
msgid "Extracts the ``HttpCookie`` with the given name"
msgstr ""

# eea373218941495fb4609bc3595189da
#: ../../java/http/routing-dsl/directives/alphabetically.rst:28
msgid ":ref:`-decodeRequest-java-`"
msgstr ""

# 961aab4f7c1c4cd38c66d89fc5d1562b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:28
msgid "Decompresses the  request if it is ``gzip`` or ``deflate`` compressed"
msgstr ""

# 1fec581efaeb4d618f4c30bb968affee
#: ../../java/http/routing-dsl/directives/alphabetically.rst:29
msgid ":ref:`-decodeRequestWith-java-`"
msgstr ""

# f7284c07885240108e333c87d099b3a7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:29
msgid "Decodes the incoming request using one of the given decoders"
msgstr ""

# be59a860846b46c5a6f53b09cd1ae506
#: ../../java/http/routing-dsl/directives/alphabetically.rst:30
msgid ":ref:`-delete-java-`"
msgstr ""

# b8eb9a7723174f569233cca4b61a924f
#: ../../java/http/routing-dsl/directives/alphabetically.rst:30
msgid "Rejects all non-DELETE requests"
msgstr ""

# 0fdf7f162800466c94d2502b63b33e86
#: ../../java/http/routing-dsl/directives/alphabetically.rst:31
msgid ":ref:`-deleteCookie-java-`"
msgstr ""

# 3f4d87babeb74196939d0e8cf313de92
#: ../../java/http/routing-dsl/directives/alphabetically.rst:31
msgid "Adds a ``Set-Cookie`` response header expiring the given cookies"
msgstr ""

# a5927cbfee3b4f58b0a18b3287e4c28d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:32
msgid ":ref:`-encodeResponse-java-`"
msgstr ""

# fbf4603ae0504d2ba83bd0908b8c08fc
#: ../../java/http/routing-dsl/directives/alphabetically.rst:32
msgid ""
"Encodes the response with the encoding that is requested by the client via "
"the ``Accept-Encoding`` header (``NoCoding``, ``Gzip`` and ``Deflate``)"
msgstr ""

# b49580296e6a4d969a7bc82b0776911f
#: ../../java/http/routing-dsl/directives/alphabetically.rst:33
msgid ":ref:`-encodeResponseWith-java-`"
msgstr ""

# 53f5489879e9497085cb5f85b508684f
#: ../../java/http/routing-dsl/directives/alphabetically.rst:33
msgid ""
"Encodes the response with the encoding that is requested by the client via "
"the ``Accept-Encoding`` header (from a user-defined set)"
msgstr ""

# 546752e7acd64b6aa588e5044e7d4ada
# e7553bfceae74646bdab4ca0e194ebdf
#: ../../java/http/routing-dsl/directives/alphabetically.rst:34
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:28
msgid ":ref:`-entity-java-`"
msgstr ""

# f183b65bd02d4da09830ae199db9f551
#: ../../java/http/routing-dsl/directives/alphabetically.rst:34
msgid "Extracts the request entity unmarshalled to a given type"
msgstr ""

# 45de731fbc2b45028eb749e0ef9e870e
# 23281361d6a245a38da61be59f6af8af
#: ../../java/http/routing-dsl/directives/alphabetically.rst:35
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:19
msgid ":ref:`-extract-java-`"
msgstr ""

# 2f31e1ab6b4a4e988bd4c325bcb682e0
#: ../../java/http/routing-dsl/directives/alphabetically.rst:35
msgid "Extracts a single value using a ``RequestContext ⇒ T`` function"
msgstr ""

# d457f45df455476a9da79f4f28a8640b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:36
msgid ":ref:`-extractClientIP-java-`"
msgstr ""

# 77381104984c4485880efda088965297
#: ../../java/http/routing-dsl/directives/alphabetically.rst:36
msgid ""
"Extracts the client's IP from either the ``X-Forwarded-``, ``Remote-"
"Address`` or ``X-Real-IP`` header"
msgstr ""

# 762be69f32b74729b6f40520af4896af
#: ../../java/http/routing-dsl/directives/alphabetically.rst:37
msgid ":ref:`-extractCredentials-java-`"
msgstr ""

# 6d9ac39fd5174a17a72202a62e2121be
#: ../../java/http/routing-dsl/directives/alphabetically.rst:37
msgid ""
"Extracts the potentially present ``HttpCredentials`` provided with the "
"request's ``Authorization`` header"
msgstr ""

# 6c3b67aeb39049a49389308cfa969512
# 11405466384a44948a96580d50e14c57
#: ../../java/http/routing-dsl/directives/alphabetically.rst:38
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:22
msgid ":ref:`-extractExecutionContext-java-`"
msgstr ""

# 6f1b600e5da8440386a983f61dfc887e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:38
msgid "Extracts the ``ExecutionContext`` from the ``RequestContext``"
msgstr ""

# 5167b38667784eaca7ae98051273be4b
# 6f447b98b88a47f8a78bb57ef4c5b84f
#: ../../java/http/routing-dsl/directives/alphabetically.rst:39
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:23
msgid ":ref:`-extractMaterializer-java-`"
msgstr ""

# c5aed11b9c2c491bb421241855075edb
#: ../../java/http/routing-dsl/directives/alphabetically.rst:39
msgid "Extracts the ``Materializer`` from the ``RequestContext``"
msgstr ""

# 84f3da7279e8443599c4c95259308ff4
#: ../../java/http/routing-dsl/directives/alphabetically.rst:40
msgid ":ref:`-extractHost-java-`"
msgstr ""

# 5dabd9ab501b49aba7f9e36924991cb6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:40
msgid "Extracts the hostname part of the Host request header value"
msgstr ""

# 238f2ccd2c5343e0a9e4de4e544e6091
# 69d4f03489a648e9aef43f51ef7149c9
#: ../../java/http/routing-dsl/directives/alphabetically.rst:41
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:25
msgid ":ref:`-extractLog-java-`"
msgstr ""

# 6954d6437b0f4b67b38d081742cea138
#: ../../java/http/routing-dsl/directives/alphabetically.rst:41
msgid "Extracts the ``LoggingAdapter`` from the ``RequestContext``"
msgstr ""

# 0cf75c050dee40f890960652ffa65db3
#: ../../java/http/routing-dsl/directives/alphabetically.rst:42
msgid ":ref:`-extractMethod-java-`"
msgstr ""

# 74b386f95a40428f92bdb178568c7b44
#: ../../java/http/routing-dsl/directives/alphabetically.rst:42
msgid "Extracts the request method"
msgstr ""

# a33ba8afb0c641d686bf1a0babed756c
# e763fb7199894c449d97e916a0e36e15
#: ../../java/http/routing-dsl/directives/alphabetically.rst:43
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:26
msgid ":ref:`-extractRequest-java-`"
msgstr ""

# 5044ea5b13734cf993578d9a68cf3989
#: ../../java/http/routing-dsl/directives/alphabetically.rst:43
msgid "Extracts the current ``HttpRequest`` instance"
msgstr ""

# c12ee267c971430280ff4a9098a7b9da
# 1b6b94226556416995e65f38d5799a36
#: ../../java/http/routing-dsl/directives/alphabetically.rst:44
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:27
msgid ":ref:`-extractRequestContext-java-`"
msgstr ""

# 526b95af33e4441e860cb28556130a0c
#: ../../java/http/routing-dsl/directives/alphabetically.rst:44
msgid "Extracts the ``RequestContext`` itself"
msgstr ""

# 5ed63b7769f842269627ec13a227a045
#: ../../java/http/routing-dsl/directives/alphabetically.rst:45
msgid ":ref:`-extractScheme-java-`"
msgstr ""

# 690e3e2244c44c1d8d9ca1c8f444922a
#: ../../java/http/routing-dsl/directives/alphabetically.rst:45
msgid "Extracts the URI scheme from the request"
msgstr ""

# bd8e733c800d458c94822c254f99243a
# 4689e32bb7b94dd9ba789020cb0f2fc3
#: ../../java/http/routing-dsl/directives/alphabetically.rst:46
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:29
msgid ":ref:`-extractSettings-java-`"
msgstr ""

# be73981e98474209b27003ee34820622
#: ../../java/http/routing-dsl/directives/alphabetically.rst:46
msgid "Extracts the ``RoutingSettings`` from the ``RequestContext``"
msgstr ""

# fec1ca65e5964a919ffb4653dfc4d094
# ece972518a274ab28b21257375318bc0
#: ../../java/http/routing-dsl/directives/alphabetically.rst:47
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:30
msgid ":ref:`-extractUnmatchedPath-java-`"
msgstr ""

# 218705688df4431a8dc6449ed5d4d777
#: ../../java/http/routing-dsl/directives/alphabetically.rst:47
msgid "Extracts the yet unmatched path from the ``RequestContext``"
msgstr ""

# 4e30f99b02c74cf7a329295cd82e0693
# 4126b9c016314846bab31329593352b6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:48
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:31
msgid ":ref:`-extractUri-java-`"
msgstr ""

# 717b87610c184645a879f8b7695a877e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:48
msgid "Extracts the complete request URI"
msgstr ""

# 8d7bee737ee64286a5a2e5e2887a6e9a
#: ../../java/http/routing-dsl/directives/alphabetically.rst:49
msgid ":ref:`-failWith-java-`"
msgstr ""

# 072973c8aaca4ce497f198a66e4f4195
#: ../../java/http/routing-dsl/directives/alphabetically.rst:49
msgid ""
"Bubbles the given error up the response chain where it is dealt with by the "
"closest :ref:`-handleExceptions-java-` directive and its "
"``ExceptionHandler``"
msgstr ""

# 204a41a8d7c0466d8b779120de5e00f6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:50
msgid ":ref:`-fileUpload-java-`"
msgstr ""

# 625aece91ed94f359818ffc6a7a33191
#: ../../java/http/routing-dsl/directives/alphabetically.rst:50
msgid "Provides a stream of an uploaded file from a multipart request"
msgstr ""

# b7006c3b78fa446eaf7a30eee8ddc26b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:51
msgid ":ref:`-formField-java-`"
msgstr ""

# 5272360b230f4982b5bfad69f5705d08
#: ../../java/http/routing-dsl/directives/alphabetically.rst:51
msgid "Extracts an HTTP form field from the request"
msgstr ""

# dfb2bc7dddb84cf386116785ef7f5d78
#: ../../java/http/routing-dsl/directives/alphabetically.rst:52
msgid ":ref:`-formFieldMap-java-`"
msgstr ""

# 479642269c8f4f89bba258c598ee0492
#: ../../java/http/routing-dsl/directives/alphabetically.rst:52
msgid ""
"Extracts a number of HTTP form field from the request as a ``Map<String, "
"String>``"
msgstr ""

# 768839b2430f48e488c1b293e89754b2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:53
msgid ":ref:`-formFieldMultiMap-java-`"
msgstr ""

# 904605ab723f47ee936642317f8e0819
#: ../../java/http/routing-dsl/directives/alphabetically.rst:53
msgid ""
"Extracts a number of HTTP form field from the request as a ``Map<String, "
"List<String>``"
msgstr ""

# ae266c8536e64fc8805aaaec4f5eea08
#: ../../java/http/routing-dsl/directives/alphabetically.rst:54
msgid ":ref:`-formFieldList-java-`"
msgstr ""

# 6a3a9df745d147c09b9135b1a60eb1c3
#: ../../java/http/routing-dsl/directives/alphabetically.rst:54
msgid ""
"Extracts a number of HTTP form field from the request as a "
"``List<Pair<String, String>>``"
msgstr ""

# fe21a6193bc54c8baa0af810a1509f28
#: ../../java/http/routing-dsl/directives/alphabetically.rst:55
msgid ":ref:`-get-java-`"
msgstr ""

# f4a7fff5198f49b0af8b170d95ca0e59
#: ../../java/http/routing-dsl/directives/alphabetically.rst:55
msgid "Rejects all non-GET requests"
msgstr ""

# 83d4a7f885a944ac90b20eee563dcbc3
#: ../../java/http/routing-dsl/directives/alphabetically.rst:56
msgid ":ref:`-getFromBrowseableDirectories-java-`"
msgstr ""

# bab09a36cfc44c448136d3e5864162af
#: ../../java/http/routing-dsl/directives/alphabetically.rst:56
msgid ""
"Serves the content of the given directories as a file-system browser, i.e. "
"files are sent and directories served as browseable listings"
msgstr ""

# 335805c3e9914f88b096552b02c16ae7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:57
msgid ":ref:`-getFromBrowseableDirectory-java-`"
msgstr ""

# 568dce75d2144d18aaaf588daa5e1799
#: ../../java/http/routing-dsl/directives/alphabetically.rst:57
msgid ""
"Serves the content of the given directory as a file-system browser, i.e. "
"files are sent and directories served as browseable listings"
msgstr ""

# be3827878039468799a3d9512a0ab939
#: ../../java/http/routing-dsl/directives/alphabetically.rst:58
msgid ":ref:`-getFromDirectory-java-`"
msgstr ""

# 9066faacf17445af8c56b791eed146b3
#: ../../java/http/routing-dsl/directives/alphabetically.rst:58
msgid ""
"Completes GET requests with the content of a file underneath a given file-"
"system directory"
msgstr ""

# 194e007a4b994827ab3f77c35e718eb5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:59
msgid ":ref:`-getFromFile-java-`"
msgstr ""

# 5d677545262644ca938091ad2d530a78
#: ../../java/http/routing-dsl/directives/alphabetically.rst:59
msgid "Completes GET requests with the content of a given file"
msgstr ""

# 5e9df598334e43bcb3e8f8b3c8f564c0
#: ../../java/http/routing-dsl/directives/alphabetically.rst:60
msgid ":ref:`-getFromResource-java-`"
msgstr ""

# aa3b28ff1148419eb8498de27d897213
#: ../../java/http/routing-dsl/directives/alphabetically.rst:60
msgid "Completes GET requests with the content of a given class-path resource"
msgstr ""

# a344ded8632841d484b9a5c3b45ccf09
#: ../../java/http/routing-dsl/directives/alphabetically.rst:61
msgid ":ref:`-getFromResourceDirectory-java-`"
msgstr ""

# 179d26d1fe354d089eaf2168874e204d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:61
msgid ""
"Completes GET requests with the content of a file underneath a given "
"\"class-path resource directory\""
msgstr ""

# 0097d3a8624347b592b8ed40b55f774b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:62
msgid ":ref:`-handleExceptions-java-`"
msgstr ""

# 8c63aa31e31c4ef4aa33cc43e3c11f3e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:62
msgid ""
"Transforms exceptions thrown during evaluation of the inner route using the "
"given ``ExceptionHandler``"
msgstr ""

# 0d2e4a91cad944fea0361a02d8093592
#: ../../java/http/routing-dsl/directives/alphabetically.rst:63
msgid ":ref:`-handleRejections-java-`"
msgstr ""

# ce74cd5f1af843e99fcbeb7c99297847
#: ../../java/http/routing-dsl/directives/alphabetically.rst:63
msgid ""
"Transforms rejections produced by the inner route using the given "
"``RejectionHandler``"
msgstr ""

# 3abbe819766c4ba9b21b0fcb494a611a
#: ../../java/http/routing-dsl/directives/alphabetically.rst:64
msgid ":ref:`-handleWebSocketMessages-java-`"
msgstr ""

# 1f44e367e6054886a740834be570c752
#: ../../java/http/routing-dsl/directives/alphabetically.rst:64
msgid ""
"Handles websocket requests with the given handler and rejects other requests"
" with an ``ExpectedWebSocketRequestRejection``"
msgstr ""

# 52c2805ca5b54d26b7f8ae387efa7df1
#: ../../java/http/routing-dsl/directives/alphabetically.rst:65
msgid ":ref:`-handleWebSocketMessagesForProtocol-java-`"
msgstr ""

# ec05db9892364ffa9cd588ae097d26c3
#: ../../java/http/routing-dsl/directives/alphabetically.rst:65
msgid ""
"Handles websocket requests with the given handler if the subprotocol matches"
" and rejects other requests with an ``ExpectedWebSocketRequestRejection`` or"
" an ``UnsupportedWebSocketSubprotocolRejection``."
msgstr ""

# c78f8e48ff3e417c9ec53c90fdd1db2c
# fa4738542bc94784ba49efbe51d6f6c5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:66
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:29
msgid ":ref:`-handleWith-java-`"
msgstr ""

# 227f8e4104cf4c28a674b0ed1fa0d984
#: ../../java/http/routing-dsl/directives/alphabetically.rst:66
msgid "Completes the request using a given function"
msgstr ""

# bad3b067cdb249af8b0636bc5171089e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:67
msgid ":ref:`-head-java-`"
msgstr ""

# 94dadfee809b493d91e5c192ea5b5f1d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:67
msgid "Rejects all non-HEAD requests"
msgstr ""

# 7db34b51d23642ea9c01fb62576fe890
#: ../../java/http/routing-dsl/directives/alphabetically.rst:68
msgid ":ref:`-headerValue-java-`"
msgstr ""

# fa9ddc953a12486fad87ed44c190d2f7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:68
msgid ""
"Extracts an HTTP header value using a given ``HttpHeader ⇒ Option<T>`` "
"function"
msgstr ""

# 9ef4dd52048c4f26ac347109ec346e2b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:69
msgid ":ref:`-headerValueByName-java-`"
msgstr ""

# fdc351899c7747c6bb8a2249b4f18d02
#: ../../java/http/routing-dsl/directives/alphabetically.rst:69
msgid "Extracts the value of the first HTTP request header with a given name"
msgstr ""

# 953cec47cc7a40929a6567f2e3f65e54
#: ../../java/http/routing-dsl/directives/alphabetically.rst:70
msgid ":ref:`-headerValueByType-java-`"
msgstr ""

# 9b9006c9976a4c45bab67ee739ad8b4e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:70
msgid "Extracts the first HTTP request header of the given type"
msgstr ""

# 54e31c4418ba4f65bf37fbca1271d0d5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:71
msgid ":ref:`-headerValuePF-java-`"
msgstr ""

# 49d30cea988c4763aa7f62f3a363d6b1
#: ../../java/http/routing-dsl/directives/alphabetically.rst:71
msgid ""
"Extracts an HTTP header value using a given ``PartialFunction<HttpHeader, "
"T>``"
msgstr ""

# 413578a5a49543909aa99f47877f1157
#: ../../java/http/routing-dsl/directives/alphabetically.rst:72
msgid ":ref:`-host-java-`"
msgstr ""

# afda2980be284c7685af93c3c9d8f3cd
#: ../../java/http/routing-dsl/directives/alphabetically.rst:72
msgid "Rejects all requests with a non-matching host name"
msgstr ""

# 9c5ba71f0cd343b5ad3b01ae657819b0
#: ../../java/http/routing-dsl/directives/alphabetically.rst:73
msgid ":ref:`-listDirectoryContents-java-`"
msgstr ""

# dbba7fd9e10e4003b85ca9452964d305
#: ../../java/http/routing-dsl/directives/alphabetically.rst:73
msgid ""
"Completes GET requests with a unified listing of the contents of all given "
"file-system directories"
msgstr ""

# 4957d5f864684d2ea6255fa1ac15b5b3
#: ../../java/http/routing-dsl/directives/alphabetically.rst:74
msgid ":ref:`-logRequest-java-`"
msgstr ""

# ecae1835b77d4e45b4220cc8f3df22d1
#: ../../java/http/routing-dsl/directives/alphabetically.rst:74
msgid "Produces a log entry for every incoming request"
msgstr ""

# a2db085c1b9b43acb23c9986e6e88b56
#: ../../java/http/routing-dsl/directives/alphabetically.rst:75
msgid ":ref:`-logRequestResult-java-`"
msgstr ""

# 9cc2b4d35eed4b70931bfd12d32d91fb
#: ../../java/http/routing-dsl/directives/alphabetically.rst:75
msgid "Produces a log entry for every incoming request and ``RouteResult``"
msgstr ""

# 8c715928f1514ff68521e33c05ad1b07
#: ../../java/http/routing-dsl/directives/alphabetically.rst:76
msgid ":ref:`-logResult-java-`"
msgstr ""

# 5270321baf484d24bd16e64de30389f8
#: ../../java/http/routing-dsl/directives/alphabetically.rst:76
msgid "Produces a log entry for every ``RouteResult``"
msgstr ""

# 5dde46df29584b808396f3c2812c9312
# 112c26706b0841f493abdc5e68b8987f
#: ../../java/http/routing-dsl/directives/alphabetically.rst:77
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:86
msgid ":ref:`-mapInnerRoute-java-`"
msgstr ""

# 7fce5e3d6bc24a078b4217d3e3143b3b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:77
msgid "Transforms its inner ``Route`` with a ``Route => Route`` function"
msgstr ""

# ccc5849e787544ddb31dd414ceb5fcc9
# 25d3f66bd2b846c29c50c3fb28157bf8
#: ../../java/http/routing-dsl/directives/alphabetically.rst:78
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:73
msgid ":ref:`-mapRejections-java-`"
msgstr ""

# ae2054ee5f2548cfa61cbfa01fe5406e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:78
msgid ""
"Transforms rejections from a previous route with an ``List<Rejection] ⇒ "
"List<Rejection>`` function"
msgstr ""

# ad238aca2b75415e9c7b5e45e241194a
# 5d10061456ce4810a020981ee4153646
#: ../../java/http/routing-dsl/directives/alphabetically.rst:79
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:40
msgid ":ref:`-mapRequest-java-`"
msgstr ""

# de8deed1db5c4a9e907f30f899dcaf18
#: ../../java/http/routing-dsl/directives/alphabetically.rst:79
msgid "Transforms the request with an ``HttpRequest => HttpRequest`` function"
msgstr ""

# 9677fa19aca5409cb0a98004e32ca91a
# bb7c7a9de86f46e4b4188e93f9734235
#: ../../java/http/routing-dsl/directives/alphabetically.rst:80
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:41
msgid ":ref:`-mapRequestContext-java-`"
msgstr ""

# 53315693d7d848b7a46a4ebaecb32f73
#: ../../java/http/routing-dsl/directives/alphabetically.rst:80
msgid ""
"Transforms the ``RequestContext`` with a ``RequestContext => "
"RequestContext`` function"
msgstr ""

# effe035ff5794e1f8c2bf41678a61e12
# 2806d12d41ed4b89a90fa798804ec567
#: ../../java/http/routing-dsl/directives/alphabetically.rst:81
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:59
msgid ":ref:`-mapResponse-java-`"
msgstr ""

# 8dd29788aa6c4c00b5d02e5bffb90c2b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:81
msgid ""
"Transforms the response with an ``HttpResponse => HttpResponse`` function"
msgstr ""

# aba38213847a415f990a561b0568997d
# cbad73be0a84473080735df6459ea21e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:82
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:60
msgid ":ref:`-mapResponseEntity-java-`"
msgstr ""

# 237d4566b8394c75b962f04d0f5e61c6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:82
msgid ""
"Transforms the response entity with an ``ResponseEntity ⇒ ResponseEntity`` "
"function"
msgstr ""

# 6e2d64130a4743d89469fa1c71c95fe0
# 6b11c5e211674a89ac691616f6539c04
#: ../../java/http/routing-dsl/directives/alphabetically.rst:83
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:61
msgid ":ref:`-mapResponseHeaders-java-`"
msgstr ""

# c1bd28f2fc3249dab9ffef09ee1da184
#: ../../java/http/routing-dsl/directives/alphabetically.rst:83
msgid ""
"Transforms the response headers with an ``List<HttpHeader] ⇒ "
"List<HttpHeader>`` function"
msgstr ""

# 3a0c24d721fb4fea99dbc5724157d451
# e2286383b83e41a9927995a020266942
#: ../../java/http/routing-dsl/directives/alphabetically.rst:84
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:74
msgid ":ref:`-mapRouteResult-java-`"
msgstr ""

# e3aa4d302412475dbec20614ac48763f
#: ../../java/http/routing-dsl/directives/alphabetically.rst:84
msgid ""
"Transforms the ``RouteResult`` with a ``RouteResult ⇒ RouteResult`` function"
msgstr ""

# eaf1e958d6ab4b3ca683312a6457077d
# 51e92dc7216440c498501f99ce99a5fe
#: ../../java/http/routing-dsl/directives/alphabetically.rst:85
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:75
msgid ":ref:`-mapRouteResultFuture-java-`"
msgstr ""

# ecd9c7c999d546fe924c92fbccb7e92b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:85
msgid ""
"Transforms the ``RouteResult`` future with a ``CompletionStage<RouteResult] "
"⇒ CompletionStage<RouteResult>`` function"
msgstr ""

# 82873e5b8cc3411e886133149d12f79d
# 6f3c274a0912423db720cd1231931d23
#: ../../java/http/routing-dsl/directives/alphabetically.rst:86
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:76
msgid ":ref:`-mapRouteResultPF-java-`"
msgstr ""

# 7011ed35a5c1458db656cc4044364ecc
#: ../../java/http/routing-dsl/directives/alphabetically.rst:86
msgid ""
"Transforms the ``RouteResult`` with a ``PartialFunction<RouteResult, "
"RouteResult>``"
msgstr ""

# 8354c6ffc20b48a3bb8f0491ed1ea703
# 4be001a0a1964771b52012f26fc53a91
#: ../../java/http/routing-dsl/directives/alphabetically.rst:87
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:77
msgid ":ref:`-mapRouteResultWith-java-`"
msgstr ""

# 4c8f12ffebe44f54a51a1b9380cb4cfa
#: ../../java/http/routing-dsl/directives/alphabetically.rst:87
msgid ""
"Transforms the ``RouteResult`` with a ``RouteResult ⇒ "
"CompletionStage<RouteResult>`` function"
msgstr ""

# 43b8d42e6bab4a35809062c37f13a555
# 81953a74b0aa4e728db04f78743ed0c2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:88
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:78
msgid ":ref:`-mapRouteResultWithPF-java-`"
msgstr ""

# 2cb85081ad724bb5a486fec1d2fc6e32
#: ../../java/http/routing-dsl/directives/alphabetically.rst:88
msgid ""
"Transforms the ``RouteResult`` with a ``PartialFunction<RouteResult, "
"CompletionStage<RouteResult]>``"
msgstr ""

# d5e1c5d692af4287a7e750c557e5986a
# f5b8af52837c4c9385d6619d076c5991
#: ../../java/http/routing-dsl/directives/alphabetically.rst:89
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:42
msgid ":ref:`-mapSettings-java-`"
msgstr ""

# fed9b2a5101c491fb57e6091560f0ee7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:89
msgid ""
"Transforms the ``RoutingSettings`` with a ``RoutingSettings ⇒ "
"RoutingSettings`` function"
msgstr ""

# 20fca9a42c3d4351867e79b0bb43be06
# 3975af1f724945a69a18c5207bd9b5e7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:90
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:43
msgid ":ref:`-mapUnmatchedPath-java-`"
msgstr ""

# d53ffa01dbb44992818d8a90e7634da2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:90
msgid ""
"Transforms the ``unmatchedPath`` of the ``RequestContext`` using a "
"``Uri.Path ⇒ Uri.Path`` function"
msgstr ""

# b4f92ebe991c44239dcf2e58af135c34
#: ../../java/http/routing-dsl/directives/alphabetically.rst:91
msgid ":ref:`-method-java-`"
msgstr ""

# 3bc5a21cfa7549bda25952be5be734ff
#: ../../java/http/routing-dsl/directives/alphabetically.rst:91
msgid "Rejects all requests whose HTTP method does not match the given one"
msgstr ""

# fbac244ee5ca4c848a5557a2e59a7eb7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:92
msgid ":ref:`-onComplete-java-`"
msgstr ""

# 9b97af83b3fa4572aa4b9967e2636779
#: ../../java/http/routing-dsl/directives/alphabetically.rst:92
msgid ""
"\"Unwraps\" a ``CompletionStage<T>`` and runs the inner route after future "
"completion with the future's value as an extraction of type ``Try<T>``"
msgstr ""

# c110142bfc474bf3b10ec100bb5e2186
#: ../../java/http/routing-dsl/directives/alphabetically.rst:93
msgid ":ref:`-onCompleteWithBreaker-java-`"
msgstr ""

# 010c372dce0249a5a80a563ec397236d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:93
msgid ""
"\"Unwraps\" a ``CompletionStage<T>`` inside a ``CircuitBreaker`` and runs "
"the inner route after future completion with the future's value as an "
"extraction of type ``Try<T>``"
msgstr ""

# 459f75ce6181440994bbbf5f6469bc06
#: ../../java/http/routing-dsl/directives/alphabetically.rst:94
msgid ":ref:`-onSuccess-java-`"
msgstr ""

# 6f12f7f62ede4c3c8960d8bc2d9b86f7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:94
msgid ""
"\"Unwraps\" a ``CompletionStage<T>`` and runs the inner route after future "
"completion with the future's value as an extraction of type ``T``"
msgstr ""

# d7eb4beed72a4538b6cbb797569d75be
#: ../../java/http/routing-dsl/directives/alphabetically.rst:95
msgid ":ref:`-optionalCookie-java-`"
msgstr ""

# fefa27b3199a4c2f85522ea89d926241
#: ../../java/http/routing-dsl/directives/alphabetically.rst:95
msgid ""
"Extracts the ``HttpCookiePair`` with the given name as an "
"``Option<HttpCookiePair>``"
msgstr ""

# 70574f940989453ebb67adc13cde02cd
#: ../../java/http/routing-dsl/directives/alphabetically.rst:96
msgid ":ref:`-optionalHeaderValue-java-`"
msgstr ""

# 00092b87f69947ac98c213f3a6da2c56
#: ../../java/http/routing-dsl/directives/alphabetically.rst:96
msgid ""
"Extracts an optional HTTP header value using a given ``HttpHeader ⇒ "
"Option<T>`` function"
msgstr ""

# d3de68cf404f42219653ce428c8bafa9
#: ../../java/http/routing-dsl/directives/alphabetically.rst:97
msgid ":ref:`-optionalHeaderValueByName-java-`"
msgstr ""

# 38f7afb558c14554bf680a85e092fdbe
#: ../../java/http/routing-dsl/directives/alphabetically.rst:97
msgid ""
"Extracts the value of the first optional HTTP request header with a given "
"name"
msgstr ""

# 8b4f31c4309e42e791747b81899de76f
#: ../../java/http/routing-dsl/directives/alphabetically.rst:98
msgid ":ref:`-optionalHeaderValueByType-java-`"
msgstr ""

# 884734f53e724eadb1441cf9613d4e65
#: ../../java/http/routing-dsl/directives/alphabetically.rst:98
msgid "Extracts the first optional HTTP request header of the given type"
msgstr ""

# 910c61c4b6004e86be764d8502846a2d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:99
msgid ":ref:`-optionalHeaderValuePF-java-`"
msgstr ""

# c34eee0a3d58459bb52e0c3a6583e201
#: ../../java/http/routing-dsl/directives/alphabetically.rst:99
msgid ""
"Extracts an optional HTTP header value using a given "
"``PartialFunction<HttpHeader, T>``"
msgstr ""

# b7c8bdee298f40f1b01917cd1fafbd35
#: ../../java/http/routing-dsl/directives/alphabetically.rst:100
msgid ":ref:`-options-java-`"
msgstr ""

# 0147d98fcf3942559a81507385e9dee7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:100
msgid "Rejects all non-OPTIONS requests"
msgstr ""

# 46c925378f014fa9a8ede6d6ba5bd0fe
#: ../../java/http/routing-dsl/directives/alphabetically.rst:101
msgid ":ref:`-overrideMethodWithParameter-java-`"
msgstr ""

# f82898c0217544eca593bcacd925f6a8
#: ../../java/http/routing-dsl/directives/alphabetically.rst:101
msgid ""
"Changes the request method to the value of the specified query parameter"
msgstr ""

# 0e2eb0463f3e4b64a188dae75d4c75ae
# 17ef98a77af94203ad068e9ded8ed371
#: ../../java/http/routing-dsl/directives/alphabetically.rst:102
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:27
msgid ":ref:`-parameter-java-`"
msgstr ""

# d6912a86568247829fdfade053a68766
#: ../../java/http/routing-dsl/directives/alphabetically.rst:102
msgid "Extracts a query parameter value from the request"
msgstr ""

# f890ece052224bd5863fa2e1794d91af
# 7920c31d933d486b98e103b3c5343949
#: ../../java/http/routing-dsl/directives/alphabetically.rst:103
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:28
msgid ":ref:`-parameterMap-java-`"
msgstr ""

# de4e091533e94ec8be37ad850083bb47
#: ../../java/http/routing-dsl/directives/alphabetically.rst:103
msgid "Extracts the request's query parameters as a ``Map<String, String>``"
msgstr ""

# cd7bbb0e2c8443adb782e0d5a759d7cc
# 3fb61ce6f42145548f366aa753b8b72a
#: ../../java/http/routing-dsl/directives/alphabetically.rst:104
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:29
msgid ":ref:`-parameterMultiMap-java-`"
msgstr ""

# 770048211c3a4eea92f5a831cd1222ca
#: ../../java/http/routing-dsl/directives/alphabetically.rst:104
msgid ""
"Extracts the request's query parameters as a ``Map<String, List<String>>``"
msgstr ""

# 976ca72f737a4d85a4636788abb961a5
# 9b4bbb6eb6da4282952f13c1df22691d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:105
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:30
msgid ":ref:`-parameterList-java-`"
msgstr ""

# 57dc85d7219a4b6bb6898487839aa857
#: ../../java/http/routing-dsl/directives/alphabetically.rst:105
msgid ""
"Extracts the request's query parameters as a ``Seq<Pair<String, String>>``"
msgstr ""

# fc3bea2be79d4664b1680d8c468d756d
# 947265745ff84a7f910765992b9d61e0
#: ../../java/http/routing-dsl/directives/alphabetically.rst:106
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:87
msgid ":ref:`-pass-java-`"
msgstr ""

# 7a0fbf43491649e98e876da000fc6e30
#: ../../java/http/routing-dsl/directives/alphabetically.rst:106
msgid ""
"Always simply passes the request on to its inner route, i.e. doesn't do "
"anything, neither with the request nor the response"
msgstr ""

# eab39c9a2e1b45409bb706993dc91199
#: ../../java/http/routing-dsl/directives/alphabetically.rst:107
msgid ":ref:`-patch-java-`"
msgstr ""

# 12be375c761a43afa5ce6338242b1ac2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:107
msgid "Rejects all non-PATCH requests"
msgstr ""

# 45ea3d2b39dd4ca798bb26fd68690ebc
#: ../../java/http/routing-dsl/directives/alphabetically.rst:108
msgid ":ref:`-path-java-`"
msgstr ""

# d5edfd18f0954920b5716abd939234dc
#: ../../java/http/routing-dsl/directives/alphabetically.rst:108
msgid ""
"Applies the given ``PathMatcher`` to the remaining unmatched path after "
"consuming a leading slash"
msgstr ""

# 1ff94d185ab64cd7840294c5dd26a26a
#: ../../java/http/routing-dsl/directives/alphabetically.rst:109
msgid ":ref:`-pathEnd-java-`"
msgstr ""

# 7d7959baedbd4cc7ab2c274d94b69d0b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:109
msgid ""
"Only passes on the request to its inner route if the request path has been "
"matched completely"
msgstr ""

# 8be3bb6b057e4bfeb3089521776378b1
#: ../../java/http/routing-dsl/directives/alphabetically.rst:110
msgid ":ref:`-pathEndOrSingleSlash-java-`"
msgstr ""

# 69527a4d80d84f1fbbed29f35e8a4f54
#: ../../java/http/routing-dsl/directives/alphabetically.rst:110
msgid ""
"Only passes on the request to its inner route if the request path has been "
"matched completely or only consists of exactly one remaining slash"
msgstr ""

# 0956d29c6db34063958e312a02dcc213
#: ../../java/http/routing-dsl/directives/alphabetically.rst:111
msgid ":ref:`-pathPrefix-java-`"
msgstr ""

# 60e21c2c84e94ba799ae55b6f93a7d01
#: ../../java/http/routing-dsl/directives/alphabetically.rst:111
msgid ""
"Applies the given ``PathMatcher`` to a prefix of the remaining unmatched "
"path after consuming a leading slash"
msgstr ""

# 81b175ef8c1446fca14965760d6e6108
#: ../../java/http/routing-dsl/directives/alphabetically.rst:112
msgid ":ref:`-pathPrefixTest-java-`"
msgstr ""

# 663318e32d754fed94bc9844624ce248
#: ../../java/http/routing-dsl/directives/alphabetically.rst:112
msgid ""
"Checks whether the unmatchedPath has a prefix matched by the given "
"``PathMatcher`` after implicitly consuming a leading slash"
msgstr ""

# e7b525519df042ce95ff48b8417a38a2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:113
msgid ":ref:`-pathSingleSlash-java-`"
msgstr ""

# 7562cc4d476340d0b40917b230723e99
#: ../../java/http/routing-dsl/directives/alphabetically.rst:113
msgid ""
"Only passes on the request to its inner route if the request path consists "
"of exactly one remaining slash"
msgstr ""

# cad91dd980994668987fb6e2fcbfd800
#: ../../java/http/routing-dsl/directives/alphabetically.rst:114
msgid ":ref:`-pathSuffix-java-`"
msgstr ""

# 82a242b9f00242f293e48cc28c64f6f4
#: ../../java/http/routing-dsl/directives/alphabetically.rst:114
msgid ""
"Applies the given ``PathMatcher`` to a suffix of the remaining unmatched "
"path (Caution: check java!)"
msgstr ""

# 6eb630e52af74b068e326fb01c6c267c
#: ../../java/http/routing-dsl/directives/alphabetically.rst:115
msgid ":ref:`-pathSuffixTest-java-`"
msgstr ""

# 8086c1c940ca49eda030bdc2d8a7ddf2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:115
msgid ""
"Checks whether the unmatched path has a suffix matched by the given "
"``PathMatcher`` (Caution: check java!)"
msgstr ""

# 7248f9a1a6e546ce8746876c70d71044
#: ../../java/http/routing-dsl/directives/alphabetically.rst:116
msgid ":ref:`-post-java-`"
msgstr ""

# 561fb1b3e19643c2aee9d00d554975aa
#: ../../java/http/routing-dsl/directives/alphabetically.rst:116
msgid "Rejects all non-POST requests"
msgstr ""

# b4998683f5d946319350a743aaa0aa33
# fdd42ecf9baa4c49bffb152bf0fec2b0
#: ../../java/http/routing-dsl/directives/alphabetically.rst:117
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:32
msgid ":ref:`-provide-java-`"
msgstr ""

# c53dc224f6ac42ba86b3ffdaab77f95b
#: ../../java/http/routing-dsl/directives/alphabetically.rst:117
msgid "Injects a given value into a directive"
msgstr ""

# dc580d7f6f694a34a0dd003e60ab6af9
#: ../../java/http/routing-dsl/directives/alphabetically.rst:118
msgid ":ref:`-put-java-`"
msgstr ""

# 175cc4abd80842c8b9d1d050c760db73
#: ../../java/http/routing-dsl/directives/alphabetically.rst:118
msgid "Rejects all non-PUT requests"
msgstr ""

# 887668541dba4232be9edfbe21bc11df
#: ../../java/http/routing-dsl/directives/alphabetically.rst:119
msgid ":ref:`-rawPathPrefix-java-`"
msgstr ""

# 60fab579430d4572866e1de26aa5ba5e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:119
msgid ""
"Applies the given matcher directly to a prefix of the unmatched path of the "
"``RequestContext``, without implicitly consuming a leading slash"
msgstr ""

# 2d59c455eb8d470d90b64056e68f5c20
#: ../../java/http/routing-dsl/directives/alphabetically.rst:120
msgid ":ref:`-rawPathPrefixTest-java-`"
msgstr ""

# 562da3b922714942bcc7203a2b03765c
#: ../../java/http/routing-dsl/directives/alphabetically.rst:120
msgid ""
"Checks whether the unmatchedPath has a prefix matched by the given "
"``PathMatcher``"
msgstr ""

# 1a6645bcd6f6460098c488ce60321227
# 4a821ecca3754db58c51cf230559ce18
#: ../../java/http/routing-dsl/directives/alphabetically.rst:121
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:79
msgid ":ref:`-recoverRejections-java-`"
msgstr ""

# b18250325e4843e59aa688cc84346397
#: ../../java/http/routing-dsl/directives/alphabetically.rst:121
msgid ""
"Transforms rejections from the inner route with an ``List<Rejection] ⇒ "
"RouteResult`` function"
msgstr ""

# c81bcd35cb5249a58cf42b09a98fa451
# f35d08fbd5444c1bb9f7ac8645e90b05
#: ../../java/http/routing-dsl/directives/alphabetically.rst:122
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:80
msgid ":ref:`-recoverRejectionsWith-java-`"
msgstr ""

# 8879373e8c5e45bcbefe707ac9f347dd
#: ../../java/http/routing-dsl/directives/alphabetically.rst:122
msgid ""
"Transforms rejections from the inner route with an ``List<Rejection] ⇒ "
"CompletionStage<RouteResult>`` function"
msgstr ""

# c14b8e9ab2cc4cfd88069b4c7aa18b9e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:123
msgid ":ref:`-redirect-java-`"
msgstr ""

# 47d5bcd75fa04dd1892be30066c098f6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:123
msgid ""
"Completes the request with redirection response of the given type to the "
"given URI"
msgstr ""

# f06477d0adfa47a4bfe43e585fa13df2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:124
msgid ":ref:`-redirectToNoTrailingSlashIfPresent-java-`"
msgstr ""

# 9748c0ca3fe04e2eacab6fcd55151cae
#: ../../java/http/routing-dsl/directives/alphabetically.rst:124
msgid ""
"If the request path ends with a slash, redirects to the same uri without "
"trailing slash in the path"
msgstr ""

# 0a5c9cab40dd4fb3bf94748be285fcce
#: ../../java/http/routing-dsl/directives/alphabetically.rst:125
msgid ":ref:`-redirectToTrailingSlashIfMissing-java-`"
msgstr ""

# c3b9e9c76e9943378ea313bcc611a522
#: ../../java/http/routing-dsl/directives/alphabetically.rst:125
msgid ""
"If the request path doesn't end with a slash, redirects to the same uri with"
" trailing slash in the path"
msgstr ""

# b11b5ea201154764b771fc5a3cf252ff
#: ../../java/http/routing-dsl/directives/alphabetically.rst:126
msgid ":ref:`-reject-java-`"
msgstr ""

# 4c07311550884cf39de7439939cc11d5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:126
msgid "Rejects the request with the given rejections"
msgstr ""

# dd19e9c2c14043c5b2b5a625f49d5aac
#: ../../java/http/routing-dsl/directives/alphabetically.rst:127
msgid ":ref:`-rejectEmptyResponse-java-`"
msgstr ""

# 5cab9b3b19894e3b9d8f61219cb58084
#: ../../java/http/routing-dsl/directives/alphabetically.rst:127
msgid "Converts responses with an empty entity into (empty) rejections"
msgstr ""

# f2445fb68e304876914791509c304f20
#: ../../java/http/routing-dsl/directives/alphabetically.rst:128
msgid ":ref:`-requestEncodedWith-java-`"
msgstr ""

# fbbde7d79cb0416598ff564c42a345cd
#: ../../java/http/routing-dsl/directives/alphabetically.rst:128
msgid ""
"Rejects the request with an ``UnsupportedRequestEncodingRejection`` if its "
"encoding doesn't match the given one"
msgstr ""

# 7e0e5c56395e4537b6cb2d3a736fb6cc
#: ../../java/http/routing-dsl/directives/alphabetically.rst:129
msgid ":ref:`-requestEntityEmpty-java-`"
msgstr ""

# f7700b1c95134b70b1e79523fbeba8df
#: ../../java/http/routing-dsl/directives/alphabetically.rst:129
msgid "Rejects if the request entity is non-empty"
msgstr ""

# e5504f9b8bab406db33efd84f857427d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:130
msgid ":ref:`-requestEntityPresent-java-`"
msgstr ""

# 08a6ad246cce48ae954b3832b89e72ec
#: ../../java/http/routing-dsl/directives/alphabetically.rst:130
msgid ""
"Rejects with a ``RequestEntityExpectedRejection`` if the request entity is "
"empty"
msgstr ""

# 1f59dd38a4b54d8fbbb1126ca8aa1107
#: ../../java/http/routing-dsl/directives/alphabetically.rst:131
msgid ":ref:`-respondWithDefaultHeader-java-`"
msgstr ""

# 6b31116e97934c6f87cc6ec81882cf55
#: ../../java/http/routing-dsl/directives/alphabetically.rst:131
msgid ""
"Adds a given response header if the response doesn't already contain a "
"header with the same name"
msgstr ""

# ef97df0b96c34c279d3672b3197ec7c6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:132
msgid ":ref:`-respondWithDefaultHeaders-java-`"
msgstr ""

# 03d4bf82def046ea98ece87c3b561f81
#: ../../java/http/routing-dsl/directives/alphabetically.rst:132
msgid ""
"Adds the subset of the given headers to the response which doesn't already "
"have a header with the respective name present in the response"
msgstr ""

# a4d4ed93565d4e59bcda54d0d3bef4aa
#: ../../java/http/routing-dsl/directives/alphabetically.rst:133
msgid ":ref:`-respondWithHeader-java-`"
msgstr ""

# b5065243efb14bfc814d799210fcb0f9
#: ../../java/http/routing-dsl/directives/alphabetically.rst:133
msgid "Unconditionally adds a given header to the outgoing response"
msgstr ""

# 79ce91fd80aa478091aab0594d81fbdf
#: ../../java/http/routing-dsl/directives/alphabetically.rst:134
msgid ":ref:`-respondWithHeaders-java-`"
msgstr ""

# 5ff0b212adc34d308800200ed31aceeb
#: ../../java/http/routing-dsl/directives/alphabetically.rst:134
msgid "Unconditionally adds the given headers to the outgoing response"
msgstr ""

# eca3f861fd0e425692598e4cec5596e7
#: ../../java/http/routing-dsl/directives/alphabetically.rst:135
msgid ":ref:`-responseEncodingAccepted-java-`"
msgstr ""

# 475c0e9b7c9643bd90e7f2a00f177d39
#: ../../java/http/routing-dsl/directives/alphabetically.rst:135
msgid ""
"Rejects the request with an ``UnacceptedResponseEncodingRejection`` if the "
"given response encoding is not accepted by the client"
msgstr ""

# 0d92b330e20b4a4e8430226aacc3d91d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:136
msgid ":ref:`-scheme-java-`"
msgstr ""

# c3ab63fdcdfb4429bd50ab82a1aaba9c
#: ../../java/http/routing-dsl/directives/alphabetically.rst:136
msgid "Rejects all requests whose URI scheme doesn't match the given one"
msgstr ""

# b57a02d2f11447edb9a4f902b91836d8
#: ../../java/http/routing-dsl/directives/alphabetically.rst:137
msgid ":ref:`-selectPreferredLanguage-java-`"
msgstr ""

# 4dcdc260cd3f45f3b288e31cf89df74e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:137
msgid ""
"Inspects the request's ``Accept-Language`` header and determines, which of a"
" given set of language alternatives is preferred by the client"
msgstr ""

# 3a683b9b4b2e48e6b7e4dc8d9f22b3e6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:138
msgid ":ref:`-setCookie-java-`"
msgstr ""

# cb27c87114df4517914e2e1ba7258219
#: ../../java/http/routing-dsl/directives/alphabetically.rst:138
msgid "Adds a ``Set-Cookie`` response header with the given cookies"
msgstr ""

# 074816561dab4ef5824d43de96606bc2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:139
msgid ":ref:`-uploadedFile-java-`"
msgstr ""

# 591640e0859a40ba9221f4a8c9718be5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:139
msgid "Streams one uploaded file from a multipart request to a file on disk"
msgstr ""

# 107ce6fdab61480daae44447fa281121
#: ../../java/http/routing-dsl/directives/alphabetically.rst:140
msgid ":ref:`-validate-java-`"
msgstr ""

# 145f5e5c722f4f56a3930deeb4759f33
#: ../../java/http/routing-dsl/directives/alphabetically.rst:140
msgid "Checks a given condition before running its inner route"
msgstr ""

# 898e8c177f8241379b2cddf166739dd2
#: ../../java/http/routing-dsl/directives/alphabetically.rst:141
msgid ":ref:`-withoutRequestTimeout-java-`"
msgstr ""

# 29c05de71bfb4177bff9c62798129cfe
#: ../../java/http/routing-dsl/directives/alphabetically.rst:141
msgid ""
"Disables :ref:`request timeouts <request-timeout-java>` for a given route."
msgstr ""

# c06d177efdce4bc4b88a74b359b6a6a5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:142
msgid ":ref:`-withoutSizeLimit-java-`"
msgstr ""

# 1d4b8fb618484914a30ae94a551efed9
#: ../../java/http/routing-dsl/directives/alphabetically.rst:142
msgid "Skips request entity size check"
msgstr ""

# 6c3d62548ac44cd1932e991966cb6c74
# 4631d0022692447fb5d32610824f9353
#: ../../java/http/routing-dsl/directives/alphabetically.rst:143
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:44
msgid ":ref:`-withExecutionContext-java-`"
msgstr ""

# 53e0bd67d28b43fa86cd6608e003a391
#: ../../java/http/routing-dsl/directives/alphabetically.rst:143
msgid "Runs its inner route with the given alternative ``ExecutionContext``"
msgstr ""

# 5abd42e01d00416ba8086c5e7de15253
# 50a4f9d3ba184b79b551251dff6c44d6
#: ../../java/http/routing-dsl/directives/alphabetically.rst:144
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:45
msgid ":ref:`-withMaterializer-java-`"
msgstr ""

# 51f0aabcf166454280c092be3bfdd998
#: ../../java/http/routing-dsl/directives/alphabetically.rst:144
msgid "Runs its inner route with the given alternative ``Materializer``"
msgstr ""

# df8b5850e759456b80698032e7bf7e58
# 1a852486a4e641008ab97d6d543aa88e
#: ../../java/http/routing-dsl/directives/alphabetically.rst:145
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:46
msgid ":ref:`-withLog-java-`"
msgstr ""

# 6137dc99e9664bcd83e2c3e3641163af
#: ../../java/http/routing-dsl/directives/alphabetically.rst:145
msgid "Runs its inner route with the given alternative ``LoggingAdapter``"
msgstr ""

# 5b06e77421cc41ed8e3211f7f367941d
#: ../../java/http/routing-dsl/directives/alphabetically.rst:146
msgid ":ref:`-withRangeSupport-java-`"
msgstr ""

# f9ece1eb795c4d11b2958ff36abf37ca
#: ../../java/http/routing-dsl/directives/alphabetically.rst:146
msgid ""
"Adds ``Accept-Ranges: bytes`` to responses to GET requests, produces partial"
" responses if the initial request contained a valid ``Range`` header"
msgstr ""

# 4574e7a224b047b5824b1ffcab1f6759
#: ../../java/http/routing-dsl/directives/alphabetically.rst:147
msgid ":ref:`-withRequestTimeout-java-`"
msgstr ""

# efe18072a94747e08e1d2b2d87444894
#: ../../java/http/routing-dsl/directives/alphabetically.rst:147
msgid ""
"Configures the :ref:`request timeouts <request-timeout-java>` for a given "
"route."
msgstr ""

# 8ec94fdc40144c169a7617e3b4d7abce
#: ../../java/http/routing-dsl/directives/alphabetically.rst:148
msgid ":ref:`-withRequestTimeoutResponse-java-`"
msgstr ""

# fab315b5d2a44b5d9fc9b7724970eb03
#: ../../java/http/routing-dsl/directives/alphabetically.rst:148
msgid ""
"Prepares the ``HttpResponse`` that is emitted if a request timeout is "
"triggered. ``RequestContext => RequestContext`` function"
msgstr ""

# 4816093f9ca548479a6d28032eecf3d8
# 3be817003d4e4bb89fa2ed06cba69bbf
#: ../../java/http/routing-dsl/directives/alphabetically.rst:149
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:47
msgid ":ref:`-withSettings-java-`"
msgstr ""

# 78aab70a8b61437ca901684d945773ca
#: ../../java/http/routing-dsl/directives/alphabetically.rst:149
msgid "Runs its inner route with the given alternative ``RoutingSettings``"
msgstr ""

# da933b8a56f84cdca44aa90169c696d5
#: ../../java/http/routing-dsl/directives/alphabetically.rst:150
msgid ":ref:`-withSizeLimit-java-`"
msgstr ""

# c0e9d5e686c147cb98128a239f106c68
#: ../../java/http/routing-dsl/directives/alphabetically.rst:150
msgid "Applies request entity size check"
msgstr ""

# 3a1abfa077fe44799852c6aef056bb90
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejection.rst:4
msgid "cancelRejection"
msgstr ""

# 8a56abc19d05493aba791ba3ffac3146
# ca5b010d41be40c08aaa1765ba7e8a16
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejection.rst:12
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejections.rst:14
msgid "Read :ref:`rejections-java` to learn more about rejections."
msgstr ""

# 523a51c987a74d42b1f7da57840dea67
# a1afe1ae450449e09b64c0d1f33dbf48
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejection.rst:14
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejections.rst:16
msgid ""
"For more advanced handling of rejections refer to the :ref"
":`-handleRejections-java-` directive which provides a nicer DSL for building"
" rejection handlers."
msgstr ""

# 03ca637155974da5b366d5c04ae27b7a
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejections.rst:4
msgid "cancelRejections"
msgstr ""

# fb8c6c14bc174867b0db2c8b72083ae8
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejections.rst:9
msgid ""
"Adds a ``TransformationRejection`` cancelling all rejections created by the "
"inner route for which the condition argument function returns ``true``."
msgstr ""

# dc0d513c54de4772acee88372817b6b8
#: ../../java/http/routing-dsl/directives/basic-directives/cancelRejections.rst:12
msgid ""
"See also :ref:`-cancelRejection-java-`, for canceling a specific rejection."
msgstr ""

# 501a49053eab47afb63c25cc25d129ea
#: ../../java/http/routing-dsl/directives/basic-directives/extract.rst:4
msgid "extract"
msgstr ""

# b8806434eaac4853849a180af7637b63
#: ../../java/http/routing-dsl/directives/basic-directives/extract.rst:9
msgid ""
"The ``extract`` directive is used as a building block for :ref:`Custom "
"Directives-java` to extract data from the ``RequestContext`` and provide it "
"to the inner route."
msgstr ""

# 6622484faba04426bf4ecb3a7abfc9f2
# 6cb013050a184bf198e5719f5ddf6666
#: ../../java/http/routing-dsl/directives/basic-directives/extract.rst:12
#: ../../java/http/routing-dsl/directives/basic-directives/provide.rst:12
msgid ""
"See :ref:`ProvideDirectives-java` for an overview of similar directives."
msgstr ""

# 4d1477e06d2a4c0c96d126a5e403f6d6
#: ../../java/http/routing-dsl/directives/basic-directives/extractActorSystem.rst:4
msgid "extractActorSystem"
msgstr ""

# df67d012a9a241e3afa4632a9841c02c
#: ../../java/http/routing-dsl/directives/basic-directives/extractActorSystem.rst:9
msgid ""
"Extracts the ``ActorSystem`` from the ``RequestContext``, which can be "
"useful when the external API in your route needs one."
msgstr ""

# aeeecd5f068d4e1bb34c87b13d666b70
#: ../../java/http/routing-dsl/directives/basic-directives/extractActorSystem.rst:14
msgid ""
"This is only supported when the available Materializer is an "
"ActorMaterializer."
msgstr ""

# 8d21c0c19e0f4a75b168f857031979f2
#: ../../java/http/routing-dsl/directives/basic-directives/extractDataBytes.rst:4
msgid "extractDataBytes"
msgstr ""

# c76aa40a81a149b185fdd2332686d59b
#: ../../java/http/routing-dsl/directives/basic-directives/extractDataBytes.rst:9
msgid ""
"Extracts the entities data bytes as ``Source[ByteString, Any]`` from the "
":class:`RequestContext`."
msgstr ""

# 31c1d115a953476eaf1cfc2dbc13f5a9
#: ../../java/http/routing-dsl/directives/basic-directives/extractDataBytes.rst:11
msgid "The directive returns a stream containing the request data bytes."
msgstr ""

# 8c4b0515b89b42838e203909595cb86d
#: ../../java/http/routing-dsl/directives/basic-directives/extractExecutionContext.rst:4
msgid "extractExecutionContext"
msgstr ""

# 094647fa74294852b564c519d8800710
#: ../../java/http/routing-dsl/directives/basic-directives/extractExecutionContext.rst:9
msgid "Extracts the ``ExecutionContext`` from the ``RequestContext``."
msgstr ""

# 807c85fca4c249a19fd7562000a99c56
#: ../../java/http/routing-dsl/directives/basic-directives/extractExecutionContext.rst:11
msgid ""
"See :ref:`-withExecutionContext-java-` to see how to customise the execution"
" context provided for an inner route."
msgstr ""

# 496318430fd84ce2b4d0a5e68702b7a7
#: ../../java/http/routing-dsl/directives/basic-directives/extractExecutionContext.rst:13
msgid "See :ref:`-extract-java-` to learn more about how extractions work."
msgstr ""

# a59bc98fcfb54e9787d2bc6aca1c0504
#: ../../java/http/routing-dsl/directives/basic-directives/extractLog.rst:4
msgid "extractLog"
msgstr ""

# c44a5e7545e943fd835f8a280ba39995
#: ../../java/http/routing-dsl/directives/basic-directives/extractLog.rst:9
msgid ""
"Extracts a :class:`LoggingAdapter` from the request context which can be "
"used for logging inside the route."
msgstr ""

# 151fe3ef08124323b47baf9d138bbbc0
#: ../../java/http/routing-dsl/directives/basic-directives/extractLog.rst:11
msgid ""
"The ``extractLog`` directive is used for providing logging to routes, such "
"that they don't have to depend on closing over a logger provided in the "
"class body."
msgstr ""

# 360147d7dc52440fa3f8562a363e5ad0
#: ../../java/http/routing-dsl/directives/basic-directives/extractLog.rst:14
msgid ""
"See :ref:`-extract-java-` and :ref:`ProvideDirectives-java` for an overview "
"of similar directives."
msgstr ""

# 10f17154041041c49c5307809237ae6d
#: ../../java/http/routing-dsl/directives/basic-directives/extractMaterializer.rst:4
msgid "extractMaterializer"
msgstr ""

# 8c07977cf12943db932106d532b2cf41
#: ../../java/http/routing-dsl/directives/basic-directives/extractMaterializer.rst:9
msgid ""
"Extracts the ``Materializer`` from the ``RequestContext``, which can be "
"useful when you want to run an Akka Stream directly in your route."
msgstr ""

# 9d2c0e1ad86b4f8cb7cb3f5b549489bc
#: ../../java/http/routing-dsl/directives/basic-directives/extractMaterializer.rst:12
msgid ""
"See also :ref:`-withMaterializer-java-` to see how to customise the used "
"materializer for specific inner routes."
msgstr ""

# a86e217d9c3c40fa8154122e78df1937
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequest.rst:4
msgid "extractRequest"
msgstr ""

# 9c7a5740d9b94350a10b13680f08059d
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequest.rst:8
msgid "Extracts the complete ``HttpRequest`` instance."
msgstr ""

# 706d57e453024133860417d2380d44d2
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequest.rst:10
msgid ""
"Use ``extractRequest`` to extract just the complete URI of the request. "
"Usually there's little use of extracting the complete request because "
"extracting of most of the aspects of HttpRequests is handled by specialized "
"directives. See :ref:`Request Directives-java`."
msgstr ""

# 4e110bfab0444d258d2a6a396360dea6
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestContext.rst:4
msgid "extractRequestContext"
msgstr ""

# 64d1c34ce2be4ea296fbc1936c891600
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestContext.rst:9
msgid "Extracts the request's underlying :class:`RequestContext`."
msgstr ""

# b44ba7c35aa24caab9e7ea2dbf9f3894
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestContext.rst:11
msgid ""
"This directive is used as a building block for most of the other directives,"
" which extract the context and by inspecting some of it's values can decide "
"what to do with the request - for example provide a value, or reject the "
"request."
msgstr ""

# 4c93f5b59da849748213dca02a470e4a
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestContext.rst:15
msgid ""
"See also :ref:`-extractRequest-java-` if only interested in the "
":class:`HttpRequest` instance itself."
msgstr ""

# d2fee910ac834e2aa15f0d437f5cf3ff
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestEntity.rst:4
msgid "extractRequestEntity"
msgstr ""

# 080b4ae5bab344f1b681b8be9055087f
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestEntity.rst:9
msgid "Extracts the ``RequestEntity`` from the :class:`RequestContext`."
msgstr ""

# 1211a3f5771a4ac0a49f57f4690a2811
#: ../../java/http/routing-dsl/directives/basic-directives/extractRequestEntity.rst:11
msgid ""
"The directive returns a ``RequestEntity`` without unmarshalling the request."
" To extract domain entity, :ref:`-entity-java-` should be used."
msgstr ""

# a1a33fd3f7284035a3679cc3bd313d9f
#: ../../java/http/routing-dsl/directives/basic-directives/extractSettings.rst:4
msgid "extractSettings"
msgstr ""

# cca3cccedcce449683b4a0504edf822d
#: ../../java/http/routing-dsl/directives/basic-directives/extractSettings.rst:9
msgid ""
"Extracts the :class:`RoutingSettings` from the :class:`RequestContext`."
msgstr ""

# 51ccec9a5a6a4ddcb2e19142f63ebc62
#: ../../java/http/routing-dsl/directives/basic-directives/extractSettings.rst:11
msgid ""
"By default the settings of the ``Http()`` extension running the route will "
"be returned. It is possible to override the settings for specific sub-routes"
" by using the :ref:`-withSettings-java-` directive."
msgstr ""

# c86d1f44f8a241a6bf9ea303c2d4ac45
#: ../../java/http/routing-dsl/directives/basic-directives/extractStrictEntity.rst:4
msgid "extractStrictEntity"
msgstr ""

# d57510916ff44b9f8123a2694175ea25
#: ../../java/http/routing-dsl/directives/basic-directives/extractStrictEntity.rst:9
msgid ""
"Extracts the strict http entity as ``HttpEntity.Strict`` from the "
":class:`RequestContext`."
msgstr ""

# d92071c5a3764bd4962d18039e16262a
# 7834e5bf46654033bdf12b87765d1ce3
#: ../../java/http/routing-dsl/directives/basic-directives/extractStrictEntity.rst:11
#: ../../java/http/routing-dsl/directives/basic-directives/toStrictEntity.rst:11
msgid ""
"A timeout parameter is given and if the stream isn't completed after the "
"timeout, the directive will be failed."
msgstr ""

# 1fd5f087ac6648ca850182f8183ec684
# 50a54da788804647ab9365b6008402eb
#: ../../java/http/routing-dsl/directives/basic-directives/extractStrictEntity.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/toStrictEntity.rst:15
msgid ""
"The directive will read the request entity into memory within the size "
"limit(8M by default) and effectively disable streaming. The size limit can "
"be configured globally with ``akka.http.parsing.max-content-length`` or "
"overridden by wrapping with :ref:`-withSizeLimit-java-` or :ref"
":`-withoutSizeLimit-java-` directive."
msgstr ""

# 4f864d5090764feaa4808610d85f32a2
#: ../../java/http/routing-dsl/directives/basic-directives/extractUnmatchedPath.rst:4
msgid "extractUnmatchedPath"
msgstr ""

# 91c80d38026043c98cf083c6e9d02f06
#: ../../java/http/routing-dsl/directives/basic-directives/extractUnmatchedPath.rst:8
msgid "Extracts the unmatched path from the request context."
msgstr ""

# 8a737d7012a247c1bdefd7436d4c3eab
#: ../../java/http/routing-dsl/directives/basic-directives/extractUnmatchedPath.rst:10
msgid ""
"The ``extractUnmatchedPath`` directive extracts the remaining path that was "
"not yet matched by any of the :ref:`PathDirectives-java` (or any custom ones"
" that change the unmatched path field of the request context). You can use "
"it for building directives that handle complete suffixes of paths (like the "
"``getFromDirectory`` directives and similar ones)."
msgstr ""

# e0cf426aed8343009e009c2eb836a594
#: ../../java/http/routing-dsl/directives/basic-directives/extractUnmatchedPath.rst:14
msgid "Use ``mapUnmatchedPath`` to change the value of the unmatched path."
msgstr ""

# 56b66f9da252470f9bd1a2fb9d63c930
#: ../../java/http/routing-dsl/directives/basic-directives/extractUri.rst:4
msgid "extractUri"
msgstr ""

# 4c7f87fd31a3406a84506bf3bdc3244d
#: ../../java/http/routing-dsl/directives/basic-directives/extractUri.rst:8
msgid "Access the full URI of the request."
msgstr ""

# 1626767c0f714f35a8548e1493d51a0a
#: ../../java/http/routing-dsl/directives/basic-directives/extractUri.rst:10
msgid ""
"Use :ref:`SchemeDirectives-java`, :ref:`HostDirectives-java`, :ref"
":`PathDirectives-java`,  and :ref:`ParameterDirectives-java` for more "
"targeted access to parts of the URI."
msgstr ""

# 766932ef37df444182ec648e2c6f7c2c
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:4
msgid "BasicDirectives"
msgstr ""

# 36110ae949864275a5ab4fac35336969
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:6
msgid ""
"Basic directives are building blocks for building :ref:`Custom Directives`. "
"As such they usually aren't used in a route directly but rather in the "
"definition of new directives."
msgstr ""

# 6b257de1a2a64a698c54b6453bef1eab
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:13
msgid "Providing Values to Inner Routes"
msgstr ""

# 39ad6b404cf4446187f3d43823d8e7d7
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:15
msgid ""
"These directives provide values to the inner routes with extractions. They "
"can be distinguished on two axes: a) provide a constant value or extract a "
"value from the ``RequestContext`` b) provide a single value or a tuple of "
"values."
msgstr ""

# 63eb7b3841ce446a99ede44646ed954a
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:20
msgid ":ref:`-extractActorSystem-java-`"
msgstr ""

# cc4ab23d9d3a47e284e9b9eba3df26f4
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:21
msgid ":ref:`-extractDataBytes-java-`"
msgstr ""

# 7ab827f409ac49e49c46379fac6d090a
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:24
msgid ":ref:`-extractStrictEntity-java-`"
msgstr ""

# 3f0ca556629e4b699ac203f48d159669
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:28
msgid ":ref:`-extractRequestEntity-java-`"
msgstr ""

# b051414c2de24459b4c1e004c66d68ef
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:38
msgid "Transforming the Request(Context)"
msgstr ""

# 74ad3623c0f34cadbaf8b9fc84974845
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:48
msgid ":ref:`-toStrictEntity-java-`"
msgstr ""

# 5309ed8541864fe894a9f01785409bda
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:54
msgid "Transforming the Response"
msgstr ""

# a724d62a0cac420b8a9d438b07309086
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:56
msgid ""
"These directives allow to hook into the response path and transform the "
"complete response or the parts of a response or the list of rejections:"
msgstr ""

# 276e45f8ed5649c8b8628982b3fcff41
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:67
msgid "Transforming the RouteResult"
msgstr ""

# ddadee340be7497cb0c7dc1f512d7ffd
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:69
msgid ""
"These directives allow to transform the RouteResult of the inner route."
msgstr ""

# 0cb0149162cb4f5db9cf9f176bd5874d
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:84
msgid "Other"
msgstr ""

# fde641612e0945208a55ff8e70b1bfe7
#: ../../java/http/routing-dsl/directives/basic-directives/index.rst:91
msgid "Alphabetically"
msgstr ""

# dfe80f906c754af99061296279f2b72c
#: ../../java/http/routing-dsl/directives/basic-directives/mapInnerRoute.rst:4
msgid "mapInnerRoute"
msgstr ""

# 5f8f34cc2ebd40659db5587653f25a35
#: ../../java/http/routing-dsl/directives/basic-directives/mapInnerRoute.rst:8
msgid ""
"Changes the execution model of the inner route by wrapping it with arbitrary"
" logic."
msgstr ""

# 56a5eb8eb4504e22be61026a10d709f4
#: ../../java/http/routing-dsl/directives/basic-directives/mapInnerRoute.rst:10
msgid ""
"The ``mapInnerRoute`` directive is used as a building block for :ref:`Custom"
" Directives-java` to replace the inner route with any other route. Usually, "
"the returned route wraps the original one with custom execution logic."
msgstr ""

# 465583ae6d804eebb274b55dd9954ef4
#: ../../java/http/routing-dsl/directives/basic-directives/mapRejections.rst:4
msgid "mapRejections"
msgstr ""

# 64edd13cd1504f739cdd9add50d1a1c7
# 5e554a530e58477d93b4f1415a14ad3d
# 0a005db67da545908b12eb49a2e77155
#: ../../java/http/routing-dsl/directives/basic-directives/mapRejections.rst:9
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejections.rst:8
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejectionsWith.rst:9
msgid ""
"**Low level directive** – unless you're sure you need to be working on this "
"low-level you might instead want to try the :ref:`-handleRejections-java-` "
"directive which provides a nicer DSL for building rejection handlers."
msgstr ""

# 62b78e3c0a964408bccb2805a84349ae
#: ../../java/http/routing-dsl/directives/basic-directives/mapRejections.rst:12
msgid ""
"The ``mapRejections`` directive is used as a building block for :ref:`Custom"
" Directives-java` to transform a list of rejections from the inner route to "
"a new list of rejections."
msgstr ""

# 5c9ecb13d05e40ff8f3000ddd475d20c
# 6bdaef92c65a47c2a3ede2e9d12a2d69
# 100fe90b37604e4ababa7419f8382be8
#: ../../java/http/routing-dsl/directives/basic-directives/mapRejections.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseEntity.rst:12
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseHeaders.rst:13
msgid ""
"See :ref:`Response Transforming Directives-java` for similar directives."
msgstr ""

# 4f8445e14c27477da2af5ce8725bb3d2
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequest.rst:4
msgid "mapRequest"
msgstr ""

# 2bbb8ddfd43948e983700f04bee99148
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequest.rst:8
msgid "Transforms the request before it is handled by the inner route."
msgstr ""

# 1b3ec77828bd4032819af517dc16c4de
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequest.rst:10
msgid ""
"The ``mapRequest`` directive is used as a building block for :ref:`Custom "
"Directives-java` to transform a request before it is handled by the inner "
"route. Changing the ``request.uri`` parameter has no effect on path matching"
" in the inner route because the unmatched path is a separate field of the "
"``RequestContext`` value which is passed into routes. To change the "
"unmatched path or other fields of the ``RequestContext`` use the :ref"
":`-mapRequestContext-java-` directive."
msgstr ""

# 78686f43460b44b4afbed5c534ee8fca
# 655685101a394561b13497268941cc92
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequest.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequestContext.rst:14
msgid ""
"See :ref:`Request Transforming Directives-java` for an overview of similar "
"directives."
msgstr ""

# 4fc3ca11c4e54fb6b7c89652179191fa
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequestContext.rst:4
msgid "mapRequestContext"
msgstr ""

# 4dcb42a025524644a9c9bc9039488a8e
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequestContext.rst:8
msgid ""
"Transforms the ``RequestContext`` before it is passed to the inner route."
msgstr ""

# 51291e31f49f45a7afe5f498a3a4f099
#: ../../java/http/routing-dsl/directives/basic-directives/mapRequestContext.rst:10
msgid ""
"The ``mapRequestContext`` directive is used as a building block for "
":ref:`Custom Directives-java` to transform the request context before it is "
"passed to the inner route. To change only the request value itself the :ref"
":`-mapRequest-java-` directive can be used instead."
msgstr ""

# e847525e4f864b6887417383b99c3d87
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponse.rst:4
msgid "mapResponse"
msgstr ""

# 50b3c9cc9d294408881b5968d631f79d
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponse.rst:9
msgid ""
"The ``mapResponse`` directive is used as a building block for :ref:`Custom "
"Directives-java` to transform a response that was generated by the inner "
"route. This directive transforms complete responses."
msgstr ""

# a01e150f904e498d80e43dd4a9d70776
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponse.rst:12
msgid ""
"See also :ref:`-mapResponseHeaders-java-` or :ref:`-mapResponseEntity-java-`"
" for more specialized variants and :ref:`Response Transforming Directives-"
"java` for similar directives."
msgstr ""

# 24bd82ee5d4f42c2bcec6a9c064b2953
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponse.rst:16
msgid "Example: Override status"
msgstr ""

# dc877f76d33d48958546cae208f9f77f
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponse.rst:21
msgid "Example: Default to empty JSON response on errors"
msgstr ""

# 7e306e499ba6401682e61459df682b2a
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseEntity.rst:4
msgid "mapResponseEntity"
msgstr ""

# e86cf52a20ee4143ba6dd17e554e45f1
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseEntity.rst:9
msgid ""
"The ``mapResponseEntity`` directive is used as a building block for "
":ref:`Custom Directives-java` to transform a response entity that was "
"generated by the inner route."
msgstr ""

# da93b18e4af44c60b5b68c7929dfec21
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseHeaders.rst:4
msgid "mapResponseHeaders"
msgstr ""

# 53b085eda47d4956a51fecbd7c9325ea
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseHeaders.rst:8
msgid ""
"Changes the list of response headers that was generated by the inner route."
msgstr ""

# a86c8a0066be40e4b87049aa5dfc926c
#: ../../java/http/routing-dsl/directives/basic-directives/mapResponseHeaders.rst:10
msgid ""
"The ``mapResponseHeaders`` directive is used as a building block for "
":ref:`Custom Directives-java` to transform the list of response headers that"
" was generated by the inner route."
msgstr ""

# 4659f5f278c34cf487eabc8748424f8d
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResult.rst:4
msgid "mapRouteResult"
msgstr ""

# 8112d99dfad04d26a711edc8316443dc
# 632169e8582a468b9d05ce77262e73a5
# d00eab9eac6d4a738d77c27e2b8476d3
# 91f620276cae433bac7fafcadd962982
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResult.rst:8
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultPF.rst:10
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWith.rst:9
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWithPF.rst:11
msgid "Changes the message the inner route sends to the responder."
msgstr ""

# 7f9866d2105e4a2ab5fea7f71f84ce24
# c64fda252479455496bfabecd0437772
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResult.rst:10
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWithPF.rst:13
msgid ""
"The ``mapRouteResult`` directive is used as a building block for "
":ref:`Custom Directives-java` to transform the :class:`RouteResult` coming "
"back from the inner route."
msgstr ""

# ceb1b0b464744492b106cb6b90fc5fa3
# f71c1a0c0bca40f290a5f020daa39877
# e547a72b3b3043b8a0e817bff3de804c
# 994a8cf3010b4db3bf7144dcd95b7ea5
# 6c4eba6201af4c76a4239036ea5567a8
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResult.rst:13
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultFuture.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultPF.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWith.rst:15
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWithPF.rst:16
msgid ""
"See :ref:`Result Transformation Directives-java` for similar directives."
msgstr ""

# 4f46171b04c44c2dada319017a41691a
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultFuture.rst:4
msgid "mapRouteResultFuture"
msgstr ""

# 459c1ac0fc3946b993469670e50786ef
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultFuture.rst:9
msgid "Asynchronous version of :ref:`-mapRouteResult-java-`."
msgstr ""

# c18fb025b0a844589069639077b23022
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultFuture.rst:11
msgid ""
"It's similar to :ref:`-mapRouteResultWith-java-`, however it's "
"``Function<CompletionStage<RouteResult>, CompletionStage<RouteResult>>`` "
"instead of ``Function<RouteResult, CompletionStage<RouteResult>>`` which may"
" be useful when combining multiple transformations and / or wanting to "
"``recover`` from a failed route result."
msgstr ""

# 1ae92742fbb64ac3aa6c4d9d57d9f181
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultPF.rst:4
msgid "mapRouteResultPF"
msgstr ""

# 325356af90ed45aa898c2451c9a364a7
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultPF.rst:8
msgid "*Partial Function* version of :ref:`-mapRouteResult-java-`."
msgstr ""

# d0f3d95d576f47ae97ebb726819a0a7f
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultPF.rst:12
msgid ""
"The ``mapRouteResult`` directive is used as a building block for "
":ref:`Custom Directives-java` to transform the :class:`RouteResult` coming "
"back from the inner route. It's similar to the :ref:`-mapRouteResult-java-` "
"directive but allows to specify a partial function that doesn't have to "
"handle all potential ``RouteResult`` instances."
msgstr ""

# 2a764e3be12f499a9b8c3a5ffa37c57b
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWith.rst:4
msgid "mapRouteResultWith"
msgstr ""

# 656e757d037a4755bc530a5c7c40a9af
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWith.rst:11
msgid ""
"The ``mapRouteResult`` directive is used as a building block for "
":ref:`Custom Directives-java` to transform the :class:`RouteResult` coming "
"back from the inner route. It's similar to the :ref:`-mapRouteResult-java-` "
"directive but returning a ``CompletionStage`` instead of a result "
"immediately, which may be useful for longer running transformations."
msgstr ""

# 32085147817d481188710c1e6d581bb0
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWithPF.rst:4
msgid "mapRouteResultWithPF"
msgstr ""

# 73e77b65ffde4974ac22cb07fa9cf720
#: ../../java/http/routing-dsl/directives/basic-directives/mapRouteResultWithPF.rst:9
msgid "Asynchronous variant of :ref:`-mapRouteResultPF-java-`."
msgstr ""

# 4d0ae1661760439d9bc5a731530c78a1
#: ../../java/http/routing-dsl/directives/basic-directives/mapSettings.rst:4
msgid "mapSettings"
msgstr ""

# d9b42d463da849cb82f69d52e39c7dfd
#: ../../java/http/routing-dsl/directives/basic-directives/mapSettings.rst:9
msgid ""
"Transforms the ``RoutingSettings`` with a ``Function<RoutingSettings, "
"RoutingSettings>``."
msgstr ""

# 0b23bd5028bb41e3a3921e2835cc0674
#: ../../java/http/routing-dsl/directives/basic-directives/mapSettings.rst:11
msgid "See also :ref:`-withSettings-java-` or :ref:`-extractSettings-java-`."
msgstr ""

# 85144f07766c497babc4d96e2ce10f8c
#: ../../java/http/routing-dsl/directives/basic-directives/mapUnmatchedPath.rst:4
msgid "mapUnmatchedPath"
msgstr ""

# dbc05523105a410abbb6939aaef780c6
#: ../../java/http/routing-dsl/directives/basic-directives/mapUnmatchedPath.rst:8
msgid ""
"Transforms the unmatchedPath field of the request context for inner routes."
msgstr ""

# b3f39aa25be5411c90696c6d77990728
#: ../../java/http/routing-dsl/directives/basic-directives/mapUnmatchedPath.rst:10
msgid ""
"The ``mapUnmatchedPath`` directive is used as a building block for writing "
":ref:`Custom Directives-java`. You can use it for implementing custom path "
"matching directives."
msgstr ""

# 82da7bb4881e4dc79b37cb211fc8927f
#: ../../java/http/routing-dsl/directives/basic-directives/mapUnmatchedPath.rst:13
msgid ""
"Use ``extractUnmatchedPath`` for extracting the current value of the "
"unmatched path."
msgstr ""

# e82e2fd77aa84fc1b8cb9af32a44aa25
#: ../../java/http/routing-dsl/directives/basic-directives/pass.rst:4
msgid "pass"
msgstr ""

# 3b3584d514f944bc82222102db090f83
#: ../../java/http/routing-dsl/directives/basic-directives/pass.rst:8
msgid "A directive that passes the request unchanged to its inner route."
msgstr ""

# d4857e2162504480905cb878c76e1148
#: ../../java/http/routing-dsl/directives/basic-directives/pass.rst:10
msgid ""
"It is usually used as a \"neutral element\" when combining directives "
"generically."
msgstr ""

# 9fae306d52ad4430868a6114ba20f5e4
#: ../../java/http/routing-dsl/directives/basic-directives/provide.rst:4
msgid "provide"
msgstr ""

# 95a9491f3a6f472f860e15805eb541d1
#: ../../java/http/routing-dsl/directives/basic-directives/provide.rst:7
msgid "Provides a constant value to the inner route."
msgstr ""

# d2ad1ee8505b437d87167426a13da059
#: ../../java/http/routing-dsl/directives/basic-directives/provide.rst:9
msgid ""
"The `provide` directive is used as a building block for :ref:`Custom "
"Directives-java` to provide a single value to the inner route."
msgstr ""

# f5f5eff43dde402a9d669a58b13e77cc
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejections.rst:4
msgid "recoverRejections"
msgstr ""

# 264100d612fd4962b032ab2f4e141c4e
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejections.rst:11
msgid ""
"Transforms rejections from the inner route with a "
"``Function<Iterable<Rejection>, RouteResult>``. A ``RouteResult`` is either "
"a ``Complete`` containing the ``HttpResponse`` or a ``Rejected`` containing "
"the rejections."
msgstr ""

# 94260da0f9344eadbdd89e5240200764
# 70a525d4ffbe4efe8feefbfe97e1c988
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejections.rst:16
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejectionsWith.rst:19
msgid ""
"To learn more about how and why rejections work read the :ref:`rejections-"
"java` section of the documentation."
msgstr ""

# 27b8fcb57e324c038314defc9e901203
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejectionsWith.rst:4
msgid "recoverRejectionsWith"
msgstr ""

# e1147820011b4255994579bf0403fca1
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejectionsWith.rst:12
msgid ""
"Transforms rejections from the inner route with a "
"``Function<Iterable<Rejection>, CompletionStage<RouteResult>>``."
msgstr ""

# ca3ae310913543d4a2c483c10d859420
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejectionsWith.rst:14
msgid "Asynchronous version of :ref:`-recoverRejections-java-`."
msgstr ""

# e0ed40cc5f0041b8b15a5ab1053af2a8
#: ../../java/http/routing-dsl/directives/basic-directives/recoverRejectionsWith.rst:16
msgid ""
"See :ref:`-recoverRejections-java-` (the synchronous equivalent of this "
"directive) for a detailed description."
msgstr ""

# 4d7fa6758d204f6195510f8766deba39
#: ../../java/http/routing-dsl/directives/basic-directives/toStrictEntity.rst:4
msgid "toStrictEntity"
msgstr ""

# b2066f82767248d9b87a7e07df456532
#: ../../java/http/routing-dsl/directives/basic-directives/toStrictEntity.rst:9
msgid ""
"Transforms the request entity to strict entity before it is handled by the "
"inner route."
msgstr ""

# 1197f71bdd7c40289c49fc9e9e97ec32
#: ../../java/http/routing-dsl/directives/basic-directives/withExecutionContext.rst:4
msgid "withExecutionContext"
msgstr ""

# ceb9022e04d54a96994373279262fba1
#: ../../java/http/routing-dsl/directives/basic-directives/withExecutionContext.rst:9
msgid ""
"Allows running an inner route using an alternative "
"``ExecutionContextExecutor`` in place of the default one."
msgstr ""

# d9a3a3f1d5984119960e7da16acea041
#: ../../java/http/routing-dsl/directives/basic-directives/withExecutionContext.rst:11
msgid ""
"The execution context can be extracted in an inner route using :ref"
":`-extractExecutionContext-java-` directly, or used by directives which "
"internally extract the materializer without sufracing this fact in the API."
msgstr ""

# f2b5c90db4a84a3d8b4b1ecfeb8cff18
#: ../../java/http/routing-dsl/directives/basic-directives/withLog.rst:4
msgid "withLog"
msgstr ""

# 19836af129b94543b235861ce84c98e3
#: ../../java/http/routing-dsl/directives/basic-directives/withLog.rst:9
msgid ""
"Allows running an inner route using an alternative :class:`LoggingAdapter` "
"in place of the default one."
msgstr ""

# 1aaba8ee8c564368ab15006066697ecf
#: ../../java/http/routing-dsl/directives/basic-directives/withLog.rst:11
msgid ""
"The logging adapter can be extracted in an inner route using :ref"
":`-extractLog-java-` directly, or used by directives which internally "
"extract the materializer without surfacing this fact in the API."
msgstr ""

# e5d9781bd477483eb6300b9c1fd5aa93
#: ../../java/http/routing-dsl/directives/basic-directives/withMaterializer.rst:4
msgid "withMaterializer"
msgstr ""

# a840f5598c5d47f59530c4cf08b63c38
#: ../../java/http/routing-dsl/directives/basic-directives/withMaterializer.rst:9
msgid ""
"Allows running an inner route using an alternative ``Materializer`` in place"
" of the default one."
msgstr ""

# fe8b007ec80a4d8aa2a98c3808aade2d
#: ../../java/http/routing-dsl/directives/basic-directives/withMaterializer.rst:11
msgid ""
"The materializer can be extracted in an inner route using :ref"
":`-extractMaterializer-java-` directly, or used by directives which "
"internally extract the materializer without sufracing this fact in the API "
"(e.g. responding with a Chunked entity)."
msgstr ""

# eea3f84d912a4fa89be79800b8f1d836
#: ../../java/http/routing-dsl/directives/basic-directives/withSettings.rst:4
msgid "withSettings"
msgstr ""

# 2a2e8d34b8fb4fdeb175da538d99da42
#: ../../java/http/routing-dsl/directives/basic-directives/withSettings.rst:9
msgid ""
"Allows running an inner route using an alternative :class:`RoutingSettings` "
"in place of the default one."
msgstr ""

# e8064b7efcef4b68b3d09d81f8f70381
#: ../../java/http/routing-dsl/directives/basic-directives/withSettings.rst:11
msgid ""
"The execution context can be extracted in an inner route using :ref"
":`-extractSettings-java-` directly, or used by directives which internally "
"extract the materializer without sufracing this fact in the API."
msgstr ""

# cb57e81b16c346039e84219d6368851a
#: ../../java/http/routing-dsl/directives/by-trait.rst:2
msgid "Predefined Directives (by trait)"
msgstr ""

# 47afd3fae0d94755b53ee0ab0315f6d0
#: ../../java/http/routing-dsl/directives/by-trait.rst:4
msgid ""
"All predefined directives are organized into traits that form one part of "
"the overarching ``Directives`` trait."
msgstr ""

# 2a805daba35c4c6aab6977e8950b0c95
#: ../../java/http/routing-dsl/directives/by-trait.rst:9
msgid "Directives filtering or extracting from the request"
msgstr ""

# 76e755ad92fd4d24b883b1e7374ddb48
#: ../../java/http/routing-dsl/directives/by-trait.rst:12
msgid "Filter and extract based on the request method."
msgstr ""

# ce22f7630fd64008bedc9be868e8b02b
#: ../../java/http/routing-dsl/directives/by-trait.rst:15
msgid "Filter and extract based on request headers."
msgstr ""

# 47d6fc78329940b49e4d81780742d7ba
#: ../../java/http/routing-dsl/directives/by-trait.rst:18
msgid "Filter and extract from the request URI path."
msgstr ""

# 56922747375541359fca1497b1b54150
#: ../../java/http/routing-dsl/directives/by-trait.rst:21
msgid "Filter and extract based on the target host."
msgstr ""

# 7c6993afd2084db59400fa97cc054400
#: ../../java/http/routing-dsl/directives/by-trait.rst:24
msgid "Filter and extract based on query parameters or form fields."
msgstr ""

# 0f0418a003894e84b7caf6e7863adcde
#: ../../java/http/routing-dsl/directives/by-trait.rst:27
msgid "Filter and decode compressed request content."
msgstr ""

# 2859326637314c63bb55fb2ef693dead
#: ../../java/http/routing-dsl/directives/by-trait.rst:30
msgid "Extract the request entity."
msgstr ""

# 130d84378eb448d88712c351ec23a5e0
#: ../../java/http/routing-dsl/directives/by-trait.rst:33
msgid "Filter and extract based on the request scheme."
msgstr ""

# 4275f50c8f5444d6a3fe150a4e39e806
#: ../../java/http/routing-dsl/directives/by-trait.rst:36
msgid "Handle authentication data from the request."
msgstr ""

# 772190d79b944135b429e3c3bbf98e51
#: ../../java/http/routing-dsl/directives/by-trait.rst:39
msgid "Filter and extract cookies."
msgstr ""

# 3496140b8c464dbea8303d6eacbaf570
#: ../../java/http/routing-dsl/directives/by-trait.rst:42
msgid "Directives handling request properties."
msgstr ""

# ba82f604170c4411b430c71061d54fde
#: ../../java/http/routing-dsl/directives/by-trait.rst:45
msgid "Handle file uploads."
msgstr ""

# cf2904ad60b84ccdb7bab925b8d44a7e
#: ../../java/http/routing-dsl/directives/by-trait.rst:51
msgid "Directives creating or transforming the response"
msgstr ""

# df5b3c8e5ece408192f0f603135b7c99
#: ../../java/http/routing-dsl/directives/by-trait.rst:54
msgid "Support for conditional requests (``304 Not Modified`` responses)."
msgstr ""

# 677586db93a0480f8858a85134b16a72
#: ../../java/http/routing-dsl/directives/by-trait.rst:57
msgid "Set, modify, or delete cookies."
msgstr ""

# 4bf8033942454ceaba7c55354d4e24a3
#: ../../java/http/routing-dsl/directives/by-trait.rst:60
msgid "Compress responses."
msgstr ""

# 4eee6791a204403aba335ed945589287
#: ../../java/http/routing-dsl/directives/by-trait.rst:63
msgid "Deliver responses from files and resources."
msgstr ""

# d0e9a80ca7064b1098e72bdd6f794dc9
#: ../../java/http/routing-dsl/directives/by-trait.rst:66
msgid "Support for range requests (``206 Partial Content`` responses)."
msgstr ""

# 58b2440eaef94225b8c62235be011c43
#: ../../java/http/routing-dsl/directives/by-trait.rst:69
msgid "Change response properties."
msgstr ""

# 668b0d901d3b4921b04cb59ad64fa3f9
#: ../../java/http/routing-dsl/directives/by-trait.rst:72
msgid "Complete or reject a request with a response."
msgstr ""

# 9d28596d7aa141d8995fd9339b0507bd
#: ../../java/http/routing-dsl/directives/by-trait.rst:75
msgid "Directives handling or transforming response properties."
msgstr ""

# fe4f0249bfd142eea3ec1542fff1c9e1
#: ../../java/http/routing-dsl/directives/by-trait.rst:78
msgid "Configure request timeouts and automatic timeout responses."
msgstr ""

# 6341914c753e472aa1aef2bc1659324d
#: ../../java/http/routing-dsl/directives/by-trait.rst:82
msgid "List of predefined directives by trait"
msgstr ""

# 17493bacde36419cae7a88a352a002b6
#: ../../java/http/routing-dsl/directives/cache-condition-directives/conditional.rst:4
msgid "conditional"
msgstr ""

# 84fa8010ca644500b24413461398b539
#: ../../java/http/routing-dsl/directives/cache-condition-directives/conditional.rst:9
msgid ""
"Wraps its inner route with support for Conditional Requests as defined by "
"http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26."
msgstr ""

# 8b7207f3b46547a58fd85fc82c5912ea
#: ../../java/http/routing-dsl/directives/cache-condition-directives/conditional.rst:13
msgid ""
"Depending on the given ``eTag`` and ``lastModified`` values this directive "
"immediately responds with ``304 Not Modified`` or ``412 Precondition "
"Failed`` (without calling its inner route) if the request comes with the "
"respective conditional headers. Otherwise the request is simply passed on to"
" its inner route."
msgstr ""

# f99a7b3ecdf74e4689cc6b95f6369222
#: ../../java/http/routing-dsl/directives/cache-condition-directives/conditional.rst:17
msgid ""
"The algorithm implemented by this directive closely follows what is defined "
"in `this section`__ of the `HTTPbis spec`__."
msgstr ""

# 85cf271f2cd84c98b0fde499e8d329eb
#: ../../java/http/routing-dsl/directives/cache-condition-directives/conditional.rst:20
msgid ""
"All responses (the ones produces by this directive itself as well as the "
"ones coming back from the inner route) are augmented with respective "
"``ETag`` and ``Last-Modified`` response headers."
msgstr ""

# b9efda171a3d4703b0bc5bdac9f26700
#: ../../java/http/routing-dsl/directives/cache-condition-directives/conditional.rst:23
msgid ""
"Since this directive requires the ``EntityTag`` and ``lastModified`` time "
"stamp for the resource as concrete arguments it is usually used quite deep "
"down in the route structure (i.e. close to the leaf-level), where the exact "
"resource targeted by the request has already been established and the "
"respective ETag/Last-Modified values can be determined."
msgstr ""

# 50cf831d66d44ddd97a8436ff21ee241
#: ../../java/http/routing-dsl/directives/cache-condition-directives/conditional.rst:28
msgid ""
"The :ref:`FileAndResourceDirectives-java` internally use the ``conditional``"
" directive for ETag and Last-Modified support (if the ``akka.http.routing"
".file-get-conditional`` setting is enabled)."
msgstr ""

# ce6383e64fe84efb84b83fad09d71639
#: ../../java/http/routing-dsl/directives/cache-condition-directives/index.rst:4
msgid "CacheConditionDirectives"
msgstr ""

# 0f946267103a4d18910241bf81061431
#: ../../java/http/routing-dsl/directives/coding-directives/decodeRequest.rst:4
msgid "decodeRequest"
msgstr ""

# 7045775880fb4abeaba9a5f6593dea92
#: ../../java/http/routing-dsl/directives/coding-directives/decodeRequest.rst:9
msgid ""
"Decompresses the incoming request if it is ``gzip`` or ``deflate`` "
"compressed. Uncompressed requests are passed through untouched. If the "
"request encoded with another encoding the request is rejected with an "
"``UnsupportedRequestEncodingRejection``."
msgstr ""

# 7f3932c9fbbb40a6a911eb94cb04d918
#: ../../java/http/routing-dsl/directives/coding-directives/decodeRequestWith.rst:4
msgid "decodeRequestWith"
msgstr ""

# 789f733c3b68423d9b282feaee69f56b
#: ../../java/http/routing-dsl/directives/coding-directives/decodeRequestWith.rst:9
msgid ""
"Decodes the incoming request if it is encoded with one of the given "
"encoders. If the request encoding doesn't match one of the given encoders "
"the request is rejected with an ``UnsupportedRequestEncodingRejection``. If "
"no decoders are given the default encoders (``Gzip``, ``Deflate``, "
"``NoCoding``) are used."
msgstr ""

# 30d41a845acd47e8a1fc3be7ec1a7264
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponse.rst:4
msgid "encodeResponse"
msgstr ""

# 712c982077154c88baf1d43be027eb7d
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponse.rst:9
msgid ""
"Encodes the response with the encoding that is requested by the client via "
"the ``Accept-Encoding`` header or rejects the request with an "
"``UnacceptedResponseEncodingRejection(supportedEncodings)``."
msgstr ""

# ffa6a313af304fd29ff86802b891e7f6
# 3b230a10372f4060a5219ba405761797
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponse.rst:11
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponseWith.rst:11
msgid ""
"The response encoding is determined by the rules specified in RFC7231_."
msgstr ""

# 8475d60c7a2f41cc97f2209cb1a31ff4
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponse.rst:13
msgid ""
"If the ``Accept-Encoding`` header is missing or empty or specifies an "
"encoding other than identity, gzip or deflate then no encoding is used."
msgstr ""

# cd71eabd842044f495c4068e6f81978b
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponseWith.rst:4
msgid "encodeResponseWith"
msgstr ""

# 9841d6ba1c9c4884b5c7806daab98262
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponseWith.rst:9
msgid ""
"Encodes the response with the encoding that is requested by the client via "
"the ``Accept-Encoding`` if it is among the provided encoders or rejects the "
"request with an ``UnacceptedResponseEncodingRejection(supportedEncodings)``."
msgstr ""

# cb8b2ad34445404d918c5b4e028644a8
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponseWith.rst:13
msgid ""
"If the ``Accept-Encoding`` header is missing then the response is encoded "
"using the ``first`` encoder."
msgstr ""

# 7928d43f8ae94076aa209a4191dcda79
#: ../../java/http/routing-dsl/directives/coding-directives/encodeResponseWith.rst:15
msgid ""
"If the ``Accept-Encoding`` header is empty and ``NoCoding`` is part of the "
"encoders then no response encoding is used. Otherwise the request is "
"rejected."
msgstr ""

# d93ccc1ae7b447778e345a8171603356
#: ../../java/http/routing-dsl/directives/coding-directives/index.rst:4
msgid "CodingDirectives"
msgstr ""

# 90668bdbef314bceb64cccfb9a7321af
#: ../../java/http/routing-dsl/directives/coding-directives/requestEncodedWith.rst:4
msgid "requestEncodedWith"
msgstr ""

# 32c84cce6fe342d4abbfab44120e2bef
#: ../../java/http/routing-dsl/directives/coding-directives/requestEncodedWith.rst:9
msgid ""
"Passes the request to the inner route if the request is encoded with the "
"argument encoding. Otherwise, rejects the request with an "
"``UnacceptedRequestEncodingRejection(encoding)``."
msgstr ""

# 572a130e37be4dba8c185d533ab6e120
#: ../../java/http/routing-dsl/directives/coding-directives/requestEncodedWith.rst:11
msgid ""
"This directive is the building block for ``decodeRequest`` to reject "
"unsupported encodings."
msgstr ""

# aab9586ebae54d46881423af26317299
# 2f91e03b02ac4d419cbac4e619715bc8
# 88f201fc1aa843359acfda49541d055f
# 9746191aed2a416daeb0b609fea9c2e7
# 9655e35d02b7476489680936989d8f40
# e6d987ce11f64ca890378ed020488d37
# c82234733227449488771e7575cabcc5
# 49ef311fcb604bae8324b67d711f23bc
# 1abca2544d2442f49fba323932181145
# b3c0803a170c437e9dff5bc94d80354b
# 3adbbbc8b1e846c7b8e9399206f1faa3
# d0aa7b1ea0074922b4539851513dcdbf
# 2ef8b9326b294dfbaa45c0a6a5e7f817
#: ../../java/http/routing-dsl/directives/coding-directives/requestEncodedWith.rst:15
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:34
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:41
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:33
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:37
#: ../../java/http/routing-dsl/directives/misc-directives/extractClientIP.rst:15
#: ../../java/http/routing-dsl/directives/misc-directives/rejectEmptyResponse.rst:16
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityEmpty.rst:17
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityPresent.rst:16
#: ../../java/http/routing-dsl/directives/misc-directives/selectPreferredLanguage.rst:17
#: ../../java/http/routing-dsl/directives/misc-directives/validate.rst:14
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessages.rst:19
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.rst:23
msgid ""
"TODO: Example snippets for JavaDSL are subject to community contributions! "
"Help us complete the docs, read more about it here: `write example snippets "
"for Akka HTTP Java DSL #20466 <https://github.com/akka/akka/issues/20466>`_."
msgstr ""

# e742c33da4eb45a9b72edb4ea566e316
#: ../../java/http/routing-dsl/directives/coding-directives/responseEncodingAccepted.rst:4
msgid "responseEncodingAccepted"
msgstr ""

# b4e7bd014fec4daf816517c996f0cbcd
#: ../../java/http/routing-dsl/directives/coding-directives/responseEncodingAccepted.rst:9
msgid ""
"Passes the request to the inner route if the request accepts the argument "
"encoding. Otherwise, rejects the request with an "
"``UnacceptedResponseEncodingRejection(encoding)``."
msgstr ""

# abc06922d4004397a769fdfbd098902d
#: ../../java/http/routing-dsl/directives/cookie-directives/cookie.rst:4
msgid "cookie"
msgstr ""

# 0f0d57b0a1b1499b8818d648197cce26
#: ../../java/http/routing-dsl/directives/cookie-directives/cookie.rst:8
msgid ""
"Extracts a cookie with a given name from a request or otherwise rejects the "
"request with a ``MissingCookieRejection`` if the cookie is missing."
msgstr ""

# b278ffaab1384288a72fc2489451d5bc
#: ../../java/http/routing-dsl/directives/cookie-directives/cookie.rst:11
msgid ""
"Use the :ref:`-optionalCookie-java-` directive instead if you want to "
"support missing cookies in your inner route."
msgstr ""

# 22629ecb72484a0ea7310c38b4e06844
#: ../../java/http/routing-dsl/directives/cookie-directives/deleteCookie.rst:4
msgid "deleteCookie"
msgstr ""

# 56a82901f3a34515b9f68616f679ff3b
#: ../../java/http/routing-dsl/directives/cookie-directives/deleteCookie.rst:8
msgid ""
"Adds a header to the response to request the removal of the cookie with the "
"given name on the client."
msgstr ""

# 53dcc6b8df254f86ba824a5f61580aae
#: ../../java/http/routing-dsl/directives/cookie-directives/deleteCookie.rst:10
msgid "Use the :ref:`-setCookie-java-` directive to update a cookie."
msgstr ""

# 4741e4e7b8c84a2fb12bc520287f0b09
#: ../../java/http/routing-dsl/directives/cookie-directives/index.rst:4
msgid "CookieDirectives"
msgstr ""

# 973d4e9ca0184ab98f7a19b046c4a1e5
#: ../../java/http/routing-dsl/directives/cookie-directives/optionalCookie.rst:4
msgid "optionalCookie"
msgstr ""

# ece7dff734e74d01911728ef864f6bc0
#: ../../java/http/routing-dsl/directives/cookie-directives/optionalCookie.rst:8
msgid "Extracts an optional cookie with a given name from a request."
msgstr ""

# 15a821a5f1344baa810a8b87477b06cf
#: ../../java/http/routing-dsl/directives/cookie-directives/optionalCookie.rst:10
msgid ""
"Use the :ref:`-cookie-java-` directive instead if the inner route does not "
"handle a missing cookie."
msgstr ""

# 7ff5421e7492488981e07edf91058d71
#: ../../java/http/routing-dsl/directives/cookie-directives/setCookie.rst:4
msgid "setCookie"
msgstr ""

# 8c47592689164161bbfe74a766cc313f
#: ../../java/http/routing-dsl/directives/cookie-directives/setCookie.rst:8
msgid ""
"Adds a header to the response to request the update of the cookie with the "
"given name on the client."
msgstr ""

# acda7b213d9d42a4a061a6df40e994c3
#: ../../java/http/routing-dsl/directives/cookie-directives/setCookie.rst:10
msgid "Use the :ref:`-deleteCookie-java-` directive to delete a cookie."
msgstr ""

# e3350445e8a944ec99603059d7a7db7a
#: ../../java/http/routing-dsl/directives/custom-directives.rst:4
msgid "Custom Directives"
msgstr ""

# 345529bad3eb49d0b95f7478ab386bca
#: ../../java/http/routing-dsl/directives/custom-directives.rst:5
msgid ""
"Part of the power of akka-http directives comes from the ease with which "
"it’s possible to define custom directives at differing levels of "
"abstraction."
msgstr ""

# 7f277dc7317d4e6db65523d25713a5d9
#: ../../java/http/routing-dsl/directives/custom-directives.rst:8
msgid "There are essentially three ways of creating custom directives:"
msgstr ""

# b29f4d0e5d4d4a65bf451eab6d834e21
#: ../../java/http/routing-dsl/directives/custom-directives.rst:10
msgid "By introducing new “labels” for configurations of existing directives"
msgstr ""

# 06b39a81cc2341bf9e5d7272ab53431e
#: ../../java/http/routing-dsl/directives/custom-directives.rst:11
msgid "By transforming existing directives"
msgstr ""

# 1f172c083c534169b6b5896cc84f36c9
#: ../../java/http/routing-dsl/directives/custom-directives.rst:12
msgid "By writing a directive “from scratch”"
msgstr ""

# 7e48751d886246c08c786788d6c9b79d
#: ../../java/http/routing-dsl/directives/custom-directives.rst:15
msgid "Configuration Labeling"
msgstr ""

# 4694df4c5fe742a9bc175480a79ec608
#: ../../java/http/routing-dsl/directives/custom-directives.rst:16
msgid ""
"The easiest way to create a custom directive is to simply assign a new name "
"for a certain configuration of one or more existing directives. In fact, "
"most of the predefined akka-http directives can be considered named "
"configurations of more low-level directives."
msgstr ""

# 479ff33c0efe4d1db4f403be950242a8
#: ../../java/http/routing-dsl/directives/custom-directives.rst:20
msgid ""
"The basic technique is explained in the chapter about Composing Directives, "
"where, for example, a new directive ``getOrPut`` is defined like this:"
msgstr ""

# 92d45ebd556344abb486babe28cb7f7a
#: ../../java/http/routing-dsl/directives/custom-directives.rst:26
msgid ""
"Multiple directives can be nested to produce a single directive out of "
"multiple like this:"
msgstr ""

# 537ed81ab4cd4f5fa4e805643388e3f5
#: ../../java/http/routing-dsl/directives/custom-directives.rst:32
msgid ""
"Another example is the :ref:`MethodDirectives-java` which are simply "
"instances of a preconfigured :ref:`-method-java-` directive. The low-level "
"directives that most often form the basis of higher-level “named "
"configuration” directives are grouped together in the :ref:`BasicDirectives-"
"java` trait."
msgstr ""

# bfa498af5ce64b71943adf98a3930376
#: ../../java/http/routing-dsl/directives/debugging-directives/index.rst:4
msgid "DebuggingDirectives"
msgstr ""

# f537e6671b164c52ab22fc303f1df8e1
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequest.rst:4
msgid "logRequest"
msgstr ""

# a2aabc39a32c44b0b563bcd460b3683f
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequest.rst:9
msgid ""
"Logs the request. The directive is available with the following parameters:"
msgstr ""

# 5aee098e2b20438baf5aebc76490778a
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequest.rst:11
msgid "A marker to prefix each log message with."
msgstr ""

# 3313ab42bc2246febd0fa693484cfedb
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequest.rst:12
msgid "A log level."
msgstr ""

# 1100f852c0044dedba1ae59d3769e620
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequest.rst:13
msgid ""
"A function that creates a :class:``LogEntry`` from the "
":class:``HttpRequest``"
msgstr ""

# cd8f314711494b2f9bd714b2894bdbb8
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequest.rst:15
msgid ""
"Use ``logResult`` for logging the response, or ``logRequestResult`` for "
"logging both."
msgstr ""

# c5e4d56d9c8542b89665473349ba1d6d
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequestResult.rst:4
msgid "logRequestResult"
msgstr ""

# 67b89b420b0546b5858ea0e1d9c32ba4
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequestResult.rst:8
msgid "Logs both, the request and the response."
msgstr ""

# 257f0fdfa5e442388591e8f9506463d1
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequestResult.rst:10
msgid ""
"This directive is a combination of :ref:`-logRequest-java-` and :ref"
":`-logResult-java-`."
msgstr ""

# 84589e50721347aebdb4b5659494f20f
# afbdd0df592246f5b19362aa3bb60bee
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequestResult.rst:12
#: ../../java/http/routing-dsl/directives/debugging-directives/logResult.rst:10
msgid ""
"See :ref:`-logRequest-java-` for the general description how these "
"directives work."
msgstr ""

# 88f6fbb0d802430eaa00d7b4571abc89
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequestResult.rst:19
msgid "Longer Example"
msgstr ""

# 395b2d79aab3404891f32615323402b1
#: ../../java/http/routing-dsl/directives/debugging-directives/logRequestResult.rst:21
msgid ""
"This example shows how to log the response time of the request using the "
"Debugging Directive"
msgstr ""

# f72454f50d6b4373bd8354ca893ff22e
#: ../../java/http/routing-dsl/directives/debugging-directives/logResult.rst:4
msgid "logResult"
msgstr ""

# 1a5cf75471a543098930df89d7497d71
#: ../../java/http/routing-dsl/directives/debugging-directives/logResult.rst:8
msgid "Logs the response."
msgstr ""

# 2b1633cfd8c1436db50b985eb73793f6
#: ../../java/http/routing-dsl/directives/debugging-directives/logResult.rst:12
msgid ""
"Use ``logRequest`` for logging the request, or ``logRequestResult`` for "
"logging both."
msgstr ""

# 894a3f1abe2745ceb08332497e92845b
#: ../../java/http/routing-dsl/directives/execution-directives/handleExceptions.rst:4
msgid "handleExceptions"
msgstr ""

# b37c26a6d8f5467187b90c1b35d9b2bf
#: ../../java/http/routing-dsl/directives/execution-directives/handleExceptions.rst:8
msgid ""
"Catches exceptions thrown by the inner route and handles them using the "
"specified ``ExceptionHandler``."
msgstr ""

# 55251b84d126495d8c14ac56bb11dd4b
#: ../../java/http/routing-dsl/directives/execution-directives/handleExceptions.rst:10
msgid ""
"Using this directive is an alternative to using a global implicitly defined "
"``ExceptionHandler`` that applies to the complete route."
msgstr ""

# 3a1ae9dda0db460294e662760c36299a
#: ../../java/http/routing-dsl/directives/execution-directives/handleExceptions.rst:13
msgid ""
"See :ref:`exception-handling-java` for general information about options for"
" handling exceptions."
msgstr ""

# e42dfe472e2c47928a07a881232c3d08
#: ../../java/http/routing-dsl/directives/execution-directives/handleRejections.rst:4
msgid "handleRejections"
msgstr ""

# 05c2bd491e824f5a87e717765fcbe1df
#: ../../java/http/routing-dsl/directives/execution-directives/handleRejections.rst:9
msgid ""
"Using this directive is an alternative to using a global implicitly defined "
"``RejectionHandler`` that applies to the complete route."
msgstr ""

# 9e2f245716d3405184e96ab1a2032b4c
#: ../../java/http/routing-dsl/directives/execution-directives/handleRejections.rst:12
msgid ""
"See :ref:`rejections-java` for general information about options for "
"handling rejections."
msgstr ""

# 2bc375abfcf247599e57d37c85b8e9ba
#: ../../java/http/routing-dsl/directives/execution-directives/index.rst:4
msgid "ExecutionDirectives"
msgstr ""

# 1abe6f7205bf47d9bf259b4a6310afd6
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.rst:4
msgid "getFromBrowseableDirectories"
msgstr ""

# 5457f1f615a24f8ba1b16054931661f4
# 9a37c99cf13040a3b8ffdfd78f9ea53b
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.rst:9
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:9
msgid ""
"The ``getFromBrowseableDirectories`` is a combination of serving files from "
"the specified directories (like ``getFromDirectory``) and listing a "
"browseable directory with ``listDirectoryContents``."
msgstr ""

# 761f0f59c1494e03ac2b90c3ba8add99
# eb09ebf351e0467dbd4041397366cef6
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.rst:12
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:12
msgid ""
"Nesting this directive beneath ``get`` is not necessary as this directive "
"will only respond to ``GET`` requests."
msgstr ""

# 2538ffa551c24b44b3cfe9a957153def
# 258ab3f5ebb346a99e6ba036b0acc8cb
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.rst:14
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:14
msgid "Use ``getFromBrowseableDirectory`` to serve only one directory."
msgstr ""

# 414150772d9743e998d58cd1759d9257
# 073d578b55724cac837c6579e9d77308
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.rst:16
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:16
msgid "Use ``getFromDirectory`` if directory browsing isn't required."
msgstr ""

# afa4b965552c4ab3bef13f5cdb2058e3
# f6b043e591cf46ddb6e6262e88a1dfd1
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.rst:18
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:18
msgid "For more details refer to :ref:`-getFromBrowseableDirectory-java-`."
msgstr ""

# c1e2c8392db540769c74d5f868fcc35b
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:4
msgid "getFromBrowseableDirectory"
msgstr ""

# 0822e59238414e43ac41fb3dfe2d7f88
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:27
msgid "Default file listing page example"
msgstr ""

# ee8d6896dbab4563b1d7bf981ef2a2b5
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:29
msgid ""
"Directives which list directories (e.g. ``getFromBrowsableDirectory``) use "
"an implicit ``DirectoryRenderer`` instance to perfm the actual rendering of "
"the file listing. This rendered can be easily overriden by simply providing "
"one in-scope for the directives to use, so you can build your custom "
"directory listings."
msgstr ""

# 12c7c92cffb54332ad35f7e59b04901d
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:34
msgid ""
"The default renderer is "
"``akka.http.scaladsl.server.directives.FileAndResourceDirectives.defaultDirectoryRenderer``,"
" and renders a listing which looks like this:"
msgstr ""

# 64ded9b73c1e4a3e812e48b9a898c377
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.rst:43
msgid ""
"It's possible to turn off rendering the footer stating which version of Akka"
" HTTP is rendering this page by configuring the ``akka.http.routing.render-"
"vanity-footer`` configuration option to ``off``."
msgstr ""

# ede4288bbbf34ba194ee6442c6fd16b7
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:4
msgid "getFromDirectory"
msgstr ""

# 7826dc43a65c4554aa91d7e312339dfe
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:9
msgid "Allows exposing a directory's files for GET requests for its contents."
msgstr ""

# 4f648edff981430bb6a415a94d637fe5
# 1e9b91c4190448daadcdd1eb71c1f62f
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:11
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:11
msgid ""
"The ``unmatchedPath`` (see :ref:`-extractUnmatchedPath-java-`) of the "
"``RequestContext`` is first transformed by the given ``pathRewriter`` "
"function, before being appended to the given directory name to build the "
"final file name."
msgstr ""

# 8a9bc81f051c461cbaf19b25177d3e8c
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:14
msgid ""
"To serve a single file use :ref:`-getFromFile-java-`. To serve browsable "
"directory listings use :ref:`-getFromBrowseableDirectories-java-`. To serve "
"files from a classpath directory use :ref:`-getFromResourceDirectory-java-` "
"instead."
msgstr ""

# 1e1e58fefcfb4797942405b99d0f34bd
# 8d2433ae392941409a315e58be95b8ef
# ff9d59f2466b4f379858c4bf52407e5d
# c95ca254ac5d4081b58d379891112fd4
# 5e7d8deec40443918ecb6a3fe619036e
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:18
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:18
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResource.rst:14
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.rst:14
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.rst:19
msgid ""
"Note that it's not required to wrap this directive with ``get`` as this "
"directive will only respond to ``GET`` requests."
msgstr ""

# 8e32e04328c1488dacdf2684fb35c780
# 53ede4f9b5394b5daa35ec4af4a63351
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:21
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:21
msgid ""
"The file's contents will be read using an Akka Streams `Source` which "
"*automatically uses a pre-configured dedicated blocking io dispatcher*, "
"which separates the blocking file operations from the rest of the stream."
msgstr ""

# 4c34281c0e2b4db8a9bddc1aa9c7959d
# c3434364fab74e8d8f5c0052072c2d6d
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromDirectory.rst:24
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:24
msgid ""
"Note also that thanks to using Akka Streams internally, the file will be "
"served at the highest speed reachable by the client, and not faster – i.e. "
"the file will *not* end up being loaded in full into memory before writing "
"it to the client."
msgstr ""

# 1f11229e5ede4e649695366950a7864f
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:4
msgid "getFromFile"
msgstr ""

# 404bab52a5984f2aac756af098d9523c
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:9
msgid ""
"Allows exposing a file to be streamed to the client issuing the request."
msgstr ""

# 678e1a962ed24bbf8839050f1063f2f9
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromFile.rst:14
msgid ""
"To files from a given directory use :ref:`-getFromDirectory-java-`. To serve"
" browsable directory listings use :ref:`-getFromBrowseableDirectories-"
"java-`. To serve files from a classpath directory use :ref"
":`-getFromResourceDirectory-java-` instead."
msgstr ""

# b2142964ca13489ca31168d87150fbe9
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResource.rst:4
msgid "getFromResource"
msgstr ""

# b707bd16ad9744468dc8b18318effea3
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResource.rst:9
msgid ""
"Completes ``GET`` requests with the content of the given classpath resource."
msgstr ""

# c1ca1d049721472f90cbe662dd6e3630
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResource.rst:11
msgid ""
"For details refer to :ref:`-getFromFile-java-` which works the same way but "
"obtaining the file from the filesystem instead of the applications "
"classpath."
msgstr ""

# 735377873f7a46118df454444bce823c
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.rst:4
msgid "getFromResourceDirectory"
msgstr ""

# ec2b4d63118240ff9cf1b438eb425694
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.rst:9
msgid ""
"Completes ``GET`` requests with the content of the given classpath resource "
"directory."
msgstr ""

# 42188e6a3c914d3dbd41b9f9fa375e84
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.rst:11
msgid ""
"For details refer to :ref:`-getFromDirectory-java-` which works the same way"
" but obtaining the file from the filesystem instead of the applications "
"classpath."
msgstr ""

# cb7229641f13404dab1b652549de5016
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/index.rst:4
msgid "FileAndResourceDirectives"
msgstr ""

# 62f277abb7f34cdbb164dc1a78b5c914
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/index.rst:6
msgid ""
"Like the :ref:`RouteDirectives-java` the ``FileAndResourceDirectives`` are "
"somewhat special in akka-http's routing DSL. Contrary to all other "
"directives they do not produce instances of type ``Directive[L <: HList]`` "
"but rather \"plain\" routes of type ``Route``. The reason is that they are "
"not meant for wrapping an inner route (like most other directives, as "
"intermediate-level elements of a route structure, do) but rather form the "
"actual route structure **leaves**."
msgstr ""

# edd2715f9b5c4995b590ac75f43c4e6b
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/index.rst:12
msgid ""
"So in most cases the inner-most element of a route structure branch is one "
"of the :ref:`RouteDirectives-java` or ``FileAndResourceDirectives``."
msgstr ""

# b28482babaff4c6fb1bac8d30b6e885b
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.rst:4
msgid "listDirectoryContents"
msgstr ""

# 02ef61f7ef364db5928af5bf1b3a38f2
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.rst:9
msgid ""
"Completes GET requests with a unified listing of the contents of all given "
"directories. The actual rendering of the directory contents is performed by "
"the in-scope ``Marshaller[DirectoryListing]``."
msgstr ""

# 123a01ca4a954de78b4794a917311cc3
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.rst:12
msgid "To just serve files use :ref:`-getFromDirectory-java-`."
msgstr ""

# 21bcb4f845e946b2b038bb078a15ef94
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.rst:14
msgid ""
"To serve files and provide a browseable directory listing use :ref"
":`-getFromBrowseableDirectories-java-` instead."
msgstr ""

# b578c1f7c36946568b3ebfaf942b8ddb
#: ../../java/http/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.rst:16
msgid ""
"The rendering can be overridden by providing a custom "
"``Marshaller[DirectoryListing]``, you can read more about it in :ref"
":`-getFromDirectory-java-` 's documentation."
msgstr ""

# 48faf33853964f1682eb745cc07eb8d0
#: ../../java/http/routing-dsl/directives/file-upload-directives/fileUpload.rst:4
msgid "fileUpload"
msgstr ""

# b83b4b34ea9644588ef56c846cbbbab5
#: ../../java/http/routing-dsl/directives/file-upload-directives/fileUpload.rst:8
msgid ""
"Simple access to the stream of bytes for a file uploaded as a multipart form"
" together with metadata about the upload as extracted value."
msgstr ""

# d1c6391a4e244e0cae300d06b865963b
#: ../../java/http/routing-dsl/directives/file-upload-directives/fileUpload.rst:11
msgid ""
"If there is no field with the given name the request will be rejected, if "
"there are multiple file parts with the same name, the first one will be used"
" and the subsequent ones ignored."
msgstr ""

# c4b90e21ea0545f4b6c7607c409cf4b2
#: ../../java/http/routing-dsl/directives/file-upload-directives/index.rst:4
msgid "FileUploadDirectives"
msgstr ""

# c2714863b8df46b5aecc7441f711e474
#: ../../java/http/routing-dsl/directives/file-upload-directives/uploadedFile.rst:4
msgid "uploadedFile"
msgstr ""

# 8ce6beafe9154cc9962079d5259228b9
#: ../../java/http/routing-dsl/directives/file-upload-directives/uploadedFile.rst:8
msgid ""
"Streams the contents of a file uploaded as a multipart form into a temporary"
" file on disk and provides the file and metadata about the upload as "
"extracted value."
msgstr ""

# 4b65a27b96e6461d83166697bf0ffadb
#: ../../java/http/routing-dsl/directives/file-upload-directives/uploadedFile.rst:11
msgid ""
"If there is an error writing to disk the request will be failed with the "
"thrown exception, if there is no field with the given name the request will "
"be rejected, if there are multiple file parts with the same name, the first "
"one will be used and the subsequent ones ignored."
msgstr ""

# b17ce1cdee70465fa0744c8224e40f46
#: ../../java/http/routing-dsl/directives/file-upload-directives/uploadedFile.rst:16
msgid ""
"This directive will stream contents of the request into a file, however one "
"can not start processing these until the file has been written completely. "
"For streaming APIs it is preferred to use the :ref:`-fileUpload-java-` "
"directive, as it allows for streaming handling of the incoming data bytes."
msgstr ""

# 1307c2ddd2964fd0938f71ebcdf48a70
#: ../../java/http/routing-dsl/directives/form-field-directives/formField.rst:4
msgid "formField"
msgstr ""

# af1e3705a7ee4f77b4a47e20edd93fb5
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldList.rst:4
msgid "formFieldList"
msgstr ""

# 43330ec19a1749bb8dd5c8a25ad0de1f
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldList.rst:8
msgid ""
"Extracts all HTTP form fields at once in the original order as (name, value)"
" tuples of type ``Map.Entry<String, String>``."
msgstr ""

# fe78c8efa3714a1cb9be745d6086159e
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldList.rst:10
msgid ""
"This directive can be used if the exact order of form fields is important or"
" if parameters can occur several times."
msgstr ""

# 862c41d015ae401fb076180ae815dc2d
# 2d3b15d14b4b44e0a9da7ea55039893c
# 2a22ffad436844e690cc55d69bf1763b
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldList.rst:13
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMap.rst:13
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMultiMap.rst:17
msgid "Warning"
msgstr ""

# 5bbf3f8242f541d7b91fdfffdf99e723
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldList.rst:14
msgid ""
"The directive reads all incoming HTT form fields without any configured "
"upper bound. It means, that requests with form fields holding significant "
"amount of data (ie. during a file upload) can cause performance issues or "
"even an ``OutOfMemoryError`` s."
msgstr ""

# 970987ebf8a947efab8c0a16cef435e1
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMap.rst:4
msgid "formFieldMap"
msgstr ""

# d649ef7d3ce1417cb8bb6842746b6cc3
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMap.rst:8
msgid ""
"Extracts all HTTP form fields at once as a ``Map<String, String>`` mapping "
"form field names to form field values."
msgstr ""

# 6afdec45ed2644f4a195e430ba259b4d
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMap.rst:10
msgid ""
"If form data contain a field value several times, the map will contain the "
"last one."
msgstr ""

# 7935fa718ebe4692873e80f9243558dc
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMap.rst:14
msgid ""
"Use of this directive can result in performance degradation or even in "
"``OutOfMemoryError`` s. See :ref:`-formFieldList-java-` for details."
msgstr ""

# b48a29b801dd4d45b4e3e9ced8968510
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMultiMap.rst:4
msgid "formFieldMultiMap"
msgstr ""

# b10108855c2b4e409066c864a32de710
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMultiMap.rst:9
msgid ""
"Extracts all HTTP form fields at once as a multi-map of type ``Map<String, "
"<List<String>>`` mapping a form name to a list of all its values."
msgstr ""

# 218cbd5d11fe41dfb56fc9d714802da2
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMultiMap.rst:12
msgid "This directive can be used if form fields can occur several times."
msgstr ""

# 0d8e574ba3724e4094f0a9adbaa63e99
# c1634ba5668a4a90b8540aa7edd71d06
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMultiMap.rst:14
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMultiMap.rst:14
msgid "The order of values is *not* specified."
msgstr ""

# b775d3648af048b9b7518f103ee487e5
#: ../../java/http/routing-dsl/directives/form-field-directives/formFieldMultiMap.rst:18
msgid ""
"Use of this directive can result in performance degradation or even in "
"``OutOfMemoryError`` s."
msgstr ""

# 03ddaa5ee41b4d379ca3b11a0772267d
#: ../../java/http/routing-dsl/directives/form-field-directives/index.rst:4
msgid "FormFieldDirectives"
msgstr ""

# fc06140a95fe49b49b8e591baae5edd0
#: ../../java/http/routing-dsl/directives/future-directives/completeOrRecoverWith.rst:4
msgid "completeOrRecoverWith"
msgstr ""

# 1427736101764af9b0d5522981367989
#: ../../java/http/routing-dsl/directives/future-directives/completeOrRecoverWith.rst:8
msgid ""
"\"Unwraps\" a ``CompletionStage<T>`` and runs the inner route when the stage"
" has failed with the stage's failure exception as an extraction of type "
"``Throwable``. If the completion stage succeeds the request is completed "
"using the values marshaller (This directive therefore requires a marshaller "
"for the completion stage value type to be provided.)"
msgstr ""

# 11bf806221094e8c93fdf82f505f597c
#: ../../java/http/routing-dsl/directives/future-directives/completeOrRecoverWith.rst:14
msgid ""
"To handle the successful case manually as well, use the :ref:`-onComplete-"
"java-` directive, instead."
msgstr ""

# ebfb3a555cd740d8811bd5f77d0c330c
#: ../../java/http/routing-dsl/directives/future-directives/index.rst:4
msgid "FuturesDirectives"
msgstr ""

# 9661851cc080487d970772dd988aa6b3
#: ../../java/http/routing-dsl/directives/future-directives/index.rst:6
msgid ""
"Future directives can be used to run inner routes once the provided "
"``Future[T]`` has been completed."
msgstr ""

# b692d717983d4ce59146eecfb8a700fd
# 6ce199ab100a4eb4a67cd4f547120c01
#: ../../java/http/routing-dsl/directives/future-directives/onComplete.rst:4
#: ../../java/stream/stages-overview.rst:319
msgid "onComplete"
msgstr ""

# 83a16c232da74de385d541be3435476c
#: ../../java/http/routing-dsl/directives/future-directives/onComplete.rst:8
msgid ""
"Evaluates its parameter of type ``CompletionStage<T>``, and once it has been"
" completed, extracts its result as a value of type ``Try<T>`` and passes it "
"to the inner route. A ``Try<T>`` can either be a ``Success`` containing the "
"``T`` value or a ``Failure`` containing the ``Throwable``."
msgstr ""

# c2877242681f4ea88f4a47405e0ed6ec
#: ../../java/http/routing-dsl/directives/future-directives/onComplete.rst:12
msgid ""
"To handle the ``Failure`` case automatically and only work with the result "
"value, use :ref:`-onSuccess-java-`."
msgstr ""

# 670d0e5dbe9e4be994eb9a1470dd3f68
#: ../../java/http/routing-dsl/directives/future-directives/onComplete.rst:14
msgid ""
"To complete with a successful result automatically and just handle the "
"failure result, use :ref:`-completeOrRecoverWith-java-`, instead."
msgstr ""

# 5bc39708f44045528424658f2d2a250e
#: ../../java/http/routing-dsl/directives/future-directives/onCompleteWithBreaker.rst:4
msgid "onCompleteWithBreaker"
msgstr ""

# 87f935bf26ee47fca8e640030f1380d3
#: ../../java/http/routing-dsl/directives/future-directives/onCompleteWithBreaker.rst:8
msgid ""
"Evaluates its parameter of type ``CompletionStage<T>`` protecting it with "
"the specified ``CircuitBreaker``. Refer to :ref:`Akka Circuit Breaker"
"<circuit-breaker>` for a detailed description of this pattern."
msgstr ""

# 843db9abf59c4184bb2076f375c952fc
#: ../../java/http/routing-dsl/directives/future-directives/onCompleteWithBreaker.rst:11
msgid ""
"If the ``CircuitBreaker`` is open, the request is rejected with a "
"``CircuitBreakerOpenRejection``. Note that in this case the request's entity"
" databytes stream is cancelled, and the connection is closed as a "
"consequence."
msgstr ""

# af552ac42f274effa011dd380fa23f75
#: ../../java/http/routing-dsl/directives/future-directives/onCompleteWithBreaker.rst:15
msgid ""
"Otherwise, the same behaviour provided by :ref:`-onComplete-java-` is to be "
"expected."
msgstr ""

# 93c82b17eacf4c5aa41d62c241da9aaf
#: ../../java/http/routing-dsl/directives/future-directives/onSuccess.rst:4
msgid "onSuccess"
msgstr ""

# 540dba9b0df6426f918443025679c58c
#: ../../java/http/routing-dsl/directives/future-directives/onSuccess.rst:8
msgid ""
"Evaluates its parameter of type ``CompletionStage<T>``, and once it has been"
" completed successfully, extracts its result as a value of type ``T`` and "
"passes it to the inner route."
msgstr ""

# eeddd788049e42689d4a0df8ba003467
#: ../../java/http/routing-dsl/directives/future-directives/onSuccess.rst:11
msgid ""
"If the future fails its failure throwable is bubbled up to the nearest "
"``ExceptionHandler``."
msgstr ""

# 94f3b8b897a9491eb79d49a72d4e775c
#: ../../java/http/routing-dsl/directives/future-directives/onSuccess.rst:13
msgid ""
"To handle the ``Failure`` case manually as well, use :ref:`-onComplete-"
"java-`, instead."
msgstr ""

# f64b8047a2134bb0a61b4557e31fceb5
#: ../../java/http/routing-dsl/directives/header-directives/checkSameOrigin.rst:4
msgid "checkSameOrigin"
msgstr ""

# 1ef3387f6d704215a13ceb585f93482f
#: ../../java/http/routing-dsl/directives/header-directives/checkSameOrigin.rst:8
msgid ""
"Checks that request comes from the same origin. Extracts the ``Origin`` "
"header value and verifies that allowed range contains the obtained value. In"
" the case of absent of the ``Origin`` header rejects with a "
"``MissingHeaderRejection``. If the origin value is not in the allowed range "
"rejects with an ``InvalidOriginHeaderRejection`` and "
"``StatusCodes.FORBIDDEN`` status."
msgstr ""

# f4a6da1805ce4bba8954043eee195603
#: ../../java/http/routing-dsl/directives/header-directives/checkSameOrigin.rst:15
msgid "Checking the ``Origin`` header:"
msgstr ""

# 38f487045d8c409194a1f1ed46cd0140
#: ../../java/http/routing-dsl/directives/header-directives/headerValue.rst:4
msgid "headerValue"
msgstr ""

# 58c12c6d36ef47a1ad98bc749c776041
# 7b63cca3d15b4630926b99edf69f18e3
#: ../../java/http/routing-dsl/directives/header-directives/headerValue.rst:8
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValue.rst:8
msgid ""
"Traverses the list of request headers with the specified function and "
"extracts the first value the function returns as ``Optional[value]``."
msgstr ""

# da7d7d39d5af4618938af8f7fcb89149
#: ../../java/http/routing-dsl/directives/header-directives/headerValue.rst:11
msgid ""
"The :ref:`-headerValue-java-` directive is a mixture of ``map`` and ``find``"
" on the list of request headers. The specified function is called once for "
"each header until the function returns ``Optional(value)``. This value is "
"extracted and presented to the inner route. If the function throws an "
"exception the request is rejected with a ``MalformedHeaderRejection``. If "
"the function returns ``Optional.empty`` for every header the request is "
"rejected as \"NotFound\"."
msgstr ""

# 6dda9060bec242cd8667f7cf4260a91e
#: ../../java/http/routing-dsl/directives/header-directives/headerValue.rst:16
msgid ""
"This directive is the basis for building other request header related "
"directives."
msgstr ""

# 49325efacc2c4cd89fe64446ab32a92c
#: ../../java/http/routing-dsl/directives/header-directives/headerValue.rst:18
msgid ""
"See also :ref:`-headerValuePF-java-` for a nicer syntactic alternative."
msgstr ""

# 61f11343857047419abd1f226767d315
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByName.rst:4
msgid "headerValueByName"
msgstr ""

# 2bae01a8afa94fcb9cc5b7d06b3e6349
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByName.rst:8
msgid "Extracts the value of the HTTP request header with the given name."
msgstr ""

# 76159a501fb34589b8863b72f67cf345
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByName.rst:10
msgid ""
"If no header with a matching name is found the request is rejected with a "
"``MissingHeaderRejection``."
msgstr ""

# 7a63a8474789411db759cdcaca879036
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByName.rst:12
msgid ""
"If the header is expected to be missing in some cases or to customize "
"handling when the header is missing use the :ref"
":`-optionalHeaderValueByName-java-` directive instead."
msgstr ""

# 3b9470c8966c44908c6fe8122c086c34
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByType.rst:4
msgid "headerValueByType"
msgstr ""

# 156ff18fa15c4998ac9215749125410e
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByType.rst:8
msgid ""
"Traverses the list of request headers and extracts the first header of the "
"given type."
msgstr ""

# f18e170c34034693aee040e13970ddf9
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByType.rst:10
msgid ""
"The ``headerValueByType`` directive finds a header of the given type in the "
"list of request header. If no header of the given type is found the request "
"is rejected with a ``MissingHeaderRejection``."
msgstr ""

# 2dd3b0057c484f229c34130a4bc6cb34
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByType.rst:13
msgid ""
"If the header is expected to be missing in some cases or to customize "
"handling when the header is missing use the :ref"
":`-optionalHeaderValueByType-java-` directive instead."
msgstr ""

# e87b4435e4a340c79bb19b679552b9c6
# 89401ddc2b054790b4f00c681ac9857b
#: ../../java/http/routing-dsl/directives/header-directives/headerValueByType.rst:17
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByType.rst:14
msgid ""
"Custom headers will only be matched by this directive if they extend "
"``ModeledCustomHeader`` from the Scala DSL and there is currently no API for"
" the Java DSL (Ticket #20415)"
msgstr ""

# 5f1a00a53b764b69902cbdeab9e9b504
#: ../../java/http/routing-dsl/directives/header-directives/headerValuePF.rst:4
msgid "headerValuePF"
msgstr ""

# c486a14fcdd6489791d4011a5d38dd06
# faf50d0f1c7a4c2c8a6eb60c4cb7b305
#: ../../java/http/routing-dsl/directives/header-directives/headerValuePF.rst:8
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValuePF.rst:8
msgid ""
"Calls the specified partial function with the first request header the "
"function is ``isDefinedAt`` and extracts the result of calling the function."
msgstr ""

# 2e36f9b912ee4b308b1bcbdb50b09926
#: ../../java/http/routing-dsl/directives/header-directives/headerValuePF.rst:11
msgid ""
"The ``headerValuePF`` directive is an alternative syntax version of :ref"
":`-headerValue-java-`."
msgstr ""

# 25bedabafe424de688f4a13aa12f8ed1
#: ../../java/http/routing-dsl/directives/header-directives/headerValuePF.rst:13
msgid ""
"If the function throws an exception the request is rejected with a "
"``MalformedHeaderRejection``."
msgstr ""

# 3c3091af10e04864b7eba586bc662e4b
#: ../../java/http/routing-dsl/directives/header-directives/headerValuePF.rst:15
msgid ""
"If the function is not defined for any header the request is rejected as "
"\"NotFound\"."
msgstr ""

# fa4bc1a58b0d438eafe168ba5ca31729
#: ../../java/http/routing-dsl/directives/header-directives/index.rst:4
msgid "HeaderDirectives"
msgstr ""

# b810ec56e2db4b1da99561d7a4ab7fc2
#: ../../java/http/routing-dsl/directives/header-directives/index.rst:6
msgid ""
"Header directives can be used to extract header values from the request. To "
"change response headers use one of the :ref:`RespondWithDirectives-java`."
msgstr ""

# ede4f70072ff4a38b6f7621464434c31
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValue.rst:4
msgid "optionalHeaderValue"
msgstr ""

# a9e8154abf3844ac916e6955129e54be
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValue.rst:11
msgid ""
"The ``optionalHeaderValue`` directive is similar to the :ref:`-headerValue-"
"java-` directive but always extracts an ``Option`` value instead of "
"rejecting the request if no matching header could be found."
msgstr ""

# a7eec3d7cc7349268e2a8daf93d847fd
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByName.rst:4
msgid "optionalHeaderValueByName"
msgstr ""

# 9273ed7224e34a7ca9d4f8b47ea090ea
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByName.rst:8
msgid ""
"Optionally extracts the value of the HTTP request header with the given "
"name."
msgstr ""

# cfcc94f2e8ad4d9e8d9cbf93afea82e9
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByName.rst:10
msgid ""
"The ``optionalHeaderValueByName`` directive is similar to the :ref"
":`-headerValueByName-java-` directive but always extracts an ``Optional`` "
"value instead of rejecting the request if no matching header could be found."
msgstr ""

# 2997bef799c8487cb954c08afb3790e1
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByType.rst:4
msgid "optionalHeaderValueByType"
msgstr ""

# 472d110881194c409be1ca84815a0ef3
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByType.rst:8
msgid ""
"Optionally extracts the value of the HTTP request header of the given type."
msgstr ""

# 24bb7a7a749f46ce8a1ee2aaa75f0fb7
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByType.rst:10
msgid ""
"The ``optionalHeaderValueByType`` directive is similar to the :ref"
":`-headerValueByType-java-` directive but always extracts an ``Optional`` "
"value instead of rejecting the request if no matching header could be found."
msgstr ""

# 7fa816ce725c48d28e025554b63d0dbd
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValueByType.rst:17
msgid ""
"To learn more about defining custom headers, read: :ref:`custom-headers-"
"scala`."
msgstr ""

# 4715ab75de4e47c8884c1e5d651c1e27
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValuePF.rst:4
msgid "optionalHeaderValuePF"
msgstr ""

# c65ea62e431b4ac492a4cfc4f3b7bf0b
#: ../../java/http/routing-dsl/directives/header-directives/optionalHeaderValuePF.rst:11
msgid ""
"The ``optionalHeaderValuePF`` directive is similar to the :ref"
":`-headerValuePF-java-` directive but always extracts an ``Optional`` value "
"instead of rejecting the request if no matching header could be found."
msgstr ""

# adf716a57f464a0989d8d1979f86f030
#: ../../java/http/routing-dsl/directives/host-directives/extractHostName.rst:4
msgid "extractHostName"
msgstr ""

# 52d7d68dae5f487ebc4105acad08e6c4
#: ../../java/http/routing-dsl/directives/host-directives/extractHostName.rst:6
msgid ""
"Extract the hostname part of the ``Host`` request header and expose it as a "
"``String`` extraction to its inner route."
msgstr ""

# 4c7ca4e3b8844b90aa853fa223d1e7a0
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:4
msgid "host"
msgstr ""

# 9c5804be0ee04c609fc826a51c829a8c
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:6
msgid ""
"Filter requests matching conditions against the hostname part of the Host "
"header value in the request."
msgstr ""

# 8bc75d9789a9462c8fd561c6482545b9
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:9
msgid "There are a few variants:"
msgstr ""

# 91143bb6541e45e3aca56068c3bc4db8
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:11
msgid "reject all requests with a hostname different from the given ones"
msgstr ""

# 2de1f33584224c01813105ee116bf891
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:12
msgid ""
"reject all requests for which the hostname does not satisfy the given "
"predicate"
msgstr ""

# e32492cf9bd24ea48f44ad78cc840836
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:13
msgid ""
"reject all requests for which the hostname does not satisfy the given "
"regular expression"
msgstr ""

# 4fd51085dab549f4af529315459e499a
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:15
msgid ""
"The regular expression matching works a little bit different: it rejects all"
" requests with a hostname that doesn't have a prefix matching the given "
"regular expression and also extracts a ``String`` to its inner route "
"following this rules:"
msgstr ""

# 01a0091781ed474ebd553822abac1f5e
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:19
msgid ""
"For all matching requests the prefix string matching the regex is extracted "
"and passed to the inner route."
msgstr ""

# c2c68ea75f9e4141b4c5a58bf3a86632
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:20
msgid ""
"If the regex contains a capturing group only the string matched by this "
"group is extracted."
msgstr ""

# 0ffc9b9f47ba45c48f314dd74c6d6e2a
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:21
msgid ""
"If the regex contains more than one capturing group an "
"``IllegalArgumentException`` is thrown."
msgstr ""

# 40780c9c60974751b420b6eeea21aba2
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:26
msgid "Matching a list of hosts:"
msgstr ""

# 0cc464213a2149c5a4a667ecdb75302e
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:30
msgid "Making sure the host satisfies the given predicate"
msgstr ""

# 6ed58d07fa8c43a09cf826d6e36ac4b4
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:34
msgid "Using a regular expressions:"
msgstr ""

# 96e24e4bd3d542338fad7456cd344fef
#: ../../java/http/routing-dsl/directives/host-directives/host.rst:38
msgid ""
"Beware that in the case of introducing multiple capturing groups in the "
"regex such as in the case bellow, the directive will fail at runtime, at the"
" moment the route tree is evaluated for the first time. This might cause "
"your http handler actor to enter in a fail/restart loop depending on your "
"supervision strategy."
msgstr ""

# 19ce0746393649419a28812343c0c993
#: ../../java/http/routing-dsl/directives/host-directives/index.rst:4
msgid "HostDirectives"
msgstr ""

# d03aaf5490c74876944a7fb4d925731e
#: ../../java/http/routing-dsl/directives/host-directives/index.rst:6
msgid ""
"HostDirectives allow you to filter requests based on the hostname part of "
"the ``Host`` header contained in incoming requests as well as extracting its"
" value for usage in inner routes."
msgstr ""

# cd929eb45b5745a58bf6575292e19068
#: ../../java/http/routing-dsl/directives/index.rst:4
msgid "Directives"
msgstr ""

# f3a7581de6b04096bade00d707d5bfe7
#: ../../java/http/routing-dsl/directives/index.rst:6
msgid ""
"A \"Directive\" is a small building block used for creating arbitrarily "
"complex :ref:`route structures <Routes>`. Akka HTTP already pre-defines a "
"large number of directives and you can easily construct your own:"
msgstr ""

# bc0d3b4ed9754068bbc5733dfbf35297
#: ../../java/http/routing-dsl/directives/index.rst:18
msgid "Basics"
msgstr ""

# 9a49f84579df41c1a0e9d8110b9ec74b
#: ../../java/http/routing-dsl/directives/index.rst:20
msgid ""
":ref:`Routes-java` effectively are simply highly specialised functions that "
"take a ``RequestContext`` and eventually ``complete`` it, which could (and "
"often should) happen asynchronously."
msgstr ""

# b9cd82c7901c4abfa1b365297c98a1d7
#: ../../java/http/routing-dsl/directives/index.rst:23
msgid "With the :ref:`-complete-java-` directive this becomes even shorter::"
msgstr ""

# 7d5fb32c4dca4b83b6ad3ada1a39372d
#: ../../java/http/routing-dsl/directives/index.rst:27
msgid ""
"Writing multiple routes that are tried as alternatives (in-order of "
"definition), is as simple as using the ``route(route1, route2)``, method::"
msgstr ""

# 5b38c87103c9470aa3d4b1cfb7497e89
#: ../../java/http/routing-dsl/directives/index.rst:38
msgid ""
"You could also simply define a \"catch all\" completion by providing it as "
"the last route to attempt to match. In the example below we use the "
"``get()`` (one of the :ref:`MethodDirectives-java`) to match all incoming "
"``GET`` requests for that route, and all other requests will be routed "
"towards the other \"catch all\" route, that completes the route::"
msgstr ""

# 3ae2a3de1f694b8ea324e1256afbe07d
#: ../../java/http/routing-dsl/directives/index.rst:50
msgid ""
"If no route matches a given request, a default ``404 Not Found`` response "
"will be returned as response."
msgstr ""

# 76865d5896df4f74b4590a895916c22c
#: ../../java/http/routing-dsl/directives/index.rst:53
msgid "Structure"
msgstr ""

# 762f0a8dd2a44c63915a59c4b701f312
#: ../../java/http/routing-dsl/directives/index.rst:55
msgid "The general anatomy of a directive is as follows::"
msgstr ""

# 3ba0a2a66d86440bb2c6201763122ce0
#: ../../java/http/routing-dsl/directives/index.rst:61
msgid ""
"It has a name, zero or more arguments and optionally an inner route (The "
":ref:`RouteDirectives-java` are special in that they are always used at the "
"leaf-level and as such cannot have inner routes)."
msgstr ""

# 0312c103129649cdbe3a080d2b5651eb
#: ../../java/http/routing-dsl/directives/index.rst:64
msgid ""
"Additionally directives can \"extract\" a number of values and make them "
"available to their inner routes as function arguments. When seen \"from the "
"outside\" a directive with its inner route form an expression of type "
"``Route``."
msgstr ""

# dc0853ba154b49e58969570d8ea6d7dc
#: ../../java/http/routing-dsl/directives/index.rst:69
msgid "What Directives do"
msgstr ""

# 62b1777ba7ac41d2954f1a8c438c73bb
#: ../../java/http/routing-dsl/directives/index.rst:71
msgid "A directive can do one or more of the following:"
msgstr ""

# 480c766e663243409e4af7cebb214bd9
#: ../../java/http/routing-dsl/directives/index.rst:75
msgid ""
"Transform the incoming ``RequestContext`` before passing it on to its inner "
"route (i.e. modify the request)"
msgstr ""

# a1e87437bcf2464e9095ba3469079fcb
#: ../../java/http/routing-dsl/directives/index.rst:76
msgid ""
"Filter the ``RequestContext`` according to some logic, i.e. only pass on "
"certain requests and reject others"
msgstr ""

# af6257daafa244cba68a1e9b0f3f2204
#: ../../java/http/routing-dsl/directives/index.rst:77
msgid ""
"Extract values from the ``RequestContext`` and make them available to its "
"inner route as \"extractions\""
msgstr ""

# fb9d678eddab4294ac83324ddd028a88
#: ../../java/http/routing-dsl/directives/index.rst:78
msgid ""
"Chain some logic into the :class:`RouteResult` future transformation chain "
"(i.e. modify the response or rejection)"
msgstr ""

# 0027359d48804870893ad929ff0673f5
#: ../../java/http/routing-dsl/directives/index.rst:79
msgid "Complete the request"
msgstr ""

# 0ef01a99711a4cefa5c69dc1f50ddb84
#: ../../java/http/routing-dsl/directives/index.rst:81
msgid ""
"This means a ``Directive`` completely wraps the functionality of its inner "
"route and can apply arbitrarily complex transformations, both (or either) on"
" the request and on the response side."
msgstr ""

# 6a20235af25940f5998ee8c15b0c8957
#: ../../java/http/routing-dsl/directives/index.rst:86
msgid "Composing Directives"
msgstr ""

# 9fb2070d283448849d01d01c08d2cd6a
#: ../../java/http/routing-dsl/directives/index.rst:88
msgid "TODO rewrite for Java API"
msgstr ""

# ed7050ff2e6246b8adf2a218d6967bc7
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:4
msgid "completeWith"
msgstr ""

# b6455650d72a4808b5fdbfad8b032fa9
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:8
msgid ""
"Uses the marshaller for a given type to produce a completion function that "
"is passed to its inner route.  You can use it to decouple marshaller "
"resolution from request completion."
msgstr ""

# f7d71afc9eb7485d9996f0818aa92b76
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:11
msgid ""
"The ``completeWith`` directive works in conjuction with ``instanceOf`` and "
"``spray.httpx.marshalling`` to convert higher-level (object) structure into "
"some lower-level serialized \"wire format\". :ref:`The marshalling "
"documentation <http-marshalling-java>` explains this process in detail. This"
" directive simplifies exposing types to clients via a route while providing "
"some form of access to the current context."
msgstr ""

# 1299cef9096a48c283bf49475de5a45e
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:17
msgid ""
"``completeWith`` is similar to ``handleWith``.  The main difference is with "
"``completeWith`` you must eventually call the completion function generated "
"by ``completeWith``.  ``handleWith`` will automatically call ``complete`` "
"when the ``handleWith`` function returns."
msgstr ""

# 9de212a32cf64534b4c5e3d1bba16e42
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:24
msgid ""
"The following example uses ``spray-json`` to marshall a simple ``Person`` "
"class to a json response.  It utilizes ``SprayJsonSupport`` via the "
"``PersonJsonSupport`` object as the in-scope unmarshaller."
msgstr ""

# a3167404ea704e5896a77f839f65dc50
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:28
msgid "TODO: Add example snippets"
msgstr ""

# 331befe66ae54a9292ecf98b35fbba18
#: ../../java/http/routing-dsl/directives/marshalling-directives/completeWith.rst:30
msgid ""
"The ``findPerson`` takes an argument of type ``Person => Unit`` which is "
"generated by the ``completeWith`` call.  We can handle any logic we want in "
"``findPerson`` and call our completion function to complete the request."
msgstr ""

# f3d90f0d8c3b438f8b55f7146dc3e363
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:4
msgid "entity"
msgstr ""

# f57856546080489fb81a582aae8b29f1
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:8
msgid ""
"Unmarshalls the request entity to the given type and passes it to its inner "
"Route.  An unmarshaller returns an ``Either`` with ``Right(value)`` if "
"successful or ``Left(exception)`` for a failure. The ``entity`` method will "
"either pass the ``value`` to the inner route or map the ``exception`` to a "
":class:``akka.http.javadsl.server.Rejection``."
msgstr ""

# c51a19187b9f453d88669f96f48e8a54
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:13
msgid ""
"The ``entity`` directive works in conjuction with ``as`` and "
"``akka.http.scaladsl.unmarshalling`` to convert some serialized \"wire "
"format\" value into a higher-level object structure. :ref:`The unmarshalling"
" documentation <http-unmarshalling-java>` explains this process in detail. "
"This directive simplifies extraction and error handling to the specified "
"type from the request."
msgstr ""

# d777be7776414f7a8c49473197b09f9a
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:18
msgid ""
"An unmarshaller will return a ``Left(exception)`` in the case of an error.  "
"This is converted to a ``akka.http.scaladsl.server.Rejection`` within the "
"``entity`` directive.  The following table lists how exceptions are mapped "
"to rejections:"
msgstr ""

# c12a991ad15d451a81b18edcd67db8b9
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:23
msgid "Left(exception)"
msgstr ""

# 8e976f2b75d041f0b8c4f0bec6475e7f
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:23
msgid "Rejection"
msgstr ""

# 12edb5e0aa29458caa6868f71b54b6d5
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:25
msgid "``ContentExpected``"
msgstr ""

# 217ff424c5de45f485d96730e8fc634b
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:25
msgid "``RequestEntityExpectedRejection``"
msgstr ""

# 5f648144e9174c3a802146ed68afb62d
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:26
msgid "``UnsupportedContentType``"
msgstr ""

# 1be0f8290b044a30b7fad467e6b55294
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:26
msgid ""
"``UnsupportedRequestContentTypeRejection``, which lists the supported types"
msgstr ""

# f4f3d2a75cdb4666ae7ad437883c1858
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:27
msgid "``MaformedContent``"
msgstr ""

# 03b406dfd67346a6a5f5a77f68f521c3
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:27
msgid "``MalformedRequestContentRejection``, with an error message and cause"
msgstr ""

# c519f7d472db42ba84f763bf46161589
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:33
msgid ""
"The following example uses ``spray-json`` to unmarshall a json request into "
"a simple ``Person`` class.  It utilizes ``SprayJsonSupport`` via the "
"``PersonJsonSupport`` object as the in-scope unmarshaller."
msgstr ""

# 6e2da5c5eadc4d8ab93d7051aef5424e
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:36
msgid "TODO: Add example snippets."
msgstr ""

# d1c02bde8ee94e1682989d4e2ba749f2
#: ../../java/http/routing-dsl/directives/marshalling-directives/entity.rst:38
msgid ""
"It is also possible to use the ``entity`` directive to obtain raw "
"``JsValue`` ( spray-json_ ) objects, by simply using ``as[JsValue]``, or any"
" other JSON type for which you have marshallers in-scope."
msgstr ""

# 4fe1a3169d5147ea86e53521a63e221b
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:4
msgid "handleWith"
msgstr ""

# 869edd9184544713bd2dc5c6f3f47364
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:8
msgid ""
"Completes the request using the given function. The input to the function is"
" produced with the in-scope entity unmarshaller and the result value of the "
"function is marshalled with the in-scope marshaller.  ``handleWith`` can be "
"a convenient method combining ``entity`` with ``complete``."
msgstr ""

# c178ea0f0c984bde90e9a7b0f07d1b04
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:13
msgid ""
"The ``handleWith`` directive is used when you want to handle a route with a "
"given function of type A ⇒ B.  ``handleWith`` will use both an in-scope "
"unmarshaller to convert a request into type A and an in-scope marshaller to "
"convert type B into a response. This is helpful when your core business "
"logic resides in some other class or you want your business logic to be "
"independent of the REST interface written with akka-http. You can use "
"``handleWith`` to \"hand off\" processing to a given function without "
"requiring any akka-http-specific functionality."
msgstr ""

# 78ecf09205ce4650bca9809566af90cd
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:20
msgid ""
"``handleWith`` is similar to ``produce``.  The main difference is "
"``handleWith`` automatically calls ``complete`` when the function passed to "
"``handleWith`` returns. Using ``produce`` you must explicity call the "
"completion function passed from the ``produce`` function."
msgstr ""

# 72780f53e0a24d07b649cdff60ccf889
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:24
msgid ""
"See :ref:`marshalling <http-marshalling-java>` and :ref:`unmarshalling "
"<http-unmarshalling-java>` for guidance on marshalling entities with akka-"
"http."
msgstr ""

# 5f9855d4a8d74a119f9886dc56c27c2d
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:30
msgid ""
"The following example uses an ``updatePerson`` function with a ``Person`` "
"case class as an input and output.  We plug this function into our route "
"using ``handleWith``. TODO: Example snippets for JavaDSL are subject to "
"community contributions! Help us complete the docs, read more about it here:"
" `write example snippets for Akka HTTP Java DSL #20466 "
"<https://github.com/akka/akka/issues/20466>`_."
msgstr ""

# eb0696a5251b41ea99baafe662a330ca
#: ../../java/http/routing-dsl/directives/marshalling-directives/handleWith.rst:35
msgid ""
"The PersonJsonSupport object handles both marshalling and unmarshalling of "
"the Person case class."
msgstr ""

# 0b541b8dd5ab436aaf8550f8041d6c27
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:4
msgid "Marshalling Directives"
msgstr ""

# 0a445abb63f84dd6a2b4d631f6b6ea85
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:6
msgid ""
"Marshalling directives work in conjunction with "
"``akka.http.scaladsl.marshalling`` and ``akka.http.scaladsl.unmarshalling`` "
"to convert a request entity to a specific type or a type to a response."
msgstr ""

# 7c366fc600f741099fe1f5a6236461ad
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:9
msgid ""
"See :ref:`marshalling <http-marshalling-java>` and :ref:`unmarshalling "
"<http-unmarshalling-java>` for specific serialization (also known as "
"pickling) guidance."
msgstr ""

# 02c3912d1d9d46258385990b6d4c0d84
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:12
msgid ""
"Marshalling directives usually rely on an in-scope implicit marshaller to "
"handle conversion."
msgstr ""

# 050c137c2586463db260e8b3a1256310
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:22
msgid "Understanding Specific Marshalling Directives"
msgstr ""

# b6f24e2935484539943e79f5785e8a3f
# dbe901ca7bfd415c9103315ca19974da
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:25
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:25
msgid "directive"
msgstr ""

# cff1afb337a0411684654630b08e6460
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:25
msgid "behavior"
msgstr ""

# eb307713e4654800ba3255631f686e97
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:27
msgid ""
"Uses a marshaller for a given type to produce a completion function for an "
"inner route. Used in conjuction with *instanceOf* to format responses."
msgstr ""

# 32ada7bb81e64df88a42dce4c7604439
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:28
msgid ""
"Unmarshalls the request entity to the given type and passes it to its inner "
"route.  Used in conjection with *as* to convert requests to objects."
msgstr ""

# 799c5f72cf6b4ff5a689d4b329dc8542
#: ../../java/http/routing-dsl/directives/marshalling-directives/index.rst:29
msgid ""
"Completes a request with a given function, using an in-scope unmarshaller "
"for an input and in-scope marshaller for the output."
msgstr ""

# 58fa44f070a74d76a98b1f7de5a8a767
#: ../../java/http/routing-dsl/directives/method-directives/delete.rst:4
msgid "delete"
msgstr ""

# 5856e08dce874ae6ac133606a159c152
#: ../../java/http/routing-dsl/directives/method-directives/delete.rst:5
msgid "Matches requests with HTTP method ``DELETE``."
msgstr ""

# a689df81d8134d1faab1780bf175bf74
#: ../../java/http/routing-dsl/directives/method-directives/delete.rst:10
msgid ""
"This directive filters an incoming request by its HTTP method. Only requests"
" with method ``DELETE`` are passed on to the inner route. All others are "
"rejected with a ``MethodRejection``, which is translated into a ``405 Method"
" Not Allowed`` response by the default ``RejectionHandler``."
msgstr ""

# df6a958cdee640379383b38838ac03d0
#: ../../java/http/routing-dsl/directives/method-directives/extractMethod.rst:4
msgid "extractMethod"
msgstr ""

# 4f8c13175623484bb5f0ba12b85ec041
#: ../../java/http/routing-dsl/directives/method-directives/extractMethod.rst:9
msgid ""
"Extracts the :class:`HttpMethod` from the request context and provides it "
"for use for other directives explicitly."
msgstr ""

# a357db7c654c413c97cc158d40718afd
#: ../../java/http/routing-dsl/directives/method-directives/extractMethod.rst:14
msgid ""
"In the below example our route first matches all ``GET`` requests, and if an"
" incoming request wasn't a ``GET``, the matching continues and the "
"extractMethod route will be applied which we can use to programatically "
"print what type of request it was - independent of what actual HttpMethod it"
" was:"
msgstr ""

# 4e420e7ec3be41ab9ee3d4770008db85
#: ../../java/http/routing-dsl/directives/method-directives/extractMethod.rst:21
msgid "Custom Http Method"
msgstr ""

# 3c7d7fce722e4b918f002abdba5562b3
#: ../../java/http/routing-dsl/directives/method-directives/extractMethod.rst:23
msgid ""
"When you define a custom HttpMethod, you can define a route using "
"extractMethod."
msgstr ""

# 8ac3ab94a3a4463cb6d6d756a23de9a6
#: ../../java/http/routing-dsl/directives/method-directives/get.rst:4
msgid "get"
msgstr ""

# cdd98dae41944939bed3eb3dae435c84
#: ../../java/http/routing-dsl/directives/method-directives/get.rst:5
msgid "Matches requests with HTTP method ``GET``."
msgstr ""

# 8e56b449dec54756a927d98799e676a4
#: ../../java/http/routing-dsl/directives/method-directives/get.rst:10
msgid ""
"This directive filters the incoming request by its HTTP method. Only "
"requests with method ``GET`` are passed on to the inner route. All others "
"are rejected with a ``MethodRejection``, which is translated into a ``405 "
"Method Not Allowed`` response by the default ``RejectionHandler``."
msgstr ""

# 09ba61c4f0c84ee8aba3cf0ddadd3c2f
# bd9a88bdc90942b287e99b233d40340d
#: ../../java/http/routing-dsl/directives/method-directives/head.rst:4
#: ../../java/stream/stages-overview.rst:236
msgid "head"
msgstr ""

# df700490e8f84a1c9f80a3730912b1d9
#: ../../java/http/routing-dsl/directives/method-directives/head.rst:5
msgid "Matches requests with HTTP method ``HEAD``."
msgstr ""

# bfc28defaed942b6865239a584dc1cb2
#: ../../java/http/routing-dsl/directives/method-directives/head.rst:10
msgid ""
"This directive filters the incoming request by its HTTP method. Only "
"requests with method ``HEAD`` are passed on to the inner route. All others "
"are rejected with a ``MethodRejection``, which is translated into a ``405 "
"Method Not Allowed`` response by the default ``RejectionHandler``."
msgstr ""

# 3f63c2b6349e42be8f92e296d06caee3
#: ../../java/http/routing-dsl/directives/method-directives/head.rst:15
msgid ""
"By default, akka-http handles HEAD-requests transparently by dispatching a "
"GET-request to the handler and stripping of the result body. See the "
"``akka.http.server.transparent-head-requests`` setting for how to disable "
"this behavior."
msgstr ""

# 3c9249b924644ef4a48fd33698656c36
#: ../../java/http/routing-dsl/directives/method-directives/index.rst:4
msgid "MethodDirectives"
msgstr ""

# f6cf750ca5be40dab6dea2d8ce56f4a5
#: ../../java/http/routing-dsl/directives/method-directives/method.rst:4
msgid "method"
msgstr ""

# 335021d4d054487aad1f224c44f3da81
#: ../../java/http/routing-dsl/directives/method-directives/method.rst:6
msgid "Matches HTTP requests based on their method."
msgstr ""

# 4876ec11ec5544ef917f3c4d83bf65af
#: ../../java/http/routing-dsl/directives/method-directives/method.rst:11
msgid ""
"This directive filters the incoming request by its HTTP method. Only "
"requests with the specified method are passed on to the inner route. All "
"others are rejected with a ``MethodRejection``, which is translated into a "
"``405 Method Not Allowed`` response by the default ``RejectionHandler``."
msgstr ""

# 1f5e603ee7bd4cc7860a60231c0b9647
#: ../../java/http/routing-dsl/directives/method-directives/options.rst:4
msgid "options"
msgstr ""

# 6512da08c74845218f60143feae44cd6
#: ../../java/http/routing-dsl/directives/method-directives/options.rst:5
msgid "Matches requests with HTTP method ``OPTIONS``."
msgstr ""

# 9dae9b8bce1649119da2c82d57476141
#: ../../java/http/routing-dsl/directives/method-directives/options.rst:10
msgid ""
"This directive filters the incoming request by its HTTP method. Only "
"requests with method ``OPTIONS`` are passed on to the inner route. All "
"others are rejected with a ``MethodRejection``, which is translated into a "
"``405 Method Not Allowed`` response by the default ``RejectionHandler``."
msgstr ""

# d24cd406959e4f0f8862cdd94438dc17
#: ../../java/http/routing-dsl/directives/method-directives/overrideMethodWithParameter.rst:4
msgid "overrideMethodWithParameter"
msgstr ""

# d03cc5f92da84e4db3ec5646ff1295e6
#: ../../java/http/routing-dsl/directives/method-directives/overrideMethodWithParameter.rst:6
msgid ""
"Changes the HTTP method of the request to the value of the specified query "
"string parameter."
msgstr ""

# c8fad36f92e9479ba72dd419d9177ead
#: ../../java/http/routing-dsl/directives/method-directives/overrideMethodWithParameter.rst:11
msgid ""
"If the query string parameter is not specified this directive has no effect."
" If the query string is specified as something that is not a HTTP method, "
"then this directive completes the request with a `501 Not Implemented` "
"response."
msgstr ""

# 80f9945781cf404bb6ca2df75ea878b2
#: ../../java/http/routing-dsl/directives/method-directives/overrideMethodWithParameter.rst:15
msgid "This directive is useful for:"
msgstr ""

# b477ec7ad4a4479ba8cfb1e696507b65
#: ../../java/http/routing-dsl/directives/method-directives/overrideMethodWithParameter.rst:17
msgid "Use in combination with JSONP (JSONP only supports GET)"
msgstr ""

# 95772915f9ed48e4b95b6fbc8ae56e1c
#: ../../java/http/routing-dsl/directives/method-directives/overrideMethodWithParameter.rst:18
msgid ""
"Supporting older browsers that lack support for certain HTTP methods. E.g. "
"IE8 does not support PATCH"
msgstr ""

# 26342f5e20cc4920a4f6f51682514c98
#: ../../java/http/routing-dsl/directives/method-directives/patch.rst:4
msgid "patch"
msgstr ""

# bc73738364c74f12b2fa75d69c73520c
#: ../../java/http/routing-dsl/directives/method-directives/patch.rst:6
msgid "Matches requests with HTTP method ``PATCH``."
msgstr ""

# f3bf02f9ec604f7bb45b3e9dfdc90e23
#: ../../java/http/routing-dsl/directives/method-directives/patch.rst:11
msgid ""
"This directive filters the incoming request by its HTTP method. Only "
"requests with method ``PATCH`` are passed on to the inner route. All others "
"are rejected with a ``MethodRejection``, which is translated into a ``405 "
"Method Not Allowed`` response by the default ``RejectionHandler``."
msgstr ""

# b80f31eae06e4169b40bd85ab1373c4a
#: ../../java/http/routing-dsl/directives/method-directives/post.rst:4
msgid "post"
msgstr ""

# 8d885b7a09604c3d81a8b6e131f99cb8
#: ../../java/http/routing-dsl/directives/method-directives/post.rst:6
msgid "Matches requests with HTTP method ``POST``."
msgstr ""

# 382265a737f34de68250bcf985946099
#: ../../java/http/routing-dsl/directives/method-directives/post.rst:11
msgid ""
"This directive filters the incoming request by its HTTP method. Only "
"requests with method ``POST`` are passed on to the inner route. All others "
"are rejected with a ``MethodRejection``, which is translated into a ``405 "
"Method Not Allowed`` response by the default ``RejectionHandler``."
msgstr ""

# 5fc1896ccba94198a7fab49b76565448
#: ../../java/http/routing-dsl/directives/method-directives/put.rst:4
msgid "put"
msgstr ""

# 39d844ffdfa8493d9c38168137cef0cc
#: ../../java/http/routing-dsl/directives/method-directives/put.rst:6
msgid "Matches requests with HTTP method ``PUT``."
msgstr ""

# 2306317388414a89884f789b1e813a37
#: ../../java/http/routing-dsl/directives/method-directives/put.rst:11
msgid ""
"This directive filters the incoming request by its HTTP method. Only "
"requests with method ``PUT`` are passed on to the inner route. All others "
"are rejected with a ``MethodRejection``, which is translated into a ``405 "
"Method Not Allowed`` response by the default ``RejectionHandler``."
msgstr ""

# 99dd227ebe6945248332d6381aed33cc
#: ../../java/http/routing-dsl/directives/misc-directives/extractClientIP.rst:4
msgid "extractClientIP"
msgstr ""

# 03b3071d2a8b41d7b8e1c47e661f5fa9
#: ../../java/http/routing-dsl/directives/misc-directives/extractClientIP.rst:8
msgid ""
"Provides the value of ``X-Forwarded-For``, ``Remote-Address``, or ``X-Real-"
"IP`` headers as an instance of ``HttpIp``."
msgstr ""

# eb2c8d6b77e24db498a95e8d27a38800
#: ../../java/http/routing-dsl/directives/misc-directives/extractClientIP.rst:10
msgid ""
"The akka-http server engine adds the ``Remote-Address`` header to every "
"request automatically if the respective setting ``akka.http.server.remote-"
"address-header`` is set to ``on``. Per default it is set to ``off``."
msgstr ""

# 1fc549be9f90484bbf8aeb76affa6d29
#: ../../java/http/routing-dsl/directives/misc-directives/index.rst:4
msgid "MiscDirectives"
msgstr ""

# 65eb8084db27469c948280895d2dc845
#: ../../java/http/routing-dsl/directives/misc-directives/rejectEmptyResponse.rst:4
msgid "rejectEmptyResponse"
msgstr ""

# 06c1d29e9c53464c9556f1a7d158e538
#: ../../java/http/routing-dsl/directives/misc-directives/rejectEmptyResponse.rst:8
msgid "Replaces a response with no content with an empty rejection."
msgstr ""

# e3ec260ed30e4533a8175c425d9adf0c
#: ../../java/http/routing-dsl/directives/misc-directives/rejectEmptyResponse.rst:10
msgid ""
"The ``rejectEmptyResponse`` directive is mostly used with marshalling "
"``Option[T]`` instances. The value ``None`` is usually marshalled to an "
"empty but successful result. In many cases ``None`` should instead be "
"handled as ``404 Not Found`` which is the effect of using "
"``rejectEmptyResponse``."
msgstr ""

# 5c9fc648bc3c46039ae0e159e2bcf0e0
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityEmpty.rst:4
msgid "requestEntityEmpty"
msgstr ""

# f80b462e8452466ca6f904bdb39c8b8d
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityEmpty.rst:8
msgid ""
"A filter that checks if the request entity is empty and only then passes "
"processing to the inner route. Otherwise, the request is rejected."
msgstr ""

# f624d9f270134474aa7e20ce353c395c
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityEmpty.rst:12
msgid "See also :ref:`-requestEntityPresent-java-` for the opposite effect."
msgstr ""

# 08be8610f57d462d9c1024189a828a03
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityPresent.rst:4
msgid "requestEntityPresent"
msgstr ""

# 52f8d423f939402fab9bb67a02344760
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityPresent.rst:8
msgid ""
"A simple filter that checks if the request entity is present and only then "
"passes processing to the inner route. Otherwise, the request is rejected."
msgstr ""

# 8ddee4219c944c96bc61637c62a5c9e9
#: ../../java/http/routing-dsl/directives/misc-directives/requestEntityPresent.rst:11
msgid "See also :ref:`-requestEntityEmpty-java-` for the opposite effect."
msgstr ""

# 29b0452e33294030811a101438984b1c
#: ../../java/http/routing-dsl/directives/misc-directives/selectPreferredLanguage.rst:4
msgid "selectPreferredLanguage"
msgstr ""

# 6915fc5376354f9cab7e1abe322ef215
#: ../../java/http/routing-dsl/directives/misc-directives/selectPreferredLanguage.rst:8
msgid ""
"Inspects the request's ``Accept-Language`` header and determines, which of a"
" given set of language alternatives is preferred by the client according to "
"content negotiation rules defined by "
"http://tools.ietf.org/html/rfc7231#section-5.3.5."
msgstr ""

# 09fdafbd2b7c467e884fba588d95a240
#: ../../java/http/routing-dsl/directives/misc-directives/selectPreferredLanguage.rst:12
msgid ""
"If there are several best language alternatives that the client has equal "
"preference for (even if this preference is zero!) the order of the arguments"
" is used as a tie breaker (first one wins)."
msgstr ""

# 8f791265d46d481699934554685b1e99
#: ../../java/http/routing-dsl/directives/misc-directives/validate.rst:4
msgid "validate"
msgstr ""

# cda9f4ccd34b414085f0739c93dcbb15
#: ../../java/http/routing-dsl/directives/misc-directives/validate.rst:5
msgid "Allows validating a precondition before handling a route."
msgstr ""

# 8b14369d6f1b4f5eace620675753339c
#: ../../java/http/routing-dsl/directives/misc-directives/validate.rst:9
msgid ""
"Checks an arbitrary condition and passes control to the inner route if it "
"returns ``true``. Otherwise, rejects the request with a "
"``ValidationRejection`` containing the given error message."
msgstr ""

# 96fd9ef76c6e4433a111620b2b9783a0
#: ../../java/http/routing-dsl/directives/misc-directives/withSizeLimit.rst:4
msgid "withSizeLimit"
msgstr ""

# d20a08e5980b4d73bef35fa4d13a0a42
#: ../../java/http/routing-dsl/directives/misc-directives/withSizeLimit.rst:8
msgid ""
"Fails the stream with ``EntityStreamSizeException`` if its request entity "
"size exceeds given limit. Limit given as parameter overrides limit "
"configured with ``akka.http.parsing.max-content-length``."
msgstr ""

# d5cf4de1434547b1944c7a53d02cbb8b
#: ../../java/http/routing-dsl/directives/misc-directives/withSizeLimit.rst:11
msgid ""
"The whole mechanism of entity size checking is intended to prevent certain "
"Denial-of-Service attacks. So suggested setup is to have ``akka.http.parsing"
".max-content-length`` relatively low and use ``withSizeLimit`` directive for"
" endpoints which expects bigger entities."
msgstr ""

# a132c0a352dd488b9a288b3722b501b4
#: ../../java/http/routing-dsl/directives/misc-directives/withSizeLimit.rst:15
msgid ""
"See also :ref:`-withoutSizeLimit-java-` for skipping request entity size "
"check."
msgstr ""

# 80860a2a7cc94c2ca7d2262f88df175b
#: ../../java/http/routing-dsl/directives/misc-directives/withoutSizeLimit.rst:4
msgid "withoutSizeLimit"
msgstr ""

# 47d745421fe84ae98d8c261863010378
#: ../../java/http/routing-dsl/directives/misc-directives/withoutSizeLimit.rst:8
msgid "Skips request entity size verification."
msgstr ""

# c9011d233e2e4528a543891b906a028e
#: ../../java/http/routing-dsl/directives/misc-directives/withoutSizeLimit.rst:10
msgid ""
"The whole mechanism of entity size checking is intended to prevent certain "
"Denial-of-Service attacks. So suggested setup is to have ``akka.http.parsing"
".max-content-length`` relatively low and use ``withoutSizeLimit`` directive "
"just for endpoints for which size verification should not be performed."
msgstr ""

# e399c3756176469aa6c2f8c565b700a2
#: ../../java/http/routing-dsl/directives/misc-directives/withoutSizeLimit.rst:14
msgid ""
"See also :ref:`-withSizeLimit-java-` for setting request entity size limit."
msgstr ""

# d8b31cec78614b8ea3d079bcccf4dedb
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:4
msgid "ParameterDirectives"
msgstr ""

# 9355a5d4fb12407fbfad1cfd10327443
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:18
msgid "When to use which parameter directive?"
msgstr ""

# 33c9393dcde648e9b48e9cb26ba379b8
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:20
msgid ""
"Usually, you want to use the high-level :ref:`-parameter-java-` directive. "
"When you need more low-level access you can use the table below to decide "
"which directive to use which shows properties of different parameter "
"directives."
msgstr ""

# 9738d75a9d3045e2bc24b3b13ecd480b
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:25
msgid "level"
msgstr ""

# bb713794b29d4af7be06bcecdf75008e
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:25
msgid "ordering"
msgstr ""

# d78b1e6922584e4f95f4eab5e0f2665b
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:25
msgid "multi"
msgstr ""

# ca662410dbec4340be247766f9513787
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:27
msgid "high"
msgstr ""

# 115223a8efb34ede902978043bf708bf
# 9b00d26927124decbc0c7a76bbd12600
# c6fe4b0de64646428b77a2a723e5fdf9
# 7068a2297f4a4b809a8a1e286135057e
# 11860a5913dd4e4ea51e34951f3e89a2
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:27
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:27
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:28
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:28
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:29
msgid "no"
msgstr ""

# 474bcacaaec943c7ba48e3a42f74679a
# e5fb0e4c6a394e38b74a300b0e1491ed
# 2f70504594e4438b9b0e97ef695771fd
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:28
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:29
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:30
msgid "low"
msgstr ""

# f774eb15f315471f9b11a78e4a0ea6d0
# 7dbc14e2adbb4956a889f1eeabd052ef
# d8de694b63c6422eb3c6648641d47352
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:29
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:30
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:30
msgid "yes"
msgstr ""

# 052db4b34ee643b0850820d2d42285ae
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:34
msgid ""
"high-level parameter directives extract subset of all parameters by name and"
" allow conversions and automatically report errors if expectations are not "
"met, low-level directives give you all parameters at once, leaving all "
"further processing to you"
msgstr ""

# 6daa5da96f7e4787b347e6dbaecab369
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:39
msgid "original ordering from request URL is preserved"
msgstr ""

# c8922516c49147dc80d70764b41e0323
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:42
msgid "multiple values per parameter name are possible"
msgstr ""

# b796632d0ba7499f9b50736e8a65e6c1
#: ../../java/http/routing-dsl/directives/parameter-directives/index.rst:45
msgid ""
"If you need to extract multiple parameters, apply the ``parameter`` "
"directive multiple times."
msgstr ""

# 50ad196c5772434481afce48f521a171
#: ../../java/http/routing-dsl/directives/parameter-directives/parameter.rst:4
msgid "parameter"
msgstr ""

# 1c06ae0df4b045be9448a4a877fc72a6
#: ../../java/http/routing-dsl/directives/parameter-directives/parameter.rst:5
msgid "Extracts a *query* parameter value from the request."
msgstr ""

# 210d16ef19a04c36b47821cea009ace0
#: ../../java/http/routing-dsl/directives/parameter-directives/parameter.rst:9
msgid ""
"See :ref:`-parameter-java-` for a detailed description of this directive."
msgstr ""

# 14828bcd29c644608d9d50b5141f8ad4
# 18442e11a99a4ff9bb45331e436df860
# a0ee7e2d1196400e8ce266639a196e4c
# 68c3da9d2d9e4a26859f0320212ffc5d
#: ../../java/http/routing-dsl/directives/parameter-directives/parameter.rst:11
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMultiMap.rst:16
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterSeq.rst:12
#: ../../java/http/routing-dsl/directives/parameter-directives/parameters.rst:10
msgid ""
"See :ref:`which-parameter-directive-java` to understand when to use which "
"directive."
msgstr ""

# 42fb717c346c44feadafb2b33826acff
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMap.rst:4
msgid "parameterMap"
msgstr ""

# 20685c28b0e9419f8807e3652b1a3584
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMap.rst:5
msgid ""
"Extracts all parameters at once as a ``Map<String, String>`` mapping "
"parameter names to parameter values."
msgstr ""

# 3ffced71a16f40039613b3b588c31914
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMap.rst:9
msgid ""
"If a query contains a parameter value several times, the map will contain "
"the last one."
msgstr ""

# 3a12a5839ba4462d9a1eef4a66c06fbf
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMap.rst:11
msgid ""
"See also :ref:`which-parameter-directive-java` to understand when to use "
"which directive."
msgstr ""

# 931b994f50ef49f98e6ad4fd74b71ea2
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMultiMap.rst:4
msgid "parameterMultiMap"
msgstr ""

# 7f33fa4f8491482fb63ef479b73b25a4
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMultiMap.rst:9
msgid ""
"Extracts all parameters at once as a multi-map of type ``Map<String, "
"List<String>>`` mapping a parameter name to a list of all its values."
msgstr ""

# 43003ad092e54ef697e14f3d650922d1
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterMultiMap.rst:12
msgid "This directive can be used if parameters can occur several times."
msgstr ""

# bfaa80ff5e32460981fad99b63fee3fd
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterSeq.rst:4
msgid "parameterList"
msgstr ""

# 216ae2be4ac74b42a1ae5614b800812f
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterSeq.rst:8
msgid ""
"Extracts all parameters at once in the original order as (name, value) "
"tuples of type ``Map.Entry<String, String>``."
msgstr ""

# c13d1e8bfe56444db4cc3639fa39273d
#: ../../java/http/routing-dsl/directives/parameter-directives/parameterSeq.rst:10
msgid ""
"This directive can be used if the exact order of parameters is important or "
"if parameters can occur several times."
msgstr ""

# 304030906d1c4b78b557e1833cc9fcb0
#: ../../java/http/routing-dsl/directives/parameter-directives/parameters.rst:4
msgid "parameters"
msgstr ""

# 1e9bba8b450a47a7887a7acef56c4070
#: ../../java/http/routing-dsl/directives/parameter-directives/parameters.rst:5
msgid "Extracts multiple *query* parameter values from the request."
msgstr ""

# 6b32a29c0c744354967b52bdff1fd2b8
# b21824e47e5e438185e05bf85b0cd7e4
#: ../../java/http/routing-dsl/directives/path-directives.rst:4
#: ../../java/http/routing-dsl/directives/path-directives/index.rst:4
msgid "PathDirectives"
msgstr ""

# db86ebb4a0b640c5ae4571d074b51943
#: ../../java/http/routing-dsl/directives/path-directives.rst:6
msgid ""
"Path directives are the most basic building blocks for routing requests "
"depending on the URI path."
msgstr ""

# ae644a091ca64a61b1cf32729755d6e2
#: ../../java/http/routing-dsl/directives/path-directives.rst:8
msgid ""
"When a request (or rather the respective ``RequestContext`` instance) enters"
" the route structure it has an \"unmatched path\" that is identical to the "
"``request.uri.path``. As it descends the routing tree and passes through one"
" or more ``pathPrefix`` or ``path`` directives the \"unmatched path\" "
"progressively gets \"eaten into\" from the left until, in most cases, it "
"eventually has been consumed completely."
msgstr ""

# a6b5d0c9da664ef399da27dbe864fba8
#: ../../java/http/routing-dsl/directives/path-directives.rst:13
msgid ""
"The two main directives are ``path`` and ``pathPrefix``. The ``path`` "
"directive tries to match the complete remaining unmatched path against the "
"specified \"path matchers\", the ``pathPrefix`` directive only matches a "
"prefix and passes the remaining unmatched path to nested directives. Both "
"directives automatically match a slash from the beginning, so that matching "
"slashes in a hierarchy of nested ``pathPrefix`` and ``path`` directives is "
"usually not needed."
msgstr ""

# 623e197e30c84173970bc449ac98fe69
#: ../../java/http/routing-dsl/directives/path-directives.rst:18
msgid ""
"Path directives take a variable amount of arguments. Each argument must be a"
" ``PathMatcher`` or a string (which is automatically converted to a path "
"matcher using ``PathMatchers.segment``). In the case of ``path`` and "
"``pathPrefix``, if multiple arguments are supplied, a slash is assumed "
"between any of the supplied path matchers. The ``rawPathX`` variants of "
"those directives on the other side do no such preprocessing, so that slashes"
" must be matched manually."
msgstr ""

# 184747b04a0b4615a28a317976abcd65
#: ../../java/http/routing-dsl/directives/path-directives.rst:24
msgid "Path Matchers"
msgstr ""

# dfa92de57e384d5b9b911ac44ac0816d
#: ../../java/http/routing-dsl/directives/path-directives.rst:26
msgid ""
"A path matcher is a description of a part of a path to match. The simplest "
"path matcher is ``PathMatcher.segment`` which matches exactly one path "
"segment against the supplied constant string."
msgstr ""

# 95813effb9eb45ffa3c2205db98b1584
#: ../../java/http/routing-dsl/directives/path-directives.rst:29
msgid ""
"Other path matchers defined in ``PathMatchers`` match the end of the path "
"(``PathMatchers.END``), a single slash (``PathMatchers.SLASH``), or nothing "
"at all (``PathMatchers.NEUTRAL``)."
msgstr ""

# a67db4cf198e48c09d2ca6959365d38c
#: ../../java/http/routing-dsl/directives/path-directives.rst:32
msgid ""
"Many path matchers are hybrids that can both match (by using them with one "
"of the PathDirectives) and extract values, Extracting a path matcher value "
"(i.e. using it with ``handleWithX``) is only allowed if it nested inside a "
"path directive that uses that path matcher and so specifies at which "
"position the value should be extracted from the path."
msgstr ""

# dad2f620ff4d4e41b5e50de2d7eacbac
#: ../../java/http/routing-dsl/directives/path-directives.rst:36
msgid "Predefined path matchers allow extraction of various types of values:"
msgstr ""

# 730c6787328049059f38374711ce7acb
#: ../../java/http/routing-dsl/directives/path-directives.rst:39
msgid ""
"Strings simply match themselves and extract no value. Note that strings are "
"interpreted as the decoded representation of the path, so if they include a "
"'/' character this character will match \"%2F\" in the encoded raw URI!"
msgstr ""

# bc082af9b45a42fe9cfc6e1961bff2bb
#: ../../java/http/routing-dsl/directives/path-directives.rst:44
msgid ""
"You can use a regular expression instance as a path matcher, which matches "
"whatever the regex matches and extracts one ``String`` value. A "
"``PathMatcher`` created from a regular expression extracts either the "
"complete match (if the regex doesn't contain a capture group) or the capture"
" group (if the regex contains exactly one capture group). If the regex "
"contains more than one capture group an ``IllegalArgumentException`` will be"
" thrown."
msgstr ""

# 0f82deeda3ce44e3b953dbbfe1788e01
#: ../../java/http/routing-dsl/directives/path-directives.rst:50
msgid "Matches exactly one path-separating slash (``/``) character."
msgstr ""

# 51b4e11de703418ea794718c93e5a802
#: ../../java/http/routing-dsl/directives/path-directives.rst:53
msgid ""
"Matches the very end of the path, similar to ``$`` in regular expressions."
msgstr ""

# b5924b6c1f9f4306a64f3dcf14953b20
#: ../../java/http/routing-dsl/directives/path-directives.rst:56
msgid ""
"Matches if the unmatched path starts with a path segment (i.e. not a slash)."
" If so the path segment is extracted as a ``String`` instance."
msgstr ""

# a4db4a7db2cb4cf3819d9bccdce2bf87
#: ../../java/http/routing-dsl/directives/path-directives.rst:60
msgid ""
"Matches and extracts the complete remaining unmatched part of the request's "
"URI path as an (encoded!) String. If you need access to the remaining "
"*decoded* elements of the path use ``RemainingPath`` instead."
msgstr ""

# ab30eb6b52a04ef3a7b15a49f4a7ef8b
#: ../../java/http/routing-dsl/directives/path-directives.rst:64
msgid ""
"Efficiently matches a number of decimal digits (unsigned) and extracts their"
" (non-negative) ``Int`` value. The matcher will not match zero digits or a "
"sequence of digits that would represent an ``Int`` value larger than "
"``Integer.MAX_VALUE``."
msgstr ""

# 6465b7ec32c94381863cf03a809e64e5
#: ../../java/http/routing-dsl/directives/path-directives.rst:68
msgid ""
"Efficiently matches a number of decimal digits (unsigned) and extracts their"
" (non-negative) ``Long`` value. The matcher will not match zero digits or a "
"sequence of digits that would represent an ``Long`` value larger than "
"``Long.MAX_VALUE``."
msgstr ""

# c025ef849cbb4603a2dfaf6c76dffae8
#: ../../java/http/routing-dsl/directives/path-directives.rst:72
msgid ""
"Efficiently matches a number of hex digits and extracts their (non-negative)"
" ``Int`` value. The matcher will not match zero digits or a sequence of "
"digits that would represent an ``Int`` value larger than "
"``Integer.MAX_VALUE``."
msgstr ""

# 03c35e01455b46238aec3e7fa498b529
#: ../../java/http/routing-dsl/directives/path-directives.rst:76
msgid ""
"Efficiently matches a number of hex digits and extracts their (non-negative)"
" ``Long`` value. The matcher will not match zero digits or a sequence of "
"digits that would represent an ``Long`` value larger than "
"``Long.MAX_VALUE``."
msgstr ""

# 7b72ff0ad5b74fbd93fa42c84bd0c753
#: ../../java/http/routing-dsl/directives/path-directives.rst:80
msgid "Matches and extracts a ``java.util.UUID`` instance."
msgstr ""

# 4218862d00dc47cd89e2c4dfb19c70d4
#: ../../java/http/routing-dsl/directives/path-directives.rst:83
msgid ""
"A matcher that always matches, doesn't consume anything and extracts "
"nothing. Serves mainly as a neutral element in ``PathMatcher`` composition."
msgstr ""

# 498b3f9c51034322a620c57cb8ecb6fc
#: ../../java/http/routing-dsl/directives/path-directives.rst:87
msgid ""
"Matches all remaining segments as a list of strings. Note that this can also"
" be \"no segments\" resulting in the empty list. If the path has a trailing "
"slash this slash will *not* be matched, i.e. remain unmatched and to be "
"consumed by potentially nested directives."
msgstr ""

# 426e98ca2e824cf48e5d278793472f3d
#: ../../java/http/routing-dsl/directives/path-directives.rst:91
msgid "Here's a collection of path matching examples:"
msgstr ""

# d3e692467cf94f91911a98418a5f358b
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:4
msgid "path"
msgstr ""

# 959f08f86dc44b4f9032b189b229c8ef
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:8
msgid ""
"Matches the complete unmatched path of the ``RequestContext`` against the "
"given ``PathMatcher``, potentially extracts one or more values (depending on"
" the type of the argument)."
msgstr ""

# 56e90bd2d28b4522b0450201df392aba
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:11
msgid ""
"This directive filters incoming requests based on the part of their URI that"
" hasn't been matched yet by other potentially existing :ref:`-pathPrefix-"
"java-` directives on higher levels of the routing structure. Its one "
"parameter is usually an expression evaluating to a ``PathMatcher`` instance "
"(see also: :ref:`pathmatcher-dsl`)."
msgstr ""

# 66d0a109475c4a5f909981a6f6fbf4ea
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:15
msgid ""
"As opposed to the :ref:`-rawPathPrefix-java-` or :ref:`-rawPathPrefixTest-"
"java-` directives ``path`` automatically adds a leading slash to its "
"``PathMatcher`` argument, you therefore don't have to start your matching "
"expression with an explicit slash."
msgstr ""

# 42cad785fafb4840b62a525d6929d67e
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:18
msgid ""
"The ``path`` directive attempts to match the **complete** remaining path, "
"not just a prefix. If you only want to match a path prefix and then delegate"
" further filtering to a lower level in your routing structure use the :ref"
":`-pathPrefix-java-` directive instead. As a consequence it doesn't make "
"sense to nest a ``path`` or :ref:`-pathPrefix-java-` directive underneath "
"another ``path`` directive, as there is no way that they will ever match "
"(since the unmatched path underneath a ``path`` directive will always be "
"empty)."
msgstr ""

# 38315204fa704ffdb00cddf070775647
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:24
msgid ""
"Depending on the type of its ``PathMatcher`` argument the ``path`` directive"
" extracts zero or more values from the URI. If the match fails the request "
"is rejected with an :ref:`empty rejection set <empty rejections>`."
msgstr ""

# e7d58e8c6663435d801589dcfc61c6c4
#: ../../java/http/routing-dsl/directives/path-directives/path.rst:27
msgid ""
"The empty string (also called empty word or identity) is a **neutral "
"element** of string concatenation operation, so it will match everything, "
"but remember that ``path`` requires whole remaining path being matched, so "
"(``/``) will succeed and (``/whatever``) will fail. The :ref:`-pathPrefix-"
"java-` provides more liberal behaviour."
msgstr ""

# f03c9bd6ab2047369fdb0a7e006eb102
#: ../../java/http/routing-dsl/directives/path-directives/pathEnd.rst:4
msgid "pathEnd"
msgstr ""

# 8c473960772947b58f052f8dda72d2b4
#: ../../java/http/routing-dsl/directives/path-directives/pathEnd.rst:8
msgid ""
"Only passes the request to its inner route if the unmatched path of the "
"``RequestContext`` is empty, i.e. the request path has been fully matched by"
" a higher-level :ref:`-path-java-` or :ref:`-pathPrefix-java-` directive."
msgstr ""

# 031771bdb5af4ddeb9ce1780142adb53
#: ../../java/http/routing-dsl/directives/path-directives/pathEnd.rst:12
msgid ""
"This directive is a simple alias for ``rawPathPrefix(PathEnd)`` and is "
"mostly used on an inner-level to discriminate \"path already fully matched\""
" from other alternatives (see the example below)."
msgstr ""

# 949e6e07a4614ce7b12335da9fe6dcec
#: ../../java/http/routing-dsl/directives/path-directives/pathEndOrSingleSlash.rst:4
msgid "pathEndOrSingleSlash"
msgstr ""

# 229b3365a3da4427a3220340a55da78d
#: ../../java/http/routing-dsl/directives/path-directives/pathEndOrSingleSlash.rst:8
msgid ""
"Only passes the request to its inner route if the unmatched path of the "
"``RequestContext`` is either empty or contains only one single slash."
msgstr ""

# a303cadddc0f4a828b75821ab4707ac6
#: ../../java/http/routing-dsl/directives/path-directives/pathEndOrSingleSlash.rst:11
msgid ""
"This directive is a simple alias for ``rawPathPrefix(Slash.? ~ PathEnd)`` "
"and is mostly used on an inner-level to discriminate \"path already fully "
"matched\" from other alternatives (see the example below)."
msgstr ""

# 7542dd00e30b493599d45247e46e9c1d
#: ../../java/http/routing-dsl/directives/path-directives/pathEndOrSingleSlash.rst:14
msgid ""
"It is equivalent to ``pathEnd | pathSingleSlash`` but slightly more "
"efficient."
msgstr ""

# 32662ea02a854e2bb165e442545826e7
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefix.rst:4
msgid "pathPrefix"
msgstr ""

# f8f91dcf8b954bc199b71548d0b3c8ae
# e1cd573d81644f9d80a7933bffe65f47
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefix.rst:8
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefix.rst:8
msgid ""
"Matches and consumes a prefix of the unmatched path of the "
"``RequestContext`` against the given ``PathMatcher``, potentially extracts "
"one or more values (depending on the type of the argument)."
msgstr ""

# 5f23adc2b7b24253a0458b451410794b
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefix.rst:11
msgid ""
"This directive filters incoming requests based on the part of their URI that"
" hasn't been matched yet by other potentially existing ``pathPrefix`` or "
":ref:`-rawPathPrefix-java-` directives on higher levels of the routing "
"structure. Its one parameter is usually an expression evaluating to a "
"``PathMatcher`` instance (see also: :ref:`pathmatcher-dsl`)."
msgstr ""

# d9398a82da214c4d9bcbf426f6aee6bc
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefix.rst:15
msgid ""
"As opposed to its :ref:`-rawPathPrefix-java-` counterpart ``pathPrefix`` "
"automatically adds a leading slash to its ``PathMatcher`` argument, you "
"therefore don't have to start your matching expression with an explicit "
"slash."
msgstr ""

# 5b352c738cde41e6b6dee5d696ccc01e
# fef710f7a4e24267b1050b129dc8dc77
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefix.rst:18
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffix.rst:21
msgid ""
"Depending on the type of its ``PathMatcher`` argument the ``pathPrefix`` "
"directive extracts zero or more values from the URI. If the match fails the "
"request is rejected with an :ref:`empty rejection set <empty rejections>`."
msgstr ""

# 1fcb5fc08a2745cca71162cae6eaf7f0
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefix.rst:21
msgid ""
"The empty string (also called empty word or identity) is a **neutral "
"element** of string concatenation operation, so it will match everything and"
" consume nothing. The :ref:`-path-java-` provides more strict behaviour."
msgstr ""

# 6daf8873cb1b4d4fbb927543ab1b2726
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefixTest.rst:4
msgid "pathPrefixTest"
msgstr ""

# 21a7d4a1569c4078b85a27c89709abed
# 59d462e0f13e468caff7f11399bd84e8
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefixTest.rst:8
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefixTest.rst:8
msgid ""
"Checks whether the unmatched path of the ``RequestContext`` has a prefix "
"matched by the given ``PathMatcher``. Potentially extracts one or more "
"values (depending on the type of the argument) but doesn't consume its match"
" from the unmatched path."
msgstr ""

# 423fe3fd2fb6443ba9468f92afca375b
# 3f1637996c3f423e9eebb0c5642695f9
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefixTest.rst:12
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefixTest.rst:12
msgid ""
"This directive is very similar to the :ref:`-pathPrefix-java-` directive "
"with the one difference that the path prefix it matched (if it matched) is "
"*not* consumed. The unmatched path of the ``RequestContext`` is therefore "
"left as is even in the case that the directive successfully matched and the "
"request is passed on to its inner route."
msgstr ""

# e6c36a4698f34c809b7b4627ec1c51b4
# 1d18ce2e7bd847328ae312396746be45
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefixTest.rst:16
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefixTest.rst:16
msgid ""
"For more info on how to create a ``PathMatcher`` see :ref:`pathmatcher-dsl`."
msgstr ""

# 7d28236737014d31a454be64c61d07b5
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefixTest.rst:18
msgid ""
"As opposed to its :ref:`-rawPathPrefixTest-java-` counterpart "
"``pathPrefixTest`` automatically adds a leading slash to its ``PathMatcher``"
" argument, you therefore don't have to start your matching expression with "
"an explicit slash."
msgstr ""

# 1988b4e6e04945f29b729b180bfcb837
#: ../../java/http/routing-dsl/directives/path-directives/pathPrefixTest.rst:21
msgid ""
"Depending on the type of its ``PathMatcher`` argument the ``pathPrefixTest``"
" directive extracts zero or more values from the URI. If the match fails the"
" request is rejected with an :ref:`empty rejection set <empty rejections>`."
msgstr ""

# 263e1014bcd24e83b15d8e36a1434338
#: ../../java/http/routing-dsl/directives/path-directives/pathSingleSlash.rst:4
msgid "pathSingleSlash"
msgstr ""

# f3e1a959bea54ca19f4d42c0822108c2
#: ../../java/http/routing-dsl/directives/path-directives/pathSingleSlash.rst:8
msgid ""
"Only passes the request to its inner route if the unmatched path of the "
"``RequestContext`` contains exactly one single slash."
msgstr ""

# 9a9c72a9a52b4df2bf67a7e374f20b3c
#: ../../java/http/routing-dsl/directives/path-directives/pathSingleSlash.rst:11
msgid ""
"This directive is a simple alias for ``pathPrefix(PathEnd)`` and is mostly "
"used for matching requests to the root URI (``/``) on an inner-level to "
"discriminate \"all path segments matched\" from other alternatives (see the "
"example below)."
msgstr ""

# dc946007b83149a4a02cf0472ad634a0
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffix.rst:4
msgid "pathSuffix"
msgstr ""

# 7455fc22e25c4463b2b2d9e2be2a643d
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffix.rst:8
msgid ""
"Matches and consumes a suffix of the unmatched path of the "
"``RequestContext`` against the given ``PathMatcher``, potentially extracts "
"one or more values (depending on the type of the argument)."
msgstr ""

# fa4bec277ae747c9a134c9aa42f6bb7f
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffix.rst:11
msgid ""
"This directive filters incoming requests based on the part of their URI that"
" hasn't been matched yet by other potentially existing path matching "
"directives on higher levels of the routing structure. Its one parameter is "
"usually an expression evaluating to a ``PathMatcher`` instance (see also: "
":ref:`pathmatcher-dsl`)."
msgstr ""

# e9a8df1ac93f49459922812e5f6ee249
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffix.rst:15
msgid ""
"As opposed to :ref:`-pathPrefix-java-` this directive matches and consumes "
"the unmatched path from the right, i.e. the end."
msgstr ""

# 99750c97d2974b0c9c8e1fd2dca11a13
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffix.rst:17
msgid ""
"For efficiency reasons, the given ``PathMatcher`` must match the desired "
"suffix in reversed-segment order, i.e. ``pathSuffix(\"baz\" / \"bar\")`` "
"would match ``/foo/bar/baz``! The order within a segment match is not "
"reversed."
msgstr ""

# 1d1d2a7f63304b3c9c46d28f95598868
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffixTest.rst:4
msgid "pathSuffixTest"
msgstr ""

# 6b8d5537fea741fb87036cc86672763d
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffixTest.rst:8
msgid ""
"Checks whether the unmatched path of the ``RequestContext`` has a suffix "
"matched by the given ``PathMatcher``. Potentially extracts one or more "
"values (depending on the type of the argument) but doesn't consume its match"
" from the unmatched path."
msgstr ""

# 5c3fd067449f4acfb78209c1bcdc65b8
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffixTest.rst:12
msgid ""
"This directive is very similar to the :ref:`-pathSuffix-java-` directive "
"with the one difference that the path suffix it matched (if it matched) is "
"*not* consumed. The unmatched path of the ``RequestContext`` is therefore "
"left as is even in the case that the directive successfully matched and the "
"request is passed on to its inner route."
msgstr ""

# 53d4f7e777d6427db66af22ba78834ad
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffixTest.rst:16
msgid ""
"As opposed to :ref:`-pathPrefixTest-java-` this directive matches and "
"consumes the unmatched path from the right, i.e. the end."
msgstr ""

# aa5d7b8cef5c407e8230b2a3c9d7e85b
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffixTest.rst:18
msgid ""
"For efficiency reasons, the given ``PathMatcher`` must match the desired "
"suffix in reversed-segment order, i.e. ``pathSuffixTest(\"baz\" / \"bar\")``"
" would match ``/foo/bar/baz``! The order within a segment match is not "
"reversed."
msgstr ""

# 39db1065d6fe4e4dae03ba2a74829dff
#: ../../java/http/routing-dsl/directives/path-directives/pathSuffixTest.rst:22
msgid ""
"Depending on the type of its ``PathMatcher`` argument the ``pathSuffixTest``"
" directive extracts zero or more values from the URI. If the match fails the"
" request is rejected with an :ref:`empty rejection set <empty rejections>`."
msgstr ""

# 04c9e883a2be4556987e62dc2a0175c0
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefix.rst:4
msgid "rawPathPrefix"
msgstr ""

# 8ef2659cf552442a8069fe6bfd60b7ed
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefix.rst:11
msgid ""
"This directive filters incoming requests based on the part of their URI that"
" hasn't been matched yet by other potentially existing ``rawPathPrefix`` or "
":ref:`-pathPrefix-java-` directives on higher levels of the routing "
"structure. Its one parameter is usually an expression evaluating to a "
"``PathMatcher`` instance (see also: :ref:`pathmatcher-dsl`)."
msgstr ""

# 9e6cdcfeaa86411c9087f25712a299e9
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefix.rst:15
msgid ""
"As opposed to its :ref:`-pathPrefix-java-` counterpart ``rawPathPrefix`` "
"does *not* automatically add a leading slash to its ``PathMatcher`` "
"argument. Rather its ``PathMatcher`` argument is applied to the unmatched "
"path as is."
msgstr ""

# eef621477a5f47f4a03dd4ae3470eeb3
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefix.rst:18
msgid ""
"Depending on the type of its ``PathMatcher`` argument the ``rawPathPrefix`` "
"directive extracts zero or more values from the URI. If the match fails the "
"request is rejected with an :ref:`empty rejection set <empty rejections>`."
msgstr ""

# 0ce4538de2074e87b035b31454292de5
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefixTest.rst:4
msgid "rawPathPrefixTest"
msgstr ""

# 912d3f3114444ad5b73cbf9fb7a039ef
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefixTest.rst:18
msgid ""
"As opposed to its :ref:`-pathPrefixTest-java-` counterpart "
"``rawPathPrefixTest`` does *not* automatically add a leading slash to its "
"``PathMatcher`` argument. Rather its ``PathMatcher`` argument is applied to "
"the unmatched path as is."
msgstr ""

# 3245cc6407e3485bb12cbca3fc08c595
#: ../../java/http/routing-dsl/directives/path-directives/rawPathPrefixTest.rst:21
msgid ""
"Depending on the type of its ``PathMatcher`` argument the "
"``rawPathPrefixTest`` directive extracts zero or more values from the URI. "
"If the match fails the request is rejected with an :ref:`empty rejection set"
" <empty rejections>`."
msgstr ""

# 8500985c09f840b38649c4bd64aa7e9a
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:4
msgid "redirectToNoTrailingSlashIfPresent"
msgstr ""

# ac7f39904b8e459aa3a74ea0f8a1d509
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:8
msgid ""
"If the requested path does end with a trailing ``/`` character, redirects to"
" the same path without that trailing slash.."
msgstr ""

# 62b18a9b075b48a4b2798e5990ed6c16
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:11
msgid ""
"Redirects the HTTP Client to the same resource yet without the trailing "
"``/``, in case the request contained it. When redirecting an HttpResponse "
"with the given redirect response code (i.e. ``MovedPermanently`` or "
"``TemporaryRedirect`` etc.) as well as a simple HTML page containing a "
"\"*click me to follow redirect*\" link to be used in case the client can "
"not, or refuses to for security reasons, automatically follow redirects."
msgstr ""

# da5f4b718b624c5eaf1b586a65a9d84e
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:16
msgid ""
"Please note that the inner paths **MUST NOT** end with an explicit trailing "
"slash (e.g. ``\"things\"./``) for the re-directed-to route to match."
msgstr ""

# bc4b15c2f49b490a9860863deae068aa
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:19
msgid ""
"A good read on the subject of how to deal with trailing slashes is available"
" on `Google Webmaster Central - To Slash or not to Slash`_."
msgstr ""

# 090f1b3fb79d40159bceaa12a45c10e4
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:21
msgid ""
"See also :ref:`-redirectToTrailingSlashIfMissing-java-` for the opposite "
"behaviour."
msgstr ""

# b94191492e7d4044b19cc61f1c7a5ea2
#: ../../java/http/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.rst:29
msgid ""
"See also :ref:`-redirectToTrailingSlashIfMissing-java-` which achieves the "
"opposite - redirecting paths in case they do *not* have a trailing slash."
msgstr ""

# 77209b81183747ed835f40100f56d4bf
#: ../../java/http/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.rst:4
msgid "redirectToTrailingSlashIfMissing"
msgstr ""

# 13dc6bff154e4881830d1d025677983b
#: ../../java/http/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.rst:8
msgid ""
"If the requested path does not end with a trailing ``/`` character, "
"redirects to the same path followed by such trailing slash."
msgstr ""

# a7b6d3a10e10459187aac7a7b78d8940
#: ../../java/http/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.rst:11
msgid ""
"Redirects the HTTP Client to the same resource yet followed by a trailing "
"``/``, in case the request did not contain it. When redirecting an "
"HttpResponse with the given redirect response code (i.e. "
"``MovedPermanently`` or ``TemporaryRedirect`` etc.) as well as a simple HTML"
" page containing a \"*click me to follow redirect*\" link to be used in case"
" the client can not, or refuses to for security reasons, automatically "
"follow redirects."
msgstr ""

# 157e51bc558f4bbf96d2dfe4cfe536bb
#: ../../java/http/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.rst:16
msgid ""
"Please note that the inner paths **MUST** end with an explicit trailing "
"slash (e.g. ``\"things\"./``) for the re-directed-to route to match."
msgstr ""

# 1cde155542604a3fb898c70ab4e59ab8
#: ../../java/http/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.rst:19
msgid ""
"See also :ref:`-redirectToNoTrailingSlashIfPresent-java-` for the opposite "
"behaviour."
msgstr ""

# f07266cbb6234f1fa7a710341d7a05db
#: ../../java/http/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.rst:25
msgid ""
"See also :ref:`-redirectToNoTrailingSlashIfPresent-java-` which achieves the"
" opposite - redirecting paths in case they do have a trailing slash."
msgstr ""

# 79f4bdff63ec4b46a970c87aa23aca1c
#: ../../java/http/routing-dsl/directives/range-directives/index.rst:4
msgid "RangeDirectives"
msgstr ""

# 1a82cc1cb8ac4a9484c164b9507caf72
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:4
msgid "withRangeSupport"
msgstr ""

# 536bb4ca18fb4b3cb3f7adee7941716b
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:8
msgid ""
"Transforms the response from its inner route into a ``206 Partial Content`` "
"response if the client requested only part of the resource with a ``Range`` "
"header."
msgstr ""

# 262a777dae79427aaf3fef6dcdba9b61
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:11
msgid ""
"Augments responses to ``GET`` requests with an ``Accept-Ranges: bytes`` "
"header and converts them into partial responses if the request contains a "
"valid ``Range`` request header. The requested byte-ranges are coalesced "
"(merged) if they lie closer together than the specified "
"``rangeCoalescingThreshold`` argument."
msgstr ""

# c8304dd41a7b45b2a4833b385336de30
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:15
msgid ""
"In order to prevent the server from becoming overloaded with trying to "
"prepare ``multipart/byteranges`` responses for high numbers of potentially "
"very small ranges the directive rejects requests requesting more than "
"``rangeCountLimit`` ranges with a ``TooManyRangesRejection``. Requests with "
"unsatisfiable ranges are rejected with an ``UnsatisfiableRangeRejection``."
msgstr ""

# 105fecf204ff4407b97e656b82551a89
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:20
msgid ""
"The ``withRangeSupport()`` form (without parameters) uses the ``range-"
"coalescing-threshold`` and ``range-count-limit`` settings from the "
"``akka.http.routing`` configuration."
msgstr ""

# 1a863aad0e6946859eb829424df7300b
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:23
msgid "This directive is transparent to non-``GET`` requests."
msgstr ""

# f3abeaa5069a42bfb47a72d1c40bccd2
#: ../../java/http/routing-dsl/directives/range-directives/withRangeSupport.rst:25
msgid "See also: https://tools.ietf.org/html/rfc7233"
msgstr ""

# 669c1ea9682b4cae8d7d6650ed5f3209
#: ../../java/http/routing-dsl/directives/respond-with-directives/index.rst:4
msgid "RespondWithDirectives"
msgstr ""

# b0fa0dc42ec741a9a466c39312f56369
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.rst:4
msgid "respondWithDefaultHeader"
msgstr ""

# 89bde50e007545ce9519aae6c72ef847
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.rst:8
msgid ""
"Adds a given HTTP header to all responses coming back from its inner route "
"only if a header with the same name doesn't exist yet in the response."
msgstr ""

# d8ac6eec7ff94dd0a609675935d5e941
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.rst:12
msgid ""
"This directive transforms ``HttpResponse`` and ``ChunkedResponseStart`` "
"messages coming back from its inner route by potentially adding the given "
"``HttpHeader`` instance to the headers list. The header is only added if "
"there is no header instance with the same name (case insensitively) already "
"present in the response."
msgstr ""

# 9fa9b78f5edc4cb1a1090271d605d3df
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.rst:17
msgid ""
"See also :ref:`-respondWithDefaultHeaders-java-`  if you'd like to add more "
"than one header."
msgstr ""

# 3c3ea6603b4b48b39982ec7d95432f90
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:4
msgid "respondWithDefaultHeaders"
msgstr ""

# 50303a772b9b48d898f33c957a1637d3
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:8
msgid ""
"Adds the given HTTP headers to all responses coming back from its inner "
"route only if a respective header with the same name doesn't exist yet in "
"the response."
msgstr ""

# b82803c4db6f4504b5e1d7d60a28719e
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:12
msgid ""
"This directive transforms ``HttpResponse`` and ``ChunkedResponseStart`` "
"messages coming back from its inner route by potentially adding the given "
"``HttpHeader`` instances to the headers list. A header is only added if "
"there is no header instance with the same name (case insensitively) already "
"present in the response."
msgstr ""

# cd95235aa24d4c57912ed67ac7db82d9
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:17
msgid ""
"See also :ref:`-respondWithDefaultHeader-java-` if you'd like to add only a "
"single header."
msgstr ""

# 90d5620862c948c08d71687f6c262853
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:23
msgid ""
"The ``respondWithDefaultHeaders`` directive is equivalent to the "
"``respondWithDefaultHeader`` directive which is shown in the example below, "
"however it allows including multiple default headers at once in the "
"directive, like so::"
msgstr ""

# 77abddc739e44af68315146aca676c6b
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:31
msgid ""
"The semantics remain the same however, as explained by the following "
"example:"
msgstr ""

# 3ccc3c3be70e4148b1b7dc01aef30793
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.rst:35
msgid ""
"See the :ref:`-respondWithDefaultHeader-java-` directive for an example with"
" only one header."
msgstr ""

# 547c554862d74fdc8b5d0733e72af1a8
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeader.rst:4
msgid "respondWithHeader"
msgstr ""

# 77ec63efb5c64d99bdc641875d860a6c
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeader.rst:8
msgid ""
"Adds a given HTTP header to all responses coming back from its inner route."
msgstr ""

# 5ba292acfe6d492085b773436ce3bd5f
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeader.rst:10
msgid ""
"This directive transforms ``HttpResponse`` and ``ChunkedResponseStart`` "
"messages coming back from its inner route by adding the given ``HttpHeader``"
" instance to the headers list."
msgstr ""

# fdec90875afc483b83bca882df126d83
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeader.rst:13
msgid ""
"See also :ref:`-respondWithHeaders-java-` if you'd like to add more than one"
" header."
msgstr ""

# 0ff4054d2fdf45829c00e0fa8f0c1b96
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeaders.rst:4
msgid "respondWithHeaders"
msgstr ""

# c8f6d8c64d1d4b79a27184eb40cd04b8
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeaders.rst:8
msgid ""
"Adds the given HTTP headers to all responses coming back from its inner "
"route."
msgstr ""

# 00e87e0fd4ce457a8f73d932098f9b06
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeaders.rst:10
msgid ""
"This directive transforms ``HttpResponse`` and ``ChunkedResponseStart`` "
"messages coming back from its inner route by adding the given ``HttpHeader``"
" instances to the headers list."
msgstr ""

# 7c6fb54a4a1743d1aa2844319aa36826
#: ../../java/http/routing-dsl/directives/respond-with-directives/respondWithHeaders.rst:13
msgid ""
"See also :ref:`-respondWithHeader-java-` if you'd like to add just a single "
"header."
msgstr ""

# b8d0f5ee5e1b438b9bed0caa1129fbf7
#: ../../java/http/routing-dsl/directives/route-directives/complete.rst:4
msgid "complete"
msgstr ""

# e401cdee54574e4ba887b88454b6c5d7
#: ../../java/http/routing-dsl/directives/route-directives/complete.rst:9
msgid "Completes the request using the given argument(s)."
msgstr ""

# 4da77ec0a9fe4d3a980667504c250605
#: ../../java/http/routing-dsl/directives/route-directives/complete.rst:11
msgid ""
"``complete`` uses the given arguments to construct a ``Route`` which simply "
"calls ``complete`` on the ``RequestContext`` with the respective "
"``HttpResponse`` instance. Completing the request will send the response "
"\"back up\" the route structure where all the logic runs that wrapping "
"directives have potentially chained into the :class:`RouteResult` future "
"transformation chain."
msgstr ""

# b54d8bc0c8d74bf282a241ed2f9feb7a
#: ../../java/http/routing-dsl/directives/route-directives/complete.rst:16
msgid ""
"Please note that the ``complete`` directive has multiple variants, like"
msgstr ""

# 00f840233ebf4c9cbc30bc3053e06ff5
#: ../../java/http/routing-dsl/directives/route-directives/failWith.rst:4
msgid "failWith"
msgstr ""

# ade19bc9106049e7aa9d151c2372b7b8
#: ../../java/http/routing-dsl/directives/route-directives/failWith.rst:8
msgid ""
"Bubbles up the given error through the route structure where it is dealt "
"with by the closest ``handleExceptions`` directive and its "
":class:`ExceptionHandler`."
msgstr ""

# 7c032d1c918845b89d8d08c79e4a6357
#: ../../java/http/routing-dsl/directives/route-directives/failWith.rst:11
msgid ""
"``failWith`` explicitly raises an exception that gets bubbled up through the"
" route structure to be picked up by the nearest ``handleExceptions`` "
"directive. Using ``failWith`` rather than simply throwing an exception "
"enables the route structure's :ref:`exception-handling-java` mechanism to "
"deal with the exception even if the current route is executed asynchronously"
" on another thread (e.g. in a ``Future`` or separate actor)."
msgstr ""

# e912403e522d4b3baa55ae27143543dc
#: ../../java/http/routing-dsl/directives/route-directives/failWith.rst:16
msgid ""
"If no ``handleExceptions`` is present above the respective location in the "
"route structure the top-level routing logic will handle the exception and "
"translate it into a corresponding ``HttpResponse`` using the in-scope "
"``ExceptionHandler`` (see also the :ref:`exception-handling-java` chapter)."
msgstr ""

# 43363a5b30f64da6aaca2d84c7fa83c5
#: ../../java/http/routing-dsl/directives/route-directives/failWith.rst:20
msgid ""
"There is one notable special case: If the given exception is a "
"``RejectionError`` exception it is *not* bubbled up, but rather the wrapped "
"exception is unpacked and \"executed\". This allows the \"tunneling\" of a "
"rejection via an exception."
msgstr ""

# 9311d758d89548c4b310b6573f3faa3c
#: ../../java/http/routing-dsl/directives/route-directives/index.rst:4
msgid "RouteDirectives"
msgstr ""

# ea5d5370c279496d8f33846c1f4f81bf
#: ../../java/http/routing-dsl/directives/route-directives/index.rst:6
msgid ""
"The ``RouteDirectives`` have a special role in akka-http's routing DSL. "
"Contrary to all other directives (except most :ref"
":`FileAndResourceDirectives-java`) they do not produce instances of type "
"``Directive[L <: HList]`` but rather \"plain\" routes of type ``Route``. The"
" reason is that the ``RouteDirectives`` are not meant for wrapping an inner "
"route (like most other directives, as intermediate-level elements of a route"
" structure, do) but rather form the leaves of the actual route structure "
"**leaves**."
msgstr ""

# a2059571a77f44f398afd6e0d1eb90da
#: ../../java/http/routing-dsl/directives/route-directives/index.rst:12
msgid ""
"So in most cases the inner-most element of a route structure branch is one "
"of the ``RouteDirectives`` (or :ref:`FileAndResourceDirectives-java`):"
msgstr ""

# 09b05a25e7ff46b5b656b81c95365ce4
#: ../../java/http/routing-dsl/directives/route-directives/redirect.rst:4
msgid "redirect"
msgstr ""

# 5524874cd8624833abc2d3ace0fa4198
#: ../../java/http/routing-dsl/directives/route-directives/redirect.rst:8
msgid ""
"Completes the request with a redirection response to a given targer URI and "
"of a given redirection type (status code)."
msgstr ""

# 446d0b03bbd54213a1c7150f8358e1b4
#: ../../java/http/routing-dsl/directives/route-directives/redirect.rst:10
msgid ""
"``redirect`` is a convenience helper for completing the request with a "
"redirection response. It is equivalent to this snippet relying on the "
"``complete`` directive:"
msgstr ""

# c81a7e60d3584da69f1df72b678e675d
#: ../../java/http/routing-dsl/directives/route-directives/reject.rst:4
msgid "reject"
msgstr ""

# bea0dbb79df94bf1b22659ee63123ca3
#: ../../java/http/routing-dsl/directives/route-directives/reject.rst:8
msgid ""
"Explicitly rejects the request optionally using the given rejection(s)."
msgstr ""

# 05571294e8114950b03d5743d5f50cc8
#: ../../java/http/routing-dsl/directives/route-directives/reject.rst:10
msgid ""
"``reject`` uses the given rejection instances (which might be the empty "
"``Seq``) to construct a ``Route`` which simply calls "
"``requestContext.reject``. See the chapter on :ref:`rejections-java` for "
"more information on what this means."
msgstr ""

# c63669bc75244136ae1f1638b8b02c26
#: ../../java/http/routing-dsl/directives/route-directives/reject.rst:13
msgid ""
"After the request has been rejected at the respective point it will continue"
" to flow through the routing structure in the search for a route that is "
"able to complete it."
msgstr ""

# 9fb0547bc8bb431f8d36a4a9d63c0e1f
#: ../../java/http/routing-dsl/directives/route-directives/reject.rst:16
msgid ""
"The explicit ``reject`` directive is used mostly when building :ref:`Custom "
"Directives`, e.g. inside of a ``flatMap`` modifier for \"filtering out\" "
"certain cases."
msgstr ""

# a483167c9e0447ca8e26496861607035
#: ../../java/http/routing-dsl/directives/scheme-directives/extractScheme.rst:4
msgid "extractScheme"
msgstr ""

# a31557861315499b89b706647ffa65db
#: ../../java/http/routing-dsl/directives/scheme-directives/extractScheme.rst:8
msgid ""
"Extracts the Uri scheme (i.e. \"``http``\", \"``https``\", etc.) for an "
"incoming request."
msgstr ""

# 1195c95cbe724188a2efee8689bf4224
#: ../../java/http/routing-dsl/directives/scheme-directives/extractScheme.rst:10
msgid ""
"For rejecting a request if it doesn't match a specified scheme name, see the"
" :ref:`-scheme-java-` directive."
msgstr ""

# 40431c7092794c578046275301eb730f
#: ../../java/http/routing-dsl/directives/scheme-directives/index.rst:4
msgid "SchemeDirectives"
msgstr ""

# 61a36be0b3d7419cbf1276e8c3ba65c3
#: ../../java/http/routing-dsl/directives/scheme-directives/index.rst:6
msgid ""
"Scheme directives can be used to extract the Uri scheme (i.e. \"http\", "
"\"https\", etc.) from requests or to reject any request that does not match "
"a specified scheme name."
msgstr ""

# 3bf2dab7219e47c38bb97d66569f91bf
#: ../../java/http/routing-dsl/directives/scheme-directives/scheme.rst:4
msgid "scheme"
msgstr ""

# ad901a890a384f1a8fce9fb2d7f51daa
#: ../../java/http/routing-dsl/directives/scheme-directives/scheme.rst:8
msgid "Rejects a request if its Uri scheme does not match a given one."
msgstr ""

# 4017dc405a0f4835b354c01455a388c1
#: ../../java/http/routing-dsl/directives/scheme-directives/scheme.rst:10
msgid ""
"The ``scheme`` directive can be used to match requests by their Uri scheme, "
"only passing through requests that match the specified scheme and rejecting "
"all others."
msgstr ""

# 8004688117124a44bbfd6c7da5c58fb1
#: ../../java/http/routing-dsl/directives/scheme-directives/scheme.rst:13
msgid ""
"A typical use case for the ``scheme`` directive would be to reject requests "
"coming in over http instead of https, or to redirect such requests to the "
"matching https URI with a ``MovedPermanently``."
msgstr ""

# fc979efc51114891834e8b125ec0d379
#: ../../java/http/routing-dsl/directives/scheme-directives/scheme.rst:17
msgid ""
"For simply extracting the scheme name, see the :ref:`-extractScheme-java-` "
"directive."
msgstr ""

# be5a5aeae1d44c89b87d6e64f96ebbfc
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:4
msgid "authenticateBasic"
msgstr ""

# c6850292942e46618d13447ea517b59b
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:5
msgid ""
"Wraps the inner route with Http Basic authentication support using a given "
"``Authenticator<T>``."
msgstr ""

# 99b9dc4314974db0ad42ff1392d18fa9
# 6bf8d46a4d824f9faad0a28c3e1fc29c
# f34092b04a3646819d519927a4f31e5b
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:9
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:9
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:9
msgid "Provides support for handling `HTTP Basic Authentication`_."
msgstr ""

# 29a87d12e3de4d95bf02d5a6da462ae9
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:11
msgid ""
"Given a function returning an ``Optional<T>`` with a value upon successful "
"authentication and an empty ``Optional<T>`` otherwise, respectively applies "
"the inner route or rejects the request with a "
":class:`AuthenticationFailedRejection` rejection, which by default is mapped"
" to an ``401 Unauthorized`` response."
msgstr ""

# c5ce710b7fc04dd2a11503c6e3cf0c2c
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:15
msgid ""
"Longer-running authentication tasks (like looking up credentials in a "
"database) should use the :ref:`-authenticateBasicAsync-java-` variant of "
"this directive which allows it to run without blocking routing layer of Akka"
" HTTP, freeing it for other requests."
msgstr ""

# ea59a3f690614c03a557664748c49d17
# 1d77648c31bb4951980fa6a9482dc11e
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:18
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:16
msgid ""
"Standard HTTP-based authentication which uses the ``WWW-Authenticate`` "
"header containing challenge data and ``Authorization`` header for receiving "
"credentials is implemented in subclasses of ``HttpAuthenticator``."
msgstr ""

# 618e0cad691a4d37a1a31eacd20fab82
# d8a17101c0f045ba92edd099fa2be66d
# c41c220945f04429b13796c3a2761bc4
# c707ee905f134998b223c12450923784
# 9f8086fd10aa444caa073d59a7d592da
# 9dd8f3b1a9d84cf7b650db74fd7c2bcd
# ff83654754c442a9b6259d02a3e66ce1
# c5684140da2c45c6a2e591daad5f269a
# 5bb294f3ce8b40f3995186b4e29202e0
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:21
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:19
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:19
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:16
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:23
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:22
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:24
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:23
#: ../../java/http/routing-dsl/directives/security-directives/extractCredentials.rst:12
msgid ""
"See :ref:`credentials-and-timing-attacks-java` for details about verifying "
"the secret."
msgstr ""

# 6d5eecf7df6a487691956789aa73127f
# e3c97211a55c4d6b9ed19d5ffb3271ec
# 125b6d823f424e53a4c16bcdf34a7dd5
# c9971ac9ea4248f699fd8632a6b45333
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasic.rst:24
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:22
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:22
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:19
msgid ""
"Make sure to use basic authentication only over SSL/TLS because credentials "
"are transferred in plaintext."
msgstr ""

# dc491d41bae6416bb68b8cbf5e2031c5
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:4
msgid "authenticateBasicAsync"
msgstr ""

# 56785a73523e49eaae7cf73530f73368
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:5
msgid ""
"Wraps the inner route with Http Basic authentication support using a given "
"``AsyncAuthenticator<T>``."
msgstr ""

# cc51b95b807c455b94817cf3292a84ab
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:9
msgid ""
"This variant of the :ref:`-authenticateBasic-java-` directive returns a "
"``Future<Optional<T>>`` which allows freeing up the routing layer of Akka "
"HTTP, freeing it for other requests. It should be used whenever an "
"authentication is expected to take a longer amount of time (e.g. looking up "
"the user in a database)."
msgstr ""

# 0a07fbc375bf4b9a8b2a1fca8e356d31
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicAsync.rst:13
msgid ""
"In case the returned option is an empty ``Optional`` the request is rejected"
" with a :class:`AuthenticationFailedRejection`, which by default is mapped "
"to an ``401 Unauthorized`` response."
msgstr ""

# 16cb9067928f47db980b2d82a49261a1
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:4
msgid "authenticateBasicPF"
msgstr ""

# cb5c1cc1a70c4b5bbe7fd86e4d571458
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:5
msgid ""
"Wraps the inner route with Http Basic authentication support using a given "
"``AuthenticatorPF<T>``."
msgstr ""

# fdedf87d2d17428db70360915b67189f
# a3be36469c784b2582118c3b8e746f3e
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:11
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:11
msgid ""
"Refer to :ref:`-authenticateBasic-java-` for a detailed description of this "
"directive."
msgstr ""

# 8e21bf6f34fc40a8b790c2b5bf7806d3
# eb4c625b3c664a6b88887ae4b75680d3
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:13
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:13
msgid ""
"Its semantics are equivalent to ``authenticateBasicPF`` 's, where not "
"handling a case in the Partial Function (PF) leaves the request to be "
"rejected with a :class:`AuthenticationFailedRejection` rejection."
msgstr ""

# 21ade78c9fe94ec5af4a3323b13a7e6a
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPF.rst:16
msgid ""
"Longer-running authentication tasks (like looking up credentials in a "
"database) should use :ref:`-authenticateBasicAsync-java-` or :ref"
":`-authenticateBasicPFAsync-java-` if you prefer to use the "
"``PartialFunction`` syntax."
msgstr ""

# 3f8238b0f7124069b427f300ebe0b35e
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:4
msgid "authenticateBasicPFAsync"
msgstr ""

# bdef1822aea0474bba3d1befcf27a067
#: ../../java/http/routing-dsl/directives/security-directives/authenticateBasicPFAsync.rst:5
msgid ""
"Wraps the inner route with Http Basic authentication support using a given "
"``AsyncAuthenticatorPF<T>``."
msgstr ""

# 045212f1198540658e4c0704e6c69b53
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:4
msgid "authenticateOAuth2"
msgstr ""

# d03df11d2b57429e8b32dfb0b6159715
# e55b8e6a5aad48d7baa978f5b0d6f4fd
# 3a7321a9dd094401a46338e506c4189b
# 5a09a7ea25964eada52f9ba870b73e6f
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:9
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:9
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:9
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:9
msgid ""
"Provides support for extracting the so-called \"*Bearer Token*\" from the "
":class:`Authorization` HTTP Header, which is used to initiate an OAuth2 "
"authorization."
msgstr ""

# d875fca05c6d414290cb4b90c5b57cc7
# d41d6fd0481c4fcaba27ad30cc0906bb
# b6e9e37893a14811a57b79b00ca2a209
# 1a68eb21845a4d94bd9d3ca104fa2f17
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:13
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:13
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:13
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:13
msgid ""
"This directive does not implement the complete OAuth2 protocol, but instead "
"enables implementing it, by extracting the needed token from the HTTP "
"headers."
msgstr ""

# ddc7c820bd7e412f81d9ade9b5212103
# 65c07b3ccef14ab7ad17460343c57b47
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:16
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:16
msgid ""
"Given a function returning ``Some<T>`` upon successful authentication and "
"``None`` otherwise, respectively applies the inner route or rejects the "
"request with a :class:`AuthenticationFailedRejection` rejection, which by "
"default is mapped to an ``401 Unauthorized`` response."
msgstr ""

# eca3c1f910aa48819d98c10de54dd141
# 962648fdb34a477e8d84cf52dc84abe4
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:20
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:21
msgid ""
"Longer-running authentication tasks (like looking up credentials in a "
"database) should use the :ref:`-authenticateOAuth2Async-java-` variant of "
"this directive which allows it to run without blocking routing layer of Akka"
" HTTP, freeing it for other requests."
msgstr ""

# e293cf9344e8456cbc63992f5b595a2a
# 7588922ada4b413fad39a94b47317983
# 42c866045654446ca00667726b8d24de
# 6f34f2f6c18b486f84fe24612e408ad2
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:25
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:24
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:26
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:25
msgid "For more information on how OAuth2 works see `RFC 6750`_."
msgstr ""

# e25e03dcf10f409f809a2494eeb4a864
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2.rst:32
msgid ""
"Usage in code is exactly the same as :ref:`-authenticateBasic-java-`, with "
"the difference that one must validate the token as OAuth2 dictates (which is"
" currently not part of Akka HTTP itself)."
msgstr ""

# 36deb42d98dd4606b56e10bd414e6c3a
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:4
msgid "authenticateOAuth2Async"
msgstr ""

# 851946642b824af29acbdd27c7015e30
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:5
msgid ""
"Wraps the inner route with OAuth Bearer Token authentication support using a"
" given ``AsyncAuthenticator<T>``."
msgstr ""

# c978e3fe842843d8bd212c6534ce0d76
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:20
msgid ""
"See also :ref:`-authenticateOAuth2-java-` if the authorization operation is "
"rather quick, and does not have to execute asynchronously."
msgstr ""

# 36c630c1889a4656be1664c0ca22c26e
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2Async.rst:32
msgid ""
"Usage in code is exactly the same as :ref:`-authenticateBasicAsync-java-`, "
"with the difference that one must validate the token as OAuth2 dictates "
"(which is currently not part of Akka HTTP itself)."
msgstr ""

# adb7941b2cd54a9aae1299733764ab19
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:4
msgid "authenticateOAuth2PF"
msgstr ""

# e283fa41ebb846fc8469c8cb154c9007
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:5
msgid ""
"Wraps the inner route with OAuth Bearer Token authentication support using a"
" given ``AuthenticatorPF<T>``."
msgstr ""

# 10e6eb609fab46728c59d90a23258bd8
# 993a8ac55379471f9f70bf4dca922844
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:16
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:16
msgid ""
"Refer to :ref:`-authenticateOAuth2-java-` for a detailed description of this"
" directive."
msgstr ""

# cebed2cebc1c4b4db20f89dcd8a24a30
# 941700ee4ca247ee98425298f66bb511
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:18
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:18
msgid ""
"Its semantics are equivalent to ``authenticateOAuth2PF`` 's, where not "
"handling a case in the Partial Function (PF) leaves the request to be "
"rejected with a :class:`AuthenticationFailedRejection` rejection."
msgstr ""

# e5a05313bf544c85b0447006a0946636
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PF.rst:33
msgid ""
"Usage in code is exactly the same as :ref:`-authenticateBasicPF-java-`, with"
" the difference that one must validate the token as OAuth2 dictates (which "
"is currently not part of Akka HTTP itself)."
msgstr ""

# 07920a7f0fde47fb9aa621e9751d85c5
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:4
msgid "authenticateOAuth2PFAsync"
msgstr ""

# 92d416d58ded407699c7336cb5777d90
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:5
msgid ""
"Wraps the inner route with OAuth Bearer Token authentication support using a"
" given ``AsyncAuthenticatorPF<T>``."
msgstr ""

# bacb14afaf444702a3df1450cacf81dd
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:21
msgid ""
"See also :ref:`-authenticateOAuth2PF-java-` if the authorization operation "
"is rather quick, and does not have to execute asynchronously."
msgstr ""

# b1e39d41331b46e18b3b879069fe1025
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.rst:33
msgid ""
"Usage in code is exactly the same as :ref:`-authenticateBasicPFAsync-java-`,"
" with the difference that one must validate the token as OAuth2 dictates "
"(which is currently not part of Akka HTTP itself)."
msgstr ""

# 5928a0f06ab4468cafff59fe63bcaa91
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.rst:4
msgid "authenticateOrRejectWithChallenge"
msgstr ""

# ebe4896b254c45678540141c2746549b
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.rst:5
msgid "Lifts an authenticator function into a directive."
msgstr ""

# fadaedbdcfd244e1baeea4cfe6140058
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.rst:9
msgid ""
"This directive allows implementing the low level challange-response type of "
"authentication that some services may require."
msgstr ""

# e8c37199647a44bdbe4e7fefe988edb9
#: ../../java/http/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.rst:11
msgid ""
"More details about challenge-response authentication are available in the "
"`RFC 2617`_, `RFC 7616`_ and `RFC 7617`_."
msgstr ""

# 2a36de81fd124103b8c829d7f32d6d7d
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:4
msgid "authorize"
msgstr ""

# 74f18f44289a4612af8704c4be763132
# 3fcc95d22def4890bf4bfa94d4ce5e12
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:5
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:5
msgid "Applies the given authorization check to the request."
msgstr ""

# 53e22a28d31f4d8587d5717359d64268
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:9
msgid ""
"The user-defined authorization check can either be supplied as a ``=> "
"Boolean`` value which is calculated just from information out of the lexical"
" scope, or as a function ``RequestContext => Boolean`` which can also take "
"information from the request itself into account."
msgstr ""

# f6356abdece14b2f89213e057d9631aa
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:13
msgid ""
"If the check returns ``true`` the request is passed on to the inner route "
"unchanged, otherwise an ``AuthorizationFailedRejection`` is created, "
"triggering a ``403 Forbidden`` response by default (the same as in the case "
"of an ``AuthenticationFailedRejection``)."
msgstr ""

# 2aab4b0c34b1415e894bb6b6f96a19cd
# 9c8259a45e6b4dc29edcff5306193f5c
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:17
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:18
msgid ""
"In a common use-case you would check if a user (e.g. supplied by any of the "
"``authenticate*`` family of directives, e.g. :ref:`-authenticateBasic-"
"java-`) is allowed to access the inner routes, e.g. by checking if the user "
"has the needed permissions."
msgstr ""

# 5c4fd561c7404369977c30fdd0b702d2
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:20
msgid ""
"See also :ref:`-authorize-java-` for the asynchronous version of this "
"directive."
msgstr ""

# e0d44b21881d44ffa794277ada8ed28f
# 32831513cf6348f6b53a5ecbccf5cf6a
#: ../../java/http/routing-dsl/directives/security-directives/authorize.rst:23
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:24
msgid ""
"See also :ref:`authentication-vs-authorization-java` to understand the "
"differences between those."
msgstr ""

# e7badd9d80bd4c86b7141c2581654263
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:4
msgid "authorizeAsync"
msgstr ""

# 04231f27fe914851bac314071bc32dfa
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:10
msgid ""
"The user-defined authorization check can either be supplied as a ``=> "
"Future[Boolean]`` value which is calculated just from information out of the"
" lexical scope, or as a function ``RequestContext => Future[Boolean]`` which"
" can also take information from the request itself into account."
msgstr ""

# dd685bc98f5e4b739ec50f72d1c7a5da
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:14
msgid ""
"If the check returns ``true`` or the ``Future`` is failed the request is "
"passed on to the inner route unchanged, otherwise an "
"``AuthorizationFailedRejection`` is created, triggering a ``403 Forbidden`` "
"response by default (the same as in the case of an "
"``AuthenticationFailedRejection``)."
msgstr ""

# 8cbfe497d0b14c72aea5e3464beace53
#: ../../java/http/routing-dsl/directives/security-directives/authorizeAsync.rst:21
msgid ""
"See also :ref:`-authorize-java-` for the synchronous version of this "
"directive."
msgstr ""

# ba5daf833c414343b2a2eb90721989ae
#: ../../java/http/routing-dsl/directives/security-directives/extractCredentials.rst:4
msgid "extractCredentials"
msgstr ""

# 736cc0bafc97462588a687bf9fafde5a
#: ../../java/http/routing-dsl/directives/security-directives/extractCredentials.rst:9
msgid ""
"Extracts the potentially present ``HttpCredentials`` provided with the "
"request's ``Authorization`` header, which can be then used to implement some"
" custom authentication or authorization logic."
msgstr ""

# 2c6f739e3c0e4f8c8b4ef28b11598212
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:4
msgid "SecurityDirectives"
msgstr ""

# ee8a35a7036340db837cfcd00c150e08
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:27
msgid "Authentication vs. Authorization"
msgstr ""

# 17751e84f6f2453dbc103decbaa8c27e
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:29
msgid ""
"**Authentication** is the process of establishing a known identity for the "
"user, whereby 'identity' is defined in the context of the application. This "
"may be done with a username/password combination, a cookie, a pre-defined IP"
" or some other mechanism. After authentication the system believes that it "
"knows who the user is."
msgstr ""

# a6d970d2577f4d0e98eba09976b759da
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:33
msgid ""
"**Authorization** is the process of determining, whether a given user is "
"allowed access to a given resource or not. In most cases, in order to be "
"able to authorize a user (i.e. allow access to some part of the system) the "
"users identity must already have been established, i.e. he/she must have "
"been authenticated. Without prior authentication the authorization would "
"have to be very crude, e.g. \"allow access for *all* users\" or \"allow "
"access for *noone*\". Only after authentication will it be possible to, "
"e.g., \"allow access to the statistics resource for *admins*, but not for "
"regular *members*\"."
msgstr ""

# 3ed77362213045bf80efb448a1af934d
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:40
msgid ""
"Authentication and authorization may happen at the same time, e.g. when "
"everyone who can properly be authenticated is also allowed access (which is "
"often a very simple and somewhat implicit authorization logic). In other "
"cases the system might have one mechanism for authentication (e.g. "
"establishing user identity via an LDAP lookup) and another one for "
"authorization (e.g. a database lookup for retrieving user access rights)."
msgstr ""

# d44f7f7a8bc44541b0dd362ed547d1a5
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:47
msgid "Authentication and Authorization in HTTP"
msgstr ""

# 140db8fef072437d8bfe5634b6bf33d0
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:49
msgid ""
"HTTP provides a general framework for access control and authentication, via"
" an extensible set of challenge-response authentication schemes, which can "
"be used by a server to challenge a client request and by a client to provide"
" authentication information. The general mechanism is defined in `RFC "
"7235`_."
msgstr ""

# f17ee55bb3564c2b95bfd66df05376c5
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:53
msgid ""
"The \"HTTP Authentication Scheme Registry\" defines the namespace for the "
"authentication schemes in challenges and credentials. You can see the "
"currently registered schemes at http://www.iana.org/assignments/http-"
"authschemes."
msgstr ""

# 87911b8e42d44ecfae22692ce260c3ce
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:56
msgid ""
"At this point Akka HTTP only implements the \"'Basic' HTTP Authentication "
"Scheme\" whose most current specification can be found here: "
"https://datatracker.ietf.org/doc/draft-ietf-httpauth-basicauth-update/."
msgstr ""

# e56eac482b74427c9fa94879590941e3
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:62
msgid "Low-level OAuth2 \"Bearer Token\" directives"
msgstr ""

# 329d122cbcb84695b0599d4b87b6f493
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:63
msgid ""
"The OAuth2 directives currently provided in Akka HTTP are not a full OAuth2 "
"protocol implementation, they are only a means of extracting the so called "
"``Bearer Token`` from the ``Authorization`` HTTP Header, as defined in `RFC "
"6750`_, and allow users to validate and complete the protocol."
msgstr ""

# 4cb6b6a8316c469bb5ff74502ca31850
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:73
msgid "Credentials and password timing attacks"
msgstr ""

# fcd9d8f1fffd4757a83d81228d119d04
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:75
msgid ""
"When transforming request ``Credentials`` into an application specific user "
"identifier the naive solution for checking the secret (password) would be a "
"regular string comparison, but doing this would open up the application to "
"timing attacks. See for example `Timing Attacks Explained`_ for an "
"explanation of the problem."
msgstr ""

# fb3d0a5c1ec642ea852ba4dc71d49243
#: ../../java/http/routing-dsl/directives/security-directives/index.rst:81
msgid ""
"To protect users of the library from that mistake the secret is not "
"available through the API, instead the method "
"``Credentials.Provided.verify(String)`` should be used. It does a constant "
"time comparison rather than returning early upon finding the first non-equal"
" character."
msgstr ""

# 0fdbec546b184c2b96a0232f797f1282
#: ../../java/http/routing-dsl/directives/timeout-directives/index.rst:4
msgid "TimeoutDirectives"
msgstr ""

# 27f43658daed4e3c808f5fb7f4ff1d55
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:4
msgid "withRequestTimeout"
msgstr ""

# 4d93e1421bbe4428b13cd46973d108af
# 9257d948a1cf446bbadf9360c29bc9fa
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:9
#: ../../java/http/routing-dsl/directives/timeout-directives/withoutRequestTimeout.rst:9
msgid ""
"This directive enables \"late\" (during request processing) control over the"
" :ref:`request-timeout-java` feature in Akka HTTP."
msgstr ""

# f8969f9998a64935aa5d4e8d89324434
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:11
msgid ""
"The timeout can be either loosened or made more tight using this directive, "
"however one should be aware that it is inherently racy (which may especially"
" show with very tight timeouts) since a timeout may already have been "
"triggered when this directive executes."
msgstr ""

# 816d03710b4f4c8cb33fd0f5306c3c9f
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:15
msgid ""
"In case of pipelined HTTP requests (multiple requests being accepted on the "
"same connection before sending the first response) a the request timeout "
"failure of the ``n-th`` request *will shut down the connection* causing the "
"already enqueued requests to be dropped. This is by-design, as the request "
"timeout feature serves as a \"safety net\" in case of programming errors "
"(e.g. a Future that never completes thus potentially blocking the entire "
"connection forever) or malicious attacks on the server."
msgstr ""

# 621a7af56013427a82d0de63a56a4e63
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:20
msgid ""
"Optionally, a timeout handler may be provided in which is called when a "
"time-out is triggered and must produce an ``HttpResponse`` that will be sent"
" back to the client instead of the \"too late\" response (in case it'd ever "
"arrive). See also :ref:`-withRequestTimeoutResponse-java-` if only looking "
"to customise the timeout response without changing the timeout itself."
msgstr ""

# eef92a0711ed44acaacd9be70082dbb5
# cf5f2d8c9975419b8694d608053713e0
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:25
#: ../../java/http/routing-dsl/directives/timeout-directives/withoutRequestTimeout.rst:15
msgid ""
"Please note that setting the timeout from within a directive is inherently "
"racy (as the \"point in time from which we're measuring the timeout\" is "
"already in the past (the moment we started handling the request), so if the "
"existing timeout already was triggered before your directive had the chance "
"to change it, an timeout may still be logged."
msgstr ""

# cb5652c9bf234ab4854be36e11d84615
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:29
msgid ""
"It is recommended to use a larger statically configured timeout (think of it"
" as a \"safety net\" against programming errors or malicious attackers) and "
"if needed tighten it using the directives – not the other way around."
msgstr ""

# 25fac7803aa1462b8d71b94c95d2ef04
# 0915c9ba892e4c3e937a84ab1a82402f
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:32
#: ../../java/http/routing-dsl/directives/timeout-directives/withoutRequestTimeout.rst:19
msgid ""
"For more information about various timeouts in Akka HTTP see :ref:`http-"
"timeouts-java`."
msgstr ""

# bbba286d443c444dad99984f8fc73e88
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeout.rst:39
msgid "With setting the handler at the same time:"
msgstr ""

# f96a938fe340402f8034b5de47511baf
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.rst:4
msgid "withRequestTimeoutResponse"
msgstr ""

# bc01a46922394534a4e81bb66ae3128a
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.rst:9
msgid ""
"Allows customising the ``HttpResponse`` that will be sent to clients in case"
" of a :ref:`request-timeout-java`."
msgstr ""

# 03cd4b3e3894481b98b3908c3219b9dc
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.rst:11
msgid ""
"See also :ref:`-withRequestTimeout-java-` or :ref:`-withoutRequestTimeout-"
"java-` if interested in dynamically changing the timeout for a given route "
"instead."
msgstr ""

# 7a51a273745744f9b917a81bd6cf4809
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.rst:15
msgid ""
"Please note that setting handler is inherently racy as the timeout is "
"measured from starting to handle the request to its deadline, thus if the "
"timeout triggers before the ``withRequestTimeoutResponse`` executed it would"
" have emitted the default timeout HttpResponse."
msgstr ""

# b53abdda299a4ea69f57b95e807ad86e
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.rst:19
msgid ""
"In practice this can only be a problem with very tight timeouts, so with "
"default settings of request timeouts being measured in seconds it shouldn't "
"be a problem in reality (though certainly a possibility still)."
msgstr ""

# ac43d910d62846b4a0534ec57e3936e0
#: ../../java/http/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.rst:22
msgid ""
"To learn more about various timeouts in Akka HTTP and how to configure them "
"see :ref:`http-timeouts-java`."
msgstr ""

# 5832b8dc60784ba29c27d9829006d6ff
#: ../../java/http/routing-dsl/directives/timeout-directives/withoutRequestTimeout.rst:4
msgid "withoutRequestTimeout"
msgstr ""

# c231c9a223de49e596dde21a81da39dc
#: ../../java/http/routing-dsl/directives/timeout-directives/withoutRequestTimeout.rst:11
msgid ""
"It is not recommended to turn off request timeouts using this method as it "
"is inherently racy and disabling request timeouts basically turns off the "
"safety net against programming mistakes that it provides."
msgstr ""

# 5f5387a6afef4551a8532869fc68534b
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessages.rst:4
msgid "handleWebSocketMessages"
msgstr ""

# ffed24a8bb54416cb6f283f37178279c
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessages.rst:9
msgid ""
"The directive first checks if the request was a valid WebSocket handshake "
"request and if yes, it completes the request with the passed handler. "
"Otherwise, the request is rejected with an "
"``ExpectedWebSocketRequestRejection``."
msgstr ""

# 2fece75ee06e4e5e83d94dca0c014301
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessages.rst:12
msgid ""
"WebSocket subprotocols offered in the ``Sec-WebSocket-Protocol`` header of "
"the request are ignored. If you want to support several protocols use the "
":ref:`-handleWebSocketMessagesForProtocol-java-` directive, instead."
msgstr ""

# d88c2aa0bc9949ada3fda2716a78a60e
# 5bed0ad17214442288606922eb20d094
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessages.rst:15
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.rst:19
msgid ""
"For more information about the WebSocket support, see :ref:`server-side-"
"websocket-support-java`."
msgstr ""

# 766ab7d7e60f46abace0e8211fbe79a4
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.rst:4
msgid "handleWebSocketMessagesForProtocol"
msgstr ""

# 0f431321c48a4a9d87b703248fb0410f
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.rst:8
msgid ""
"Handles WebSocket requests with the given handler if the given subprotocol "
"is offered in the ``Sec-WebSocket-Protocol`` header of the request and "
"rejects other requests with an ``ExpectedWebSocketRequestRejection`` or an "
"``UnsupportedWebSocketSubprotocolRejection``."
msgstr ""

# d78a51713f8d4b32bb6ff0c3c28cbaf0
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.rst:12
msgid ""
"The directive first checks if the request was a valid WebSocket handshake "
"request and if the request offers the passed subprotocol name. If yes, the "
"directive completes the request with the passed handler. Otherwise, the "
"request is either rejected with an ``ExpectedWebSocketRequestRejection`` or "
"an ``UnsupportedWebSocketSubprotocolRejection``."
msgstr ""

# 8e62471bdc264b308c5ec7266c9bb04c
#: ../../java/http/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.rst:16
msgid ""
"To support several subprotocols, for example at the same path, several "
"instances of ``handleWebSocketMessagesForProtocol`` can be chained using "
"``~`` as you can see in the below example."
msgstr ""

# 9c1055e2f6b54d0b8970c7753ce7b52d
#: ../../java/http/routing-dsl/directives/websocket-directives/index.rst:4
msgid "WebSocketDirectives"
msgstr ""

# 215d679a17894151bf307e6cdd6580e8
#: ../../java/http/routing-dsl/exception-handling.rst:4
msgid "Exception Handling"
msgstr ""

# a98470cbac3149ebbd0e060d2ebdbcdf
#: ../../java/http/routing-dsl/exception-handling.rst:6
msgid ""
"Exceptions thrown during route execution bubble up through the route "
"structure to the next enclosing :ref:`-handleExceptions-java-` directive or "
"the top of your route structure."
msgstr ""

# 9284a9ffb831448f8c29d6c274e15117
#: ../../java/http/routing-dsl/exception-handling.rst:9
msgid ""
"Similarly to the way that :ref:`rejections-java` are handled the :ref"
":`-handleExceptions-java-` directive delegates the actual job of converting "
"an exception to its argument, an ``ExceptionHandler``."
msgstr ""

# 63f5e60344c94e118e22378c7321645b
#: ../../java/http/routing-dsl/exception-handling.rst:12
msgid ""
"An ``ExceptionHandler`` is a partial function, so it can choose which "
"exceptions it would like to handle and which not. Unhandled exceptions will "
"simply continue to bubble up in the route structure. At the root of the "
"route tree any still unhandled exception will be dealt with by the top-level"
" handler which always handles *all* exceptions."
msgstr ""

# 6939fe92f405490297f4331b35ee9adf
#: ../../java/http/routing-dsl/exception-handling.rst:17
msgid ""
"``Route.seal`` internally wraps its argument route with the :ref"
":`-handleExceptions-java-` directive in order to \"catch\" and handle any "
"exception."
msgstr ""

# 6a46e1079dd348b5836a31b94a439ace
#: ../../java/http/routing-dsl/exception-handling.rst:20
msgid ""
"So, if you'd like to customize the way certain exceptions are handled you "
"need to write a custom ``ExceptionHandler``. Once you have defined your "
"custom ``ExceptionHandler`` you can supply it as argument to the :ref"
":`-handleExceptions-java-` directive. That will apply your handler to the "
"inner route given to that directive."
msgstr ""

# 665dfa74aad34a3597aa2a6d60897eb1
#: ../../java/http/routing-dsl/exception-handling.rst:24
msgid ""
"Here is an example for wiring up a custom handler via :ref"
":`-handleExceptions-java-`:"
msgstr ""

# 1b31b913409343f5912dc1ed3140adfc
#: ../../java/http/routing-dsl/exception-handling.rst:26
msgid "TODO"
msgstr ""

# 42ad3750e97745849955dbb97b8e5294
#: ../../java/http/routing-dsl/index.rst:4
msgid "High-level Server-Side API"
msgstr ""

# 2862dc8312fb412391147b072a478198
#: ../../java/http/routing-dsl/index.rst:6
msgid ""
"In addition to the :ref:`http-low-level-server-side-api-java` Akka HTTP "
"provides a very flexible \"Routing DSL\" for elegantly defining RESTful web "
"services. It picks up where the low-level API leaves off and offers much of "
"the higher-level functionality of typical web servers or frameworks, like "
"deconstruction of URIs, content negotiation or static content serving."
msgstr ""

# e9602ca46fb94f29bab2250ef08ff127
#: ../../java/http/routing-dsl/index.rst:11
msgid ""
"To use the high-level API you need to add a dependency to the ``akka-http-"
"experimental`` module."
msgstr ""

# 38df730908704afe83d235ac4e350d06
#: ../../java/http/routing-dsl/index.rst:26
msgid "Handling HTTP Server failures in the High-Level API"
msgstr ""

# d09356d4fb8e4b8f8f27739dacfed097
# 555283ff61e84809a569c9072a3dc7a1
#: ../../java/http/routing-dsl/index.rst:27
#: ../../java/http/server-side/low-level-server-side-api.rst:187
msgid ""
"There are various situations when failure may occur while initialising or "
"running an Akka HTTP server. Akka by default will log all these failures, "
"however sometimes one may want to react to failures in addition to them just"
" being logged, for example by shutting down the actor system, or notifying "
"some external monitoring end-point explicitly."
msgstr ""

# 04b8888de1e249be8436b13b47b74cf6
#: ../../java/http/routing-dsl/index.rst:33
msgid "Bind failures"
msgstr ""

# ff38017b361c4f05868e2c7af177b341
#: ../../java/http/routing-dsl/index.rst:34
msgid ""
"For example the server might be unable to bind to the given port. For "
"example when the port is already taken by another application, or if the "
"port is privileged (i.e. only usable by ``root``). In this case the "
"\"binding future\" will fail immediately, and we can react to if by "
"listening on the CompletionStage's completion:"
msgstr ""

# 7ea88e0541a94c7ead5403687291c5fa
#: ../../java/http/routing-dsl/index.rst:43
msgid ""
"For a more low-level overview of the kinds of failures that can happen and "
"also more fine-grained control over them refer to the :ref:`handling-http-"
"server-failures-low-level-java` documentation."
msgstr ""

# 70c41251f3a54b5e87a1efffb8b2e0fe
#: ../../java/http/routing-dsl/index.rst:47
msgid "Failures and exceptions inside the Routing DSL"
msgstr ""

# 8ce5121bd54b4b0987ae39d3a24e3eec
#: ../../java/http/routing-dsl/index.rst:49
msgid ""
"Exception handling within the Routing DSL is done by providing "
":class:`ExceptionHandler` s which are documented in-depth in the :ref"
":`exception-handling-java` section of the documtnation. You can use them to "
"transform exceptions into :class:`HttpResponse` s with apropriate error "
"codes and human-readable failure descriptions."
msgstr ""

# e590da0fecb24597b8fc549c608a4eee
#: ../../java/http/routing-dsl/index.rst:54
msgid "File uploads"
msgstr ""

# 43d347682f114914af43e2fbb1abc35d
#: ../../java/http/routing-dsl/index.rst:56
msgid ""
"For high level directives to handle uploads see the :ref"
":`FileUploadDirectives-java`."
msgstr ""

# 492e29ec0cff48fc9e9b681b8e7dc659
#: ../../java/http/routing-dsl/index.rst:58
msgid ""
"Handling a simple file upload from for example a browser form with a `file` "
"input can be done by accepting a `Multipart.FormData` entity, note that the "
"body parts are `Source` rather than all available right away, and so is the "
"individual body part payload so you will need to consume those streams both "
"for the file and for the form fields."
msgstr ""

# e0db02d2103845abbd1456f5290a5068
#: ../../java/http/routing-dsl/index.rst:63
msgid ""
"Here is a simple example which just dumps the uploaded file into a temporary"
" file on disk, collects some form fields and saves an entry to a fictive "
"database:"
msgstr ""

# 192b379805ff49dcb5f4b357807f30dd
#: ../../java/http/routing-dsl/index.rst:66
msgid "TODO missing example 1"
msgstr ""

# 685a9aed21d6474080ef87d49d6d475a
#: ../../java/http/routing-dsl/index.rst:68
msgid ""
"You can transform the uploaded files as they arrive rather than storing then"
" in a temporary file as in the previous example. In this example we accept "
"any number of ``.csv`` files, parse those into lines and split each line "
"before we send it to an actor for further processing:"
msgstr ""

# 041a984568fd4b5194c91343c9a7a1b8
#: ../../java/http/routing-dsl/index.rst:72
msgid "TODO missing example 2"
msgstr ""

# 28f5853f40f2427ab06167daece73cf7
#: ../../java/http/routing-dsl/marshalling.rst:4
msgid "Marshalling & Unmarshalling"
msgstr ""

# bf5347c858ef4a6aa9095b6c48804cdd
#: ../../java/http/routing-dsl/marshalling.rst:6
msgid ""
"\"Marshalling\" is the process of converting a higher-level (object) "
"structure into some kind of lower-level representation (and vice versa), "
"often a binary wire format. Other popular names for it are \"Serialization\""
" or \"Pickling\"."
msgstr ""

# fdd2669d465b488985d6aa6c7c52e57a
#: ../../java/http/routing-dsl/marshalling.rst:10
msgid ""
"In akka-http \"Marshalling\" means the conversion of an object of type T "
"into an HttpEntity, which forms the entity body of an HTTP request or "
"response (depending on whether used on the client or server side)."
msgstr ""

# b60ae907b42e42e99e53fce13bc7f285
#: ../../java/http/routing-dsl/marshalling.rst:16
msgid ""
"On the server-side marshalling is used to convert an application-domain "
"object to a response (entity). Requests can contain an ``Accept`` header "
"that lists acceptable content types for the client. A marshaller contains "
"the logic to negotiate the result content types based on the ``Accept`` and "
"the ``AcceptCharset`` headers."
msgstr ""

# a9c6d81cf559434e9c8abca98c08e208
#: ../../java/http/routing-dsl/marshalling.rst:20
msgid ""
"Marshallers can be specified when completing a request with "
"``RequestContext.complete`` or by using one of the "
"``RouteDirectives.complete`` directives."
msgstr ""

# a923690556854b2fa684d90e89ed712f
#: ../../java/http/routing-dsl/marshalling.rst:23
msgid "These marshallers are provided by akka-http:"
msgstr ""

# 8a4365402d964251a57ebf547afe12dd
#: ../../java/http/routing-dsl/marshalling.rst:25
msgid ""
"Use :ref:`json-jackson-support-java` to create an marshaller that can "
"convert a POJO to an ``application/json`` response using jackson_."
msgstr ""

# 5f244dae95a54559afa3b8e0a58732e8
#: ../../java/http/routing-dsl/marshalling.rst:27
msgid ""
"Use ``Marshaller.stringToEntity``, ``Marshaller.byteArrayToEntity``, "
"``Marshaller.byteStringToEntity``, combined with "
"``Marshaller.entityToResponse`` to create custom marshallers."
msgstr ""

# 500046a729ae4f00b6d83bd5b47ac341
#: ../../java/http/routing-dsl/marshalling.rst:33
msgid ""
"On the server-side unmarshalling is used to convert a request (entity) to an"
" application-domain object. This is done in the "
"``MarshallingDirectives.request`` or ``MarshallingDirectives.entity`` "
"directive. There are several unmarshallers provided by akka-http:"
msgstr ""

# a3015c80e48b41c084ee6fd2f2cdfae8
#: ../../java/http/routing-dsl/marshalling.rst:37
msgid ""
"Use :ref:`json-jackson-support-java` to create an unmarshaller that can "
"convert an ``application/json`` request to a POJO using jackson_."
msgstr ""

# de46255f796842d2922e6e9ab5db7c7d
#: ../../java/http/routing-dsl/marshalling.rst:39
msgid ""
"Use the predefined ``Unmarshaller.entityToString``, "
"``Unmarshaller.entityToByteString``, ``Unmarshaller.entityToByteArray``, "
"``Unmarshaller.entityToCharArray`` to convert to those basic types."
msgstr ""

# 758058723e3a41f78b5025f77b3fa3e7
#: ../../java/http/routing-dsl/marshalling.rst:41
msgid ""
"Use ``Unmarshaller.sync`` or ``Unmarshaller.async`` to create a custom "
"unmarshaller."
msgstr ""

# b8f606be9c794c4a9b6e6a5a0d16a55f
#: ../../java/http/routing-dsl/overview.rst:4
msgid "Routing DSL Overview"
msgstr ""

# 45d0ec2cd2ac4b5f9097b394eec5c1b1
#: ../../java/http/routing-dsl/overview.rst:6
msgid ""
"The Akka HTTP :ref:`http-low-level-server-side-api-java` provides a "
"``Flow``- or ``Function``-level interface that allows an application to "
"respond to incoming HTTP requests by simply mapping requests to responses "
"(excerpt from :ref:`Low-level server side example <http-low-level-server-"
"side-example-java>`):"
msgstr ""

# 6cf68dc045d54982801d6e388f7e9a3d
#: ../../java/http/routing-dsl/overview.rst:13
msgid ""
"While it'd be perfectly possible to define a complete REST API service "
"purely by inspecting the incoming ``HttpRequest`` this approach becomes "
"somewhat unwieldy for larger services due to the amount of syntax "
"\"ceremony\" required. Also, it doesn't help in keeping your service "
"definition as DRY_ as you might like."
msgstr ""

# 978f3ccdfe674419a00a118acc8e7638
#: ../../java/http/routing-dsl/overview.rst:17
msgid ""
"As an alternative Akka HTTP provides a flexible DSL for expressing your "
"service behavior as a structure of composable elements (called :ref"
":`directives-java`) in a concise and readable way. Directives are assembled "
"into a so called *route structure* which, at its top-level, can be used to "
"create a handler ``Flow`` (or, alternatively, an async handler function) "
"that can be directly supplied to a ``bind`` call."
msgstr ""

# 00771e8600ec453cad9bf0a23d8a6ad7
#: ../../java/http/routing-dsl/overview.rst:22
msgid ""
"Here's the complete example rewritten using the composable high-level API:"
msgstr ""

# 40fbd0804f24492bb0757d8d53000392
#: ../../java/http/routing-dsl/overview.rst:27
msgid "The core of the Routing DSL becomes available with a single import::"
msgstr ""

# 19b88788346d4ee4bd68ef52f8a4f8d2
#: ../../java/http/routing-dsl/overview.rst:31
msgid ""
"Or by extending the ``akka.http.javadsl.server.AllDirectives`` class which "
"brings together all directives into a single class for easier access::"
msgstr ""

# 5394c08d12ef40ccbc147444411d7487
#: ../../java/http/routing-dsl/overview.rst:36
msgid ""
"Of course it is possible to directly import only the directives you need "
"(i.e. ``WebSocketDirectives`` etc)."
msgstr ""

# ac41abbf92794964a0ada4f915179592
#: ../../java/http/routing-dsl/rejections.rst:4
msgid "Rejections"
msgstr ""

# 571640ee37e24defaf901b0d7c897f1c
#: ../../java/http/routing-dsl/rejections.rst:5
msgid "TODO update to Java APIs"
msgstr ""

# c3a2591a1342410ba0b2151e0160b514
#: ../../java/http/routing-dsl/rejections.rst:7
msgid ""
"In the chapter about constructing :ref:`Routes` the ``~`` operator was "
"introduced, which connects two routes in a way that allows a second route to"
" get a go at a request if the first route \"rejected\" it. The concept of "
"\"rejections\" is used by Akka HTTP for maintaining a more functional "
"overall architecture and in order to be able to properly handle all kinds of"
" error scenarios."
msgstr ""

# 0d40a69077dd4db1a24ae57df70354a1
#: ../../java/http/routing-dsl/rejections.rst:12
msgid ""
"When a filtering directive, like the :ref:`-get-` directive, cannot let the "
"request pass through to its inner route because the filter condition is not "
"satisfied (e.g. because the incoming request is not a GET request) the "
"directive doesn't immediately complete the request with an error response. "
"Doing so would make it impossible for other routes chained in after the "
"failing filter to get a chance to handle the request. Rather, failing "
"filters \"reject\" the request in the same way as by explicitly calling "
"``requestContext.reject(...)``."
msgstr ""

# f74d658e8cec44f38fa9319745d6718b
#: ../../java/http/routing-dsl/rejections.rst:18
msgid ""
"After having been rejected by a route the request will continue to flow "
"through the routing structure and possibly find another route that can "
"complete it. If there are more rejections all of them will be picked up and "
"collected."
msgstr ""

# 8f9c639ae9134b538cd66122db4aeecb
#: ../../java/http/routing-dsl/rejections.rst:21
msgid ""
"If the request cannot be completed by (a branch of) the route structure an "
"enclosing :ref:`-handleRejections-java-` directive can be used to convert a "
"set of rejections into an ``HttpResponse`` (which, in most cases, will be an"
" error response). ``Route.seal`` internally wraps its argument route with "
"the :ref:`-handleRejections-java-` directive in order to \"catch\" and "
"handle any rejection."
msgstr ""

# 86d6d53920cd4cae88fa0797e2e0520e
#: ../../java/http/routing-dsl/rejections.rst:28
msgid "Predefined Rejections"
msgstr ""

# f5696e36a53b41f0a2844686581097bc
#: ../../java/http/routing-dsl/rejections.rst:30
msgid ""
"A rejection encapsulates a specific reason why a route was not able to "
"handle a request. It is modeled as an object of type ``Rejection``. Akka "
"HTTP comes with a set of `predefined rejections`__, which are used by the "
"many :ref:`predefined directives <Predefined Directives-java>`."
msgstr ""

# 5fe8c9b89e524746a0c25f89fddd7400
#: ../../java/http/routing-dsl/rejections.rst:34
msgid ""
"Rejections are gathered up over the course of a Route evaluation and finally"
" converted to ``HttpResponse`` replies by the :ref:`-handleRejections-` "
"directive if there was no way for the request to be completed."
msgstr ""

# 41f6823d0ff24023bb490078e85f7b27
#: ../../java/http/routing-dsl/rejections.rst:43
msgid "The RejectionHandler"
msgstr ""

# 1777177d1a8546149104b09091ab9390
#: ../../java/http/routing-dsl/rejections.rst:45
msgid ""
"The :ref:`-handleRejections-` directive delegates the actual job of "
"converting a list of rejections to its argument, a RejectionHandler__, which"
" is defined like this::"
msgstr ""

# 3679d6ae052c416cad1ec4136844c596
#: ../../java/http/routing-dsl/rejections.rst:52
msgid ""
"Since a ``RejectionHandler`` returns an ``Option[Route]`` it can choose "
"whether it would like to handle the current set of rejections or not. If it "
"returns ``None`` the rejections will simply continue to flow through the "
"route structure."
msgstr ""

# 796860217e3d4c03901313ee1aa6bae5
#: ../../java/http/routing-dsl/rejections.rst:55
msgid ""
"The default ``RejectionHandler`` applied by the top-level glue code that "
"turns a ``Route`` into a ``Flow`` or async handler function for the :ref"
":`low-level API <http-low-level-server-side-api>` (via ``Route.handlerFlow``"
" or ``Route.asyncHandler``) will handle *all* rejections that reach it."
msgstr ""

# c571cbc725ae4abd924a0fa8c6f534be
#: ../../java/http/routing-dsl/rejections.rst:61
msgid "Rejection Cancellation"
msgstr ""

# c9c41061e351481ea2b6e4d0a08a952a
#: ../../java/http/routing-dsl/rejections.rst:63
msgid ""
"As you can see from its definition above the ``RejectionHandler`` doesn't "
"handle single rejections but a whole list of them. This is because some "
"route structure produce several \"reasons\" why a request could not be "
"handled."
msgstr ""

# c0f41b011c184d34b15d527fcd7fb5d5
#: ../../java/http/routing-dsl/rejections.rst:66
msgid "Take this route structure for example:"
msgstr ""

# 4fb179efc95146d9aa67bd7640df06cb
# 7755e900b484428792b9772298023930
#: ../../java/http/routing-dsl/rejections.rst:68
#: ../../java/http/routing-dsl/rejections.rst:104
msgid "TODO missing sample"
msgstr ""

# 211be215a4354c2da532d9b5de766e33
#: ../../java/http/routing-dsl/rejections.rst:70
msgid ""
"For uncompressed POST requests this route structure would initially yield "
"two rejections:"
msgstr ""

# 57fcdab39b894c8cbc27051aa56a142c
#: ../../java/http/routing-dsl/rejections.rst:72
msgid ""
"a ``MethodRejection`` produced by the :ref:`-get-` directive (which rejected"
" because the request is not a GET request)"
msgstr ""

# 49f4268513b341a8a173c767460cf135
#: ../../java/http/routing-dsl/rejections.rst:73
msgid ""
"an ``UnsupportedRequestEncodingRejection`` produced by the "
":ref:`-decodeRequestWith-` directive (which only accepts gzip-compressed "
"requests here)"
msgstr ""

# 30275ef2f4b04782be7b9b290de9fe42
#: ../../java/http/routing-dsl/rejections.rst:76
msgid ""
"In reality the route even generates one more rejection, a "
"``TransformationRejection`` produced by the :ref:`-post-` directive. It "
"\"cancels\" all other potentially existing *MethodRejections*, since they "
"are invalid after the :ref:`-post-` directive allowed the request to pass "
"(after all, the route structure *can* deal with POST requests). These types "
"of rejection cancellations are resolved *before* a ``RejectionHandler`` sees"
" the rejection list. So, for the example above the ``RejectionHandler`` will"
" be presented with only a single-element rejection list, containing nothing "
"but the ``UnsupportedRequestEncodingRejection``."
msgstr ""

# 22f205e883304561a74252c59c860872
#: ../../java/http/routing-dsl/rejections.rst:87
msgid "Empty Rejections"
msgstr ""

# 1c1a25688fa94097a8552b630a6b47c5
#: ../../java/http/routing-dsl/rejections.rst:89
msgid ""
"Since rejections are passed around in a list (or rather immutable ``Seq``) "
"you might ask yourself what the semantics of an empty rejection list are. In"
" fact, empty rejection lists have well defined semantics. They signal that a"
" request was not handled because the respective resource could not be found."
" Akka HTTP reserves the special status of \"empty rejection\" to this most "
"common failure a service is likely to produce."
msgstr ""

# c77051d007b746e389a70c956b0d00fa
#: ../../java/http/routing-dsl/rejections.rst:94
msgid ""
"So, for example, if the :ref:`-path-` directive rejects a request it does so"
" with an empty rejection list. The :ref:`-host-` directive behaves in the "
"same way."
msgstr ""

# 20dde7c4b3d041a2a0d9ef0591c49210
#: ../../java/http/routing-dsl/rejections.rst:99
msgid "Customizing Rejection Handling"
msgstr ""

# 7aafa0ac392c466d8f4dfca8506243fd
#: ../../java/http/routing-dsl/rejections.rst:101
msgid ""
"If you'd like to customize the way certain rejections are handled you'll "
"have to write a custom :ref:`RejectionHandler <The RejectionHandler>`. Here "
"is an example:"
msgstr ""

# 9219d28ad9994180ae8cb68ebcdd1339
#: ../../java/http/routing-dsl/rejections.rst:106
msgid ""
"The easiest way to construct a ``RejectionHandler`` is via the "
"``RejectionHandler.Builder`` that Akka HTTP provides. After having created a"
" new ``Builder`` instance with ``RejectionHandler.newBuilder()`` you can "
"attach handling logic for certain types of rejections through three helper "
"methods:"
msgstr ""

# 53785653d8904f6fa598edbb460c23f3
#: ../../java/http/routing-dsl/rejections.rst:111
msgid ""
"Handles certain rejections with the given partial function. The partial "
"function simply produces a ``Route`` which is run when the rejection is "
"\"caught\". This makes the full power of the Routing DSL available for "
"defining rejection handlers and even allows for recursing back into the main"
" route structure if required."
msgstr ""

# feab1f2726d64948bf47885e359d7a15
#: ../../java/http/routing-dsl/rejections.rst:116
msgid ""
"Handles all rejections of a certain type at the same time. This is useful "
"for cases where your need access to more than the first rejection of a "
"certain type, e.g. for producing the error message to an unsupported request"
" method."
msgstr ""

# 79d77edca2364014833f2ca1b33a98e8
#: ../../java/http/routing-dsl/rejections.rst:120
msgid ""
"As described :ref:`above <Empty Rejections>` \"Resource Not Found\" is "
"special as it is represented with an empty rejection set. The "
"``handleNotFound`` helper let's you specify the \"recovery route\" for this "
"case."
msgstr ""

# 578b78bf8f62423688a6f61e05103212
#: ../../java/http/routing-dsl/rejections.rst:123
msgid ""
"Even though you could handle several different rejection types in a single "
"partial function supplied to ``handle`` it is recommended to split these up "
"into distinct ``handle`` attachments instead. This way the priority between "
"rejections is properly defined via the order of your ``handle`` clauses "
"rather than the (sometimes hard to predict or control) order of rejections "
"in the rejection set."
msgstr ""

# 67b77c01f79c48af9e2147c5e1712049
#: ../../java/http/routing-dsl/rejections.rst:128
msgid ""
"Once you have defined your custom ``RejectionHandler`` you have two options "
"for \"activating\" it:"
msgstr ""

# 46f683e3bbe346a29d8b61df3eaeb1ab
#: ../../java/http/routing-dsl/rejections.rst:130
msgid "Bring it into implicit scope at the top-level."
msgstr ""

# c9985c42c77747bd8bc5e201facb8254
#: ../../java/http/routing-dsl/rejections.rst:131
msgid "Supply it as argument to the :ref:`-handleRejections-` directive."
msgstr ""

# 0743478adc1445268257d5820f1346c3
#: ../../java/http/routing-dsl/rejections.rst:133
msgid ""
"In the first case your handler will be \"sealed\" (which means that it will "
"receive the default handler as a fallback for all cases your handler doesn't"
" handle itself) and used for all rejections that are not handled within the "
"route structure itself."
msgstr ""

# 41efd26da3554f168d5eed982290a9de
#: ../../java/http/routing-dsl/rejections.rst:137
msgid ""
"The second case allows you to restrict the applicability of your handler to "
"certain branches of your route structure."
msgstr ""

# dd569c3cc00d45538f5632654373459f
#: ../../java/http/routing-dsl/routes.rst:4
msgid "Routes"
msgstr ""

# 02d3b20292b04e56b3337c83eb6198bd
#: ../../java/http/routing-dsl/routes.rst:6
msgid ""
"The \"Route\" is the central concept of Akka HTTP's Routing DSL. All the "
"structures you build with the DSL, no matter whether they consists of a "
"single line or span several hundred lines, are functions turning a "
"``RequestContext`` into a ``CompletionStage<RouteResult>``."
msgstr ""

# 3a2f1d5630e64b7ba6337920022216cb
#: ../../java/http/routing-dsl/routes.rst:10
msgid ""
"A ``Route`` itself is a function that operates on a ``RequestContext`` and "
"returns a ``RouteResult``. The ``RequestContext`` is a data structure that "
"contains the current request and auxiliary data like the so far unmatched "
"path of the request URI that gets passed through the route structure. It "
"also contains the current ``ExecutionContext`` and "
"``akka.stream.Materializer``, so that these don't have to be passed around "
"manually."
msgstr ""

# 320721efa149458982c96da1a43f1689
#: ../../java/http/routing-dsl/routes.rst:15
msgid ""
"Generally when a route receives a request (or rather a ``RequestContext`` "
"for it) it can do one of these things:"
msgstr ""

# ffe652e3927f4ee9a92875e08b07bb3f
#: ../../java/http/routing-dsl/routes.rst:17
msgid ""
"Complete the request by returning the value of "
"``requestContext.complete(...)``"
msgstr ""

# 2a5b4c3006144c8788ee72a21bb38369
#: ../../java/http/routing-dsl/routes.rst:18
msgid ""
"Reject the request by returning the value of ``requestContext.reject(...)`` "
"(see :ref:`rejections-java`)"
msgstr ""

# be947399e44a49e4adb29533abf453d3
#: ../../java/http/routing-dsl/routes.rst:19
msgid ""
"Fail the request by returning the value of ``requestContext.fail(...)`` or "
"by just throwing an exception (see :ref:`exception-handling-java`)"
msgstr ""

# f1ab0953e1694b159e2d4fc9ba85ba58
#: ../../java/http/routing-dsl/routes.rst:20
msgid ""
"Do any kind of asynchronous processing and instantly return a "
"``Future[RouteResult]`` to be eventually completed later"
msgstr ""

# 30a96888287f40ae8f58a691351e9ba7
#: ../../java/http/routing-dsl/routes.rst:22
msgid ""
"The first case is pretty clear, by calling ``complete`` a given response is "
"sent to the client as reaction to the request. In the second case \"reject\""
" means that the route does not want to handle the request. You'll see "
"further down in the section about route composition what this is good for."
msgstr ""

# 0f1ef322e4a04aca9275be66e0776112
#: ../../java/http/routing-dsl/routes.rst:26
msgid ""
"A ``Route`` can be \"sealed\" using ``Route.seal``, which relies on the in-"
"scope ``RejectionHandler`` and ``ExceptionHandler`` instances to convert "
"rejections and exceptions into appropriate HTTP responses for the client."
msgstr ""

# b346525817a84f18885e2d523141110b
#: ../../java/http/routing-dsl/routes.rst:29
msgid ""
"Using ``Route.handlerFlow`` or ``Route.asyncHandler`` a ``Route`` can be "
"lifted into a handler ``Flow`` or async handler function to be used with a "
"``bindAndHandleXXX`` call from the :ref:`http-low-level-server-side-api`."
msgstr ""

# 0dc01ba9763644a79d379154cf566f24
#: ../../java/http/routing-dsl/routes.rst:36
msgid "RequestContext"
msgstr ""

# 54d1d3beb7ee4d2889e93148887e869c
#: ../../java/http/routing-dsl/routes.rst:38
msgid ""
"The request context wraps an ``HttpRequest`` instance to enrich it with "
"additional information that are typically required by the routing logic, "
"like an ``ExecutionContext``, ``Materializer``, ``LoggingAdapter`` and the "
"configured ``RoutingSettings``. It also contains the ``unmatchedPath``, a "
"value that describes how much of the request URI has not yet been matched by"
" a :ref:`Path Directive <PathDirectives>`."
msgstr ""

# beeb5bc8cd9f48f18c707b9b4b99ef47
#: ../../java/http/routing-dsl/routes.rst:43
msgid ""
"The ``RequestContext`` itself is immutable but contains several helper "
"methods which allow for convenient creation of modified copies."
msgstr ""

# f280fd408c57452aa074fe9d26cd2afa
#: ../../java/http/routing-dsl/routes.rst:49
msgid "RouteResult"
msgstr ""

# f3933b90fdaf48b3bbbd7ffbd3956d31
#: ../../java/http/routing-dsl/routes.rst:51
msgid ""
"The ``RouteResult`` is an opaque structure that represents possible results "
"of evaluating a route. A ``RouteResult`` can only be created by using one of"
" the methods of the ``RequestContext``. A result can either be a response, "
"if it was generated by one of the ``completeX`` methods, or a rejection that"
" contains information about why the route could not handle the request."
msgstr ""

# 50bc0011472b40e6ba4cde24eddcb33d
#: ../../java/http/routing-dsl/routes.rst:58
msgid "Composing Routes"
msgstr ""

# c8b3500465bb4d96bd5369ab4c9bab4f
#: ../../java/http/routing-dsl/routes.rst:60
msgid "Routes are composed to form the route tree in two principle ways."
msgstr ""

# 7337f391767840e298a8474cc7d968c1
#: ../../java/http/routing-dsl/routes.rst:62
msgid ""
"A route can be wrapped by a \"Directive\" which adds some behavioral aspect "
"to its wrapped \"inner route\". In the Java DSL, a Directive is a method "
"that returns a Route. In many cases, a Directive method will have an inner "
"route argument that is invoked when its semantics decide to do so, e.g. when"
" a URL path is matched."
msgstr ""

# 5becc1f647314e7a9ed858e95edb8206
#: ../../java/http/routing-dsl/routes.rst:66
msgid "Example topics for directives include:"
msgstr ""

# b82e1d07540a4cd28da6753ddb0a3c2f
#: ../../java/http/routing-dsl/routes.rst:68
msgid ""
"filtering requests to decide which requests will get to the inner route"
msgstr ""

# 1cdb818564cd46c3aefce29ac785ae7b
#: ../../java/http/routing-dsl/routes.rst:69
msgid "transforming the request before passing it to the inner route"
msgstr ""

# 417fce79b5464cdf89680e4b036d503a
#: ../../java/http/routing-dsl/routes.rst:70
msgid ""
"transforming the response (or more generally the route result) received from"
" the inner route"
msgstr ""

# 1ad4893efd0f4619b47813d29a187793
#: ../../java/http/routing-dsl/routes.rst:71
msgid ""
"applying side-effects around inner route processing, such as measuring the "
"time taken to run the inner route"
msgstr ""

# 3416663a27b64cd39d53f99765c285de
#: ../../java/http/routing-dsl/routes.rst:73
msgid ""
"The other way of composition is defining a list of ``Route`` alternatives. "
"Alternative routes are tried one after the other until one route \"accepts\""
" the request and provides a response. Otherwise, a route can also \"reject\""
" a request, in which case further alternatives are explored. Alternatives "
"are specified by passing a list of routes to to ``RouteDirectives.route()``."
msgstr ""

# 2908562abf1d46a2b7ed1759f9a3fa92
#: ../../java/http/routing-dsl/routes.rst:81
msgid "The Routing Tree"
msgstr ""

# cafaa8921d504062b7c6dbef23bc9ec9
#: ../../java/http/routing-dsl/routes.rst:83
msgid ""
"Essentially, when you combine routes via nesting and alternative, you build "
"a routing structure that forms a tree. When a request comes in it is "
"injected into this tree at the root and flows down through all the branches "
"in a depth-first manner until either some node completes it or it is fully "
"rejected."
msgstr ""

# a5d42dabbefe4ab4bb5a67fa8bda1c55
#: ../../java/http/routing-dsl/routes.rst:87
msgid ""
"Consider this schematic example. In place of directiveA, directiveB, etc., "
"you can just imagine any of the available directives, e.g. matching a "
"particular path, header or request parameter.::"
msgstr ""

# a8b96974b85f42478c8bc5552a9f5dd5
#: ../../java/http/routing-dsl/routes.rst:108
msgid "Here five directives form a routing tree."
msgstr ""

# ade85fe74a1d48a1beef5ab701857425
#: ../../java/http/routing-dsl/routes.rst:110
msgid ""
"Route 1 will only be reached if directives ``a``, ``b`` and ``c`` all let "
"the request pass through."
msgstr ""

# de58ad791e2641c2bd66ada4ef476686
#: ../../java/http/routing-dsl/routes.rst:111
msgid ""
"Route 2 will run if ``a`` and ``b`` pass, ``c`` rejects and ``d`` passes."
msgstr ""

# 0ad4eaf322d34874a013bf7a8eb77ed5
#: ../../java/http/routing-dsl/routes.rst:112
msgid "Route 3 will run if ``a`` and ``b`` pass, but ``c`` and ``d`` reject."
msgstr ""

# 50d83e08aa6f4a629fac01bd7b9d8769
#: ../../java/http/routing-dsl/routes.rst:114
msgid ""
"Route 3 can therefore be seen as a \"catch-all\" route that only kicks in, "
"if routes chained into preceding positions reject. This mechanism can make "
"complex filtering logic quite easy to implement: simply put the most "
"specific cases up front and the most general cases in the back."
msgstr ""

# 72f6123323cb47a1a0f10315173ef0a7
#: ../../java/http/routing-dsl/source-streaming-support.rst:4
msgid "Source Streaming"
msgstr ""

# 7a93826a6be24403b9ff798e7133014f
#: ../../java/http/routing-dsl/source-streaming-support.rst:6
msgid ""
"Akka HTTP supports completing a request with an Akka ``Source<T, _>``, which"
" makes it possible to easily build and consume streaming end-to-end APIs "
"which apply back-pressure throughout the entire stack."
msgstr ""

# df50ee26d503476f9aa6cef5151862e8
#: ../../java/http/routing-dsl/source-streaming-support.rst:9
msgid ""
"It is possible to complete requests with raw ``Source<ByteString, _>``, "
"however often it is more convenient to stream on an element-by-element "
"basis, and allow Akka HTTP to handle the rendering internally - for example "
"as a JSON array, or CSV stream (where each element is separated by a new-"
"line)."
msgstr ""

# 85849502aa5e49c4a60b687cc2d9232d
#: ../../java/http/routing-dsl/source-streaming-support.rst:13
msgid ""
"In the following sections we investigate how to make use of the JSON "
"Streaming infrastructure, however the general hints apply to any kind of "
"element-by-element streaming you could imagine."
msgstr ""

# 265f6d0b415a45ea9a7c4d4b22756303
#: ../../java/http/routing-dsl/source-streaming-support.rst:17
msgid "JSON Streaming"
msgstr ""

# dfc28e54a92a400aada0ba052f32116d
#: ../../java/http/routing-dsl/source-streaming-support.rst:19
msgid ""
"`JSON Streaming`_ is a term refering to streaming a (possibly infinite) "
"stream of element as independent JSON objects as a continuous HTTP request "
"or response. The elements are most often separated using newlines, however "
"do not have to be. Concatenating elements side-by-side or emitting \"very "
"long\" JSON array is also another use case."
msgstr ""

# b63c30334c9d4531af182d0fde9f0966
#: ../../java/http/routing-dsl/source-streaming-support.rst:24
msgid ""
"In the below examples, we'll be refering to the ``Tweet`` and "
"``Measurement`` case classes as our model, which are defined as:"
msgstr ""

# aead257a53e446f3ae1cf5c31dd864af
#: ../../java/http/routing-dsl/source-streaming-support.rst:31
msgid "Responding with JSON Streams"
msgstr ""

# 61d3252cb258457a8da7958626b85158
#: ../../java/http/routing-dsl/source-streaming-support.rst:33
msgid ""
"In this example we implement an API representing an infinite stream of "
"tweets, very much like Twitter's `Streaming API`_."
msgstr ""

# ba280583f4664f6c9c5dde470d2b536d
#: ../../java/http/routing-dsl/source-streaming-support.rst:35
msgid ""
"Firstly, we'll need to get some additional marshalling infrastructure set "
"up, that is able to marshal to and from an Akka Streams ``Source<T,_>``. "
"Here we'll use the ``Jackson`` helper class from ``akka-http-jackson`` (a "
"separate library that you should add as a dependency if you want to use "
"Jackson with Akka HTTP)."
msgstr ""

# 4e4baa1de5b74267acb5d29defbd109e
#: ../../java/http/routing-dsl/source-streaming-support.rst:39
msgid ""
"First we enable JSON Streaming by making an implicit "
"``EntityStreamingSupport`` instance available (Step 1)."
msgstr ""

# 5219137f59ef4aee98e595be9ba0ca80
#: ../../java/http/routing-dsl/source-streaming-support.rst:41
msgid ""
"The default mode of rendering a ``Source`` is to represent it as an JSON "
"Array. If you want to change this representation for example to use Twitter "
"style new-line separated JSON objects, you can do so by configuring the "
"support trait accordingly."
msgstr ""

# 3575d9e0713a4b1fb643f426376e3d06
#: ../../java/http/routing-dsl/source-streaming-support.rst:44
msgid ""
"In Step 1.1. we demonstrate to configure configude the rendering to be new-"
"line separated, and also how parallel marshalling can be applied. We "
"configure the Support object to render the JSON as series of new-line "
"separated JSON objects, simply by providing the ``start``, ``sep`` and "
"``end`` ByteStrings, which will be emitted at the apropriate places in the "
"rendered stream. Although this format is *not* valid JSON, it is pretty "
"popular since parsing it is relatively simple - clients need only to find "
"the new-lines and apply JSON unmarshalling for an entire line of JSON."
msgstr ""

# b90ebf6c66c8470f8dcdf91bc28b48d6
#: ../../java/http/routing-dsl/source-streaming-support.rst:50
msgid ""
"The final step is simply completing a request using a Source of tweets, as "
"simple as that:"
msgstr ""

# a33f5088470d4c9f9f8162398c357b6d
#: ../../java/http/routing-dsl/source-streaming-support.rst:57
msgid "Consuming JSON Streaming uploads"
msgstr ""

# cb2d153303a3409b97c2d6710a2269e7
#: ../../java/http/routing-dsl/source-streaming-support.rst:59
msgid ""
"Sometimes the client may be sending a streaming request, for example an "
"embedded device initiated a connection with the server and is feeding it "
"with one line of measurement data."
msgstr ""

# 1febfb59de6e4457b719b62636a18fd3
#: ../../java/http/routing-dsl/source-streaming-support.rst:62
msgid ""
"In this example, we want to consume this data in a streaming fashion from "
"the request entity, and also apply back-pressure to the underlying TCP "
"connection, if the server can not cope with the rate of incoming data (back-"
"pressure will be applied automatically thanks to using Akka HTTP/Streams)."
msgstr ""

# e8c96d3b529240c2a9d5aca23a2eec24
#: ../../java/http/routing-dsl/source-streaming-support.rst:72
msgid "Simple CSV streaming example"
msgstr ""

# 022929524c1d4bbb9070f3d490fcce1f
#: ../../java/http/routing-dsl/source-streaming-support.rst:74
msgid ""
"Akka HTTP provides another ``EntityStreamingSupport`` out of the box, namely"
" ``csv`` (comma-separated values). For completeness, we demonstrate its "
"usage in the below snippet. As you'll notice, switching betweeen streaming "
"modes is fairly simple, one only has to make sure that an implicit "
"``Marshaller`` of the requested type is available, and that the streaming "
"support operates on the same ``Content-Type`` as the rendered values. "
"Otherwise you'll see an error during runtime that the marshaller did not "
"expose the expected content type and thus we can not render the streaming "
"response)."
msgstr ""

# 19dbb6dc343841a99fad8df555ebe684
#: ../../java/http/routing-dsl/source-streaming-support.rst:84
msgid "Implementing custom EntityStreamingSupport traits"
msgstr ""

# 9b81828ac4e847e0bd9dc3302dfca4fc
#: ../../java/http/routing-dsl/source-streaming-support.rst:86
msgid ""
"The ``EntityStreamingSupport`` infrastructure is open for extension and not "
"bound to any single format, content type or marshalling library. The "
"provided JSON support does not rely on Spray JSON directly, but uses "
"``Marshaller<T, ByteString>`` instances, which can be provided using any "
"JSON marshalling library (such as Circe, Jawn or Play JSON)."
msgstr ""

# ab18582dc2084bcf888e3b70510ee40c
#: ../../java/http/routing-dsl/source-streaming-support.rst:90
msgid ""
"When implementing a custom support trait, one should simply extend the "
"``EntityStreamingSupport`` abstract class, and implement all of it's "
"methods. It's best to use the existing implementations as a guideline."
msgstr ""

# 4a24a4919d6148a7ba1a144345625ef7
#: ../../java/http/routing-dsl/testkit.rst:4
msgid "Route Testkit"
msgstr ""

# 1e0c30aa9a094f1692047194981f8efe
#: ../../java/http/routing-dsl/testkit.rst:6
msgid ""
"akka-http has a testkit that provides a convenient way of testing your "
"routes with JUnit. It allows running requests against a route (without "
"hitting the network) and provides means to assert against response "
"properties in a compact way."
msgstr ""

# 80344e9836e7442597a73cfcc1c2bb33
#: ../../java/http/routing-dsl/testkit.rst:10
msgid "To use the testkit you need to take these steps:"
msgstr ""

# 545fe0286f69460cadb163c266e847ac
#: ../../java/http/routing-dsl/testkit.rst:12
msgid "add a dependency to the ``akka-http-testkit`` module"
msgstr ""

# 8ce9a671fa7146878c9f4e97e1cb5215
#: ../../java/http/routing-dsl/testkit.rst:13
msgid "derive the test class from ``JUnitRouteTest``"
msgstr ""

# 348b196f534f49edb84a15f42c2ad183
#: ../../java/http/routing-dsl/testkit.rst:14
msgid ""
"wrap the route under test with ``RouteTest.testRoute`` to create a "
"``TestRoute``"
msgstr ""

# e33c57af4c6245c498d13780ee2c5de1
#: ../../java/http/routing-dsl/testkit.rst:15
msgid ""
"run requests against the route using ``TestRoute.run(request)`` which will "
"return a ``TestResponse``"
msgstr ""

# 1695545ffd9447e68865e1d51b6626eb
#: ../../java/http/routing-dsl/testkit.rst:17
msgid ""
"use the methods of ``TestResponse`` to assert on properties of the response"
msgstr ""

# 340519c7e61b4ea690a642f85453c13e
#: ../../java/http/routing-dsl/testkit.rst:22
msgid ""
"To see the testkit in action consider the following simple calculator app "
"service:"
msgstr ""

# a20757038d044032bd7e027741c072eb
#: ../../java/http/routing-dsl/testkit.rst:27
msgid ""
"The app extends from ``HttpApp`` which brings all of the directives into "
"scope. Method ``createRoute`` needs to be implemented to return the complete"
" route of the app."
msgstr ""

# a466195b75b8439a8ecfbf87151c6720
#: ../../java/http/routing-dsl/testkit.rst:30
msgid "Here's how you would test that service:"
msgstr ""

# 7279b6cf683e4a38b8edafe028fdcaac
#: ../../java/http/routing-dsl/testkit.rst:37
msgid "Writing Asserting against the HttpResponse"
msgstr ""

# 6db43a3426a34ee1b8693bedc69366c1
#: ../../java/http/routing-dsl/testkit.rst:39
msgid ""
"The testkit supports a fluent DSL to write compact assertions on the "
"response by chaining assertions using \"dot-syntax\". To simplify working "
"with streamed responses the entity of the response is first \"strictified\","
" i.e. entity data is collected into a single ``ByteString`` and provided the"
" entity is supplied as an ``HttpEntityStrict``. This allows to write several"
" assertions against the same entity data which wouldn't (necessarily) be "
"possible for the streamed version."
msgstr ""

# e4686a28eeca492b9f05495277c71c1f
#: ../../java/http/routing-dsl/testkit.rst:45
msgid ""
"All of the defined assertions provide HTTP specific error messages aiding in"
" diagnosing problems."
msgstr ""

# fd569497e1054da6bc0c79258564fea3
#: ../../java/http/routing-dsl/testkit.rst:47
msgid ""
"Currently, these methods are defined on ``TestResponse`` to assert on the "
"response:"
msgstr ""

# 028c349e90e449cf833e49a01bd8c7e8
#: ../../java/http/routing-dsl/testkit.rst:50
msgid "Assertion                                        Description"
msgstr ""

# 34110e44f6544727baef2c70e80d2e54
#: ../../java/http/routing-dsl/testkit.rst:52
msgid "``assertStatusCode(int expectedCode)``"
msgstr ""

# e68d3b36c5f3440c8e19f987b77650e2
#: ../../java/http/routing-dsl/testkit.rst:52
msgid "Asserts that the numeric response status code equals the expected one"
msgstr ""

# 6e9a32ae35484ef1b5e281be7905adeb
#: ../../java/http/routing-dsl/testkit.rst:53
msgid "``assertStatusCode(StatusCode expectedCode)``"
msgstr ""

# c2ecf3ae78824eb99937e1a0ce0cdd3a
#: ../../java/http/routing-dsl/testkit.rst:53
msgid "Asserts that the response ``StatusCode`` equals the expected one"
msgstr ""

# c614240110094364ad1bc57dacac05c9
#: ../../java/http/routing-dsl/testkit.rst:54
msgid "``assertMediaType(String expectedType)``"
msgstr ""

# bb66c9e9dd20427bb5fea7a939c29ef9
#: ../../java/http/routing-dsl/testkit.rst:54
msgid ""
"Asserts that the media type part of the response's content type matches the "
"given String"
msgstr ""

# b13bb19eea47406596d0db3c0e481d46
#: ../../java/http/routing-dsl/testkit.rst:56
msgid "``assertMediaType(MediaType expectedType)``"
msgstr ""

# a705a07fc2e64484b8ff3e4c577d45e3
#: ../../java/http/routing-dsl/testkit.rst:56
msgid ""
"Asserts that the media type part of the response's content type matches the "
"given ``MediaType``"
msgstr ""

# 3541ee70d955406dae0732b0f63e301a
#: ../../java/http/routing-dsl/testkit.rst:58
msgid "``assertEntity(String expectedStringContent)``"
msgstr ""

# c3bed9d937b44dbb876cf1ab8a1e748e
#: ../../java/http/routing-dsl/testkit.rst:58
msgid ""
"Asserts that the entity data interpreted as UTF8 equals the expected String"
msgstr ""

# 4b350dec87bd49dca65e4df304a70658
#: ../../java/http/routing-dsl/testkit.rst:60
msgid "``assertEntityBytes(ByteString expectedBytes)``"
msgstr ""

# 841a16025eb14b8c908574ebd5fde6d1
#: ../../java/http/routing-dsl/testkit.rst:60
msgid "Asserts that the entity data bytes equal the expected ones"
msgstr ""

# 1d479b0064b848a2adc4aeb1daa43ee9
#: ../../java/http/routing-dsl/testkit.rst:61
msgid "``assertEntityAs(Unmarshaller<T> unmarshaller, expectedValue: T)``"
msgstr ""

# dbf642ec5441469cb84d2665e3ddaa7c
#: ../../java/http/routing-dsl/testkit.rst:61
msgid ""
"Asserts that the entity data if unmarshalled with the given marshaller "
"equals the given value"
msgstr ""

# f31d806140054fa79ad2da88dac77cfe
#: ../../java/http/routing-dsl/testkit.rst:63
msgid "``assertHeaderExists(HttpHeader expectedHeader)``"
msgstr ""

# a504f6da5acb4f29844f743e5d490f0b
#: ../../java/http/routing-dsl/testkit.rst:63
msgid ""
"Asserts that the response contains an HttpHeader instance equal to the "
"expected one"
msgstr ""

# 99e216144d0f40318fb16ca842138125
#: ../../java/http/routing-dsl/testkit.rst:65
msgid "``assertHeaderKindExists(String expectedHeaderName)``"
msgstr ""

# 302a513510914b2cb8e618b75cd8a792
#: ../../java/http/routing-dsl/testkit.rst:65
msgid "Asserts that the response contains a header with the expected name"
msgstr ""

# 669bb4fd1f894ee491f9b20692136d04
#: ../../java/http/routing-dsl/testkit.rst:66
msgid "``assertHeader(String name, String expectedValue)``"
msgstr ""

# 9a4a324eae7749d790c9a26be3c27146
#: ../../java/http/routing-dsl/testkit.rst:66
msgid ""
"Asserts that the response contains a header with the given name and value."
msgstr ""

# b9e5a4553861419e82d58bee9d8941cf
#: ../../java/http/routing-dsl/testkit.rst:70
msgid ""
"It's, of course, possible to use any other means of writing assertions by "
"inspecting the properties the response manually. As written above, "
"``TestResponse.entity`` and ``TestResponse.response`` return strict versions"
" of the entity data."
msgstr ""

# 2a29f38a59124bbf852b30a96e03bca0
#: ../../java/http/routing-dsl/testkit.rst:75
msgid "Supporting Custom Test Frameworks"
msgstr ""

# 2c02ec9883f2400593f76e883c1d8019
#: ../../java/http/routing-dsl/testkit.rst:77
msgid ""
"Adding support for a custom test framework is achieved by creating new "
"superclass analogous to ``JUnitRouteTest`` for writing tests with the custom"
" test framwork deriving from ``akka.http.javadsl.testkit.RouteTest`` and "
"implementing its abstract methods. This will allow users of the test "
"framework to use ``testRoute`` and to write assertions using the assertion "
"methods defined on ``TestResponse``."
msgstr ""

# 0fdaff26a9054c3d89cd0fe71a93301b
#: ../../java/http/server-side-https-support.rst:4
msgid "Server-Side HTTPS Support"
msgstr ""

# efcc2bfd953f493db100b95ec73c9cad
#: ../../java/http/server-side-https-support.rst:6
msgid ""
"Akka HTTP supports TLS encryption on the server-side as well as on the :ref"
":`client-side <clientSideHTTPS>`."
msgstr ""

# 74ce458f25204ee6ad5e9ade5b32cad9
#: ../../java/http/server-side-https-support.rst:14
msgid ""
"On the server-side the ``bind``, and ``bindAndHandleXXX`` methods of the "
"`akka.http.javadsl.Http`_ extension define an optional ``httpsContext`` "
"parameter, which can receive the HTTPS configuration in the form of an "
"``HttpsContext`` instance. If defined encryption is enabled on all accepted "
"connections. Otherwise it is disabled (which is the default)."
msgstr ""

# 9212982316024844a190af0df0d5c2e1
#: ../../java/http/server-side-https-support.rst:19
msgid ""
"For detailed documentation for client-side HTTPS support refer to "
":ref:`clientSideHTTPS`."
msgstr ""

# b313a7be88014c4ea06c4e41096f05d6
#: ../../java/http/server-side-https-support.rst:39
msgid ""
"In order to use SSL-Config in Akka so it logs to the right ActorSystem-wise "
"logger etc., the ``AkkaSSLConfig`` extension is provided. Obtaining it is as"
" simple as:"
msgstr ""

# bc643221a4054363881a84df61a89b40
#: ../../java/http/server-side-https-support.rst:45
msgid ""
"While typical usage, for example for configuring http client settings would "
"be applied globally by configuring ssl-config in ``application.conf``, it's "
"possible to obtain the extension and ``copy`` it while modifying any "
"configuration that you might need to change and then use that specific "
"``AkkaSSLConfig`` instance while establishing connections be it client or "
"server-side."
msgstr ""

# f9beffde3e514f9d91f7f173a867351b
#: ../../java/http/server-side-https-support.rst:51
msgid "Obtaining SSL/TLS Certificates"
msgstr ""

# 0c78927362564714970337fb46e16e65
#: ../../java/http/server-side-https-support.rst:52
msgid ""
"In order to run an HTTPS server a certificate has to be provided, which "
"usually is either obtained from a signing authority or created by yourself "
"for local or staging environment purposes."
msgstr ""

# f568f6dade7c410484b55cc9c1a1bc43
#: ../../java/http/server-side-https-support.rst:55
msgid ""
"Signing authorities often provide instructions on how to create a Java "
"keystore (typically with reference to Tomcat configuration). If you want to "
"generate your own certificates, the official Oracle documentation on how to "
"generate keystores using the JDK keytool utility can be found `here "
"<https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html>`_."
msgstr ""

# b33d6442f09b45eb937dbe9106f550b8
#: ../../java/http/server-side-https-support.rst:59
msgid ""
"SSL-Config provides a more targeted guide on generating certificates, so we "
"recommend you start with the guide titled `Generating X.509 Certificates "
"<http://typesafehub.github.io/ssl-config/CertificateGeneration.html>`_."
msgstr ""

# f5a1efa213c144e5b320809f0ab6a5d8
#: ../../java/http/server-side-https-support.rst:65
msgid "Using HTTPS"
msgstr ""

# 3e9fe7ca654a40f9beafb26a10670261
#: ../../java/http/server-side-https-support.rst:67
msgid ""
"Once you have obtained the server certificate, using it is as simple as "
"preparing an ``HttpsConnectionContext`` and either setting it as the default"
" one to be used by all servers started by the given ``Http`` extension or "
"passing it in explicitly when binding the server."
msgstr ""

# 99b4bd1166b34fe5ad7e098943f313b7
#: ../../java/http/server-side-https-support.rst:71
msgid ""
"The below example shows how setting up HTTPS works when using the "
"``akka.http.javadsl.server.HttpApp`` convenience class. Firstly you will "
"create and configure an instance of "
"``akka.http.javadsl.HttpsConnectionContext`` :"
msgstr ""

# c134378e2e0347b6b6625e0783e2aa6f
#: ../../java/http/server-side-https-support.rst:77
msgid ""
"Then pass it to ``akka.http.javadsl.Http`` class's "
"``setDefaultServerHttpContext`` method, like in the below ``main`` method."
msgstr ""

# ef68a67046f24a52bcf482f1aba7a7aa
#: ../../java/http/server-side-https-support.rst:83
msgid "Running both HTTP and HTTPS"
msgstr ""

# 0e3d2d530a6f47a3b1e5de1145100787
#: ../../java/http/server-side-https-support.rst:84
msgid ""
"If you want to run HTTP and HTTPS servers in a single application, you can "
"call ``bind...`` methods twice, one for HTTPS, and the other for HTTP."
msgstr ""

# 976154659600492fa018ced48cb319e9
#: ../../java/http/server-side-https-support.rst:87
msgid ""
"When configuring HTTPS, you can do it up like explained in the above :ref"
":`using-https-java` section,"
msgstr ""

# 6bb389dbfd1b47b998a1a167e768ddc0
#: ../../java/http/server-side-https-support.rst:92
msgid "or via :ref:`ssl-config-java` (not explained here though)."
msgstr ""

# 5875e85746e24d97b2a71d695ce6adbe
#: ../../java/http/server-side-https-support.rst:94
msgid ""
"Then, call ``bind...`` methods twice like below. The blow "
"``SimpleServerApp.useHttps(system)`` is calling the above defined HTTP "
"``public static HttpsConnectionContext useHttps(ActorSystem system)`` "
"method."
msgstr ""

# 98f19848817c44ff8169f44a7b61331b
#: ../../java/http/server-side-https-support.rst:101
msgid "Further reading"
msgstr ""

# 264e6c1c1c8c4ed0bdd5b6cb2e69b620
#: ../../java/http/server-side-https-support.rst:103
msgid ""
"The topic of properly configuring HTTPS for your web server is an always "
"changing one, thus we recommend staying up to date with various security "
"breach news and of course keep your JVM at the latest version possible, as "
"the default settings are often updated by Oracle in reaction to various "
"security updates and known issues."
msgstr ""

# 338c62b751c8462e8bbbc8adfb8a3aef
#: ../../java/http/server-side-https-support.rst:108
msgid ""
"We also recommend having a look at the `Play documentation about securing "
"your app`_, as well as the techniques described in the Play documentation "
"about setting up a `reverse proxy to terminate TLS in front of your "
"application`_ instead of terminating TLS inside the JVM, and therefore Akka "
"HTTP, itself."
msgstr ""

# 9d327cc7e7a14d5b8b1b429cd4be3773
#: ../../java/http/server-side-https-support.rst:112
msgid "Other excellent articles on the subject:"
msgstr ""

# 231d370b96664af489d73c1fd2bbf573
#: ../../java/http/server-side-https-support.rst:114
msgid ""
"`Oracle Java SE 8: Creating a Keystore using JSSE "
"<https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#CreateKeystore>`_"
msgstr ""

# fc27a53ad5cf42eea0aef2fc27c03705
#: ../../java/http/server-side-https-support.rst:115
msgid ""
"`Java PKI Programmer's Guide "
"<https://docs.oracle.com/javase/8/docs/technotes/guides/security/certpath/CertPathProgGuide.html>`_"
msgstr ""

# 84bda88f47464893a4481a67524f2054
#: ../../java/http/server-side-https-support.rst:116
msgid ""
"`Fixing X.509 Certificates "
"<https://tersesystems.com/2014/03/20/fixing-x509-certificates/>`_"
msgstr ""

# 4320d4905f5d42a7bd6eea8d10132204
#: ../../java/http/server-side/low-level-server-side-api.rst:4
msgid "Low-Level Server-Side API"
msgstr ""

# d304ad5a496a462db898e67563fb0b96
#: ../../java/http/server-side/low-level-server-side-api.rst:6
msgid ""
"Apart from the :ref:`HTTP Client <http-client-side-java>` Akka HTTP also "
"provides an embedded, `Reactive-Streams`_-based, fully asynchronous HTTP/1.1"
" server implemented on top of :ref:`Akka Stream <streams-java>`."
msgstr ""

# 12dee49651044ec8a861cc668e12ea81
#: ../../java/http/server-side/low-level-server-side-api.rst:9
msgid "It sports the following features:"
msgstr ""

# 56f006bcdd2f4c6fac4e05c098ed7ba0
#: ../../java/http/server-side/low-level-server-side-api.rst:11
msgid "Full support for `HTTP persistent connections`_"
msgstr ""

# 3bd8c11ca57041a9b4b135a82a9df106
#: ../../java/http/server-side/low-level-server-side-api.rst:12
msgid "Full support for `HTTP pipelining`_"
msgstr ""

# b87a882c942d44b8a58586928bed17dc
#: ../../java/http/server-side/low-level-server-side-api.rst:13
msgid ""
"Full support for asynchronous HTTP streaming including \"chunked\" transfer "
"encoding accessible through an idiomatic API"
msgstr ""

# b07f5f9b341548ea9787de196eec5f8c
#: ../../java/http/server-side/low-level-server-side-api.rst:14
msgid "Optional SSL/TLS encryption"
msgstr ""

# 330cbc15dfa4459896ec008142390447
#: ../../java/http/server-side/low-level-server-side-api.rst:15
msgid "WebSocket support"
msgstr ""

# 859de41f97c34fae893889c08b0ed144
#: ../../java/http/server-side/low-level-server-side-api.rst:21
msgid "The server-side components of Akka HTTP are split into two layers:"
msgstr ""

# 7e48e88888614cd09f92a12f47e54f74
#: ../../java/http/server-side/low-level-server-side-api.rst:23
msgid ""
"The basic low-level server implementation in the ``akka-http-core`` module"
msgstr ""

# 889bdea240764e92a859a9cd4d73f644
#: ../../java/http/server-side/low-level-server-side-api.rst:24
msgid "Higher-level functionality in the ``akka-http`` module"
msgstr ""

# cd754a467eca43249ec468e7c8472ddc
#: ../../java/http/server-side/low-level-server-side-api.rst:26
msgid ""
"The low-level server (1) is scoped with a clear focus on the essential "
"functionality of an HTTP/1.1 server:"
msgstr ""

# 7140d211a70f48f6bc4f4710b848f2f0
#: ../../java/http/server-side/low-level-server-side-api.rst:28
msgid "Connection management"
msgstr ""

# c12659eb760e4acb8d3005b3536d1192
#: ../../java/http/server-side/low-level-server-side-api.rst:29
msgid "Parsing and rendering of messages and headers"
msgstr ""

# 0b54a5918c6e446288410f13a75e1460
#: ../../java/http/server-side/low-level-server-side-api.rst:30
msgid "Timeout management (for requests and connections)"
msgstr ""

# 6ecdf6ea31474650ae760b7bc6e98d3d
#: ../../java/http/server-side/low-level-server-side-api.rst:31
msgid "Response ordering (for transparent pipelining support)"
msgstr ""

# 7c4024a424aa43c38aa0ce3989d7bd00
#: ../../java/http/server-side/low-level-server-side-api.rst:33
msgid ""
"All non-core features of typical HTTP servers (like request routing, file "
"serving, compression, etc.) are left to the higher layers, they are not "
"implemented by the ``akka-http-core``-level server itself. Apart from "
"general focus this design keeps the server core small and light-weight as "
"well as easy to understand and maintain."
msgstr ""

# 557760ea49e64a24a5f75117fb488b2e
#: ../../java/http/server-side/low-level-server-side-api.rst:38
msgid ""
"Depending on your needs you can either use the low-level API directly or "
"rely on the high-level :ref:`Routing DSL <http-high-level-server-side-api-"
"java>` which can make the definition of more complex service logic much "
"easier."
msgstr ""

# a4530f63f943493fa7ab4720a8792608
#: ../../java/http/server-side/low-level-server-side-api.rst:44
msgid "Streams and HTTP"
msgstr ""

# 23e4c4dbdcca43c089dfe3e6cfc04a89
#: ../../java/http/server-side/low-level-server-side-api.rst:46
msgid ""
"The Akka HTTP server is implemented on top of :ref:`Akka Stream <streams-"
"java>` and makes heavy use of it - in its implementation as well as on all "
"levels of its API."
msgstr ""

# e2f43b10c28740bea29398896d18c52a
#: ../../java/http/server-side/low-level-server-side-api.rst:49
msgid ""
"On the connection level Akka HTTP offers basically the same kind of "
"interface as :ref:`Akka Stream IO <stream-io-java>`: A socket binding is "
"represented as a stream of incoming connections. The application pulls "
"connections from this stream source and, for each of them, provides a "
"``Flow<HttpRequest, HttpResponse, ?>`` to \"translate\" requests into "
"responses."
msgstr ""

# 3bbd2397ad894ebeaab93396566d87bf
#: ../../java/http/server-side/low-level-server-side-api.rst:53
msgid ""
"Apart from regarding a socket bound on the server-side as a "
"``Source<IncomingConnection>`` and each connection as a "
"``Source<HttpRequest>`` with a ``Sink<HttpResponse>`` the stream abstraction"
" is also present inside a single HTTP message: The entities of HTTP requests"
" and responses are generally modeled as a ``Source<ByteString>``. See also "
"the :ref:`http-model-java` for more information on how HTTP messages are "
"represented in Akka HTTP."
msgstr ""

# 6679a40dc8324c808e49626c3ff8630b
#: ../../java/http/server-side/low-level-server-side-api.rst:60
msgid "Starting and Stopping"
msgstr ""

# f8a7b70843bb41e49c7fc0f6ce529e93
#: ../../java/http/server-side/low-level-server-side-api.rst:62
msgid ""
"On the most basic level an Akka HTTP server is bound by invoking the "
"``bind`` method of the `akka.http.javadsl.Http`_ extension:"
msgstr ""

# 10a07a455b7f4843b5dd622bd431be38
#: ../../java/http/server-side/low-level-server-side-api.rst:68
msgid ""
"Arguments to the ``Http().bind`` method specify the interface and port to "
"bind to and register interest in handling incoming HTTP connections. "
"Additionally, the method also allows for the definition of socket options as"
" well as a larger number of settings for configuring the server according to"
" your needs."
msgstr ""

# 47a909839ba4412ba726ff892ec5447b
#: ../../java/http/server-side/low-level-server-side-api.rst:72
msgid ""
"The result of the ``bind`` method is a ``Source<Http.IncomingConnection>`` "
"which must be drained by the application in order to accept incoming "
"connections. The actual binding is not performed before this source is "
"materialized as part of a processing pipeline. In case the bind fails (e.g. "
"because the port is already busy) the materialized stream will immediately "
"be terminated with a respective exception. The binding is released (i.e. the"
" underlying socket unbound) when the subscriber of the incoming connection "
"source has cancelled its subscription. Alternatively one can use the "
"``unbind()`` method of the ``Http.ServerBinding`` instance that is created "
"as part of the connection source's materialization process. The "
"``Http.ServerBinding`` also provides a way to get a hold of the actual local"
" address of the bound socket, which is useful for example when binding to "
"port zero (and thus letting the OS pick an available port)."
msgstr ""

# a3d38f8702a647709e1e82e9f4db3eb6
#: ../../java/http/server-side/low-level-server-side-api.rst:90
msgid ""
"When a new connection has been accepted it will be published as an "
"``Http.IncomingConnection`` which consists of the remote address and methods"
" to provide a ``Flow<HttpRequest, HttpResponse, ?>`` to handle requests "
"coming in over this connection."
msgstr ""

# d782f07c9a634767928a7f4e87c69db7
#: ../../java/http/server-side/low-level-server-side-api.rst:94
msgid ""
"Requests are handled by calling one of the ``handleWithXXX`` methods with a "
"handler, which can either be"
msgstr ""

# 63dfd62d6efe49eba2d3136b4c014534
#: ../../java/http/server-side/low-level-server-side-api.rst:96
msgid "a ``Flow<HttpRequest, HttpResponse, ?>`` for ``handleWith``,"
msgstr ""

# db6637cdeee54ce78e736542b5787f99
#: ../../java/http/server-side/low-level-server-side-api.rst:97
msgid ""
"a function ``Function<HttpRequest, HttpResponse>`` for "
"``handleWithSyncHandler``,"
msgstr ""

# 20d00acf593a48b2afdeb33edce28188
#: ../../java/http/server-side/low-level-server-side-api.rst:98
msgid ""
"a function ``Function<HttpRequest, CompletionStage<HttpResponse>>`` for "
"``handleWithAsyncHandler``."
msgstr ""

# 5b0151a1fb1c418e88c8af74d6d8aae7
#: ../../java/http/server-side/low-level-server-side-api.rst:100
msgid "Here is a complete example:"
msgstr ""

# 571a68f78d444dc3bd52f0b26c5af3a1
#: ../../java/http/server-side/low-level-server-side-api.rst:105
msgid ""
"In this example, a request is handled by transforming the request stream "
"with a function ``Function<HttpRequest, HttpResponse>`` using "
"``handleWithSyncHandler`` (or equivalently, Akka Stream's ``map`` operator)."
" Depending on the use case many other ways of providing a request handler "
"are conceivable using Akka Stream's combinators."
msgstr ""

# 9c028575368f4c25a86f1430a96baf5d
#: ../../java/http/server-side/low-level-server-side-api.rst:109
msgid ""
"If the application provides a ``Flow`` it is also the responsibility of the "
"application to generate exactly one response for every request and that the "
"ordering of responses matches the ordering of the associated requests (which"
" is relevant if HTTP pipelining is enabled where processing of multiple "
"incoming requests may overlap). When relying on ``handleWithSyncHandler`` or"
" ``handleWithAsyncHandler``, or the ``map`` or ``mapAsync`` stream "
"operators, this requirement will be automatically fulfilled."
msgstr ""

# 2d89a9375b7644cba6531b4497b9123f
#: ../../java/http/server-side/low-level-server-side-api.rst:115
msgid ""
"See :ref:`http-routing-java` for a more convenient high-level DSL to create "
"request handlers."
msgstr ""

# 4ca045e7aba641e9afbbcdb87aee64a9
#: ../../java/http/server-side/low-level-server-side-api.rst:118
msgid "Streaming Request/Response Entities"
msgstr ""

# 880aca24b8fd4a07a783faa70ae31315
#: ../../java/http/server-side/low-level-server-side-api.rst:120
msgid ""
"Streaming of HTTP message entities is supported through subclasses of "
"``HttpEntity``. The application needs to be able to deal with streamed "
"entities when receiving a request as well as, in many cases, when "
"constructing responses. See :ref:`HttpEntity-java` for a description of the "
"alternatives."
msgstr ""

# 0c65c82977cc4ed299b69c3f93a4eaed
#: ../../java/http/server-side/low-level-server-side-api.rst:127
msgid "Closing a connection"
msgstr ""

# a4070307d8154b538059c847d6a4af3a
#: ../../java/http/server-side/low-level-server-side-api.rst:129
msgid ""
"The HTTP connection will be closed when the handling ``Flow`` cancels its "
"upstream subscription or the peer closes the connection. An often times more"
" convenient alternative is to explicitly add a ``Connection: close`` header "
"to an ``HttpResponse``. This response will then be the last one on the "
"connection and the server will actively close the connection when it has "
"been sent out."
msgstr ""

# d498c2a7784a4053a31c957a5cc1d746
#: ../../java/http/server-side/low-level-server-side-api.rst:134
msgid ""
"Connection will also be closed if request entity has been cancelled (e.g. by"
" attaching it to ``Sink.cancelled()``) or consumed only partially (e.g. by "
"using ``take`` combinator). In order to prevent this behaviour entity should"
" be explicitly drained by attaching it to ``Sink.ignore()``."
msgstr ""

# 56248f04f76f43499d8c877f5f3a6dd9
#: ../../java/http/server-side/low-level-server-side-api.rst:149
msgid ""
"On the server-side the stand-alone HTTP layer forms a "
"``BidiFlow<HttpResponse, SslTlsOutbound, SslTlsInbound, HttpRequest, "
"NotUsed>``, that is a stage that \"upgrades\" a potentially encrypted raw "
"connection to the HTTP level."
msgstr ""

# 2331a29da10f478389459b52a2f9216e
#: ../../java/http/server-side/low-level-server-side-api.rst:152
msgid ""
"You create an instance of the layer by calling one of the two overloads of "
"the ``Http.get(system).serverLayer`` method, which also allows for varying "
"degrees of configuration. Note, that the returned instance is not reusable "
"and can only be materialized once."
msgstr ""

# 7b12184d66ef425091870d0ff91cec57
#: ../../java/http/server-side/low-level-server-side-api.rst:157
msgid "Controlling server parallelism"
msgstr ""

# a1e3bab636124b82a5f2a1882c01f683
#: ../../java/http/server-side/low-level-server-side-api.rst:159
msgid ""
"Request handling can be parallelized on two axes, by handling several "
"connections in parallel and by relying on HTTP pipelining to send several "
"requests on one connection without waiting for a response first. In both "
"cases the client controls the number of ongoing requests. To prevent being "
"overloaded by too many requests, Akka HTTP can limit the number of requests "
"it handles in parallel."
msgstr ""

# b951ed19b13e489caf638c79d260d0c8
#: ../../java/http/server-side/low-level-server-side-api.rst:164
msgid ""
"To limit the number of simultaneously open connections, use the "
"``akka.http.server.max-connections`` setting. This setting applies to all of"
" ``Http.bindAndHandle*`` methods. If you use ``Http.bind``, incoming "
"connections are represented by a ``Source<IncomingConnection, ...>``. Use "
"Akka Stream's combinators to apply backpressure to control the flow of "
"incoming connections, e.g. by using ``throttle`` or ``mapAsync``."
msgstr ""

# fe0f1a6e1a084361ac68860c175c7e56
#: ../../java/http/server-side/low-level-server-side-api.rst:169
msgid ""
"HTTP pipelining is generally discouraged (and `disabled by most browsers "
"<https://en.wikipedia.org/w/index.php?title=HTTP_pipelining&oldid=700966692#Implementation_in_web_browsers>`_)"
" but is nevertheless fully supported in Akka HTTP. The limit is applied on "
"two levels. First, there's the ``akka.http.server.pipeline-limit`` config "
"setting which prevents that more than the given number of outstanding "
"requests is ever given to the user-supplied handler-flow. On the other hand,"
" the handler flow itself can apply any kind of throttling itself. If you use"
" one of the ``Http.bindAndHandleSync`` or ``Http.bindAndHandleAsync`` entry-"
"points, you can specify the ``parallelism`` argument (default = 1, i.e. "
"pipelining disabled) to control the number of concurrent requests per "
"connection. If you use ``Http.bindAndHandle`` or ``Http.bind``, the user-"
"supplied handler flow has full control over how many request it accepts "
"simultaneously by applying backpressure. In this case, you can e.g. use Akka"
" Stream's ``mapAsync`` combinator with a given parallelism to limit the "
"number of concurrently handled requests. Effectively, the more constraining "
"one of these two measures, config setting and manual flow shaping, will "
"determine how parallel requests on one connection are handled."
msgstr ""

# a41395955dbb4ad4bee92ba571c49c20
#: ../../java/http/server-side/low-level-server-side-api.rst:185
msgid "Handling HTTP Server failures in the Low-Level API"
msgstr ""

# 4e97e0abb8a6442c9c316b685898372b
#: ../../java/http/server-side/low-level-server-side-api.rst:191
msgid ""
"There are multiple things that can fail when creating and materializing an "
"HTTP Server (similarily, the same applied to a plain streaming ``Tcp`` "
"server). The types of failures that can happen on different layers of the "
"stack, starting from being unable to start the server, and ending with "
"failing to unmarshal an HttpRequest, examples of failures include (from "
"outer-most, to inner-most):"
msgstr ""

# 0f6712bf123545f49c34e0faec909f3d
#: ../../java/http/server-side/low-level-server-side-api.rst:196
msgid "Failure to ``bind`` to the specified address/port,"
msgstr ""

# 9f1c46e789914f64a8ab942def4ad584
#: ../../java/http/server-side/low-level-server-side-api.rst:197
msgid ""
"Failure while accepting new ``IncommingConnection`` s, for example when the "
"OS has run out of file descriptors or memory,"
msgstr ""

# cdf81eee8f6645f1bcc29e5b7146e8c0
#: ../../java/http/server-side/low-level-server-side-api.rst:198
msgid ""
"Failure while handling a connection, for example if the incoming "
"``HttpRequest`` is malformed."
msgstr ""

# ce34c1c280aa4512b96807e6468fa2c3
#: ../../java/http/server-side/low-level-server-side-api.rst:200
msgid ""
"This section describes how to handle each failure situation, and in which "
"situations these failures may occur."
msgstr ""

# b2be8f3e327e43d2b61465e620efdcf6
#: ../../java/http/server-side/low-level-server-side-api.rst:205
msgid ""
"The first type of failure is when the server is unable to bind to the given "
"port. For example when the port is already taken by another application, or "
"if the port is privileged (i.e. only usable by ``root``). In this case the "
"\"binding future\" will fail immediatly, and we can react to if by listening"
" on the CompletionStage’s completion:"
msgstr ""

# c0bc01e0575c4c1fa00dad4114ba8858
#: ../../java/http/server-side/low-level-server-side-api.rst:212
msgid ""
"Once the server has successfully bound to a port, the "
"``Source<IncomingConnection, ?>`` starts running and emiting new incoming "
"connections. This source technically can signal a failure as well, however "
"this should only happen in very dramantic situations such as running out of "
"file descriptors or memory available to the system, such that it's not able "
"to accept a new incoming connection. Handling failures in Akka Streams is "
"pretty stright forward, as failures are signaled through the stream starting"
" from the stage which failed, all the way downstream to the final stages."
msgstr ""

# 8f3cb9f99888455aaf349a8b2d55e634
#: ../../java/http/server-side/low-level-server-side-api.rst:221
msgid ""
"In the example below we add a custom ``GraphStage`` (see :ref:`stream-"
"customize-java`) in order to react to the stream's failure. We signal a "
"``failureMonitor`` actor with the cause why the stream is going down, and "
"let the Actor handle the rest – maybe it'll decide to restart the server or "
"shutdown the ActorSystem, that however is not our concern anymore."
msgstr ""

# af8884fc3b984e359e133fb917968ccd
#: ../../java/http/server-side/low-level-server-side-api.rst:231
msgid ""
"The third type of failure that can occur is when the connection has been "
"properly established, however afterwards is terminated abruptly – for "
"example by the client aborting the underlying TCP connection. To handle this"
" failure we can use the same pattern as in the previous snippet, however "
"apply it to the connection's Flow:"
msgstr ""

# 291167ff0e9a4b53b0db0c772baf4e47
#: ../../java/http/server-side/low-level-server-side-api.rst:238
msgid ""
"These failures can be described more or less infrastructure related, they "
"are failing bindings or connections. Most of the time you won't need to dive"
" into those very deeply, as Akka will simply log errors of this kind anyway,"
" which is a reasonable default for such problems."
msgstr ""

# 78c90bf6f3a9419fa0605ef5d287e796
#: ../../java/http/server-side/websocket-support.rst:4
msgid "Server-Side WebSocket Support"
msgstr ""

# b71eec5a15a148739f7f287449e642f2
#: ../../java/http/server-side/websocket-support.rst:6
msgid ""
"WebSocket is a protocol that provides a bi-directional channel between "
"browser and webserver usually run over an upgraded HTTP(S) connection. Data "
"is exchanged in messages whereby a message can either be binary data or "
"unicode text."
msgstr ""

# 4363e2ffdee84ab99aea86631ef86364
#: ../../java/http/server-side/websocket-support.rst:9
msgid ""
"Akka HTTP provides a stream-based implementation of the WebSocket protocol "
"that hides the low-level details of the underlying binary framing wire-"
"protocol and provides a simple API to implement services using WebSocket."
msgstr ""

# be7a8694c7204226bb632fed170f33e7
#: ../../java/http/server-side/websocket-support.rst:14
msgid "Model"
msgstr ""

# 35fc4f6cbff84e6e8fe7f704ef17d439
#: ../../java/http/server-side/websocket-support.rst:16
msgid ""
"The basic unit of data exchange in the WebSocket protocol is a message. A "
"message can either be binary message, i.e. a sequence of octets or a text "
"message, i.e. a sequence of unicode code points."
msgstr ""

# badba2cd35dc408faab99c895e2f3a2c
#: ../../java/http/server-side/websocket-support.rst:19
msgid ""
"In the data model the two kinds of messages, binary and text messages, are "
"represented by the two classes ``BinaryMessage`` and ``TextMessage`` "
"deriving from a common superclass ``Message``. The superclass ``Message`` "
"contains ``isText`` and ``isBinary`` methods to distinguish a message and "
"``asBinaryMessage`` and ``asTextMessage`` methods to cast a message."
msgstr ""

# c0c1e6129e1b464e85dc60189f3d4aa4
#: ../../java/http/server-side/websocket-support.rst:24
msgid ""
"The subclasses ``BinaryMessage`` and ``TextMessage`` contain methods to "
"access the data. Take the API of ``TextMessage`` as an example "
"(``BinaryMessage`` is very similar with ``String`` replaced by "
"``ByteString``):"
msgstr ""

# e72bdac4d38a465583964169591c80ae
#: ../../java/http/server-side/websocket-support.rst:30
msgid ""
"The data of a message is provided as a stream because WebSocket messages do "
"not have a predefined size and could (in theory) be infinitely long. "
"However, only one message can be open per direction of the WebSocket "
"connection, so that many application level protocols will want to make use "
"of the delineation into (small) messages to transport single application-"
"level data units like \"one event\" or \"one chat message\"."
msgstr ""

# 7df0c54f108a4e298a52d97d90f466e0
#: ../../java/http/server-side/websocket-support.rst:35
msgid ""
"Many messages are small enough to be sent or received in one go. As an "
"opportunity for optimization, the model provides the notion of a \"strict\" "
"message to represent cases where a whole message was received in one go. If "
"``TextMessage.isStrict`` returns true, the complete data is already "
"available and can be accessed with ``TextMessage.getStrictText`` "
"(analogously for ``BinaryMessage``)."
msgstr ""

# ad1f971770674b9d86985278999949c0
#: ../../java/http/server-side/websocket-support.rst:40
msgid ""
"When receiving data from the network connection the WebSocket implementation"
" tries to create a strict message whenever possible, i.e. when the complete "
"data was received in one chunk. However, the actual chunking of messages "
"over a network connection and through the various streaming abstraction "
"layers is not deterministic from the perspective of the application. "
"Therefore, application code must be able to handle both streamed and strict "
"messages and not expect certain messages to be strict. (Particularly, note "
"that tests against ``localhost`` will behave differently than tests against "
"remote peers where data is received over a physical network connection.)"
msgstr ""

# 47e4b2ea839c4591aefbbcee1343ffb7
#: ../../java/http/server-side/websocket-support.rst:47
msgid ""
"For sending data, you can use the static ``TextMessage.create(String)`` "
"method to create a strict message if the complete message has already been "
"assembled. Otherwise, use ``TextMessage.create(Source<String, ?>)`` to "
"create a streaming message from an Akka Stream source."
msgstr ""

# d8a7577b2c724bae8594c0231b574d3f
#: ../../java/http/server-side/websocket-support.rst:53
msgid "Server API"
msgstr ""

# c112aa3882404f9f91b3659b1fb08c35
#: ../../java/http/server-side/websocket-support.rst:55
msgid ""
"The entrypoint for the WebSocket API is the synthetic ``UpgradeToWebSocket``"
" header which is added to a request if Akka HTTP encounters a WebSocket "
"upgrade request."
msgstr ""

# aa9cfc5cf6a5478d833a70522dda624b
#: ../../java/http/server-side/websocket-support.rst:58
msgid ""
"The WebSocket specification mandates that details of the WebSocket "
"connection are negotiated by placing special-purpose HTTP-headers into "
"request and response of the HTTP upgrade. In Akka HTTP these HTTP-level "
"details of the WebSocket handshake are hidden from the application and don't"
" need to be managed manually."
msgstr ""

# 4f25bfbdc26e432d8417d80b4bf0cc35
#: ../../java/http/server-side/websocket-support.rst:62
msgid ""
"Instead, the synthetic ``UpgradeToWebSocket`` represents a valid WebSocket "
"upgrade request. An application can detect a WebSocket upgrade request by "
"looking for the ``UpgradeToWebSocket`` header. It can choose to accept the "
"upgrade and start a WebSocket connection by responding to that request with "
"an ``HttpResponse`` generated by one of the "
"``UpgradeToWebSocket.handleMessagesWith`` methods. In its most general form "
"this method expects two arguments: first, a handler ``Flow<Message, Message,"
" ?>`` that will be used to handle WebSocket messages on this connection. "
"Second, the application can optionally choose one of the proposed "
"application-level sub-protocols by inspecting the values of "
"``UpgradeToWebSocket.getRequestedProtocols`` and pass the chosen protocol "
"value to ``handleMessagesWith``."
msgstr ""

# c366228bec994ff69de8830220614430
#: ../../java/http/server-side/websocket-support.rst:71
msgid "Handling Messages"
msgstr ""

# 541d40a11af54385b8f7f47bd4a1b288
#: ../../java/http/server-side/websocket-support.rst:73
msgid ""
"A message handler is expected to be implemented as a ``Flow<Message, "
"Message, ?>``. For typical request-response scenarios this fits very well "
"and such a ``Flow`` can be constructed from a simple function by using "
"``Flow.<Message>create().map`` or ``Flow.<Message>create().mapAsync``."
msgstr ""

# 3e126f7c770647548b5b6fda73a37515
#: ../../java/http/server-side/websocket-support.rst:77
msgid ""
"There are other use-cases, e.g. in a server-push model, where a server "
"message is sent spontaneously, or in a true bi-directional scenario where "
"input and output aren't logically connected. Providing the handler as a "
"``Flow`` in these cases may not fit. An overload of "
"``UpgradeToWebSocket.handleMessagesWith`` is provided, instead, which allows"
" to pass an output-generating ``Source<Message, ?>`` and an input-receiving "
"``Sink<Message, ?>`` independently."
msgstr ""

# fcf13423ce1641d487e0334d971e714c
#: ../../java/http/server-side/websocket-support.rst:82
msgid ""
"Note that a handler is required to consume the data stream of each message "
"to make place for new messages. Otherwise, subsequent messages may be stuck "
"and message traffic in this direction will stall."
msgstr ""

# 63e72fda57b64010ab66f450543d7e50
#: ../../java/http/server-side/websocket-support.rst:88
msgid "Let's look at an example_."
msgstr ""

# cdd8c047420740c582ab44492b2615df
#: ../../java/http/server-side/websocket-support.rst:90
msgid ""
"WebSocket requests come in like any other requests. In the example, requests"
" to ``/greeter`` are expected to be WebSocket requests:"
msgstr ""

# d47739115ff34da898817528e2ea786a
#: ../../java/http/server-side/websocket-support.rst:96
msgid ""
"It uses a helper method "
"``akka.http.javadsl.model.ws.WebSocket.handleWebSocketRequestWith`` which "
"can be used if only WebSocket requests are expected. The method looks for "
"the ``UpgradeToWebSocket`` header and returns a response that will install "
"the passed WebSocket handler if the header is found. If the request is no "
"WebSocket request it will return a ``400 Bad Request`` error response."
msgstr ""

# c81262be522c444f9aa5fdf85a65c2e9
#: ../../java/http/server-side/websocket-support.rst:101
msgid ""
"In the example, the passed handler expects text messages where each message "
"is expected to contain (a person's) name and then responds with another text"
" message that contains a greeting:"
msgstr ""

# 5d829a5e5bcb46dc9541cfe429c06425
#: ../../java/http/server-side/websocket-support.rst:108
msgid ""
"Inactive WebSocket connections will be dropped according to the :ref:`idle-"
"timeout settings <idle-timeouts-java>`. In case you need to keep inactive "
"connections alive, you can either tweak your idle-timeout or inject 'keep-"
"alive' messages regularly."
msgstr ""

# d4169c045558498b9136830010736a74
#: ../../java/http/server-side/websocket-support.rst:113
msgid "Routing support"
msgstr ""

# 1097078df05d4813b1523e5db8205c79
#: ../../java/http/server-side/websocket-support.rst:115
msgid ""
"The routing DSL provides the ``handleWebSocketMessages`` directive to "
"install a WebSocket handler if a request is a WebSocket request. Otherwise, "
"the directive rejects the request."
msgstr ""

# 520ad7df95e24620b935961e1bd8dc9e
#: ../../java/http/server-side/websocket-support.rst:118
msgid ""
"Let's look at how the above example can be rewritten using the high-level "
"routing DSL."
msgstr ""

# e02718e06f594a1c9dfd22835ee10026
#: ../../java/http/server-side/websocket-support.rst:120
msgid ""
"Instead of writing the request handler manually, the routing behavior of the"
" app is defined by a route that uses the ``handleWebSocketRequests`` "
"directive in place of the ``WebSocket.handleWebSocketRequestWith``:"
msgstr ""

# 9170633300ca432ba0d5e01fff22eacf
#: ../../java/http/server-side/websocket-support.rst:126
msgid ""
"The handling code itself will be the same as with using the low-level API."
msgstr ""

# a799a64b15594417a27de4fe0b9a72fa
#: ../../java/http/server-side/websocket-support.rst:128
msgid "See the `full routing example`_."
msgstr ""

# 8a865b0eecfc459fa8a45020aeb5e58f
# 9715eb48b1e04d5880057e2f3c47f208
#: ../../java/index-actors.rst:2 ../../java/untyped-actors.rst:5
msgid "Actors"
msgstr "アクター"

# b133293fda554ef2a8d60b5f36f12217
#: ../../java/index-futures.rst:2
msgid "Futures and Agents"
msgstr ""

# 84f157e3a31848e9aea3d4c819ad1aa5
#: ../../java/index-network.rst:2
msgid "Networking"
msgstr ""

# 7c8836c651f74922ab5f0207a6d103e0
#: ../../java/index-utilities.rst:2
msgid "Utilities"
msgstr ""

# 1bc3b43371b2442d96b746d8dcf800bd
#: ../../java/io.rst:4
msgid "I/O"
msgstr ""

# 28d8204b3897487aaa8bfa0a619c4736
#: ../../java/io.rst:9
msgid ""
"The ``akka.io`` package has been developed in collaboration between the Akka"
" and `spray.io`_ teams. Its design combines experiences from the ``spray-"
"io`` module with improvements that were jointly developed for more general "
"consumption as an actor-based service."
msgstr ""

# 6db5b77673e2448b97cca1cd5627b5f9
#: ../../java/io.rst:14
msgid ""
"The guiding design goal for this I/O implementation was to reach extreme "
"scalability, make no compromises in providing an API correctly matching the "
"underlying transport mechanism and to be fully event-driven, non-blocking "
"and asynchronous.  The API is meant to be a solid foundation for the "
"implementation of network protocols and building higher abstractions; it is "
"not meant to be a full-service high-level NIO wrapper for end users."
msgstr ""

# 4aaec0a24b234aee96979fe800d8f8e2
#: ../../java/io.rst:22
msgid "Terminology, Concepts"
msgstr ""

# 7d56c7234f454243a0ec18b7e0c28b0c
#: ../../java/io.rst:23
msgid ""
"The I/O API is completely actor based, meaning that all operations are "
"implemented with message passing instead of direct method calls. Every I/O "
"driver (TCP, UDP) has a special actor, called a *manager* that serves as an "
"entry point for the API. I/O is broken into several drivers. The manager for"
" a particular driver is accessible by querying an ``ActorSystem``. For "
"example the following code looks up the TCP manager and returns its "
"``ActorRef``:"
msgstr ""

# 07466d3efa2d40f89a064bba584349ff
#: ../../java/io.rst:31
msgid ""
"The manager receives I/O command messages and instantiates worker actors in "
"response. The worker actors present themselves to the API user in the reply "
"to the command that was sent. For example after a ``Connect`` command sent "
"to the TCP manager the manager creates an actor representing the TCP "
"connection. All operations related to the given TCP connections can be "
"invoked by sending messages to the connection actor which announces itself "
"by sending a ``Connected`` message."
msgstr ""

# 3c11ef6bf2ce4f7297edf1fac99424f5
#: ../../java/io.rst:38
msgid "DeathWatch and Resource Management"
msgstr ""

# a3b9a9cd56094619b9610e5566f3eb56
#: ../../java/io.rst:40
msgid ""
"I/O worker actors receive commands and also send out events. They usually "
"need a user-side counterpart actor listening for these events (such events "
"could be inbound connections, incoming bytes or acknowledgements for "
"writes). These worker actors *watch* their listener counterparts. If the "
"listener stops then the worker will automatically release any resources that"
" it holds. This design makes the API more robust against resource leaks."
msgstr ""

# 02342d7ff3b341e8b548c7b2e1e17946
#: ../../java/io.rst:45
msgid ""
"Thanks to the completely actor based approach of the I/O API the opposite "
"direction works as well: a user actor responsible for handling a connection "
"can watch the connection actor to be notified if it unexpectedly terminates."
msgstr ""

# cc678ecead25412dbc5a1a8549cd1e76
#: ../../java/io.rst:49
msgid "Write models (Ack, Nack)"
msgstr ""

# 0c7d2a34f4644731bb5348a9b6c6ef03
#: ../../java/io.rst:51
msgid ""
"I/O devices have a maximum throughput which limits the frequency and size of"
" writes. When an application tries to push more data than a device can "
"handle, the driver has to buffer bytes until the device is able to write "
"them. With buffering it is possible to handle short bursts of intensive "
"writes --- but no buffer is infinite. \"Flow control\" is needed to avoid "
"overwhelming device buffers."
msgstr ""

# da741b732dfc4d44a65159b661182c48
#: ../../java/io.rst:56
msgid "Akka supports two types of flow control:"
msgstr ""

# 3a810785c3fb4743b39dd96c7863b67f
#: ../../java/io.rst:58
msgid ""
"*Ack-based*, where the driver notifies the writer when writes have "
"succeeded."
msgstr ""

# 3870714df6ce4f6aad9073e9279cc4a7
#: ../../java/io.rst:60
msgid ""
"*Nack-based*, where the driver notifies the writer when writes have failed."
msgstr ""

# d64b072e0a8442e1a4a96e2f5d7d327a
#: ../../java/io.rst:62
msgid ""
"Each of these models is available in both the TCP and the UDP "
"implementations of Akka I/O."
msgstr ""

# f3d89b2f86bf46f395060985b806c244
#: ../../java/io.rst:64
msgid ""
"Individual writes can be acknowledged by providing an ack object in the "
"write message (``Write`` in the case of TCP and ``Send`` for UDP). When the "
"write is complete the worker will send the ack object to the writing actor. "
"This can be used to implement *ack-based* flow control; sending new data "
"only when old data has been acknowledged."
msgstr ""

# 2f4aea41f6284b759212d44f2fe0ef19
#: ../../java/io.rst:68
msgid ""
"If a write (or any other command) fails, the driver notifies the actor that "
"sent the command with a special message (``CommandFailed`` in the case of "
"UDP and TCP). This message will also notify the writer of a failed write, "
"serving as a nack for that write. Please note, that in a nack-based flow-"
"control setting the writer has to be prepared for the fact that the failed "
"write might not be the most recent write it sent. For example, the failure "
"notification for a write ``W1`` might arrive after additional write commands"
" ``W2`` and ``W3`` have been sent. If the writer wants to resend any nacked "
"messages it may need to keep a buffer of pending messages."
msgstr ""

# 7fa4476298a34046909e6503e33cfe3e
#: ../../java/io.rst:76
msgid ""
"An acknowledged write does not mean acknowledged delivery or storage; "
"receiving an ack for a write simply signals that the I/O driver has "
"successfully processed the write. The Ack/Nack protocol described here is a "
"means of flow control not error handling. In other words, data may still be "
"lost, even if every write is acknowledged."
msgstr ""

# 891965276a994a5a890545450bd699ae
#: ../../java/io.rst:83
msgid "ByteString"
msgstr ""

# f4d9cbd5be04486ea2b1eadb9dd076f3
#: ../../java/io.rst:85
msgid ""
"To maintain isolation, actors should communicate with immutable objects "
"only. ``ByteString`` is an immutable container for bytes. It is used by "
"Akka's I/O system as an efficient, immutable alternative the traditional "
"byte containers used for I/O on the JVM, such as ``byte[]`` and "
"``ByteBuffer``."
msgstr ""

# 2f24708fc9da493e8d2d6524fa766487
#: ../../java/io.rst:89
msgid ""
"``ByteString`` is a `rope-like "
"<http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ data structure that"
" is immutable and provides fast concatenation and slicing operations "
"(perfect for I/O). When two ``ByteString``\\s are concatenated together they"
" are both stored within the resulting ``ByteString`` instead of copying both"
" to a new array. Operations such as ``drop`` and ``take`` return "
"``ByteString``\\s that still reference the original array, but just change "
"the offset and length that is visible. Great care has also been taken to "
"make sure that the internal array cannot be modified. Whenever a potentially"
" unsafe array is used to create a new ``ByteString`` a defensive copy is "
"created. If you require a ``ByteString`` that only blocks a much memory as "
"necessary for it's content, use the ``compact`` method to get a "
"``CompactByteString`` instance. If the ``ByteString`` represented only a "
"slice of the original array, this will result in copying all bytes in that "
"slice."
msgstr ""

# 57e498a79b634a4d8f14a24b8f1073ff
#: ../../java/io.rst:99
msgid ""
"``ByteString`` inherits all methods from ``IndexedSeq``, and it also has "
"some new ones. For more information, look up the ``akka.util.ByteString`` "
"class and it's companion object in the ScalaDoc."
msgstr ""

# 24db8c9d753a481bb7fc384a75228104
#: ../../java/io.rst:101
msgid ""
"``ByteString`` also comes with its own optimized builder and iterator "
"classes ``ByteStringBuilder`` and ``ByteIterator`` which provide extra "
"features in addition to those of normal builders and iterators."
msgstr ""

# a7f83a5e2ff6489c8d05edd7f55d6d99
#: ../../java/io.rst:105
msgid "Compatibility with java.io"
msgstr ""

# 5e6c2838d41e4a02ba4ec3c6f9f7f49d
#: ../../java/io.rst:107
msgid ""
"A ``ByteStringBuilder`` can be wrapped in a ``java.io.OutputStream`` via the"
" ``asOutputStream`` method. Likewise, ``ByteIterator`` can we wrapped in a "
"``java.io.InputStream`` via ``asInputStream``. Using these, ``akka.io`` "
"applications can integrate legacy code based on ``java.io`` streams."
msgstr ""

# 1b2c36e7c2634e1bbf27d8b32db6b4e2
#: ../../java/io.rst:110
msgid "Architecture in-depth"
msgstr ""

# b36e8ecb12bf4711a92f4ae477b32d7c
#: ../../java/io.rst:112
msgid ""
"For further details on the design and internal architecture see :ref:`io-"
"layer`."
msgstr ""

# 7426721782924879908f6e91ee68b5d3
#: ../../java/io-tcp.rst:4
msgid "Using TCP"
msgstr ""

# b735f5fac8ca43e5b10070526a942fb8
#: ../../java/io-tcp.rst:6
msgid ""
"The code snippets through-out this section assume the following imports:"
msgstr ""

# 9d67dc4751d24ae0a93b697f84fbf515
#: ../../java/io-tcp.rst:10
msgid ""
"All of the Akka I/O APIs are accessed through manager objects. When using an"
" I/O API, the first step is to acquire a reference to the appropriate "
"manager. The code below shows how to acquire a reference to the ``Tcp`` "
"manager."
msgstr ""

# 5bd23020bd2a43cba0a3057d6c331742
#: ../../java/io-tcp.rst:15
msgid ""
"The manager is an actor that handles the underlying low level I/O resources "
"(selectors, channels) and instantiates workers for specific tasks, such as "
"listening to incoming connections."
msgstr ""

# 03733f347e024d82ae2903f35b57180d
#: ../../java/io-tcp.rst:19
msgid "Connecting"
msgstr ""

# 779bf8c031884d82aad63c52feb7939a
#: ../../java/io-tcp.rst:23
msgid ""
"The first step of connecting to a remote address is sending a "
":class:`Connect` message to the TCP manager; in addition to the simplest "
"form shown above there is also the possibility to specify a local "
":class:`InetSocketAddress` to bind to and a list of socket options to apply."
msgstr ""

# c2fbd5469f0842f6a8b7a1678c66116a
#: ../../java/io-tcp.rst:30
msgid ""
"The SO_NODELAY (TCP_NODELAY on Windows) socket option defaults to true in "
"Akka, independently of the OS default settings. This setting disables "
"Nagle's algorithm, considerably improving latency for most applications. "
"This setting could be overridden by passing ``SO.TcpNoDelay(false)`` in the "
"list of socket options of the ``Connect`` message."
msgstr ""

# fcd96a50a921401dbf3b125da028e240
#: ../../java/io-tcp.rst:36
msgid ""
"The TCP manager will then reply either with a :class:`CommandFailed` or it "
"will spawn an internal actor representing the new connection. This new actor"
" will then send a :class:`Connected` message to the original sender of the "
":class:`Connect` message."
msgstr ""

# 6eb461cc751c426a9d33a5f0778aaedf
#: ../../java/io-tcp.rst:41
msgid ""
"In order to activate the new connection a :class:`Register` message must be "
"sent to the connection actor, informing that one about who shall receive "
"data from the socket. Before this step is done the connection cannot be "
"used, and there is an internal timeout after which the connection actor will"
" shut itself down if no :class:`Register` message is received."
msgstr ""

# 691bdca3ff7b46b4b90403d31782bebc
#: ../../java/io-tcp.rst:47
msgid ""
"The connection actor watches the registered handler and closes the "
"connection when that one terminates, thereby cleaning up all internal "
"resources associated with that connection."
msgstr ""

# 927eabef5a5440259909cc7f9dfa06f3
#: ../../java/io-tcp.rst:51
msgid ""
"The actor in the example above uses :meth:`become` to switch from "
"unconnected to connected operation, demonstrating the commands and events "
"which are observed in that state. For a discussion on :class:`CommandFailed`"
" see `Throttling Reads and Writes`_ below. :class:`ConnectionClosed` is a "
"trait, which marks the different connection close events. The last line "
"handles all connection close events in the same way. It is possible to "
"listen for more fine-grained connection close events, see `Closing "
"Connections`_ below."
msgstr ""

# 359739d628874d1dba8a453d0245e512
#: ../../java/io-tcp.rst:60
msgid "Accepting connections"
msgstr ""

# aa61e5e505264acda7a6d7fa6ea7fa1c
#: ../../java/io-tcp.rst:64
msgid ""
"To create a TCP server and listen for inbound connections, a :class:`Bind` "
"command has to be sent to the TCP manager.  This will instruct the TCP "
"manager to listen for TCP connections on a particular "
":class:`InetSocketAddress`; the port may be specified as ``0`` in order to "
"bind to a random port."
msgstr ""

# e40d72411bfb4bfe8676354623d3d7d3
#: ../../java/io-tcp.rst:69
msgid ""
"The actor sending the :class:`Bind` message will receive a :class:`Bound` "
"message signaling that the server is ready to accept incoming connections; "
"this message also contains the :class:`InetSocketAddress` to which the "
"socket was actually bound (i.e. resolved IP address and correct port "
"number)."
msgstr ""

# 053a59d4d8164deea49c81213b9bed5b
#: ../../java/io-tcp.rst:74
msgid ""
"From this point forward the process of handling connections is the same as "
"for outgoing connections. The example demonstrates that handling the reads "
"from a certain connection can be delegated to another actor by naming it as "
"the handler when sending the :class:`Register` message. Writes can be sent "
"from any actor in the system to the connection actor (i.e. the actor which "
"sent the :class:`Connected` message). The simplistic handler is defined as:"
msgstr ""

# 2d786b4fe21041c5b1890fce5dec071c
#: ../../java/io-tcp.rst:83
msgid ""
"For a more complete sample which also takes into account the possibility of "
"failures when sending please see `Throttling Reads and Writes`_ below."
msgstr ""

# 8d89083cbb2d4baca3cf3efa16f2f5ab
#: ../../java/io-tcp.rst:86
msgid ""
"The only difference to outgoing connections is that the internal actor "
"managing the listen port—the sender of the :class:`Bound` message—watches "
"the actor which was named as the recipient for :class:`Connected` messages "
"in the :class:`Bind` message. When that actor terminates the listen port "
"will be closed and all resources associated with it will be released; "
"existing connections will not be terminated at this point."
msgstr ""

# 6e563b03f6cd4f10a6ea40618d893dee
#: ../../java/io-tcp.rst:94
msgid "Closing connections"
msgstr ""

# 53463ae60eed4b478868fa681da6b93d
#: ../../java/io-tcp.rst:96
msgid ""
"A connection can be closed by sending one of the commands ``Close``, "
"``ConfirmedClose`` or ``Abort`` to the connection actor."
msgstr ""

# cef3bc32178d4f9cb00842b2694340ba
#: ../../java/io-tcp.rst:99
msgid ""
"``Close`` will close the connection by sending a ``FIN`` message, but "
"without waiting for confirmation from the remote endpoint. Pending writes "
"will be flushed. If the close is successful, the listener will be notified "
"with ``Closed``."
msgstr ""

# e448b898c14f4bf58526f1910d30d80e
#: ../../java/io-tcp.rst:103
msgid ""
"``ConfirmedClose`` will close the sending direction of the connection by "
"sending a ``FIN`` message, but data will continue to be received until the "
"remote endpoint closes the connection, too. Pending writes will be flushed. "
"If the close is successful, the listener will be notified with "
"``ConfirmedClosed``."
msgstr ""

# c3aac75d28454b4b91813685d2885cbf
#: ../../java/io-tcp.rst:107
msgid ""
"``Abort`` will immediately terminate the connection by sending a ``RST`` "
"message to the remote endpoint. Pending writes will be not flushed. If the "
"close is successful, the listener will be notified with ``Aborted``."
msgstr ""

# fc4993f6943442b58caf217ea67c7e70
#: ../../java/io-tcp.rst:110
msgid ""
"``PeerClosed`` will be sent to the listener if the connection has been "
"closed by the remote endpoint. Per default, the connection will then "
"automatically be closed from this endpoint as well. To support half-closed "
"connections set the ``keepOpenOnPeerClosed`` member of the ``Register`` "
"message to ``true`` in which case the connection stays open until it "
"receives one of the above close commands."
msgstr ""

# 153c841687c142a2a63caacc561fec18
#: ../../java/io-tcp.rst:115
msgid ""
"``ErrorClosed`` will be sent to the listener whenever an error happened that"
" forced the connection to be closed."
msgstr ""

# 07391bb0ce934ceb9a1ea7d74be196a2
#: ../../java/io-tcp.rst:117
msgid ""
"All close notifications are sub-types of ``ConnectionClosed`` so listeners "
"who do not need fine-grained close events may handle all close events in the"
" same way."
msgstr ""

# fefb659817a54fdc9661a59a4e81c415
#: ../../java/io-tcp.rst:121
msgid "Writing to a connection"
msgstr ""

# d1fd61166e62440297e44015b66ccab6
#: ../../java/io-tcp.rst:123
msgid ""
"Once a connection has been established data can be sent to it from any actor"
" in the form of a ``Tcp.WriteCommand``. ``Tcp.WriteCommand`` is an abstract "
"class with three concrete implementations:"
msgstr ""

# 068cc9718b554b479132d72e9306259a
#: ../../java/io-tcp.rst:127
msgid ""
"The simplest ``WriteCommand`` implementation which wraps a ``ByteString`` "
"instance and an \"ack\" event. A ``ByteString`` (as explained in :ref:`this "
"section <bytestring_java>`) models one or more chunks of immutable in-memory"
" data with a maximum (total) size of 2 GB (2^31 bytes)."
msgstr ""

# 7f500316fb144202b9eeb0fbd8226d6f
#: ../../java/io-tcp.rst:132
msgid ""
"If you want to send \"raw\" data from a file you can do so efficiently with "
"the ``Tcp.WriteFile`` command. This allows you do designate a (contiguous) "
"chunk of on-disk bytes for sending across the connection without the need to"
" first load them into the JVM memory. As such ``Tcp.WriteFile`` can \"hold\""
" more than 2GB of data and an \"ack\" event if required."
msgstr ""

# a0e5339b700744b78677dc7c5d908fd7
#: ../../java/io-tcp.rst:138
msgid ""
"Sometimes you might want to group (or interleave) several ``Tcp.Write`` "
"and/or ``Tcp.WriteFile`` commands into one atomic write command which gets "
"written to the connection in one go. The ``Tcp.CompoundWrite`` allows you to"
" do just that and offers three benefits:"
msgstr ""

# 313091a10000499692510cf596dc698c
#: ../../java/io-tcp.rst:142
msgid ""
"As explained in the following section the TCP connection actor can only "
"handle one single write command at a time. By combining several writes into "
"one ``CompoundWrite`` you can have them be sent across the connection with "
"minimum overhead and without the need to spoon feed them to the connection "
"actor via an *ACK-based* message protocol."
msgstr ""

# acf8b6aec95144cb93565e19263e4520
#: ../../java/io-tcp.rst:147
msgid ""
"Because a ``WriteCommand`` is atomic you can be sure that no other actor can"
" \"inject\" other writes into your series of writes if you combine them into"
" one single ``CompoundWrite``. In scenarios where several actors write to "
"the same connection this can be an important feature which can be somewhat "
"hard to achieve otherwise."
msgstr ""

# 8994356ed3ea48a7b345569b3838888e
#: ../../java/io-tcp.rst:151
msgid ""
"The \"sub writes\" of a ``CompoundWrite`` are regular ``Write`` or "
"``WriteFile`` commands that themselves can request \"ack\" events. These "
"ACKs are sent out as soon as the respective \"sub write\" has been "
"completed. This allows you to attach more than one ACK to a ``Write`` or "
"``WriteFile`` (by combining it with an empty write that itself requests an "
"ACK) or to have the connection actor acknowledge the progress of "
"transmitting the ``CompoundWrite`` by sending out intermediate ACKs at "
"arbitrary points."
msgstr ""

# d000941924794620b3d6a42d1c3cceb7
#: ../../java/io-tcp.rst:158
msgid "Throttling Reads and Writes"
msgstr ""

# f593c5c4554448dfaf7d10300c8df738
#: ../../java/io-tcp.rst:160
msgid ""
"The basic model of the TCP connection actor is that it has no internal "
"buffering (i.e. it can only process one write at a time, meaning it can "
"buffer one write until it has been passed on to the O/S kernel in full). "
"Congestion needs to be handled at the user level, for both writes and reads."
msgstr ""

# 29dd575cb0d247f5be1722cfed22227d
#: ../../java/io-tcp.rst:165
msgid "For back-pressuring writes there are three modes of operation"
msgstr ""

# 09190bb050854f22a52710e3968678d9
#: ../../java/io-tcp.rst:167
msgid ""
"*ACK-based:* every :class:`Write` command carries an arbitrary object, and "
"if this object is not ``Tcp.NoAck`` then it will be returned to the sender "
"of the :class:`Write` upon successfully writing all contained data to the "
"socket. If no other write is initiated before having received this "
"acknowledgement then no failures can happen due to buffer overrun."
msgstr ""

# 0db0c4b8bd7c4494bc2258a6029ef594
#: ../../java/io-tcp.rst:173
msgid ""
"*NACK-based:* every write which arrives while a previous write is not yet "
"completed will be replied to with a :class:`CommandFailed` message "
"containing the failed write. Just relying on this mechanism requires the "
"implemented protocol to tolerate skipping writes (e.g. if each write is a "
"valid message on its own and it is not required that all are delivered). "
"This mode is enabled by setting the ``useResumeWriting`` flag to ``false`` "
"within the :class:`Register` message during connection activation."
msgstr ""

# 16a86db029fa444ba5793db3866cf860
#: ../../java/io-tcp.rst:181
msgid ""
"*NACK-based with write suspending:* this mode is very similar to the NACK-"
"based one, but once a single write has failed no further writes will succeed"
" until a :class:`ResumeWriting` message is received. This message will be "
"answered with a :class:`WritingResumed` message once the last accepted write"
" has completed. If the actor driving the connection implements buffering and"
" resends the NACK’ed messages after having awaited the "
":class:`WritingResumed` signal then every message is delivered exactly once "
"to the network socket."
msgstr ""

# d368ea959ea84c6eb4ffcd8f970960ce
#: ../../java/io-tcp.rst:190
msgid ""
"These write models (with the exception of the second which is rather "
"specialised) are demonstrated in complete examples below. The full and "
"contiguous source is available `on GitHub <@github@/akka-"
"docs/rst/java/code/docs/io/japi>`_."
msgstr ""

# 5b1c98c33cce4b43a5f975c82f919fc4
#: ../../java/io-tcp.rst:194
msgid "For back-pressuring reads there are two modes of operation"
msgstr ""

# 832660f1e8fe4f56ad908012f4d55d33
#: ../../java/io-tcp.rst:196
msgid ""
"*Push-reading:* in this mode the connection actor sends the registered "
"reader actor incoming data as soon as available as :class:`Received` events."
" Whenever the reader actor wants to signal back-pressure to the remote TCP "
"endpoint it can send a :class:`SuspendReading` message to the connection "
"actor to indicate that it wants to suspend the reception of new data. No "
":class:`Received` events will arrive until a corresponding "
":class:`ResumeReading` is sent indicating that the receiver actor is ready "
"again."
msgstr ""

# 62b987364aab45e2972886a5516a0a91
#: ../../java/io-tcp.rst:203
msgid ""
"*Pull-reading:* after sending a :class:`Received` event the connection actor"
" automatically suspends accepting data from the socket until the reader "
"actor signals with a :class:`ResumeReading` message that it is ready to "
"process more input data. Hence new data is \"pulled\" from the connection by"
" sending :class:`ResumeReading` messages."
msgstr ""

# 0921e8375cf84c31b48adb50f1f9f855
#: ../../java/io-tcp.rst:210
msgid ""
"It should be obvious that all these flow control schemes only work between "
"one writer/reader and one connection actor; as soon as multiple actors send "
"write commands to a single connection no consistent result can be achieved."
msgstr ""

# 2982a32c2cae400092f3111a8265bbd7
#: ../../java/io-tcp.rst:215
msgid "ACK-Based Write Back-Pressure"
msgstr ""

# fa4eb671ebce47a8a25c7b4f251e1523
#: ../../java/io-tcp.rst:217
msgid ""
"For proper function of the following example it is important to configure "
"the connection to remain half-open when the remote side closed its writing "
"end: this allows the example :class:`EchoHandler` to write all outstanding "
"data back to the client before fully closing the connection. This is enabled"
" using a flag upon connection activation (observe the :class:`Register` "
"message):"
msgstr ""

# 6e7eb7a41ff44e5db9b5a5a95858468a
#: ../../java/io-tcp.rst:225
msgid "With this preparation let us dive into the handler itself:"
msgstr ""

# 2178abddbec144389c5faff39b3b0c19
#: ../../java/io-tcp.rst:230
msgid ""
"The principle is simple: when having written a chunk always wait for the "
"``Ack`` to come back before sending the next chunk. While waiting we switch "
"behavior such that new incoming data are buffered. The helper functions used"
" are a bit lengthy but not complicated:"
msgstr ""

# 027995afd94d4d4ea5641160f06fbd2e
#: ../../java/io-tcp.rst:237
msgid ""
"The most interesting part is probably the last: an ``Ack`` removes the "
"oldest data chunk from the buffer, and if that was the last chunk then we "
"either close the connection (if the peer closed its half already) or return "
"to the idle behavior; otherwise we just send the next buffered chunk and "
"stay waiting for the next ``Ack``."
msgstr ""

# c4433950bad24713972741115d1c9ca2
#: ../../java/io-tcp.rst:243
msgid ""
"Back-pressure can be propagated also across the reading side back to the "
"writer on the other end of the connection by sending the "
":class:`SuspendReading` command to the connection actor. This will lead to "
"no data being read from the socket anymore (although this does happen after "
"a delay because it takes some time until the connection actor processes this"
" command, hence appropriate head-room in the buffer should be present), "
"which in turn will lead to the O/S kernel buffer filling up on our end, then"
" the TCP window mechanism will stop the remote side from writing, filling up"
" its write buffer, until finally the writer on the other side cannot push "
"any data into the socket anymore. This is how end-to-end back-pressure is "
"realized across a TCP connection."
msgstr ""

# e214c7bb0c2544b48ce6afa589bbe202
#: ../../java/io-tcp.rst:255
msgid "NACK-Based Write Back-Pressure with Suspending"
msgstr ""

# 7953e4063df3489ea0cb642f22a6ebd9
#: ../../java/io-tcp.rst:260
msgid ""
"The principle here is to keep writing until a :class:`CommandFailed` is "
"received, using acknowledgements only to prune the resend buffer. When a "
"such a failure was received, transition into a different state for handling "
"and handle resending of all queued data:"
msgstr ""

# 088069b545284f20a4360ab619e987e1
#: ../../java/io-tcp.rst:267
msgid ""
"It should be noted that all writes which are currently buffered have also "
"been sent to the connection actor upon entering this state, which means that"
" the :class:`ResumeWriting` message is enqueued after those writes, leading "
"to the reception of all outstanding :class:`CommandFailed` messages (which "
"are ignored in this state) before receiving the :class:`WritingResumed` "
"signal. That latter message is sent by the connection actor only once the "
"internally queued write has been fully completed, meaning that a subsequent "
"write will not fail. This is exploited by the :class:`EchoHandler` to switch"
" to an ACK-based approach for the first ten writes after a failure before "
"resuming the optimistic write-through behavior."
msgstr ""

# 9c0f4cb70575483196f7f0fb6be1111d
#: ../../java/io-tcp.rst:280
msgid ""
"Closing the connection while still sending all data is a bit more involved "
"than in the ACK-based approach: the idea is to always send all outstanding "
"messages and acknowledge all successful writes, and if a failure happens "
"then switch behavior to await the :class:`WritingResumed` event and start "
"over."
msgstr ""

# b57a0dcc8a3e4f129cad64c29198c804
#: ../../java/io-tcp.rst:285
msgid "The helper functions are very similar to the ACK-based case:"
msgstr ""

# fc928f8ea22e497d9afff2d07cf02736
#: ../../java/io-tcp.rst:290
msgid "Read Back-Pressure with Pull Mode"
msgstr ""

# 65b1920c251641c59355f90f87430e10
#: ../../java/io-tcp.rst:292
msgid ""
"When using push based reading, data coming from the socket is sent to the "
"actor as soon as it is available. In the case of the previous Echo server "
"example this meant that we needed to maintain a buffer of incoming data to "
"keep it around since the rate of writing might be slower than the rate of "
"the arrival of new data."
msgstr ""

# e798c0544d5a44e9a8235617aa6f945b
#: ../../java/io-tcp.rst:297
msgid ""
"With the Pull mode this buffer can be completely eliminated as the following"
" snippet demonstrates:"
msgstr ""

# 2d368d1be2574c46bf8986de15f96f63
#: ../../java/io-tcp.rst:302
msgid ""
"The idea here is that reading is not resumed until the previous write has "
"been completely acknowledged by the connection actor. Every pull mode "
"connection actor starts from suspended state. To start the flow of data we "
"send a ``ResumeReading`` in the ``preStart`` method to tell the connection "
"actor that we are ready to receive the first chunk of data. Since we only "
"resume reading when the previous data chunk has been completely written "
"there is no need for maintaining a buffer."
msgstr ""

# 5f824777a3b94c3da59617f0cdee2543
#: ../../java/io-tcp.rst:310
msgid ""
"To enable pull reading on an outbound connection the ``pullMode`` parameter "
"of the :class:`Connect` should be set to ``true``:"
msgstr ""

# 74fc5b6051f24cb1840073f31f54ec73
#: ../../java/io-tcp.rst:316
msgid "Pull Mode Reading for Inbound Connections"
msgstr ""

# 325afdb49d7949e98e9b938615ce79ce
#: ../../java/io-tcp.rst:318
msgid ""
"The previous section demonstrated how to enable pull reading mode for "
"outbound connections but it is possible to create a listener actor with this"
" mode of reading by setting the ``pullMode`` parameter of the :class:`Bind` "
"command to ``true``:"
msgstr ""

# 5b9c47c3de6948f3a88d9d2ade7f7fef
#: ../../java/io-tcp.rst:324
msgid ""
"One of the effects of this setting is that all connections accepted by this "
"listener actor will use pull mode reading."
msgstr ""

# a084075413e04d618007178591c62362
#: ../../java/io-tcp.rst:327
msgid ""
"Another effect of this setting is that in addition of setting all inbound "
"connections to pull mode, accepting connections becomes pull based, too. "
"This means that after handling one (or more) :class:`Connected` events the "
"listener actor has to be resumed by sending it a :class:`ResumeAccepting` "
"message."
msgstr ""

# f409731ae9b4410fbb904fada5113108
#: ../../java/io-tcp.rst:332
msgid ""
"Listener actors with pull mode start suspended so to start accepting "
"connections a :class:`ResumeAccepting`  command has to be sent to the "
"listener actor after binding was successful:"
msgstr ""

# 04a2925703bb42e9b431b34e49a0a237
#: ../../java/io-tcp.rst:337
msgid ""
"As shown in the example after handling an incoming connection we need to "
"resume accepting again. The :class:`ResumeAccepting` message accepts a "
"``batchSize`` parameter that specifies how many new connections are accepted"
" before a next :class:`ResumeAccepting` message is needed to resume handling"
" of new connections."
msgstr ""

# 0537a842a2604d15bb021cf42a7f1e1d
#: ../../java/io-udp.rst:4
msgid "Using UDP"
msgstr ""

# f5fea303f77d411a9ebf10ac2beca567
#: ../../java/io-udp.rst:6
msgid ""
"UDP is a connectionless datagram protocol which offers two different ways of"
" communication on the JDK level:"
msgstr ""

# 4aeee0f377344dfe92637fb0b9982bef
#: ../../java/io-udp.rst:9
msgid ""
"sockets which are free to send datagrams to any destination and receive "
"datagrams from any origin"
msgstr ""

# 3600acf976214b5b87f312fb87e4c8ac
#: ../../java/io-udp.rst:12
msgid ""
"sockets which are restricted to communication with one specific remote "
"socket address"
msgstr ""

# 0b8b69520a7b440895a99c43ed76b7a4
#: ../../java/io-udp.rst:15
msgid ""
"In the low-level API the distinction is made—confusingly—by whether or not "
":meth:`connect` has been called on the socket (even when connect has been "
"called the protocol is still connectionless). These two forms of UDP usage "
"are offered using distinct IO extensions described below."
msgstr ""

# c40107948dd04cb891e5e6a6730dcc4a
#: ../../java/io-udp.rst:21
msgid "Unconnected UDP"
msgstr ""

# d1a454074ccc450ab42d8ef32528a5ca
#: ../../java/io-udp.rst:24
msgid "Simple Send"
msgstr ""

# 1caedc1ac45a4f479ad0819fbece85ef
#: ../../java/io-udp.rst:28
msgid ""
"The simplest form of UDP usage is to just send datagrams without the need of"
" getting a reply. To this end a “simple sender” facility is provided as "
"demonstrated above. The UDP extension is queried using the "
":meth:`simpleSender` message, which is answered by a "
":class:`SimpleSenderReady` notification. The sender of this message is the "
"newly created sender actor which from this point onward can be used to send "
"datagrams to arbitrary destinations; in this example it will just send any "
"UTF-8 encoded :class:`String` it receives to a predefined remote address."
msgstr ""

# 81f3c401e59342909cf6aa040d83bad3
#: ../../java/io-udp.rst:39
msgid ""
"The simple sender will not shut itself down because it cannot know when you "
"are done with it. You will need to send it a :class:`PoisonPill` when you "
"want to close the ephemeral port the sender is bound to."
msgstr ""

# 85cbcc04938f4a49aa386fc515566319
#: ../../java/io-udp.rst:44
msgid "Bind (and Send)"
msgstr ""

# 50757fab9b2d4f1eae406d31767b9b1e
#: ../../java/io-udp.rst:48
msgid ""
"If you want to implement a UDP server which listens on a socket for incoming"
" datagrams then you need to use the :meth:`bind` command as shown above. The"
" local address specified may have a zero port in which case the operating "
"system will automatically choose a free port and assign it to the new "
"socket. Which port was actually bound can be found out by inspecting the "
":class:`Bound` message."
msgstr ""

# 78c0fb60d321454bb2eae0acb17e67e8
#: ../../java/io-udp.rst:55
msgid ""
"The sender of the :class:`Bound` message is the actor which manages the new "
"socket. Sending datagrams is achieved by using the :meth:`send` message type"
" and the socket can be closed by sending a :meth:`unbind` command, in which "
"case the socket actor will reply with a :class:`Unbound` notification."
msgstr ""

# b7520d6084f940e98d6c2af5d2a6cc21
#: ../../java/io-udp.rst:60
msgid ""
"Received datagrams are sent to the actor designated in the :meth:`bind` "
"message, whereas the :class:`Bound` message will be sent to the sender of "
"the :meth:`bind`."
msgstr ""

# 36570ef31ad848b99a8c3eeac1f88cfc
#: ../../java/io-udp.rst:65
msgid "Connected UDP"
msgstr ""

# 1049ee88a98d48dfb6e88c90a53f57a8
#: ../../java/io-udp.rst:67
msgid ""
"The service provided by the connection based UDP API is similar to the bind-"
"and-send service we saw earlier, but the main difference is that a "
"connection is only able to send to the ``remoteAddress`` it was connected "
"to, and will receive datagrams only from that address."
msgstr ""

# 67a7cc609a454607a11ca04b742afe8f
#: ../../java/io-udp.rst:74
msgid ""
"Consequently the example shown here looks quite similar to the previous one,"
" the biggest difference is the absence of remote address information in "
":meth:`send` and :class:`Received` messages."
msgstr ""

# 10ef40592bc54f7e8ecae992225e362f
#: ../../java/io-udp.rst:80
msgid ""
"There is a small performance benefit in using connection based UDP API over "
"the connectionless one.  If there is a SecurityManager enabled on the "
"system, every connectionless message send has to go through a security "
"check, while in the case of connection-based UDP the security check is "
"cached after connect, thus writes do not suffer an additional performance "
"penalty."
msgstr ""

# f26cc1ed49984ebc88200cd7a20f78bd
#: ../../java/io-udp.rst:87
msgid "UDP Multicast"
msgstr ""

# fb741f1ed31f494fbffdd8c64a6d7e7a
#: ../../java/io-udp.rst:89
msgid ""
"If you want to use UDP multicast you will need to use Java 7. Akka provides "
"a way to control various options of ``DatagramChannel`` through the "
"``akka.io.Inet.SocketOption`` interface. The example below shows how to "
"setup a receiver of multicast messages using IPv6 protocol."
msgstr ""

# dce5aa1e53f44c94883b5d9506e0d45b
#: ../../java/io-udp.rst:94
msgid ""
"To select a Protocol Family you must extend "
"``akka.io.Inet.DatagramChannelCreator`` class which implements "
"``akka.io.Inet.SocketOption``. Provide custom logic for opening a datagram "
"channel by overriding :meth:`create` method."
msgstr ""

# 93a07b74426143e5a3de467cfdf6c2a4
#: ../../java/io-udp.rst:100
msgid "Another socket option will be needed to join a multicast group."
msgstr ""

# 25c219a2307549d48baee541e6be18f3
#: ../../java/io-udp.rst:104
msgid "Socket options must be provided to :meth:`UdpMessage.bind` command."
msgstr ""

# 12e745c9e0aa4b11bcb6796f02585d7e
# b01d66d479714a0087381c609b821867
#: ../../java/lambda-actors.rst:5 ../../java/lambda-index-actors.rst:4
msgid "Actors (Java with Lambda Support)"
msgstr ""

# 565303d318f9453eb919f25be8d6a631
# d73868be2f7640a89eb64faa2403d0a1
#: ../../java/lambda-actors.rst:7 ../../java/untyped-actors.rst:8
msgid ""
"The `Actor Model`_ provides a higher level of abstraction for writing "
"concurrent and distributed systems. It alleviates the developer from having "
"to deal with explicit locking and thread management, making it easier to "
"write correct concurrent and parallel systems. Actors were defined in the "
"1973 paper by Carl Hewitt but have been popularized by the Erlang language, "
"and used for example at Ericsson with great success to build highly "
"concurrent and reliable telecom systems."
msgstr ""
"`アクターモデル`は並行分散システムを作るための高度な抽象を提供します。アクターモデルを用いることで開発者は明示的なロックやスレッドの管理を行う労力を軽減した上で信頼性のある並行並列なシステムを作ることができます。アクターは"
" Cal Herwitt が1973年に論文として発表したものですが、Erlangによって世に広められ、この成功例として Ericsson "
"社による高い並行性と信頼性を持つ電気通信システムの構築が挙げられます。"

# 94c645f3dfcf465fa3ea0ff1420cf0d4
# d565591007634b2bb407de9b9aaadbb8
#: ../../java/lambda-actors.rst:15 ../../java/untyped-actors.rst:16
msgid ""
"The API of Akka’s Actors is similar to Scala Actors which has borrowed some "
"of its syntax from Erlang."
msgstr "Akka のアクターは Erlang からシンタックスを拝借した Scala のアクターと似ています。"

# fe51492e8ca24c1c98ef8b9c66d94abf
#: ../../java/lambda-actors.rst:22
msgid ""
"The Java with lambda support part of Akka is marked as **“experimental”** as"
" of its introduction in Akka 2.3.0. We will continue to improve this API "
"based on our users’ feedback, which implies that while we try to keep "
"incompatible changes to a minimum, but the binary compatibility guarantee "
"for maintenance releases does not apply to the "
":class:`akka.actor.AbstractActor`, related classes and the "
":class:`akka.japi.pf` package."
msgstr ""

# aa4a19e6eee44d708c475bdc1304ba5e
# a069e4879dbb4ea98dfd2ec054df5d46
#: ../../java/lambda-actors.rst:29 ../../java/untyped-actors.rst:23
msgid "Creating Actors"
msgstr "アクターの生成"

# 55f61e07cbd141e8ba4ad595b75952cf
# e1c474b16527402aa5ae82776461d1c3
#: ../../java/lambda-actors.rst:33 ../../java/untyped-actors.rst:27
msgid ""
"Since Akka enforces parental supervision every actor is supervised and "
"(potentially) the supervisor of its children, it is advisable that you "
"familiarize yourself with :ref:`actor-systems` and :ref:`supervision` and it"
" may also help to read :ref:`addressing`."
msgstr ""
"Akka では全てのアクターが親となるアクターに監視され、同時に子供のアクターの supervisor "
"になる(可能性がある)という方式をとっています。この方式については :ref:`actor-systems` や :ref:`supervision` "
"あるいは :ref:`addressing` といった記事を参考に読んでみるとよいでしょう。"

# e3f958c82822402fa58c9d6fb402792a
# 4b5a07b537ce411a954488bac8927c5f
#: ../../java/lambda-actors.rst:39 ../../java/untyped-actors.rst:33
msgid "Defining an Actor class"
msgstr "アクターのクラスを定義する"

# 4600c9645ad245a2abef17352b8f52d4
#: ../../java/lambda-actors.rst:41
msgid ""
"Actor classes are implemented by extending the :class:`AbstractActor` class "
"and setting the “initial behavior” in the constructor by calling the "
":meth:`receive` method in the :class:`AbstractActor`."
msgstr ""

# 2459d6235b6241288311bb212dc18008
#: ../../java/lambda-actors.rst:45
msgid ""
"The argument to the :meth:`receive` method is a "
"``PartialFunction<Object,BoxedUnit>`` that defines which messages your Actor"
" can handle, along with the implementation of how the messages should be "
"processed."
msgstr ""

# 4ba7dd9bc99c4793be358fd38915b837
# 751ef06ca19a410f831fc621ba6254ea
#: ../../java/lambda-actors.rst:49 ../../java/lambda-actors.rst:631
msgid ""
"Don't let the type signature scare you. To allow you to easily build up a "
"partial function there is a builder named ``ReceiveBuilder`` that you can "
"use."
msgstr ""

# ba5c99ae7cc742dba69f18bad6f91d7c
# a08924f6f795420992d8b88c55b3af4f
# 95bcf1677906478287f8661b63534799
# d9b7be894c49467e87a030dd8dbb98e8
#: ../../java/lambda-actors.rst:52 ../../java/lambda-actors.rst:634
#: ../../java/untyped-actors.rst:38 ../../java/untyped-actors.rst:578
msgid "Here is an example:"
msgstr "以下はこのサンプルコードです。"

# d8de717e27314da5af630ecd79d9d3c1
#: ../../java/lambda-actors.rst:57
msgid ""
"Please note that the Akka Actor ``receive`` message loop is exhaustive, "
"which is different compared to Erlang and the late Scala Actors. This means "
"that you need to provide a pattern match for all messages that it can accept"
" and if you want to be able to handle unknown messages then you need to have"
" a default case as in the example above. Otherwise an "
"``akka.actor.UnhandledMessage(message, sender, recipient)`` will be "
"published to the ``ActorSystem``'s ``EventStream``."
msgstr ""
"Akkaのアクターの``receive``メッセージループは網羅的であるということに注意してください。これはErlangやScala言語組み込みのアクターとは異なっています。つまり受け取ることのできる全てのメッセージについてのパターンマッチを書く必要があり、未知のメッセージを処理したい場合はデフォルトのcaseを書かなければいけません。これを行わなかった場合は"
" ``ActorSystem``の``EventStream``に`akka.actor.UnhandledMessage(message, "
"sender, recipient)``が発行されます。"

# fc66345bc0544c3fb790aa362ef9d613
#: ../../java/lambda-actors.rst:65
msgid ""
"Note further that the return type of the behavior defined above is ``Unit``;"
" if the actor shall reply to the received message then this must be done "
"explicitly as explained below."
msgstr ""
"また、振る舞いの戻り値の型が``Unit``であることにも注意してください。アクターが受け取ったメッセージに対して応答を返す場合、後で説明するようにこれを明示的に行う必要があります。"

# 7259f296cecb4b4b85b1539d9765b552
#: ../../java/lambda-actors.rst:69
msgid ""
"The argument to the :meth:`receive` method is a partial function object, "
"which is stored within the actor as its “initial behavior”, see "
"`Become/Unbecome`_ for further information on changing the behavior of an "
"actor after its construction."
msgstr ""

# 301ef38c102d4f2d851ef8671ede6ee9
# 9e1feb4bf4d14480b898026e257c0578
#: ../../java/lambda-actors.rst:75 ../../java/untyped-actors.rst:43
msgid "Props"
msgstr "Props"

# 7c61e15bfe594524b4d0ae014deae986
# d044586b65e94b958327fe4c5ed7c7b5
#: ../../java/lambda-actors.rst:77 ../../java/untyped-actors.rst:45
msgid ""
":class:`Props` is a configuration class to specify options for the creation "
"of actors, think of it as an immutable and thus freely shareable recipe for "
"creating an actor including associated deployment information (e.g. which "
"dispatcher to use, see more below). Here are some examples of how to create "
"a :class:`Props` instance."
msgstr ""
":class:`Propsはアクターを生成するときのオプションを指定するための設定クラスです。このクラスのインスタンスは不変なので気軽に共有することができるアクターを生成するためのレシピと考えることができます。また、このレシピにはデプロイに関係した情報(例えばどのdispatcherを使うかとかいったもの)も含めることができます。"

# 49e11c6ab7c34283be7369b1fd5d7189
#: ../../java/lambda-actors.rst:86
msgid ""
"The second variant shows how to pass constructor arguments to the "
":class:`Actor` being created, but it should only be used outside of actors "
"as explained below."
msgstr ""
"二つ目のやり方は生成する:class:`Actor`にどのように引数を渡すかということを例示していますが、後で説明するように、アクターの外側のみで用いるべきやり方です。"

# e513786b14a84e438fb169eba0d266ca
#: ../../java/lambda-actors.rst:90
msgid ""
"The last line shows a possibility to pass constructor arguments regardless "
"of the context it is being used in. The presence of a matching constructor "
"is verified during construction of the :class:`Props` object, resulting in "
"an :class:`IllegalArgumentException` if no or multiple matching constructors"
" are found."
msgstr ""
"最後のやり方はアクターのコンストラクタに引数を渡す場合にどのようなコンテクストでも使うことができるやり方です。Propsオブジェクトの中でどのコンストラクタを用いるべきかということを調べて、適当なコンストラクタが見つからなかった場合や複数のコンストラクタにマッチしてしまった場合には:class:`IllegalArgumentException`"
" となってしまいます。"

# 5744665edcdf4a0b83174ac7b6248132
#: ../../java/lambda-actors.rst:97
msgid "Dangerous Variants"
msgstr "危険な方法"

# 28300bb52ae6490bbf4704a38c67ca87
#: ../../java/lambda-actors.rst:101
msgid ""
"This method is not recommended to be used within another actor because it "
"encourages to close over the enclosing scope, resulting in non-serializable "
":class:`Props` and possibly race conditions (breaking the actor "
"encapsulation). On the other hand using this variant in a :class:`Props` "
"factory in the actor’s companion object as documented under “Recommended "
"Practices” below is completely fine."
msgstr ""

# 71a574ab5ec043359a870cc1a7cd0316
#: ../../java/lambda-actors.rst:108
msgid ""
"There were two use-cases for these methods: passing constructor arguments to"
" the actor—which is solved by the newly introduced "
":meth:`Props.create(clazz, args)` method above or the recommended practice "
"below—and creating actors “on the spot” as anonymous classes. The latter "
"should be solved by making these actors named classes instead (if they are "
"not declared within a top-level ``object`` then the enclosing instance’s "
"``this`` reference needs to be passed as the first argument)."
msgstr ""

# 4ce6305407634a279859f21a6fc9a155
#: ../../java/lambda-actors.rst:118
msgid ""
"Declaring one actor within another is very dangerous and breaks actor "
"encapsulation. Never pass an actor’s ``this`` reference into :class:`Props`!"
msgstr ""
"あるアクターを別のアクターの中で宣言することは非常に危険でアクターのカプセル化を破壊してしまいます。アクターの\"this\"への参照を:class:`Props`に渡してしまわないように注意してください。"

# dce7fd2c3d364b8ab5918893bb05e134
# 72d97cce04fe492a816ec499e21262ce
#: ../../java/lambda-actors.rst:122 ../../java/untyped-actors.rst:77
msgid "Recommended Practices"
msgstr "推奨される手法"

# d785dd1bfd24492984028c7e3e6dbe29
#: ../../java/lambda-actors.rst:124
msgid ""
"It is a good idea to provide factory methods on the companion object of each"
" :class:`Actor` which help keeping the creation of suitable :class:`Props` "
"as close to the actor definition as possible. This also avoids the pitfalls "
"associated with using the ``Props.create(...)`` method which takes a by-name"
" argument, since within a companion object the given code block will not "
"retain a reference to its enclosing scope:"
msgstr ""

# 2a2328ac1bee4b14bcfeb664260f36fa
# 609bc53eee744e11982fc6e826d2ec32
#: ../../java/lambda-actors.rst:133 ../../java/untyped-actors.rst:87
msgid ""
"Another good practice is to declare what messages an Actor can receive as "
"close to the actor definition as possible (e.g. as static classes inside the"
" Actor or using other suitable class), which makes it easier to know what it"
" can receive."
msgstr ""

# f72c6ce486734ef29a7d570c60c82749
# 65f6174dd7584a97934e2129f351160e
#: ../../java/lambda-actors.rst:141 ../../java/untyped-actors.rst:95
msgid "Creating Actors with Props"
msgstr "Propsを使ったアクターの生成"

# 871676ffc5c54c20934219cfe831a02a
# 5f4792b32a9e4cf4ba69d03dafe6d6c7
#: ../../java/lambda-actors.rst:143 ../../java/untyped-actors.rst:97
msgid ""
"Actors are created by passing a :class:`Props` instance into the "
":meth:`actorOf` factory method which is available on :class:`ActorSystem` "
"and :class:`ActorContext`."
msgstr ""
"アクターは:class:`Props`のインスタンスを:class:`ActorSystem`や:class:`ActorContext`が持っている:meth:`actorOf`というファクトリメソッドに渡すことで生成できます。"

# 6497b10d1d314ad89467898ec6671005
# c35190322e374b1d9568d9c4e40d1215
#: ../../java/lambda-actors.rst:150 ../../java/untyped-actors.rst:104
msgid ""
"Using the :class:`ActorSystem` will create top-level actors, supervised by "
"the actor system’s provided guardian actor, while using an actor’s context "
"will create a child actor."
msgstr ""
":class:`ActorSystem`を使うとトップレベルのアクターを生成できます。トップレベルのアクターはアクターシステムが提供しているガーディアンアクターによって監視されます。一方でコンテクストから生成したアクターはそのアクターの子アクターになります。"

# 749a48c73a4f422fa15b031b393cec50
# 94bbf84af11744aa89ad02225d6a2255
#: ../../java/lambda-actors.rst:157 ../../java/untyped-actors.rst:111
msgid ""
"It is recommended to create a hierarchy of children, grand-children and so "
"on such that it fits the logical failure-handling structure of the "
"application, see :ref:`actor-systems`."
msgstr ""
"子供から孫といった階層を作るようにしてください。そのようにすることでアプリケーションの論理的なエラー処理の構造を作ることができます。詳しくは:ref"
":`actor-systems`を参照してください。"

# c97d6fedf13a435692ddc9df032563f0
# 6282d161ad6745d0bee5b9d49de230c0
#: ../../java/lambda-actors.rst:161 ../../java/untyped-actors.rst:115
msgid ""
"The call to :meth:`actorOf` returns an instance of :class:`ActorRef`. This "
"is a handle to the actor instance and the only way to interact with it. The "
":class:`ActorRef` is immutable and has a one to one relationship with the "
"Actor it represents. The :class:`ActorRef` is also serializable and network-"
"aware. This means that you can serialize it, send it over the wire and use "
"it on a remote host and it will still be representing the same Actor on the "
"original node, across the network."
msgstr ""
":meth:`actorOf`を呼ぶことで:class:`ActorRef`のインスタンスを得ることができます。:class:`ActorRef`はアクターのインスタンスとつながっていて、アクターと対話するための唯一の手段となります。:class:`ActorRef`は不変でそれが表現しているアクターと一対一の関係を持っています。:class:`ActorRef`は永続化可能なのでネットワークを介することができます。つまり、シリアライズしたインスタンスをリモートのホストに送信した場合、元のノードのアクターをネットワークを超えて表現することができます。"

# e391ea0dc5d44a95b19689bc3f7c4e7c
# dfafd2da7c334ccebdfc1cba92136c6f
#: ../../java/lambda-actors.rst:169 ../../java/untyped-actors.rst:123
msgid ""
"The name parameter is optional, but you should preferably name your actors, "
"since that is used in log messages and for identifying actors. The name must"
" not be empty or start with ``$``, but it may contain URL encoded characters"
" (eg. ``%20`` for a blank space).  If the given name is already in use by "
"another child to the same parent an `InvalidActorNameException` is thrown."
msgstr ""

# eb559e969dba442d8ff0538f1c567524
# 73e76e299aeb4e09ba39136a081a7ac5
#: ../../java/lambda-actors.rst:175 ../../java/untyped-actors.rst:129
msgid "Actors are automatically started asynchronously when created."
msgstr "アクターは生成されたら非同期に自動的に開始されます。"

# e01e3d8a57ef44ebbd926a687825c23c
# f4a9977449114c1e80d353391fe75e8b
#: ../../java/lambda-actors.rst:180 ../../java/untyped-actors.rst:134
msgid "Dependency Injection"
msgstr "依存性の注入"

# b82c0a4a8a2e44368208b1fc827544f4
# 47bade2f7dd547d2b948827a2d08263b
#: ../../java/lambda-actors.rst:182 ../../java/untyped-actors.rst:136
msgid ""
"If your UntypedActor has a constructor that takes parameters then those need"
" to be part of the :class:`Props` as well, as described `above`__. But there"
" are cases when a factory method must be used, for example when the actual "
"constructor arguments are determined by a dependency injection framework."
msgstr ""

# 3c0bb7fb027149cfa21a972546fbf90e
# d78d9a79fdfd4a2092f4a33e96e957d0
#: ../../java/lambda-actors.rst:196 ../../java/untyped-actors.rst:150
msgid ""
"You might be tempted at times to offer an :class:`IndirectActorProducer` "
"which always returns the same instance, e.g. by using a static field. This "
"is not supported, as it goes against the meaning of an actor restart, which "
"is described here: :ref:`supervision-restart`."
msgstr ""

# 13482935cc204ba0a98865faa07ca2ff
# e60ed59dc4224cdc8b42cb05257be6e4
#: ../../java/lambda-actors.rst:201 ../../java/untyped-actors.rst:155
msgid ""
"When using a dependency injection framework, actor beans *MUST NOT* have "
"singleton scope."
msgstr "依存性の注入を行うフレームワークを使う場合、アクターのbeanはシングルトンスコープであることは*許可されません*。"

# 9265a680dbd744208af627a8491a9b10
# 865a8faa8be8464ab701e8ec532ebd53
#: ../../java/lambda-actors.rst:204 ../../java/untyped-actors.rst:158
msgid ""
"Techniques for dependency injection and integration with dependency "
"injection frameworks are described in more depth in the `Using Akka with "
"Dependency Injection <http://letitcrash.com/post/55958814293/akka-"
"dependency-injection>`_ guideline and the `Akka Java Spring "
"<http://www.lightbend.com/activator/template/akka-java-spring>`_ tutorial in"
" Lightbend Activator."
msgstr ""
"依存性の注入のためのテクニックや依存性注入を行うフレームワークとの統合については`Using Akka with Dependency "
"Injection  <http://letitcrash.com/post/55958814293/akka-dependency-"
"injection>`_ guidelineやLightbend Activatorの中の`Akka Java Spring "
"<http://www.lightbend.com/activator/template/akka-java-spring>`_ "
"tutorialにより詳しい情報があります。"

# 03f79c42378048f19c854e02cb2c719b
# 14515ca418b44d09a4fcbcfd749bcb7c
#: ../../java/lambda-actors.rst:211 ../../java/untyped-actors.rst:165
msgid "The Inbox"
msgstr "Inbox"

# 831498c4e889409cb284cf39cde22f8b
# 324200b201094c0888e2f2f4c1b11cb9
#: ../../java/lambda-actors.rst:213 ../../java/untyped-actors.rst:167
msgid ""
"When writing code outside of actors which shall communicate with actors, the"
" ``ask`` pattern can be a solution (see below), but there are two things it "
"cannot do: receiving multiple replies (e.g. by subscribing an "
":class:`ActorRef` to a notification service) and watching other actors’ "
"lifecycle. For these purposes there is the :class:`Inbox` class:"
msgstr ""
"アクターの外側のコードからアクターと通信をする場合、``ask``パターン(後で出てきます)を使うのが一つの方法ですが、それを使えない場合が二つあります。一つは複数のメッセージを受け取るような場合(例えば通知サービスとして実装されている:class:`ActorRef`を購読する場合)で、もう一つはActorのライフサイクルをwatchしている場合です。こういった場合のために:class:`Inbox`というクラスが用意されています。"

# feed54e1ee464df0895a5addc0be0965
# 9d298765c8fb4e7d966e21f92738ce41
#: ../../java/lambda-actors.rst:221 ../../java/untyped-actors.rst:175
msgid ""
"The :meth:`send` method wraps a normal :meth:`tell` and supplies the "
"internal actor’s reference as the sender. This allows the reply to be "
"received on the last line.  Watching an actor is quite simple as well:"
msgstr ""

# 34a47716637c45a2a5ea51feeb88e8c7
#: ../../java/lambda-actors.rst:228
msgid "Actor API"
msgstr "Actor API"

# e0107ee8e0e14a8da6e56b3eb4b396d5
#: ../../java/lambda-actors.rst:230
msgid ""
"The :class:`AbstractActor` class defines a method called :meth:`receive`, "
"that is used to set the “initial behavior” of the actor."
msgstr ""

# 316fda88435b4efa8f81c34072b3e07e
#: ../../java/lambda-actors.rst:233
msgid ""
"If the current actor behavior does not match a received message, "
":meth:`unhandled` is called, which by default publishes an "
"``akka.actor.UnhandledMessage(message, sender, recipient)`` on the actor "
"system’s event stream (set configuration item ``akka.actor.debug.unhandled``"
" to ``on`` to have them converted into actual Debug messages)."
msgstr ""
"現在のアクターの振る舞いが受け取ったメッセージを処理できない場合、:meth:`unhandled`が呼ばれ、そのデフォルトの実装では``akka.actor.UnhandledMessage(message,"
" sender, "
"recipient)``をアクターシステムのイベントストリームに発行します(これは``akka.actor.debug.unhandled``という設定を``on``にすることで実際のデバッグのメッセージに変換されます)。"

# 18295e9df81745bfa14b304e3e1eb12f
# cd06933b1f57407391669b110dd48ffe
#: ../../java/lambda-actors.rst:240 ../../java/untyped-actors.rst:193
msgid "In addition, it offers:"
msgstr ":class:`Actor` traitには他にも以下のようなメソッドがあります。"

# b6512a4802a14fa2b9a233d57e9622d3
#: ../../java/lambda-actors.rst:242
msgid ":meth:`self()` reference to the :class:`ActorRef` of the actor"
msgstr ""

# 73d9f4f3c2944399a01be2d2607e97d3
#: ../../java/lambda-actors.rst:244
msgid ""
":meth:`sender()` reference sender Actor of the last received message, "
"typically used as described in :ref:`LambdaActor.Reply`"
msgstr ""

# 7da47012ba7942d6a55c6523e1114a53
# 3bbfb05e06984df4af94c7aa19bc6bc5
#: ../../java/lambda-actors.rst:246 ../../java/untyped-actors.rst:199
msgid ""
":meth:`supervisorStrategy()` user overridable definition the strategy to use"
" for supervising child actors"
msgstr ""

# 7504a76e05174972bbbabc6f8e03c816
#: ../../java/lambda-actors.rst:248
msgid ""
"This strategy is typically declared inside the actor in order to have access"
" to the actor’s internal state within the decider function: since failure is"
" communicated as a message sent to the supervisor and processed like other "
"messages (albeit outside of the normal behavior), all values and variables "
"within the actor are available, as is the ``sender`` reference (which will "
"be the immediate child reporting the failure; if the original failure "
"occurred within a distant descendant it is still reported one level up at a "
"time)."
msgstr ""
"このストラテジーは戦略を決めるための関数の中でアクターの内部状態にアクセスするため、通常アクターの中で宣言します。障害は supervisor "
"にメッセージとして通知され、他のメッセージと同じように処理されます。(通常の振る舞いの外側に置かれるものの)この関数の中ではアクター内部の全ての値や変数、\"sender\"への参照を利用することができます。(これは直接の子アクターが報告した障害の情報に含まれます。元となる障害が孫以上の子孫の場合でも障害が起きた階層の"
" sender が報告されます。)"

# ced31b6a38674579bf8cd63b68d229c4
#: ../../java/lambda-actors.rst:257
msgid ""
":meth:`context()` exposes contextual information for the actor and the "
"current message, such as:"
msgstr ""

# f5ebcbce79294742a6c29fad7394efa0
# 1875d809bb7a4ab1bf4d991e83e647a5
#: ../../java/lambda-actors.rst:259 ../../java/untyped-actors.rst:212
msgid "factory methods to create child actors (:meth:`actorOf`)"
msgstr "子アクターを作るためのファクトリメソッド(:meth:`actorOf`)"

# 262894ba9c1f44e9b0b25338c5c373eb
# 455e1c2e1fe04000b134a14871de01d4
#: ../../java/lambda-actors.rst:260 ../../java/untyped-actors.rst:213
msgid "system that the actor belongs to"
msgstr "アクターが所属しているシステム"

# 9a50a75a0502464fac273ae5ce393af8
# 15477ce259bd46559c5c49be819b24b4
#: ../../java/lambda-actors.rst:261 ../../java/untyped-actors.rst:214
msgid "parent supervisor"
msgstr "supervisorである親アクター"

# a7e435b5b1744521b414abcc10e2f160
# b30f43d8a5314719a7ab6148ce0f4054
#: ../../java/lambda-actors.rst:262 ../../java/untyped-actors.rst:215
msgid "supervised children"
msgstr "監視している子アクター"

# 8fc1d437dc5940ffba6c8e1ec87d3faa
# 72cf69e188094dda9e0dc702b1649496
#: ../../java/lambda-actors.rst:263 ../../java/untyped-actors.rst:216
msgid "lifecycle monitoring"
msgstr "ライフサイクルの監視"

# f993adf175b84a4791b386e11474ffba
#: ../../java/lambda-actors.rst:264
msgid "hotswap behavior stack as described in :ref:`actor-hotswap-lambda`"
msgstr ""

# 4da4fb48922e44968320db7d2a3f6de4
# 915278c3086542d2ac6499451798b3d8
#: ../../java/lambda-actors.rst:266 ../../java/untyped-actors.rst:219
msgid ""
"The remaining visible methods are user-overridable life-cycle hooks which "
"are described in the following:"
msgstr ""
"ここまででまだ残っているアクセス可能なメソッドはユーザがオーバーライドすることで以下の述べるアクターのライフサイクルにフックすることができるメソッドです。"

# d98d2be8f8e54170a0ed5f6f10b76752
#: ../../java/lambda-actors.rst:271
msgid ""
"The implementations shown above are the defaults provided by the "
":class:`AbstractActor` class."
msgstr ""

# 697bee2feca94e46a6c2a7960488fb28
# 6c0edfd622ef4485aef36a2317af23a8
#: ../../java/lambda-actors.rst:275 ../../java/untyped-actors.rst:230
msgid "Actor Lifecycle"
msgstr "アクターのライフサクル"

# 5a1b5ef934b44a2190cca12e705ffee2
# 273d80413a0244cf841423ac64ff2cba
#: ../../java/lambda-actors.rst:281 ../../java/untyped-actors.rst:236
msgid ""
"A path in an actor system represents a \"place\" which might be occupied by "
"a living actor. Initially (apart from system initialized actors) a path is "
"empty. When ``actorOf()`` is called it assigns an *incarnation* of the actor"
" described by the passed ``Props`` to the given path. An actor incarnation "
"is identified by the path *and a UID*. A restart only swaps the ``Actor`` "
"instance defined by the ``Props`` but the incarnation and hence the UID "
"remains the same."
msgstr ""
"アクターシステムにおけるパスは生存しているアクターによって占有されている\"場所\"を表現しています。始めは(システムによって初期化されたアクターを除き)パスは空になっています。"
" ``actorOf()`` を呼びだすと ``Prop`` "
"で表現されたアクターの*インカーネーション*が与えられたパスに生成されます。アクターのインカーネーションはパスと *UID* "
"によって識別されます。再起動が行われたときには ``Actor`` のインスタンスは置き換えられますが、インカーネーションの方は置き換えられないので "
"UID は同じものになります。"

# 4aa64314bfbd45f692db307bbea1ad29
#: ../../java/lambda-actors.rst:289
msgid ""
"The lifecycle of an incarnation ends when the actor is stopped. At that "
"point the appropriate lifecycle events are called and watching actors are "
"notified of the termination. After the incarnation is stopped, the path can "
"be reused again by creating an actor with ``actorOf()``. In this case the "
"name of the new incarnation will be the same as the previous one but the "
"UIDs will differ."
msgstr ""

# 2fb5dc9139c7470094b78c8a8c42a742
# 4f4e78028d7145c280d31ba2e4a96124
#: ../../java/lambda-actors.rst:298 ../../java/untyped-actors.rst:254
msgid ""
"It is important to note that Actors do not stop automatically when no longer"
" referenced, every Actor that is created must also explicitly be destroyed. "
"The only simplification is that stopping a parent Actor will also "
"recursively stop all the child Actors that this parent has created."
msgstr ""
"アクターは参照されなくなったとしても自動的に停止することはないという点は重要です。生成された全てのアクターは明示的に破棄する必要があります。ただし親のアクターを停止する場合、そのアクターが生成した全ての子供のアクターも停止されるのでこの点は単純です。"

# a8eeea7b99da400d8443b8b99cf76fe4
# 4a7f5b5fc1604566a56477bee4b748b7
#: ../../java/lambda-actors.rst:303 ../../java/untyped-actors.rst:259
msgid ""
"An ``ActorRef`` always represents an incarnation (path and UID) not just a "
"given path. Therefore if an actor is stopped and a new one with the same "
"name is created an ``ActorRef`` of the old incarnation will not point to the"
" new one."
msgstr ""
"``ActorRef``はただ単に与えられたパスを表現しているのではなくいつでもインカーネーション(パスとUID)を表現しています。つまりアクターを停止して同じ名前のアクターを生成した場合、新しく生成した``ActorRef``は古いインカーネーションでなく新しいインカーネーションを指しています。"

# 0300fa584ed0499f85c9f494915c454b
#: ../../java/lambda-actors.rst:308
msgid ""
"``ActorSelection`` on the other hand points to the path (or multiple paths "
"if wildcards are used) and is completely oblivious to which incarnation is "
"currently occupying it. ``ActorSelection`` cannot be watched for this "
"reason. It is possible to resolve the current incarnation's ``ActorRef`` "
"living under the path by sending an ``Identify`` message to the "
"``ActorSelection`` which will be replied to with an ``ActorIdentity`` "
"containing the correct reference (see :ref:`actorSelection-lambda`). This "
"can also be done with the ``resolveOne`` method of the "
":class:`ActorSelection`, which returns a ``Future`` of the matching "
":class:`ActorRef`."
msgstr ""

# 1d25f89b34534462b5e782e54f98111a
# 34d92e3e5c084050b31010e94b6309f8
#: ../../java/lambda-actors.rst:321 ../../java/untyped-actors.rst:277
msgid "Lifecycle Monitoring aka DeathWatch"
msgstr "ライフサイクルの監視、DeathWatch"

# f342855cf2eb46e0ba7980c6d84a27e7
# 35bf45d2bdad414781d254c0ba9eff02
#: ../../java/lambda-actors.rst:323 ../../java/untyped-actors.rst:279
msgid ""
"In order to be notified when another actor terminates (i.e. stops "
"permanently, not temporary failure and restart), an actor may register "
"itself for reception of the :class:`Terminated` message dispatched by the "
"other actor upon termination (see `Stopping Actors`_). This service is "
"provided by the :class:`DeathWatch` component of the actor system."
msgstr ""
"他のアクターの停止を知るために(例えば、永久に停止された場合や一時的ではない障害によって再起動された場合など)、アクターは他のアクターが停止時に発する "
":class:`Terminated` メッセージを受け取るようにすることができます。(`Stopping "
"Actors`_も参照のこと)この機能はアクターシステムの :class:`DeathWatch` というコンポーネントによって提供されています。"

# eb1cb2c42afc4235aceb5c376fb49b4a
#: ../../java/lambda-actors.rst:329
msgid "Registering a monitor is easy:"
msgstr "モニターを登録するのは簡単です。"

# 5bd30b47564846989b64698e3fd5b2d9
# 5e4bde7ccd784e3390a23cb45e6a86ab
#: ../../java/lambda-actors.rst:333 ../../java/untyped-actors.rst:291
msgid ""
"It should be noted that the :class:`Terminated` message is generated "
"independent of the order in which registration and termination occur. In "
"particular, the watching actor will receive a :class:`Terminated` message "
"even if the watched actor has already been terminated at the time of "
"registration."
msgstr ""
":class:`Terminated` "
"メッセージは登録や停止がどのような順番で起きたかとは独立して生成されることに注意してください。典型的な例として、監視を行うアクターは例え監視の登録を行った時点ですでに監視対象のアクターが停止されていたとしても"
" :class:`Treminated` メッセージを受け取ることになります。"

# eb4cb6cafc394deebd0be8259cf59f2c
# f5a581008a0b486b851a76ef00fb6d12
#: ../../java/lambda-actors.rst:338 ../../java/untyped-actors.rst:296
msgid ""
"Registering multiple times does not necessarily lead to multiple messages "
"being generated, but there is no guarantee that only exactly one such "
"message is received: if termination of the watched actor has generated and "
"queued the message, and another registration is done before this message has"
" been processed, then a second message will be queued, because registering "
"for monitoring of an already terminated actor leads to the immediate "
"generation of the :class:`Terminated` message."
msgstr ""
"監視の登録を複数回行うことが必ずしも複数のメッセージを作ることになるわけではありませんが、こうしたメッセージを正確に一度受け取ることができる保障はありません。監視対象のアクターの停止メッセージが作られてキューに入ってから、このメッセージが処理される前に他のところで登録が行われたら、二つ目のメッセージがキューに入ります。何故なら既に停止したアクターの監視を登録すると、直ちに:"
" class:`Terminated` が生成されるためです。"

# 16185320de6441d2bc1b5e13e6655d59
#: ../../java/lambda-actors.rst:346
msgid ""
"It is also possible to deregister from watching another actor’s liveliness "
"using ``context.unwatch(target)``. This works even if the "
":class:`Terminated` message has already been enqueued in the mailbox; after "
"calling :meth:`unwatch` no :class:`Terminated` message for that actor will "
"be processed anymore."
msgstr ""
"同じようなことが他のアクターの生存監視を ``context.unwatch(target)`` を使ってやめた場合にも起こりえます。これは例え "
":class:`Terminated` "
"メッセージがメールボックスに入っていたとしても、:meth:`unwatch`の呼び出しの後には監視を停止したアクターの "
":class:`Terminated` メッセージは処理されないためです。"

# 45aeed6204024ece9e9b51bc56afce94
# 4bffea6c136848fe999213d990079132
#: ../../java/lambda-actors.rst:354 ../../java/untyped-actors.rst:311
msgid "Start Hook"
msgstr "Start Hook"

# cd904f23b2fa45b9879dc67ba0e8c422
# 2ee4c63b6bb74cf5ae416bf4562894e4
#: ../../java/lambda-actors.rst:356 ../../java/untyped-actors.rst:313
msgid ""
"Right after starting the actor, its :meth:`preStart` method is invoked."
msgstr "アクターが正しく起動すると、 :meth:`preStart` というメソッドが呼び出されます。"

# 5d5161d8f3614af5a9a9e8237283f804
# af4ec135fa844a5dbd78061930ff1281
#: ../../java/lambda-actors.rst:360 ../../java/untyped-actors.rst:317
msgid ""
"This method is called when the actor is first created. During restarts it is"
" called by the default implementation of :meth:`postRestart`, which means "
"that by overriding that method you can choose whether the initialization "
"code in this method is called only exactly once for this actor or for every "
"restart. Initialization code which is part of the actor’s constructor will "
"always be called when an instance of the actor class is created, which "
"happens at every restart."
msgstr ""
"このメソッドはアクタがーが初めに生成されたときに呼び出されます。アクターが再起動したときには :meth:`postRestart` "
"のデフォルトの実装がこのメソッドの呼び出しを行いますが、このメソッドをオーバーライドすることによって初期化のコードを一度だけ呼び出されるようにするのか、再起動のたびに呼び出されるようにするのかを選択することができます。アクターのコンストラクタの中の初期化コードはアクターが生成された時や再起動したときに常に呼び出されます。"

# 7cc0843b967945248359d3494077861d
# f294cd522e0445769c0107d5bdfe3fc5
#: ../../java/lambda-actors.rst:371 ../../java/untyped-actors.rst:326
msgid "Restart Hooks"
msgstr "Restart Hook"

# 4dcb0e3069c24affb42c93b487c13b57
# a2d9bea912d84ea7ac45e97bfab30c3d
#: ../../java/lambda-actors.rst:373 ../../java/untyped-actors.rst:328
msgid ""
"All actors are supervised, i.e. linked to another actor with a fault "
"handling strategy. Actors may be restarted in case an exception is thrown "
"while processing a message (see :ref:`supervision`). This restart involves "
"the hooks mentioned above:"
msgstr ""
"全てのアクターは、例えば他のアクターによるエラー処理のストラテジーに紐づくことによって監視されています。アクターがメッセージを処理しているときに例外をスローした場合は再起動が行われます。(:ref:`supervision`"
" を参照)この再起動は上記に挙げたフック処理のトリガになります。"

# dfbecfe017a943ef9a6222578e912950
#: ../../java/lambda-actors.rst:378
msgid ""
"The old actor is informed by calling :meth:`preRestart` with the exception "
"which caused the restart and the message which triggered that exception; the"
" latter may be ``None`` if the restart was not caused by processing a "
"message, e.g. when a supervisor does not trap the exception and is restarted"
" in turn by its supervisor, or if an actor is restarted due to a sibling’s "
"failure. If the message is available, then that message’s sender is also "
"accessible in the usual way (i.e. by calling ``sender``)."
msgstr ""
"古いアクターには :meth:`preRestart` "
"の中で再起動の原因となった例外と例外を引き起こしたメッセージが通知されます。後者のメッセージは、例えばsupervisorが例外を補足せずにそれより上位のsupervisorに再起動された場合やアクターが兄弟関係にあるアクターの障害によって再起動された場合など、再起動の原因となったのがメッセージの処理ではない場合には"
"　``None`` "
"が受け渡されます。メッセージが受け渡された場合には、メッセージのsenderもいつもと同じやり方で取得することができます。(これは、``sender``の呼び出しを行うことでできます)"

# 7383211ad53042a2a569f57c8791907f
# 26f1b2cf46144cfe8126315a14104a4a
#: ../../java/lambda-actors.rst:386 ../../java/untyped-actors.rst:341
msgid ""
"This method is the best place for cleaning up, preparing hand-over to the "
"fresh actor instance, etc.  By default it stops all children and calls "
":meth:`postStop`."
msgstr ""
"このメソッドは新しいアクターのインスタンスなどへの引き継ぎのためにクリーンアップを行うのにもっともよい場所です。デフォルトの実装では全ての子アクターを停止して"
" :meth:`postStop` を呼び出すようになっています。"

# b405b4b43db148a89b5b8b53b9f11264
# e7e7247dbb2c4989a434094ba99806ba
#: ../../java/lambda-actors.rst:390 ../../java/untyped-actors.rst:345
msgid ""
"The initial factory from the ``actorOf`` call is used to produce the fresh "
"instance."
msgstr "新しいインスタンスを生成するために :meth:`actorOf` の呼び出し時から引き継いだ初期化のファクトリを利用します。"

# ee63683b255e4912820be8cd0e34602f
# 499e13c9483749faaf5493e28a88431c
#: ../../java/lambda-actors.rst:393 ../../java/untyped-actors.rst:348
msgid ""
"The new actor’s :meth:`postRestart` method is invoked with the exception "
"which caused the restart. By default the :meth:`preStart` is called, just as"
" in the normal start-up case."
msgstr ""
"新しく生成したアクターの :meth:`postRestart` に再起動の原因となった例外を受け渡して呼び出します。デフォルトの実装では "
":meth:`preStart` の呼び出しを行って通常のアクターの開始と同じように振る舞います。"

# b2b6977562ab4ff498d47f074ba86e43
# 3e3d09895e2a489f9eeb338be9b142a7
#: ../../java/lambda-actors.rst:397 ../../java/untyped-actors.rst:352
msgid ""
"An actor restart replaces only the actual actor object; the contents of the "
"mailbox is unaffected by the restart, so processing of messages will resume "
"after the :meth:`postRestart` hook returns. The message that triggered the "
"exception will not be received again. Any message sent to an actor while it "
"is being restarted will be queued to its mailbox as usual."
msgstr ""
"アクターの再起動では実際のアクターのオブジェクトが入れ替わるだけです。再起動がメールボックの内容に影響を及ぼすことはないので、メッセージの処理は "
":metho:`postRestart` "
"の処理が終わった後に再開されます。例外の原因となったメッセージを再び受け取ることはありません。再起動中にアクターが受け取ったメッセージは通常メールボックスには入りません。"

# 17a48ed3deb143649ffa6aac2e797451
# 226fb53abf124022b37eeee9b3f4295d
#: ../../java/lambda-actors.rst:406 ../../java/untyped-actors.rst:361
msgid ""
"Be aware that the ordering of failure notifications relative to user "
"messages is not deterministic. In particular, a parent might restart its "
"child before it has processed the last messages sent by the child before the"
" failure. See :ref:`message-ordering` for details."
msgstr ""
"障害の通知とユーザのメッセージの相対的な順番が決定的ではないことに注意してください。特に、親のアクターによって子アクターが障害が起きる前に受け取った最後のメッセージを処理する前に再起動してしまうことがあります。詳細については"
" :ref:`message-ordering` を参照してください。"

# 7ca0d9279e214f68bfa84af453f86598
# 605c2eabb67c43c699bcef5b65a922e7
#: ../../java/lambda-actors.rst:414 ../../java/untyped-actors.rst:368
msgid "Stop Hook"
msgstr "Stop Hook"

# 46a574fc76764124a8c874f3fbeba2e7
# 8c3b3500eff843718bc8e1ba5da7b20d
#: ../../java/lambda-actors.rst:416 ../../java/untyped-actors.rst:370
msgid ""
"After stopping an actor, its :meth:`postStop` hook is called, which may be "
"used e.g. for deregistering this actor from other services. This hook is "
"guaranteed to run after message queuing has been disabled for this actor, "
"i.e. messages sent to a stopped actor will be redirected to the "
":obj:`deadLetters` of the :obj:`ActorSystem`."
msgstr ""
"アクターが停止した後には、そのアクターの :meth:`postStop` "
"フックが呼び出されるので、これを使って他のサービスからこのアクターを登録解除するといった処理を行うようにします。ここのフックはこのアクターに対するメッセージのキューイングが利用できなくなってから呼び出されることが保障されています。停止されたアクターに送信したメッセージは"
" :obj:`ActorSystem` の :obj:`deadLetters` にリダイレクトされるようになります。"

# f64618e50c574492b62607a32ab5ef23
# b60fc7e02d1f48d5bbb30aa645aa0877
#: ../../java/lambda-actors.rst:425 ../../java/untyped-actors.rst:380
msgid "Identifying Actors via Actor Selection"
msgstr "Actor Selectionを使ったアクターの識別"

# 9725d994018e4d0e96242871fdb58d57
# cf4c57b17c5046cdb0ca131a139893a8
#: ../../java/lambda-actors.rst:427 ../../java/untyped-actors.rst:382
msgid ""
"As described in :ref:`addressing`, each actor has a unique logical path, "
"which is obtained by following the chain of actors from child to parent "
"until reaching the root of the actor system, and it has a physical path, "
"which may differ if the supervision chain includes any remote supervisors. "
"These paths are used by the system to look up actors, e.g. when a remote "
"message is received and the recipient is searched, but they are also useful "
"more directly: actors may look up other actors by specifying absolute or "
"relative paths—logical or physical—and receive back an "
":class:`ActorSelection` with the result:"
msgstr ""
":ref:`addressing` "
"で述べたように、アクターはそれぞれ一意な論理パスを持っていて、子供から親を辿ってアクターシステムのルートにまで遡ることができることができます。また、アクターは物理的なパスも持っていますが、監視のチェーンの中にリモートのsupervisorが存在する場合には論理的なパスと異なることがあります。これらのパスはリモートからメッセージを受け取った時に受信者を検索するのに利用されたりしますが、もっと直接的な利点があります。アクターは絶対パスもしくは相対パスを"
"--これらは論理的なものと物理的なものがあります--を使ってほかのアクターを検索し :class:`ActorSelection` "
"を使ってその結果を受け取ることができます。"

# 0deed122f3f94c0bbff20e86ba4b602b
# fd86e36ba52347b7bc64d7bb93a62301
#: ../../java/lambda-actors.rst:441 ../../java/untyped-actors.rst:396
msgid ""
"It is always preferable to communicate with other Actors using their "
"ActorRef instead of relying upon ActorSelection. Exceptions are"
msgstr "通常、アクターの通信はActorSelectionに頼らずにActorRefを使う方が望ましいです。ただし、次の場合は例外です。"

# a8fd1c5e165247deba2e01ffd10b7a66
#: ../../java/lambda-actors.rst:444
msgid ""
"sending messages using the :ref:`at-least-once-delivery-java-lambda` "
"facility"
msgstr ""

# 4baf7ab0fd3c4a509db3005bf36dba0d
# 956c4d4e01f64dd6b5aa5995f02868f6
#: ../../java/lambda-actors.rst:445 ../../java/untyped-actors.rst:400
msgid "initiating first contact with a remote system"
msgstr "リモートシステムとの始めの通信を行う場合"

# 897478b7370944a4833f1b70f44d7f1b
# 63396b6726e740f1951fe6cd5aadad0b
#: ../../java/lambda-actors.rst:447 ../../java/untyped-actors.rst:402
msgid ""
"In all other cases ActorRefs can be provided during Actor creation or "
"initialization, passing them from parent to child or introducing Actors by "
"sending their ActorRefs to other Actors within messages."
msgstr ""
"上記以外のケースでは、親から子にActorRefを渡したり、ActorRefへの参照を含メッセージを他のアクターに送信するなど、アクターの生成時や初期化時にActorRefを受け渡す方法があります。"

# 1647c0ef476d462fb15bc910dfc06060
# 0af307f6d00b42339c0377eea8f1610e
#: ../../java/lambda-actors.rst:451 ../../java/untyped-actors.rst:406
msgid ""
"The supplied path is parsed as a :class:`java.net.URI`, which basically "
"means that it is split on ``/`` into path elements. If the path starts with "
"``/``, it is absolute and the look-up starts at the root guardian (which is "
"the parent of ``\"/user\"``); otherwise it starts at the current actor. If a"
" path element equals ``..``, the look-up will take a step “up” towards the "
"supervisor of the currently traversed actor, otherwise it will step “down” "
"to the named child. It should be noted that the ``..`` in actor paths here "
"always means the logical structure, i.e. the supervisor."
msgstr ""

# 56c6a1d2bcac4933b7c2d937a87b7ed5
# 5cab9d52578849c1a5f5f9720b30678f
#: ../../java/lambda-actors.rst:460 ../../java/untyped-actors.rst:415
msgid ""
"The path elements of an actor selection may contain wildcard patterns "
"allowing for broadcasting of messages to that section:"
msgstr ""

# baeaab5b3c6e4a7e9550291425124959
# 545bbbdec06046ad952058401e5f3f63
#: ../../java/lambda-actors.rst:465 ../../java/untyped-actors.rst:420
msgid ""
"Messages can be sent via the :class:`ActorSelection` and the path of the "
":class:`ActorSelection` is looked up when delivering each message. If the "
"selection does not match any actors the message will be dropped."
msgstr ""

# d3aa44ff50024a1d92f2201bc57cd2c4
#: ../../java/lambda-actors.rst:469
msgid ""
"To acquire an :class:`ActorRef` for an :class:`ActorSelection` you need to "
"send a message to the selection and use the ``sender()`` reference of the "
"reply from the actor. There is a built-in ``Identify`` message that all "
"Actors will understand and automatically reply to with a ``ActorIdentity`` "
"message containing the :class:`ActorRef`. This message is handled specially "
"by the actors which are traversed in the sense that if a concrete name "
"lookup fails (i.e. a non-wildcard path element does not correspond to a live"
" actor) then a negative result is generated. Please note that this does not "
"mean that delivery of that reply is guaranteed, it still is a normal "
"message."
msgstr ""

# b667b00ea8574ca5b7d140c6970b6b0d
#: ../../java/lambda-actors.rst:482
msgid ""
"You can also acquire an :class:`ActorRef` for an :class:`ActorSelection` "
"with the ``resolveOne`` method of the :class:`ActorSelection`. It returns a "
"``Future`` of the matching :class:`ActorRef` if such an actor exists (see "
"also :ref:`actor-java-lambda` for Java compatibility). It is completed with "
"failure [[akka.actor.ActorNotFound]] if no such actor exists or the "
"identification didn't complete within the supplied `timeout`."
msgstr ""

# 7908bc2426a040089a2b219c9228f2d5
# 86689250b4aa44398958e11501850486
#: ../../java/lambda-actors.rst:489 ../../java/untyped-actors.rst:443
msgid ""
"Remote actor addresses may also be looked up, if :ref:`remoting <remoting-"
"java>` is enabled:"
msgstr ""

# 13dc310edd3e45afbbcc53a9b105f1e6
#: ../../java/lambda-actors.rst:493
msgid ""
"An example demonstrating actor look-up is given in :ref:`remote-sample-"
"java`."
msgstr ""

# ad506e83fd884ff9a116b41ddae8d239
# ac93d66d70484791986e58c29f414f08
# d8c751eac9e84b53b12da0bf2631e23d
#: ../../java/lambda-actors.rst:496 ../../java/typed-actors.rst:115
#: ../../java/untyped-actors.rst:450
msgid "Messages and immutability"
msgstr ""

# 7864168d04f346d5ad3199d3fae99ccd
# 354461b896af497c8ef1913c16c5adbd
#: ../../java/lambda-actors.rst:498 ../../java/untyped-actors.rst:452
msgid ""
"**IMPORTANT**: Messages can be any kind of object but have to be immutable. "
"Akka can’t enforce immutability (yet) so this has to be by convention."
msgstr ""

# eb048013eecb4400881b37571ea5e8b0
# dda0cf96d55141a89a9a7af790945ee9
#: ../../java/lambda-actors.rst:502 ../../java/untyped-actors.rst:456
msgid "Here is an example of an immutable message:"
msgstr ""

# 4a159d18f1274f028f628698f0ae38bf
# ae21021909b0413586212ae0c3bf3f3a
#: ../../java/lambda-actors.rst:507 ../../java/untyped-actors.rst:462
msgid "Send messages"
msgstr ""

# 94c9b1aad1db4f7e940f5be1dd0a2f50
# 3db5be5c77a9415fbeae1f6c374bec91
#: ../../java/lambda-actors.rst:509 ../../java/untyped-actors.rst:464
msgid "Messages are sent to an Actor through one of the following methods."
msgstr ""

# 94115fe627634de2a560ed3eeb60dbea
# fa58434d10b34477bf4b1ab441361884
#: ../../java/lambda-actors.rst:511 ../../java/untyped-actors.rst:466
msgid ""
"``tell`` means “fire-and-forget”, e.g. send a message asynchronously and "
"return immediately."
msgstr ""

# 9df73023b6864c35bade17c0b266fd00
# bd1ec9a9cec44b43a95652318b46b30b
#: ../../java/lambda-actors.rst:513 ../../java/untyped-actors.rst:468
msgid ""
"``ask`` sends a message asynchronously and returns a :class:`Future` "
"representing a possible reply."
msgstr ""

# 7ba79a74ce3c48cc84a170f0a6fe9f99
# 49aa5323a2ce47ebb3fe1bd120882fde
#: ../../java/lambda-actors.rst:516 ../../java/untyped-actors.rst:471
msgid "Message ordering is guaranteed on a per-sender basis."
msgstr ""

# b6f501bdfd4c468faecaf6f763ec2f3c
# 5173108d016a427ab618d628795853da
#: ../../java/lambda-actors.rst:520 ../../java/untyped-actors.rst:475
msgid ""
"There are performance implications of using ``ask`` since something needs to"
" keep track of when it times out, there needs to be something that bridges a"
" ``Promise`` into an ``ActorRef`` and it also needs to be reachable through "
"remoting. So always prefer ``tell`` for performance, and only ``ask`` if you"
" must."
msgstr ""

# d1ce9b67650e460dbbf75aa7b5ae7b61
# 204cd2729953417c956fdad71ea430f7
#: ../../java/lambda-actors.rst:525 ../../java/untyped-actors.rst:480
msgid ""
"In all these methods you have the option of passing along your own "
"``ActorRef``. Make it a practice of doing so because it will allow the "
"receiver actors to be able to respond to your message, since the sender "
"reference is sent along with the message."
msgstr ""

# 2926fcb019944beca5838c76c7623288
# 93bc453c3ac84f0099607d7ef2923641
#: ../../java/lambda-actors.rst:532 ../../java/untyped-actors.rst:487
msgid "Tell: Fire-forget"
msgstr ""

# d8f2f57bd37b4a33a4fc67c87a293ca8
# dd8b402ab7eb446dafa02da74b570f57
#: ../../java/lambda-actors.rst:534 ../../java/untyped-actors.rst:489
msgid ""
"This is the preferred way of sending messages. No blocking waiting for a "
"message. This gives the best concurrency and scalability characteristics."
msgstr ""

# 41f8b63f17844594b2e36e64e3d529ac
#: ../../java/lambda-actors.rst:539
msgid ""
"The sender reference is passed along with the message and available within "
"the receiving actor via its :meth:`sender()` method while processing this "
"message. Inside of an actor it is usually :meth:`self()` who shall be the "
"sender, but there can be cases where replies shall be routed to some other "
"actor—e.g. the parent—in which the second argument to :meth:`tell` would be "
"a different one. Outside of an actor and if no reply is needed the second "
"argument can be ``null``; if a reply is needed outside of an actor you can "
"use the ask-pattern described next.."
msgstr ""

# 78edc9d9c3d24ad28e95d60a83697a88
# 3719bd82407d498fbc92a2497b2800fb
#: ../../java/lambda-actors.rst:551 ../../java/untyped-actors.rst:506
msgid "Ask: Send-And-Receive-Future"
msgstr ""

# 4e4933511e3e4d8da282e05c928e044b
# 1fe9dd1cae954bf58545e60d4e82cf58
#: ../../java/lambda-actors.rst:553 ../../java/untyped-actors.rst:508
msgid ""
"The ``ask`` pattern involves actors as well as futures, hence it is offered "
"as a use pattern rather than a method on :class:`ActorRef`:"
msgstr ""

# 4633cc472c154d8cb6a50bdaa697cb56
# 8d714e257b5b49be9594fa25175fd39c
#: ../../java/lambda-actors.rst:559 ../../java/untyped-actors.rst:514
msgid ""
"This example demonstrates ``ask`` together with the ``pipe`` pattern on "
"futures, because this is likely to be a common combination. Please note that"
" all of the above is completely non-blocking and asynchronous: ``ask`` "
"produces a :class:`Future`, two of which are composed into a new future "
"using the :meth:`Futures.sequence` and :meth:`map` methods and then ``pipe``"
" installs an ``onComplete``-handler on the future to effect the submission "
"of the aggregated :class:`Result` to another actor."
msgstr ""

# dff91152184e40b5a437b052d7e15448
#: ../../java/lambda-actors.rst:567
msgid ""
"Using ``ask`` will send a message to the receiving Actor as with ``tell``, "
"and the receiving actor must reply with ``sender().tell(reply, self())`` in "
"order to complete the returned :class:`Future` with a value. The ``ask`` "
"operation involves creating an internal actor for handling this reply, which"
" needs to have a timeout after which it is destroyed in order not to leak "
"resources; see more below."
msgstr ""

# 5146bec1d8884122b4f4c2faf2617129
# 79e0d065b538491d91ea6793c48df7cd
#: ../../java/lambda-actors.rst:576 ../../java/untyped-actors.rst:535
msgid ""
"To complete the future with an exception you need send a Failure message to "
"the sender. This is *not done automatically* when an actor throws an "
"exception while processing a message."
msgstr ""

# 13577c74e7da45bd8b8fc14b00e3c223
# 72698ae7c7a3496db2e93a64ece8872b
#: ../../java/lambda-actors.rst:581 ../../java/untyped-actors.rst:540
msgid ""
"If the actor does not complete the future, it will expire after the timeout "
"period, specified as parameter to the ``ask`` method; this will complete the"
" :class:`Future` with an :class:`AskTimeoutException`."
msgstr ""

# 35c4ecdbc2c44c96b27b6bf6c9039251
# 20c3efebc4db4a32bb703459cccd37aa
#: ../../java/lambda-actors.rst:585 ../../java/untyped-actors.rst:544
msgid ""
"See :ref:`futures-java` for more information on how to await or query a "
"future."
msgstr ""

# 50d33d4610aa47d7b67ec31f166671b6
# c54ab032fcf24a5296a9d2abe86f6ab8
#: ../../java/lambda-actors.rst:588 ../../java/untyped-actors.rst:547
msgid ""
"The ``onComplete``, ``onSuccess``, or ``onFailure`` methods of the "
"``Future`` can be used to register a callback to get a notification when the"
" Future completes. Gives you a way to avoid blocking."
msgstr ""

# 626341f13dba4f6cb93655d93260f812
# 588acd0adb2f488297027c77b2908e68
#: ../../java/lambda-actors.rst:594 ../../java/untyped-actors.rst:553
msgid ""
"When using future callbacks, inside actors you need to carefully avoid "
"closing over the containing actor’s reference, i.e. do not call methods or "
"access mutable state on the enclosing actor from within the callback. This "
"would break the actor encapsulation and may introduce synchronization bugs "
"and race conditions because the callback will be scheduled concurrently to "
"the enclosing actor. Unfortunately there is not yet a way to detect these "
"illegal accesses at compile time. See also: :ref:`jmm-shared-state`"
msgstr ""

# ac699482a3b74ebb8a00dc44e5ad82e7
# 6fd602b691784c3090b4f7241c9739a6
#: ../../java/lambda-actors.rst:603 ../../java/untyped-actors.rst:562
msgid "Forward message"
msgstr ""

# 93247f0e01564baf9ee44bd3c7b48ce5
#: ../../java/lambda-actors.rst:605
msgid ""
"You can forward a message from one actor to another. This means that the "
"original sender address/reference is maintained even though the message is "
"going through a 'mediator'. This can be useful when writing actors that work"
" as routers, load-balancers, replicators etc."
msgstr ""

# 58555b99c2b545a6bfa151cae9c217db
# 689b1b5ce4694e7fb264c8ff45eae4df
#: ../../java/lambda-actors.rst:613 ../../java/untyped-actors.rst:573
msgid "Receive messages"
msgstr ""

# 4dce817db6a543e795f8633e0723b2b1
#: ../../java/lambda-actors.rst:615
msgid ""
"An Actor either has to set its initial receive behavior in the constructor "
"by calling the :meth:`receive` method in the :class:`AbstractActor`:"
msgstr ""

# cdc44b4e7d3e4c0d98dac27bb6e91852
#: ../../java/lambda-actors.rst:622
msgid ""
"or by implementing the :meth:`receive` method in the :class:`Actor` "
"interface:"
msgstr ""

# 411f15ad19284d7c9abedd9c686d1739
#: ../../java/lambda-actors.rst:626
msgid ""
"Both the argument to the :class:`AbstractActor` :meth:`receive` method and "
"the return type of the :class:`Actor` :meth:`receive` method is a "
"``PartialFunction<Object, BoxedUnit>`` that defines which messages your "
"Actor can handle, along with the implementation of how the messages should "
"be processed."
msgstr ""

# b365c160565e4a00a4398f2eadfc3987
# 0d13a1eeb73c46ebbdfb696c11604e52
#: ../../java/lambda-actors.rst:642 ../../java/untyped-actors.rst:589
msgid "Reply to messages"
msgstr ""

# d7c1992e2a054c498c1e97f51d384ba1
#: ../../java/lambda-actors.rst:644
msgid ""
"If you want to have a handle for replying to a message, you can use "
"``sender()``, which gives you an ActorRef. You can reply by sending to that "
"ActorRef with ``sender().tell(replyMsg, self())``. You can also store the "
"ActorRef for replying later, or passing on to other actors. If there is no "
"sender (a message was sent without an actor or future context) then the "
"sender defaults to a 'dead-letter' actor ref."
msgstr ""

# fc9821e87e32445c9f1273d473ffa44f
# 53e7953fc547407295c7e9acaabe3bcc
#: ../../java/lambda-actors.rst:655 ../../java/untyped-actors.rst:602
msgid "Receive timeout"
msgstr ""

# 48bcf8ece8044458902d08fb6316d72e
#: ../../java/lambda-actors.rst:657
msgid ""
"The `ActorContext` :meth:`setReceiveTimeout` defines the inactivity timeout "
"after which the sending of a `ReceiveTimeout` message is triggered. When "
"specified, the receive function should be able to handle an "
"`akka.actor.ReceiveTimeout` message. 1 millisecond is the minimum supported "
"timeout."
msgstr ""

# 79dacba1595f4eefae82e99fb8e229b8
# a89b3788390b42b4bb3e6ffa0f28b18e
#: ../../java/lambda-actors.rst:662 ../../java/untyped-actors.rst:609
msgid ""
"Please note that the receive timeout might fire and enqueue the "
"`ReceiveTimeout` message right after another message was enqueued; hence it "
"is **not guaranteed** that upon reception of the receive timeout there must "
"have been an idle period beforehand as configured via this method."
msgstr ""

# a21df5f3bdf9448abfec0ead2a6c43c2
# 1c5b52e8a06b445fb9d90ce9759a1067
#: ../../java/lambda-actors.rst:666 ../../java/untyped-actors.rst:613
msgid ""
"Once set, the receive timeout stays in effect (i.e. continues firing "
"repeatedly after inactivity periods). Pass in `Duration.Undefined` to switch"
" off this feature."
msgstr ""

# 5bbfc63efb384a6984faf7d5a8ffd641
# 4402ea4d58c3491eae29e2c5e96aef7d
#: ../../java/lambda-actors.rst:671 ../../java/untyped-actors.rst:618
msgid ""
"Messages marked with ``NotInfluenceReceiveTimeout`` will not reset the "
"timer. This can be useful when ``ReceiveTimeout`` should be fired by "
"external inactivity but not influenced by internal activity, e.g. scheduled "
"tick messages."
msgstr ""

# e86a0ecc828040d2aba4bf2c6d27ffef
# f04280aa2cd74fa29e4d09b6fc4f2fdc
#: ../../java/lambda-actors.rst:678 ../../java/untyped-actors.rst:625
msgid "Stopping actors"
msgstr ""

# df5ded99cdb241fda45ea233a2dce425
#: ../../java/lambda-actors.rst:680
msgid ""
"Actors are stopped by invoking the :meth:`stop` method of a "
"``ActorRefFactory``, i.e. ``ActorContext`` or ``ActorSystem``. Typically the"
" context is used for stopping child actors and the system for stopping top "
"level actors. The actual termination of the actor is performed "
"asynchronously, i.e. :meth:`stop` may return before the actor is stopped."
msgstr ""

# 2e94792f9fe443559a9b73ddefb9005d
# 47b4ee436bd14b9b8a1b97bffa47d924
#: ../../java/lambda-actors.rst:686 ../../java/untyped-actors.rst:635
msgid ""
"Processing of the current message, if any, will continue before the actor is"
" stopped, but additional messages in the mailbox will not be processed. By "
"default these messages are sent to the :obj:`deadLetters` of the "
":obj:`ActorSystem`, but that depends on the mailbox implementation."
msgstr ""

# 8353b9376999487aa0d947c63edbd561
#: ../../java/lambda-actors.rst:691
msgid ""
"Termination of an actor proceeds in two steps: first the actor suspends its "
"mailbox processing and sends a stop command to all its children, then it "
"keeps processing the internal termination notifications from its children "
"until the last one is gone, finally terminating itself (invoking "
":meth:`postStop`, dumping mailbox, publishing :class:`Terminated` on the "
":ref:`DeathWatch <deathwatch-lambda>`, telling its supervisor). This "
"procedure ensures that actor system sub-trees terminate in an orderly "
"fashion, propagating the stop command to the leaves and collecting their "
"confirmation back to the stopped supervisor. If one of the actors does not "
"respond (i.e. processing a message for extended periods of time and "
"therefore not receiving the stop command), this whole process will be stuck."
msgstr ""

# d3203c720d844d299d9b445a0ebc3b94
# c8d0b5b527d748369efea64945d1de1c
#: ../../java/lambda-actors.rst:703 ../../java/untyped-actors.rst:652
msgid ""
"Upon :meth:`ActorSystem.terminate()`, the system guardian actors will be "
"stopped, and the aforementioned process will ensure proper termination of "
"the whole system."
msgstr ""

# f126fd822b5a408b8ed8d0c3cb5e59e3
# 2ce15fbd047b4ed5a673a6eabeff53a6
#: ../../java/lambda-actors.rst:707 ../../java/untyped-actors.rst:656
msgid ""
"The :meth:`postStop()` hook is invoked after an actor is fully stopped. This"
" enables cleaning up of resources:"
msgstr ""

# 13bc612ab0b34062accb0b49c414cb9e
# b0ef635124f944008e7815aa9f1b4ed9
#: ../../java/lambda-actors.rst:715 ../../java/untyped-actors.rst:664
msgid ""
"Since stopping an actor is asynchronous, you cannot immediately reuse the "
"name of the child you just stopped; this will result in an "
":class:`InvalidActorNameException`. Instead, :meth:`watch()` the terminating"
" actor and create its replacement in response to the :class:`Terminated` "
"message which will eventually arrive."
msgstr ""

# 68f6ec4b4e2248d5ad3c1f128edad339
# 765f1b995a9748aab307fb62ab6a8be8
#: ../../java/lambda-actors.rst:724 ../../java/untyped-actors.rst:673
msgid "PoisonPill"
msgstr ""

# 205561de5748499387c37ae0aaba947a
# 5ee91a2a9d5e4c0abdd3602c87deb8c0
#: ../../java/lambda-actors.rst:726 ../../java/untyped-actors.rst:675
msgid ""
"You can also send an actor the ``akka.actor.PoisonPill`` message, which will"
" stop the actor when the message is processed. ``PoisonPill`` is enqueued as"
" ordinary messages and will be handled after messages that were already "
"queued in the mailbox."
msgstr ""

# 41dcba2136f84439820359f7f765db98
# 7a4d01538eaa483c9b78910e9d0116a5
#: ../../java/lambda-actors.rst:732 ../../java/untyped-actors.rst:686
msgid "Graceful Stop"
msgstr ""

# e290e2c11bbb485b96134a34d2cefa2a
# 4b71b50dafd0407b88635ca2877555b0
#: ../../java/lambda-actors.rst:734 ../../java/untyped-actors.rst:688
msgid ""
":meth:`gracefulStop` is useful if you need to wait for termination or "
"compose ordered termination of several actors:"
msgstr ""

# 924f2e2843de421194785aee2a121a25
# 901d4586348f4bc39ee5e9d6c8fbbaef
#: ../../java/lambda-actors.rst:743 ../../java/untyped-actors.rst:700
msgid ""
"When ``gracefulStop()`` returns successfully, the actor’s ``postStop()`` "
"hook will have been executed: there exists a happens-before edge between the"
" end of ``postStop()`` and the return of ``gracefulStop()``."
msgstr ""

# e2e8ab0b944c4a5483b8131c807d04b1
#: ../../java/lambda-actors.rst:747
msgid ""
"In the above example a custom ``Manager.Shutdown`` message is sent to the "
"target actor to initiate the process of stopping the actor. You can use "
"``PoisonPill`` for this, but then you have limited possibilities to perform "
"interactions with other actors before stopping the target actor. Simple "
"cleanup tasks can be handled in ``postStop``."
msgstr ""

# 6849111e50134588943cb4be379be63c
# aaea62cddb2f4b589dca6fc81d314905
#: ../../java/lambda-actors.rst:754 ../../java/untyped-actors.rst:711
msgid ""
"Keep in mind that an actor stopping and its name being deregistered are "
"separate events which happen asynchronously from each other. Therefore it "
"may be that you will find the name still in use after ``gracefulStop()`` "
"returned. In order to guarantee proper deregistration, only reuse names from"
" within a supervisor you control and only in response to a "
":class:`Terminated` message, i.e. not for top-level actors."
msgstr ""

# 1a64991c02c34208ae451d454e0d22c5
#: ../../java/lambda-actors.rst:764
msgid "Become/Unbecome"
msgstr ""

# f1deb26eb77646059daad808327727ab
# 65b5a6a8a00f495a839ffef02756e6cf
#: ../../java/lambda-actors.rst:767 ../../java/untyped-actors.rst:724
msgid "Upgrade"
msgstr ""

# e593600336244cae985136ab5220c785
#: ../../java/lambda-actors.rst:769
msgid ""
"Akka supports hotswapping the Actor’s message loop (e.g. its implementation)"
" at runtime: invoke the ``context.become`` method from within the Actor. "
":meth:`become` takes a ``PartialFunction<Object, BoxedUnit>`` that "
"implements the new message handler. The hotswapped code is kept in a Stack "
"which can be pushed and popped."
msgstr ""

# 27aae01cb6b344afa759bdb97a309c4f
# fe688286c152430480383289a0a9fe19
#: ../../java/lambda-actors.rst:777 ../../java/untyped-actors.rst:733
msgid ""
"Please note that the actor will revert to its original behavior when "
"restarted by its Supervisor."
msgstr ""

# 38330ff291fb47afa755c36809930476
#: ../../java/lambda-actors.rst:779
msgid "To hotswap the Actor behavior using ``become``:"
msgstr ""

# 2846dadbc8f54881a03fdb2f9ec16ef9
#: ../../java/lambda-actors.rst:783
msgid ""
"This variant of the :meth:`become` method is useful for many different "
"things, such as to implement a Finite State Machine (FSM, for an example see"
" `Dining Hakkers`_). It will replace the current behavior (i.e. the top of "
"the behavior stack), which means that you do not use :meth:`unbecome`, "
"instead always the next behavior is explicitly installed."
msgstr ""

# 478357b6b11f4a43b2464f3f01fcaa6f
# d6c41b3036da4d60a26166d1604518a9
#: ../../java/lambda-actors.rst:791 ../../java/untyped-actors.rst:748
msgid ""
"The other way of using :meth:`become` does not replace but add to the top of"
" the behavior stack. In this case care must be taken to ensure that the "
"number of “pop” operations (i.e. :meth:`unbecome`) matches the number of "
"“push” ones in the long run, otherwise this amounts to a memory leak (which "
"is why this behavior is not the default)."
msgstr ""

# 4efd6ed4ade24bf9982871b44d2ce38b
# 92a30d1c58274c649d4dd5fe1c5e039e
#: ../../java/lambda-actors.rst:802 ../../java/untyped-actors.rst:759
msgid "Stash"
msgstr ""

# 9e4305a2857e415fa90ccdb7bcf15b08
#: ../../java/lambda-actors.rst:804
msgid ""
"The ``AbstractActorWithStash`` class enables an actor to temporarily stash "
"away messages that can not or should not be handled using the actor's "
"current behavior. Upon changing the actor's message handler, i.e., right "
"before invoking ``context().become()`` or ``context().unbecome()``, all "
"stashed messages can be \"unstashed\", thereby prepending them to the "
"actor's mailbox. This way, the stashed messages can be processed in the same"
" order as they have been received originally. An actor that extends "
"``AbstractActorWithStash`` will automatically get a deque-based mailbox."
msgstr ""

# 44bc035bdd8a40269ab3eedc7c1d9687
#: ../../java/lambda-actors.rst:815
msgid ""
"The abstract class ``AbstractActorWithStash`` implements the marker "
"interface ``RequiresMessageQueue<DequeBasedMessageQueueSemantics>`` which "
"requests the system to automatically choose a deque based mailbox "
"implementation for the actor. If you want more control over the mailbox, see"
" the documentation on mailboxes: :ref:`mailboxes-java`."
msgstr ""

# e66cf4e7ec114c3685934916cb79271c
#: ../../java/lambda-actors.rst:821
msgid "Here is an example of the ``AbstractActorWithStash`` class in action:"
msgstr ""

# ad2484e617b149e3a6afcee2607d687f
# fd9f307f45ac47aaa3cf6534a854473e
#: ../../java/lambda-actors.rst:825 ../../java/untyped-actors.rst:783
msgid ""
"Invoking ``stash()`` adds the current message (the message that the actor "
"received last) to the actor's stash. It is typically invoked when handling "
"the default case in the actor's message handler to stash messages that "
"aren't handled by the other cases. It is illegal to stash the same message "
"twice; to do so results in an ``IllegalStateException`` being thrown. The "
"stash may also be bounded in which case invoking ``stash()`` may lead to a "
"capacity violation, which results in a ``StashOverflowException``. The "
"capacity of the stash can be configured using the ``stash-capacity`` setting"
" (an ``Int``) of the mailbox's configuration."
msgstr ""

# 73bca216321a4a85828def5837709791
# cb3a79d397e54b2da9f722615f6bd52a
#: ../../java/lambda-actors.rst:836 ../../java/untyped-actors.rst:794
msgid ""
"Invoking ``unstashAll()`` enqueues messages from the stash to the actor's "
"mailbox until the capacity of the mailbox (if any) has been reached (note "
"that messages from the stash are prepended to the mailbox). In case a "
"bounded mailbox overflows, a ``MessageQueueAppendFailedException`` is "
"thrown. The stash is guaranteed to be empty after calling ``unstashAll()``."
msgstr ""

# 5f77c2134ee44378b49469eb0fe55bc7
# 4e90fc474e6b41bc96ab205f9a1a4380
#: ../../java/lambda-actors.rst:843 ../../java/untyped-actors.rst:801
msgid ""
"The stash is backed by a ``scala.collection.immutable.Vector``. As a result,"
" even a very large number of messages may be stashed without a major impact "
"on performance."
msgstr ""

# 0d96d0eda3d048f68d2096cd21a53d1b
#: ../../java/lambda-actors.rst:847
msgid ""
"Note that the stash is part of the ephemeral actor state, unlike the "
"mailbox. Therefore, it should be managed like other parts of the actor's "
"state which have the same property. The :class:`AbstractActorWithStash` "
"implementation of :meth:`preRestart` will call ``unstashAll()``, which is "
"usually the desired behavior."
msgstr ""

# ec73d323947f4259ad5dd5d8beef1e36
#: ../../java/lambda-actors.rst:855
msgid ""
"If you want to enforce that your actor can only work with an unbounded "
"stash, then you should use the ``AbstractActorWithUnboundedStash`` class "
"instead."
msgstr ""

# c878fc62e1a44076b60a20c546dd9e08
# 913c54e3332046ffaaf026d6d83e3ecb
#: ../../java/lambda-actors.rst:862 ../../java/untyped-actors.rst:820
msgid "Killing an Actor"
msgstr ""

# f693d9f02b8940238b6baf10377695a1
# 91c95a58e92647cbb60b57af14e6484b
#: ../../java/lambda-actors.rst:864 ../../java/untyped-actors.rst:822
msgid ""
"You can kill an actor by sending a ``Kill`` message. This will cause the "
"actor to throw a :class:`ActorKilledException`, triggering a failure. The "
"actor will suspend operation and its supervisor will be asked how to handle "
"the failure, which may mean resuming the actor, restarting it or terminating"
" it completely. See :ref:`supervision-directives` for more information."
msgstr ""

# 5dc741ea237943a395eeac7b0bacbfdd
# 918a2f4eb4534cc790c4222d48adc3b6
#: ../../java/lambda-actors.rst:870 ../../java/untyped-actors.rst:828
msgid "Use ``Kill`` like this:"
msgstr ""

# b56c0e8a7ba9479db29146f991cf450b
# 8116a60123054fb4906eff8bbd5f430e
#: ../../java/lambda-actors.rst:876 ../../java/untyped-actors.rst:834
msgid "Actors and exceptions"
msgstr ""

# ec360f37e4a04bbdb57ca4e5281b5318
# 68b07834c8c44c398edb882e10d30d67
#: ../../java/lambda-actors.rst:878 ../../java/untyped-actors.rst:836
msgid ""
"It can happen that while a message is being processed by an actor, that some"
" kind of exception is thrown, e.g. a database exception."
msgstr ""

# 22bc40c9e4754858b3004929cc239745
# aca77179c8ec4de8b7ad8bc306b3d4b4
#: ../../java/lambda-actors.rst:882 ../../java/untyped-actors.rst:840
msgid "What happens to the Message"
msgstr ""

# 5585f8f6593249b1852f36ca0f68dd64
# c89a3849dabd4ceb9639646d0377d2af
#: ../../java/lambda-actors.rst:884 ../../java/untyped-actors.rst:842
msgid ""
"If an exception is thrown while a message is being processed (i.e. taken out"
" of its mailbox and handed over to the current behavior), then this message "
"will be lost. It is important to understand that it is not put back on the "
"mailbox. So if you want to retry processing of a message, you need to deal "
"with it yourself by catching the exception and retry your flow. Make sure "
"that you put a bound on the number of retries since you don't want a system "
"to livelock (so consuming a lot of cpu cycles without making progress). "
"Another possibility would be to have a look at the :ref:`PeekMailbox pattern"
" <mailbox-acking>`."
msgstr ""

# d7c0f072af5c410d8ee7b3defea1b0b9
# a6e031afa28f442591b581631857c71c
#: ../../java/lambda-actors.rst:894 ../../java/untyped-actors.rst:852
msgid "What happens to the mailbox"
msgstr ""

# c96b50a2c56247538f6a1d3cfd349d4d
# 3e1a957caa1640369cabbe44bd4c9be8
#: ../../java/lambda-actors.rst:896 ../../java/untyped-actors.rst:854
msgid ""
"If an exception is thrown while a message is being processed, nothing "
"happens to the mailbox. If the actor is restarted, the same mailbox will be "
"there. So all messages on that mailbox will be there as well."
msgstr ""

# f51922edc509442c9694fd6dd1bf79a8
# d592a9005e03496ea68cd44f3d1881d1
#: ../../java/lambda-actors.rst:901 ../../java/untyped-actors.rst:859
msgid "What happens to the actor"
msgstr ""

# 29fdf31b1b624aa1bdb1164ef75872e8
# 8c6697b3c9ab4672b5c9889a42a08666
#: ../../java/lambda-actors.rst:903 ../../java/untyped-actors.rst:861
msgid ""
"If code within an actor throws an exception, that actor is suspended and the"
" supervision process is started (see :ref:`supervision`). Depending on the "
"supervisor’s decision the actor is resumed (as if nothing happened), "
"restarted (wiping out its internal state and starting from scratch) or "
"terminated."
msgstr ""

# f1998e11d7cf48e0abe7aa744a16f4af
# af82d66484294c8295d37c4d3769fdbc
#: ../../java/lambda-actors.rst:909 ../../java/untyped-actors.rst:867
msgid "Initialization patterns"
msgstr ""

# 4dae8760ea5842f282a47e31991b583d
# e998743029444b7caa5849f544b04374
#: ../../java/lambda-actors.rst:911 ../../java/untyped-actors.rst:869
msgid ""
"The rich lifecycle hooks of Actors provide a useful toolkit to implement "
"various initialization patterns. During the lifetime of an ``ActorRef``, an "
"actor can potentially go through several restarts, where the old instance is"
" replaced by a fresh one, invisibly to the outside observer who only sees "
"the ``ActorRef``."
msgstr ""

# 387630d194224054840c2edcccbbd3e2
# a9d570ede6d54ec989777000c9deec9c
#: ../../java/lambda-actors.rst:915 ../../java/untyped-actors.rst:873
msgid ""
"One may think about the new instances as \"incarnations\". Initialization "
"might be necessary for every incarnation of an actor, but sometimes one "
"needs initialization to happen only at the birth of the first instance when "
"the ``ActorRef`` is created. The following sections provide patterns for "
"different initialization needs."
msgstr ""

# eb50bc7ff16f415b9a29b3d99a8a5ea9
# 5d9bf7c6714c4b4cab834d8fe5169b9b
#: ../../java/lambda-actors.rst:920 ../../java/untyped-actors.rst:878
msgid "Initialization via constructor"
msgstr ""

# 94cd399d5cc446e18b2e4cad263baa88
# b00ef4b92bea455e80618a5486d0525c
#: ../../java/lambda-actors.rst:922 ../../java/untyped-actors.rst:880
msgid ""
"Using the constructor for initialization has various benefits. First of all,"
" it makes it possible to use ``val`` fields to store any state that does not"
" change during the life of the actor instance, making the implementation of "
"the actor more robust. The constructor is invoked for every incarnation of "
"the actor, therefore the internals of the actor can always assume that "
"proper initialization happened. This is also the drawback of this approach, "
"as there are cases when one would like to avoid reinitializing internals on "
"restart. For example, it is often useful to preserve child actors across "
"restarts. The following section provides a pattern for this case."
msgstr ""

# 33e36619fe8e4e1095de771e3e7213a9
# b9d5baed53064fc8afaf523a2ffb5836
#: ../../java/lambda-actors.rst:930 ../../java/untyped-actors.rst:888
msgid "Initialization via preStart"
msgstr ""

# b7220218933d473e9c4cc99cd49bf992
# fb2b351475f64d168957233983877fe6
#: ../../java/lambda-actors.rst:932 ../../java/untyped-actors.rst:890
msgid ""
"The method ``preStart()`` of an actor is only called once directly during "
"the initialization of the first instance, that is, at creation of its "
"``ActorRef``. In the case of restarts, ``preStart()`` is called from "
"``postRestart()``, therefore if not overridden, ``preStart()`` is called on "
"every incarnation. However, overriding ``postRestart()`` one can disable "
"this behavior, and ensure that there is only one call to ``preStart()``."
msgstr ""

# c434f32741fa41988d78a6ad72c1ac43
# 7aec8a8d2b7d4d95b3fe30b02e4148d4
#: ../../java/lambda-actors.rst:937 ../../java/untyped-actors.rst:895
msgid ""
"One useful usage of this pattern is to disable creation of new ``ActorRefs``"
" for children during restarts. This can be achieved by overriding "
"``preRestart()``:"
msgstr ""

# 752c0d808b7d4f3ba5ff99e90c63cd10
# aecd894965ec46c591eb46e2859fcb9f
#: ../../java/lambda-actors.rst:942 ../../java/untyped-actors.rst:900
msgid ""
"Please note, that the child actors are *still restarted*, but no new "
"``ActorRef`` is created. One can recursively apply the same principles for "
"the children, ensuring that their ``preStart()`` method is called only at "
"the creation of their refs."
msgstr ""

# 8fa928b0a7284ccba7bd73dfe7825d08
# 4945a4c587c14df8ae24e6b59d3b0c16
#: ../../java/lambda-actors.rst:946 ../../java/untyped-actors.rst:904
msgid "For more information see :ref:`supervision-restart`."
msgstr ""

# 1869bb085b0342d4a9fcb08e34209092
# 70265a4146d84154b4be284c23712e2a
#: ../../java/lambda-actors.rst:949 ../../java/untyped-actors.rst:907
msgid "Initialization via message passing"
msgstr ""

# 33f001668936449da94af42a4c4d88e0
# e512a653a866461791c51d92751b8ca6
#: ../../java/lambda-actors.rst:951 ../../java/untyped-actors.rst:909
msgid ""
"There are cases when it is impossible to pass all the information needed for"
" actor initialization in the constructor, for example in the presence of "
"circular dependencies. In this case the actor should listen for an "
"initialization message, and use ``become()`` or a finite state-machine state"
" transition to encode the initialized and uninitialized states of the actor."
msgstr ""

# ecf93c756d2a464bb4ab8dc2704adbe6
# 2b74b5ac47ea4454bc6a36ef52682395
#: ../../java/lambda-actors.rst:958 ../../java/untyped-actors.rst:916
msgid ""
"If the actor may receive messages before it has been initialized, a useful "
"tool can be the ``Stash`` to save messages until the initialization "
"finishes, and replaying them after the actor became initialized."
msgstr ""

# 092d952cbd064e3c92af0c0ad2564328
# cde094c9c7324faebaded2f922a39dfe
#: ../../java/lambda-actors.rst:963 ../../java/untyped-actors.rst:921
msgid ""
"This pattern should be used with care, and applied only when none of the "
"patterns above are applicable. One of the potential issues is that messages "
"might be lost when sent to remote actors. Also, publishing an ``ActorRef`` "
"in an uninitialized state might lead to the condition that it receives a "
"user message before the initialization has been done."
msgstr ""

# d2265c40cc6841509d5c9e192605e014
#: ../../java/lambda-actors.rst:971
msgid "Lambdas and Performance"
msgstr ""

# 51de2adc9d6b4f5dba481da91a6214ff
#: ../../java/lambda-actors.rst:973
msgid ""
"There is one big difference between the optimized partial functions created "
"by the Scala compiler and the ones created by the ``ReceiveBuilder``. The "
"partial functions created by the ``ReceiveBuilder`` consist of multiple "
"lambda expressions for every match statement, where each lambda is an object"
" referencing the code to be run. This is something that the JVM can have "
"problems optimizing and the resulting code might not be as performant as the"
" Scala equivalent or the corresponding :ref:`untyped actor <untyped-actors-"
"java>` version."
msgstr ""

# 88b6e3d07d5644f3a9a843a921c32e77
#: ../../java/lambda-fault-tolerance.rst:4
msgid "Fault Tolerance (Java with Lambda Support)"
msgstr ""

# 01569c204eda41fc96ac63fa373ee74c
#: ../../java/lambda-fault-tolerance.rst:19
msgid ""
"Read the following source code. The inlined comments explain the different "
"pieces of the fault handling and why they are added. It is also highly "
"recommended to run this sample as it is easy to follow the log output to "
"understand what is happening in runtime."
msgstr ""

# b769c54e712640b8a1e4f899d904d9f0
#: ../../java/lambda-fsm.rst:5
msgid "FSM (Java with Lambda Support)"
msgstr ""

# a1ad57997ef04c86b3eb0f4d4b894235
#: ../../java/lambda-fsm.rst:11
msgid ""
"The FSM (Finite State Machine) is available as an abstract base class that "
"implements an Akka Actor and is best described in the `Erlang design "
"principles "
"<http://www.erlang.org/documentation/doc-4.8.2/doc/design_principles/fsm.html>`_"
msgstr ""

# def2c15391f446b09a1b5f9d662ab119
#: ../../java/lambda-fsm.rst:15
msgid "A FSM can be described as a set of relations of the form:"
msgstr ""

# 45a8fc885b744a6096ace3ea8461d8e9
#: ../../java/lambda-fsm.rst:26
msgid ""
"The Java with lambda support part of Akka is marked as **“experimental”** as"
" of its introduction in Akka 2.3.0. We will continue to improve this API "
"based on our users’ feedback, which implies that while we try to keep "
"incompatible changes to a minimum, but the binary compatibility guarantee "
"for maintenance releases does not apply to the "
":class:`akka.actor.AbstractFSM`, related classes and the "
":class:`akka.japi.pf` package."
msgstr ""

# 231a119adb5346d290911b0ace2b4ad2
# ef90d7403c9f4f479e2748fb18c86d2b
#: ../../java/lambda-fsm.rst:33 ../../java/lambda-persistence.rst:746
msgid "A Simple Example"
msgstr ""

# bc992b26092d4b2591401817d069ffbf
#: ../../java/lambda-fsm.rst:35
msgid ""
"To demonstrate most of the features of the :class:`AbstractFSM` class, "
"consider an actor which shall receive and queue messages while they arrive "
"in a burst and send them on after the burst ended or a flush request is "
"received."
msgstr ""

# 11a22910800649e38bb13008396d0b6a
#: ../../java/lambda-fsm.rst:39
msgid "First, consider all of the below to use these import statements:"
msgstr ""

# 69ca82da088f4b0aae97c34a2e5b82bb
#: ../../java/lambda-fsm.rst:43
msgid ""
"The contract of our “Buncher” actor is that it accepts or produces the "
"following messages:"
msgstr ""

# f7c2c13f4c1941488cb9f435f9a47e5f
#: ../../java/lambda-fsm.rst:49
msgid ""
"``SetTarget`` is needed for starting it up, setting the destination for the "
"``Batches`` to be passed on; ``Queue`` will add to the internal queue while "
"``Flush`` will mark the end of a burst."
msgstr ""

# 09a000c5c3084f9b968678b82471391a
#: ../../java/lambda-fsm.rst:53
msgid ""
"The actor can be in two states: no message queued (aka ``Idle``) or some "
"message queued (aka ``Active``). The states and the state data is defined "
"like this:"
msgstr ""

# 2e0b4e0ecd7e4141bb872880209104e2
#: ../../java/lambda-fsm.rst:60
msgid ""
"The actor starts out in the idle state. Once a message arrives it will go to"
" the active state and stay there as long as messages keep arriving and no "
"flush is requested. The internal state data of the actor is made up of the "
"target actor reference to send the batches to and the actual queue of "
"messages."
msgstr ""

# b7ad57080c914d78ae0a212058797a38
#: ../../java/lambda-fsm.rst:65
msgid "Now let’s take a look at the skeleton for our FSM actor:"
msgstr ""

# e3500766c4ec42b68234fcee4f6f1eb4
#: ../../java/lambda-fsm.rst:71
msgid ""
"The basic strategy is to declare the actor, by inheriting the "
":class:`AbstractFSM` class and specifying the possible states and data "
"values as type parameters. Within the body of the actor a DSL is used for "
"declaring the state machine:"
msgstr ""

# bf100274e11e45d691aed1f2a43887fd
#: ../../java/lambda-fsm.rst:75
msgid ":meth:`startWith` defines the initial state and initial data"
msgstr ""

# 70f3fdde67f34c9f9f2b714929fd3864
#: ../../java/lambda-fsm.rst:76
msgid ""
"then there is one :meth:`when(<state>) { ... }` declaration per state to be "
"handled (could potentially be multiple ones, the passed "
":class:`PartialFunction` will be concatenated using :meth:`orElse`)"
msgstr ""

# 9fe1340415e7467286dc9e8903060684
#: ../../java/lambda-fsm.rst:79
msgid ""
"finally starting it up using :meth:`initialize`, which performs the "
"transition into the initial state and sets up timers (if required)."
msgstr ""

# 8c201e09e8ab40d6b513812066ed3caa
#: ../../java/lambda-fsm.rst:82
msgid ""
"In this case, we start out in the ``Idle`` and ``Uninitialized`` state, "
"where only the ``SetTarget()`` message is handled; ``stay`` prepares to end "
"this event’s processing for not leaving the current state, while the "
"``using`` modifier makes the FSM replace the internal state (which is "
"``Uninitialized`` at this point) with a fresh ``Todo()`` object containing "
"the target actor reference. The ``Active`` state has a state timeout "
"declared, which means that if no message is received for 1 second, a "
"``FSM.StateTimeout`` message will be generated. This has the same effect as "
"receiving the ``Flush`` command in this case, namely to transition back into"
" the ``Idle`` state and resetting the internal queue to the empty vector. "
"But how do messages get queued? Since this shall work identically in both "
"states, we make use of the fact that any event which is not handled by the "
"``when()`` block is passed to the ``whenUnhandled()`` block:"
msgstr ""

# bc9656f9df3b4c029a484f27c8486741
#: ../../java/lambda-fsm.rst:98
msgid ""
"The first case handled here is adding ``Queue()`` requests to the internal "
"queue and going to the ``Active`` state (this does the obvious thing of "
"staying in the ``Active`` state if already there), but only if the FSM data "
"are not ``Uninitialized`` when the ``Queue()`` event is received. "
"Otherwise—and in all other non-handled cases—the second case just logs a "
"warning and does not change the internal state."
msgstr ""

# da9cd8ffc25d4ca6a0abc60472d91b0d
#: ../../java/lambda-fsm.rst:105
msgid ""
"The only missing piece is where the ``Batches`` are actually sent to the "
"target, for which we use the ``onTransition`` mechanism: you can declare "
"multiple such blocks and all of them will be tried for matching behavior in "
"case a state transition occurs (i.e. only when the state actually changes)."
msgstr ""

# ffaaf9c7cac044f3bf8987dfc502b64a
#: ../../java/lambda-fsm.rst:112
msgid ""
"The transition callback is a partial function which takes as input a pair of"
" states—the current and the next state. During the state change, the old "
"state data is available via ``stateData`` as shown, and the new state data "
"would be available as ``nextStateData``."
msgstr ""

# ca20583b68fe4c9daca64195edbf2485
#: ../../java/lambda-fsm.rst:117
msgid ""
"To verify that this buncher actually works, it is quite easy to write a test"
" using the :ref:`akka-testkit`, here using JUnit as an example:"
msgstr ""

# 54148e6f66f34cabbe9a20c839efb26b
#: ../../java/lambda-fsm.rst:124
msgid "Reference"
msgstr ""

# 660a5439b51944ae809aceaa32228441
#: ../../java/lambda-fsm.rst:127
msgid "The AbstractFSM Class"
msgstr ""

# 0b18b058b74548beabeb21d58a76f1b2
#: ../../java/lambda-fsm.rst:129
msgid ""
"The :class:`AbstractFSM` abstract class is the base class used to implement "
"an FSM. It implements Actor since an Actor is created to drive the FSM."
msgstr ""

# fe8b363bd3fd4b0db2bea29df9ed7401
#: ../../java/lambda-fsm.rst:138
msgid ""
"The AbstractFSM class defines a ``receive`` method which handles internal "
"messages and passes everything else through to the FSM logic (according to "
"the current state). When overriding the ``receive`` method, keep in mind "
"that e.g. state timeout handling depends on actually passing the messages "
"through the FSM logic."
msgstr ""

# 7dacfc6568174b6b89cfcfd7e78d72d7
#: ../../java/lambda-fsm.rst:144
msgid "The :class:`AbstractFSM` class takes two type parameters:"
msgstr ""

# c4b5112cc52b4365826855c5d6e18159
#: ../../java/lambda-fsm.rst:146
msgid "the supertype of all state names, usually an enum,"
msgstr ""

# 7b331ee25cfa476b843d06d00939b9b8
#: ../../java/lambda-fsm.rst:147
msgid ""
"the type of the state data which are tracked by the :class:`AbstractFSM` "
"module itself."
msgstr ""

# 4d043e221eb4494297316853de9f68b6
#: ../../java/lambda-fsm.rst:154
msgid ""
"The state data together with the state name describe the internal state of "
"the state machine; if you stick to this scheme and do not add mutable fields"
" to the FSM class you have the advantage of making all changes of the "
"internal state explicit in a few well-known places."
msgstr ""

# e79d4c232f06490cae5a60b18fb2b6ff
#: ../../java/lambda-fsm.rst:160
msgid "Defining States"
msgstr ""

# 7e71217c8eb8427e87ddc67892a99d1a
#: ../../java/lambda-fsm.rst:162
msgid "A state is defined by one or more invocations of the method"
msgstr ""

# 5ecd7aa8b20746d88d2e88846dfb1eef
#: ../../java/lambda-fsm.rst:164
msgid ":func:`when(<name>[, stateTimeout = <timeout>])(stateFunction)`."
msgstr ""

# f87ad0ed71704021ba85feb5dabf5004
#: ../../java/lambda-fsm.rst:166
msgid ""
"The given name must be an object which is type-compatible with the first "
"type parameter given to the :class:`AbstractFSM` class. This object is used "
"as a hash key, so you must ensure that it properly implements :meth:`equals`"
" and :meth:`hashCode`; in particular it must not be mutable. The easiest fit"
" for these requirements are case objects."
msgstr ""

# a1efe48851e9401381eabf77445848e0
#: ../../java/lambda-fsm.rst:172
msgid ""
"If the :meth:`stateTimeout` parameter is given, then all transitions into "
"this state, including staying, receive this timeout by default. Initiating "
"the transition with an explicit timeout may be used to override this "
"default, see `Initiating Transitions`_ for more information. The state "
"timeout of any state may be changed during action processing with "
":func:`setStateTimeout(state, duration)`. This enables runtime configuration"
" e.g. via external message."
msgstr ""

# ba0acb45b5a04a47b8262221d88424e2
#: ../../java/lambda-fsm.rst:180
msgid ""
"The :meth:`stateFunction` argument is a :class:`PartialFunction[Event, "
"State]`, which is conveniently given using the state function builder syntax"
" as demonstrated below:"
msgstr ""

# aa3fabb256ae4e53a0f81479219221ee
#: ../../java/lambda-fsm.rst:189
msgid ""
"It is required that you define handlers for each of the possible FSM states,"
" otherwise there will be failures when trying to switch to undeclared "
"states."
msgstr ""

# 0c3ba3c5045d4e6fac3122b6d784a6f0
#: ../../java/lambda-fsm.rst:192
msgid ""
"It is recommended practice to declare the states as an enum and then verify "
"that there is a ``when`` clause for each of the states. If you want to leave"
" the handling of a state “unhandled” (more below), it still needs to be "
"declared like this:"
msgstr ""

# 738cce1b054c4a50bb954491799d1e67
#: ../../java/lambda-fsm.rst:199
msgid "Defining the Initial State"
msgstr ""

# ccd5783f64a84800bdabd1df4cff2435
#: ../../java/lambda-fsm.rst:201
msgid "Each FSM needs a starting point, which is declared using"
msgstr ""

# c19a0017d73647388ffdcab939dfc364
#: ../../java/lambda-fsm.rst:203
msgid ":func:`startWith(state, data[, timeout])`"
msgstr ""

# dd3e7fd3bcd94206a19d7be71b49cb43
#: ../../java/lambda-fsm.rst:205
msgid ""
"The optionally given timeout argument overrides any specification given for "
"the desired initial state. If you want to cancel a default timeout, use "
":obj:`Duration.Inf`."
msgstr ""

# 7b897940112345a0ac6332869de1affa
#: ../../java/lambda-fsm.rst:210
msgid "Unhandled Events"
msgstr ""

# ae70ed4e757d4ff6b89847169ce27867
#: ../../java/lambda-fsm.rst:212
msgid ""
"If a state doesn't handle a received event a warning is logged. If you want "
"to do something else in this case you can specify that with "
":func:`whenUnhandled(stateFunction)`:"
msgstr ""

# a582e9d90c3748aba8559662fdb775b2
#: ../../java/lambda-fsm.rst:219
msgid ""
"Within this handler the state of the FSM may be queried using the "
":meth:`stateName` method."
msgstr ""

# c6d79ec547c44bf8acbd28772ceb45e8
#: ../../java/lambda-fsm.rst:222
msgid ""
"**IMPORTANT**: This handler is not stacked, meaning that each invocation of "
":func:`whenUnhandled` replaces the previously installed handler."
msgstr ""

# 2b9ab8c742d043dbb374143b37908d14
#: ../../java/lambda-fsm.rst:226
msgid "Initiating Transitions"
msgstr ""

# 6be2a4f7189642309312afe041148c16
#: ../../java/lambda-fsm.rst:228
msgid ""
"The result of any :obj:`stateFunction` must be a definition of the next "
"state unless terminating the FSM, which is described in `Termination from "
"Inside`_. The state definition can either be the current state, as described"
" by the :func:`stay` directive, or it is a different state as given by "
":func:`goto(state)`. The resulting object allows further qualification by "
"way of the modifiers described in the following:"
msgstr ""

# e714e305e68c4e53947c8a643cab67f8
#: ../../java/lambda-fsm.rst:235
msgid ":meth:`forMax(duration)`"
msgstr ""

# e8ac3dc3424e4b5ba43cc4a2a3c6401a
#: ../../java/lambda-fsm.rst:237
msgid ""
"This modifier sets a state timeout on the next state. This means that a "
"timer is started which upon expiry sends a :obj:`StateTimeout` message to "
"the FSM. This timer is canceled upon reception of any other message in the "
"meantime; you can rely on the fact that the :obj:`StateTimeout` message will"
" not be processed after an intervening message."
msgstr ""

# e17e8517a5b64f118661b56048775f4b
#: ../../java/lambda-fsm.rst:243
msgid ""
"This modifier can also be used to override any default timeout which is "
"specified for the target state. If you want to cancel the default timeout, "
"use :obj:`Duration.Inf`."
msgstr ""

# dcdf519672b24872820de255dd03c868
#: ../../java/lambda-fsm.rst:247
msgid ":meth:`using(data)`"
msgstr ""

# 5e98713d058b4e889463b489af2aa74c
#: ../../java/lambda-fsm.rst:249
msgid ""
"This modifier replaces the old state data with the new data given. If you "
"follow the advice :ref:`above <fsm-philosophy>`, this is the only place "
"where internal state data are ever modified."
msgstr ""

# 50dc16aff6aa4200ab0b459b853f0844
#: ../../java/lambda-fsm.rst:253
msgid ":meth:`replying(msg)`"
msgstr ""

# 4e09a652ebc444f8bba8aa8bc020e8b2
#: ../../java/lambda-fsm.rst:255
msgid ""
"This modifier sends a reply to the currently processed message and otherwise"
" does not modify the state transition."
msgstr ""

# 4e25eb3b255541af8e5670c8570a3793
#: ../../java/lambda-fsm.rst:258
msgid ""
"All modifiers can be chained to achieve a nice and concise description:"
msgstr ""

# a83d90f5148246c5b2ddb46ab46640af
#: ../../java/lambda-fsm.rst:263
msgid ""
"The parentheses are not actually needed in all cases, but they visually "
"distinguish between modifiers and their arguments and therefore make the "
"code even more pleasant to read for foreigners."
msgstr ""

# 14486edd268141a58f0a4053f284de35
#: ../../java/lambda-fsm.rst:269
msgid ""
"Please note that the ``return`` statement may not be used in :meth:`when` "
"blocks or similar; this is a Scala restriction. Either refactor your code "
"using ``if () ... else ...`` or move it into a method definition."
msgstr ""

# 41d39e930e3b4c30a83ab06cacc37eec
#: ../../java/lambda-fsm.rst:274
msgid "Monitoring Transitions"
msgstr ""

# f6c470abd87549a294920c5b7ec367cf
#: ../../java/lambda-fsm.rst:276
msgid ""
"Transitions occur \"between states\" conceptually, which means after any "
"actions you have put into the event handling block; this is obvious since "
"the next state is only defined by the value returned by the event handling "
"logic. You do not need to worry about the exact order with respect to "
"setting the internal state variable, as everything within the FSM actor is "
"running single-threaded anyway."
msgstr ""

# b1969f9cb3e142aa805a280f9359520b
#: ../../java/lambda-fsm.rst:284
msgid "Internal Monitoring"
msgstr ""

# eec18e3f6bcd43da8504d92a73990fd3
#: ../../java/lambda-fsm.rst:286
msgid ""
"Up to this point, the FSM DSL has been centered on states and events. The "
"dual view is to describe it as a series of transitions. This is enabled by "
"the method"
msgstr ""

# 84024cdb219845a2a306bf23dd73f403
#: ../../java/lambda-fsm.rst:290
msgid ":func:`onTransition(handler)`"
msgstr ""

# 8de994316a6b40428dd715fab2be6514
#: ../../java/lambda-fsm.rst:292
msgid ""
"which associates actions with a transition instead of with a state and "
"event. The handler is a partial function which takes a pair of states as "
"input; no resulting state is needed as it is not possible to modify the "
"transition in progress."
msgstr ""

# e9e7e2306a58487185a1b9e1393e4413
#: ../../java/lambda-fsm.rst:300
msgid ""
"It is also possible to pass a function object accepting two states to "
":func:`onTransition`, in case your transition handling logic is implemented "
"as a method:"
msgstr ""

# fdf422112f914c8c88ea683bb0a31ed1
#: ../../java/lambda-fsm.rst:307
msgid ""
"The handlers registered with this method are stacked, so you can intersperse"
" :func:`onTransition` blocks with :func:`when` blocks as suits your design. "
"It should be noted, however, that *all handlers will be invoked for each "
"transition*, not only the first matching one. This is designed specifically "
"so you can put all transition handling for a certain aspect into one place "
"without having to worry about earlier declarations shadowing later ones; the"
" actions are still executed in declaration order, though."
msgstr ""

# ce9529fdf8174bea8adae7bbafaf09c5
#: ../../java/lambda-fsm.rst:317
msgid ""
"This kind of internal monitoring may be used to structure your FSM according"
" to transitions, so that for example the cancellation of a timer upon "
"leaving a certain state cannot be forgot when adding new target states."
msgstr ""

# d116a9d48f5d428fb93f823b3fedc10d
#: ../../java/lambda-fsm.rst:322
msgid "External Monitoring"
msgstr ""

# 6ee34ce2579a4cdf9b24061d578c8206
#: ../../java/lambda-fsm.rst:324
msgid ""
"External actors may be registered to be notified of state transitions by "
"sending a message :class:`SubscribeTransitionCallBack(actorRef)`. The named "
"actor will be sent a :class:`CurrentState(self, stateName)` message "
"immediately and will receive :class:`Transition(actorRef, oldState, "
"newState)` messages whenever a new state is reached. External monitors may "
"be unregistered by sending :class:`UnsubscribeTransitionCallBack(actorRef)` "
"to the FSM actor."
msgstr ""

# cfceeb51e95f45bb98b99310df3153d9
#: ../../java/lambda-fsm.rst:331
msgid ""
"Stopping a listener without unregistering will not remove the listener from "
"the subscription list; use :class:`UnsubscribeTransitionCallback` before "
"stopping the listener."
msgstr ""

# 3216e57a7ed842fe9a4e1d8d8ee9e1ac
#: ../../java/lambda-fsm.rst:336
msgid "Timers"
msgstr ""

# 75858fdb984e4f4ca1c00808ab838532
#: ../../java/lambda-fsm.rst:338
msgid ""
"Besides state timeouts, FSM manages timers identified by :class:`String` "
"names. You may set a timer using"
msgstr ""

# 7db64d0a012344bbab5a126c75245a87
#: ../../java/lambda-fsm.rst:341
msgid ":func:`setTimer(name, msg, interval, repeat)`"
msgstr ""

# 4566920413254064941de62484e26fc1
#: ../../java/lambda-fsm.rst:343
msgid ""
"where :obj:`msg` is the message object which will be sent after the duration"
" :obj:`interval` has elapsed. If :obj:`repeat` is :obj:`true`, then the "
"timer is scheduled at fixed rate given by the :obj:`interval` parameter. Any"
" existing timer with the same name will automatically be canceled before "
"adding the new timer."
msgstr ""

# 36839f95b56745f2819ff735833e235c
#: ../../java/lambda-fsm.rst:349
msgid "Timers may be canceled using"
msgstr ""

# ef95b7db41b548cba5ed696acbb26394
#: ../../java/lambda-fsm.rst:351
msgid ":func:`cancelTimer(name)`"
msgstr ""

# f5fb36596be545cbac3a052bd73d7429
#: ../../java/lambda-fsm.rst:353
msgid ""
"which is guaranteed to work immediately, meaning that the scheduled message "
"will not be processed after this call even if the timer already fired and "
"queued it. The status of any timer may be inquired with"
msgstr ""

# be40f99de2b6461b8223f4073f39abfd
#: ../../java/lambda-fsm.rst:357
msgid ":func:`isTimerActive(name)`"
msgstr ""

# 0fc04dff6d924e44bf7691822727468a
#: ../../java/lambda-fsm.rst:359
msgid ""
"These named timers complement state timeouts because they are not affected "
"by intervening reception of other messages."
msgstr ""

# 6c09b0c7745843209469223d77a41a5b
#: ../../java/lambda-fsm.rst:363
msgid "Termination from Inside"
msgstr ""

# 6f7b39ff017e4b3d9b65fea11ab1560f
#: ../../java/lambda-fsm.rst:365
msgid "The FSM is stopped by specifying the result state as"
msgstr ""

# 914c4aa7038f46fd935f712604bdd021
#: ../../java/lambda-fsm.rst:367
msgid ":func:`stop([reason[, data]])`"
msgstr ""

# 945050ebd5a64cb7bf85b564db5ccd62
#: ../../java/lambda-fsm.rst:369
msgid ""
"The reason must be one of :obj:`Normal` (which is the default), "
":obj:`Shutdown` or :obj:`Failure(reason)`, and the second argument may be "
"given to change the state data which is available during termination "
"handling."
msgstr ""

# eb9a3e11686c4e2da46ee413a2894a13
#: ../../java/lambda-fsm.rst:375
msgid ""
"It should be noted that :func:`stop` does not abort the actions and stop the"
" FSM immediately. The stop action must be returned from the event handler in"
" the same way as a state transition (but note that the ``return`` statement "
"may not be used within a :meth:`when` block)."
msgstr ""

# 42fffee18ddb4b1b8fd8357850b68c29
#: ../../java/lambda-fsm.rst:383
msgid ""
"You can use :func:`onTermination(handler)` to specify custom code that is "
"executed when the FSM is stopped. The handler is a partial function which "
"takes a :class:`StopEvent(reason, stateName, stateData)` as argument:"
msgstr ""

# 8bea68c7bd48418d8284174cd3fff9f5
#: ../../java/lambda-fsm.rst:390
msgid ""
"As for the :func:`whenUnhandled` case, this handler is not stacked, so each "
"invocation of :func:`onTermination` replaces the previously installed "
"handler."
msgstr ""

# 003d75fd89b549db898959201b450585
#: ../../java/lambda-fsm.rst:394
msgid "Termination from Outside"
msgstr ""

# 4f907f17935d44f693971fdd5f9e5778
#: ../../java/lambda-fsm.rst:396
msgid ""
"When an :class:`ActorRef` associated to a FSM is stopped using the "
":meth:`stop()` method, its :meth:`postStop` hook will be executed. The "
"default implementation by the :class:`AbstractFSM` class is to execute the "
":meth:`onTermination` handler if that is prepared to handle a "
":obj:`StopEvent(Shutdown, ...)`."
msgstr ""

# 1d3bca901e7c44898ad582dd3db525fc
#: ../../java/lambda-fsm.rst:404
msgid ""
"In case you override :meth:`postStop` and want to have your "
":meth:`onTermination` handler called, do not forget to call "
"``super.postStop``."
msgstr ""

# 3e3f690d02934f79b2077836f3de8152
#: ../../java/lambda-fsm.rst:409
msgid "Testing and Debugging Finite State Machines"
msgstr ""

# 0c1321d6f2a44e47bd3b9b359c16f6db
#: ../../java/lambda-fsm.rst:411
msgid ""
"During development and for trouble shooting FSMs need care just as any other"
" actor. There are specialized tools available as described in "
":ref:`TestFSMRef` and in the following."
msgstr ""

# fb9aa0073a104682a99dd8511bb23a25
#: ../../java/lambda-fsm.rst:416
msgid "Event Tracing"
msgstr ""

# 98fdfdf54eac4e478dc18e7cc45163ab
#: ../../java/lambda-fsm.rst:418
msgid ""
"The setting ``akka.actor.debug.fsm`` in :ref:`configuration` enables logging"
" of an event trace by :class:`LoggingFSM` instances:"
msgstr ""

# 8e2a4ccabd8143c8988563a7646a72a6
#: ../../java/lambda-fsm.rst:425
msgid "This FSM will log at DEBUG level:"
msgstr ""

# 653c077ae7f14df5b31e9c2b183f54d4
#: ../../java/lambda-fsm.rst:427
msgid ""
"all processed events, including :obj:`StateTimeout` and scheduled timer "
"messages"
msgstr ""

# 7da8e29787574bb1ad1c49b9681927eb
#: ../../java/lambda-fsm.rst:429
msgid "every setting and cancellation of named timers"
msgstr ""

# 2b6e3a580df84c859afddee28c6ccadf
#: ../../java/lambda-fsm.rst:430
msgid "all state transitions"
msgstr ""

# cc0ca07d981441f1a99bce8b7ab6a99d
#: ../../java/lambda-fsm.rst:432
msgid ""
"Life cycle changes and special messages can be logged as described for "
":ref:`Actors <actor.logging-scala>`."
msgstr ""

# 075d5f2e188446fe906852add9ef3815
#: ../../java/lambda-fsm.rst:436
msgid "Rolling Event Log"
msgstr ""

# 99477bd5b01a48eb8d6fad74f196292a
#: ../../java/lambda-fsm.rst:438
msgid ""
"The :class:`AbstractLoggingFSM` class adds one more feature to the FSM: a "
"rolling event log which may be used during debugging (for tracing how the "
"FSM entered a certain failure state) or for other creative uses:"
msgstr ""

# 80ed34c9571f444980e2b10069e1beb4
#: ../../java/lambda-fsm.rst:445
msgid "The :meth:`logDepth` defaults to zero, which turns off the event log."
msgstr ""

# a16ac55e5f8849d7a41ea3c52b9ed596
#: ../../java/lambda-fsm.rst:449
msgid ""
"The log buffer is allocated during actor creation, which is why the "
"configuration is done using a virtual method call. If you want to override "
"with a ``val``, make sure that its initialization happens before the "
"initializer of :class:`LoggingFSM` runs, and do not change the value "
"returned by ``logDepth`` after the buffer has been allocated."
msgstr ""

# deaae2993c294c969e87b46fcf80c3cd
#: ../../java/lambda-fsm.rst:455
msgid ""
"The contents of the event log are available using method :meth:`getLog`, "
"which returns an :class:`IndexedSeq[LogEntry]` where the oldest entry is at "
"index zero."
msgstr ""

# ee37ad4bdb2242599a511870215ec004
#: ../../java/lambda-fsm.rst:462
msgid ""
"A bigger FSM example contrasted with Actor's :meth:`become`/:meth:`unbecome`"
" can be found in the `Lightbend Activator "
"<http://www.lightbend.com/platform/getstarted>`_ template named `Akka FSM in"
" Scala <http://www.lightbend.com/activator/template/akka-sample-fsm-java-"
"lambda>`_"
msgstr ""

# 4e2ee5977d894d22bc013e39f9c3fe98
#: ../../java/lambda-index-actors.rst:6
msgid ""
"Starting with Akka 2.4.2 we have begun to introduce Java 8 types (most "
"prominently ``java.util.concurrent.CompletionStage`` and "
"``java.util.Optional``) where that was possible without breaking binary or "
"source compatibility. Where this was not possible (for example in the return"
" type of ``ActorSystem.terminate()``) please refer to the ``scala-"
"java8-compat`` library that allows easy conversion between the Scala and "
"Java counterparts. The artifact can be included in Maven builds using::"
msgstr ""

# e3190cf36cd24958b8ac4c05f51ec010
#: ../../java/lambda-index-actors.rst:20
msgid ""
"We will only be able to seamlessly integrate all functional interfaces once "
"we can rely on Scala 2.12 to provide full interoperability—this will mean "
"that Scala users can directly implement Java Functional Interfaces using "
"lambda syntax as well as that Java users can directly implement Scala "
"functions using lambda syntax."
msgstr ""

# 740313dfe6554dd580c4eb7a497fc639
#: ../../java/lambda-persistence.rst:5
msgid "Persistence (Java with Lambda Support)"
msgstr ""

# 6eb0e410303c4dcf9b3109a387c5d23b
# c0024dc72b8d415f9669ac64b54d8a1d
#: ../../java/lambda-persistence.rst:8 ../../java/persistence.rst:7
msgid ""
"Akka persistence enables stateful actors to persist their internal state so "
"that it can be recovered when an actor is started, restarted after a JVM "
"crash or by a supervisor, or migrated in a cluster. The key concept behind "
"Akka persistence is that only changes to an actor's internal state are "
"persisted but never its current state directly (except for optional "
"snapshots). These changes are only ever appended to storage, nothing is ever"
" mutated, which allows for very high transaction rates and efficient "
"replication. Stateful actors are recovered by replaying stored changes to "
"these actors from which they can rebuild internal state. This can be either "
"the full history of changes or starting from a snapshot which can "
"dramatically reduce recovery times. Akka persistence also provides point-to-"
"point communication with at-least-once message delivery semantics."
msgstr ""

# b82ef82652dd4273be88b5e64cf2d742
#: ../../java/lambda-persistence.rst:17
msgid ""
"Akka persistence is inspired by the `eventsourced`_ library. It follows the "
"same concepts and architecture of `eventsourced`_ but significantly differs "
"on API and implementation level."
msgstr ""

# fc06719a06e2461bb6ba1d68caad9113
# 64d7b995028b4d6f82e546fb2047897b
#: ../../java/lambda-persistence.rst:25 ../../java/persistence.rst:29
msgid ""
"Akka persistence is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

# 25b4948b2304486c8bbc6c3e2d61a611
# 497e26f934b346269d9c9500409c9bf3
#: ../../java/lambda-persistence.rst:33 ../../java/persistence.rst:37
msgid ""
"The Akka persistence extension comes with few built-in persistence plugins, "
"including in-memory heap based journal, local file-system based snapshot-"
"store and LevelDB based journal."
msgstr ""

# f3fca46775544000b52a32a57f237d5d
# dad435b0ea634e96bd4d794ea11319a9
#: ../../java/lambda-persistence.rst:36 ../../java/persistence.rst:40
msgid ""
"LevelDB based plugins will require the following additional dependency "
"declaration::"
msgstr ""

# a597c75768f6448791e3c33e518ac8ae
# b567d3a2d6e14c09a5b7bac1ce052df1
#: ../../java/lambda-persistence.rst:50 ../../java/persistence.rst:54
msgid "Architecture"
msgstr ""

# 3bcb079884d842b7944f44c0d5b0795c
#: ../../java/lambda-persistence.rst:52
msgid ""
"*AbstractPersistentActor*: Is a persistent, stateful actor. It is able to "
"persist events to a journal and can react to them in a thread-safe manner. "
"It can be used to implement both *command* as well as *event sourced* "
"actors. When a persistent actor is started or restarted, journaled messages "
"are replayed to that actor so that it can recover internal state from these "
"messages."
msgstr ""

# 82992badf35949f199ce09a7e22650cc
#: ../../java/lambda-persistence.rst:57
msgid ""
"*AbstractPersistentView*: A view is a persistent, stateful actor that "
"receives journaled messages that have been written by another persistent "
"actor. A view itself does not journal new messages, instead, it updates "
"internal state only from a persistent actor's replicated message stream."
msgstr ""

# fb072257956f4f4789389b19f98eb81b
#: ../../java/lambda-persistence.rst:61
msgid ""
"*AbstractPersistentActorAtLeastOnceDelivery*: To send messages with at-"
"least-once delivery semantics to destinations, also in case of sender and "
"receiver JVM crashes."
msgstr ""

# c5f18ad9ed6c4535bbd8c0fd7af6fb29
#: ../../java/lambda-persistence.rst:64
msgid ""
"*AsyncWriteJournal*: A journal stores the sequence of messages sent to a "
"persistent actor. An application can control which messages are journaled "
"and which are received by the persistent actor without being journaled. The "
"storage backend of a journal is pluggable. The persistence extension comes "
"with a \"leveldb\" journal plugin which writes to the local filesystem. "
"Replicated journals are available as `Community plugins`_."
msgstr ""

# 1b1f859e231744b2bd5234a059b4565d
#: ../../java/lambda-persistence.rst:69
msgid ""
"*Snapshot store*: A snapshot store persists snapshots of a persistent "
"actor's or a view's internal state. Snapshots are used for optimizing "
"recovery times. The storage backend of a snapshot store is pluggable. The "
"persistence extension comes with a \"local\" snapshot storage plugin which "
"writes to the local filesystem. Replicated snapshot stores are available as "
"`Community plugins`_."
msgstr ""

# d43d57d0e704448b8d8ddf748eba28f7
#: ../../java/lambda-persistence.rst:74
msgid ""
"*Event sourcing*. Based on the building blocks described above, Akka "
"persistence provides abstractions for the development of event sourced "
"applications (see section :ref:`event-sourcing-java-lambda`)"
msgstr ""

# 394963da4f2541cfb37b7b39088e337e
# 28fb9248b99544d0a7977ca5eabddbf4
#: ../../java/lambda-persistence.rst:82 ../../java/persistence.rst:83
msgid "Event sourcing"
msgstr ""

# 0fd6518516064c2a860378b6de8ae23f
#: ../../java/lambda-persistence.rst:84
msgid ""
"The basic idea behind `Event Sourcing`_ is quite simple. A persistent actor "
"receives a (non-persistent) command which is first validated if it can be "
"applied to the current state. Here validation can mean anything, from simple"
" inspection of a command message's fields up to a conversation with several "
"external services, for example. If validation succeeds, events are generated"
" from the command, representing the effect of the command. These events are "
"then persisted and, after successful persistence, used to change the actor's"
" state. When the persistent actor needs to be recovered, only the persisted "
"events are replayed of which we know that they can be successfully applied. "
"In other words, events cannot fail when being replayed to a persistent "
"actor, in contrast to commands. Event sourced actors may of course also "
"process commands that do not change application state such as query commands"
" for example."
msgstr ""

# f3d2c9f2cc6d4cc5a20b4e6a788328f0
#: ../../java/lambda-persistence.rst:95
msgid ""
"Akka persistence supports event sourcing with the "
"``AbstractPersistentActor`` abstract class. An actor that extends this class"
" uses the ``persist`` method to persist and handle events. The behavior of "
"an ``AbstractPersistentActor`` is defined by implementing ``receiveRecover``"
" and ``receiveCommand``. This is demonstrated in the following example."
msgstr ""

# c3fea2532347489f9e0106fa15c879fe
# 501b0f04a3de43bd8b8561c2c799e818
#: ../../java/lambda-persistence.rst:101 ../../java/persistence.rst:102
msgid ""
"The example defines two data types, ``Cmd`` and ``Evt`` to represent "
"commands and events, respectively. The ``state`` of the "
"``ExamplePersistentActor`` is a list of persisted event data contained in "
"``ExampleState``."
msgstr ""

# ba0dec2c38314efc82d21fc6275d5b16
#: ../../java/lambda-persistence.rst:104
msgid ""
"The persistent actor's ``receiveRecover`` method defines how ``state`` is "
"updated during recovery by handling ``Evt`` and ``SnapshotOffer`` messages. "
"The persistent actor's ``receiveCommand`` method is a command handler. In "
"this example, a command is handled by generating two events which are then "
"persisted and handled. Events are persisted by calling ``persist`` with an "
"event (or a sequence of events) as first argument and an event handler as "
"second argument."
msgstr ""

# 196f5b2dad0c4574a41ab15fce04fc43
# c61bb437ba65453b9088262546abd4e3
#: ../../java/lambda-persistence.rst:109 ../../java/persistence.rst:110
msgid ""
"The ``persist`` method persists events asynchronously and the event handler "
"is executed for successfully persisted events. Successfully persisted events"
" are internally sent back to the persistent actor as individual messages "
"that trigger event handler executions. An event handler may close over "
"persistent actor state and mutate it. The sender of a persisted event is the"
" sender of the corresponding command. This allows event handlers to reply to"
" the sender of a command (not shown)."
msgstr ""

# 9c04de5ecb864001881fdf62de6aa7e3
# 0084b0f58b2b47edab6b19c983fe3235
#: ../../java/lambda-persistence.rst:115 ../../java/persistence.rst:116
msgid ""
"The main responsibility of an event handler is changing persistent actor "
"state using event data and notifying others about successful state changes "
"by publishing events."
msgstr ""

# 115fa7d0301f4e859e869c82b4ddde16
#: ../../java/lambda-persistence.rst:118
msgid ""
"When persisting events with ``persist`` it is guaranteed that the persistent"
" actor will not receive further commands between the ``persist`` call and "
"the execution(s) of the associated event handler. This also holds for "
"multiple ``persist`` calls in context of a single command. Incoming messages"
" are :ref:`stashed <internal-stash-lambda>` until the ``persist`` is "
"completed."
msgstr ""

# 00e3d5b2510f4acc80360ae8c066d3db
#: ../../java/lambda-persistence.rst:123
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped. If persistence of an event is rejected before it is stored, e.g. "
"due to serialization error, ``onPersistRejected`` will be invoked (logging a"
" warning by default), and the actor continues with next message."
msgstr ""

# d91547c94ce3402887cf9ddc6f07f028
#: ../../java/lambda-persistence.rst:128
msgid ""
"The easiest way to run this example yourself is to download `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_ and open the "
"tutorial named `Akka Persistence Samples in Java with Lambdas "
"<http://www.lightbend.com/activator/template/akka-sample-persistence-java-"
"lambda>`_. It contains instructions on how to run the "
"``PersistentActorExample``."
msgstr ""

# 9f1327ce34f44c7499e1cfe780d6d6ee
#: ../../java/lambda-persistence.rst:134
msgid ""
"It's also possible to switch between different command handlers during "
"normal processing and recovery with ``context().become()`` and "
"``context().unbecome()``. To get the actor into the same state after "
"recovery you need to take special care to perform the same state transitions"
" with ``become`` and ``unbecome`` in the ``receiveRecover`` method as you "
"would have done in the command handler. Note that when using ``become`` from"
" ``receiveRecover`` it will still only use the ``receiveRecover`` behavior "
"when replaying the events. When replay is completed it will use the new "
"behavior."
msgstr ""

# f0d9c26a7f7245e3bd8c9df7a6343681
# 7e284a5772344134a5a7c2e14097e427
# a6783a095a6b4456a373d01307942379
# 9294bc0a07db4eda94e13e756fa20a0f
#: ../../java/lambda-persistence.rst:142 ../../java/lambda-persistence.rst:519
#: ../../java/persistence.rst:143 ../../java/persistence.rst:525
msgid "Identifiers"
msgstr ""

# 6c9a44bef3d14318ad512f29f2403cce
# c665103f80a04e12807c2d68e84e2b7c
#: ../../java/lambda-persistence.rst:144 ../../java/persistence.rst:145
msgid ""
"A persistent actor must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``persistenceId`` method."
msgstr ""

# de12a3f3bfb74a02b1cf86db7d592cc5
# 967ec58217034d1dab1bad3410e5dc90
# 51ae176391f042b78d25810faa6e84c3
# c24ce6e9a1b74c9c88b52894d03536be
#: ../../java/lambda-persistence.rst:152 ../../java/lambda-persistence.rst:510
#: ../../java/persistence.rst:154 ../../java/persistence.rst:516
msgid "Recovery"
msgstr ""

# c50c26a594504d22bbda7fc1f4a3fe44
#: ../../java/lambda-persistence.rst:154
msgid ""
"By default, a persistent actor is automatically recovered on start and on "
"restart by replaying journaled messages. New messages sent to a persistent "
"actor during recovery do not interfere with replayed messages. New messages "
"will only be received by a persistent actor after recovery completes."
msgstr ""

# 36d6197f39774ceea09e05f84b607019
# 3584da8da5bc456b98da31385e78f3b2
#: ../../java/lambda-persistence.rst:159 ../../java/persistence.rst:161
msgid ""
"Accessing the ``sender()`` for replayed messages will always result in a "
"``deadLetters`` reference, as the original sender is presumed to be long "
"gone. If you indeed have to notify an actor during recovery in the future, "
"store its ``ActorPath`` explicitly in your persisted events."
msgstr ""

# ee7013d139394d468c5eb2fe985d260f
# e1b653e130734139964462f8f0309605
#: ../../java/lambda-persistence.rst:164 ../../java/persistence.rst:166
msgid "Recovery customization"
msgstr ""

# 81eb70ca2203461884a135928c43bf0a
#: ../../java/lambda-persistence.rst:166
msgid ""
"Applications may also customise how recovery is performed by returning a "
"customised ``Recovery`` object in the ``recovery`` method of a "
"``AbstractPersistentActor``, for example setting an upper bound to the "
"replay which allows the actor to be replayed to a certain point \"in the "
"past\" instead to its most up to date state:"
msgstr ""

# 4ff8ac4587b94a0e996b7ce850d26e03
#: ../../java/lambda-persistence.rst:172
msgid ""
"Recovery can be disabled by returning ``Recovery.none`` in the ``recovery`` "
"method of a ``PersistentActor``:"
msgstr ""

# 9a5b9dbec1c44be9b51d5e5ca59f6da1
# 5e14716df2794f98993ffaf8682c14c6
#: ../../java/lambda-persistence.rst:177 ../../java/persistence.rst:179
msgid "Recovery status"
msgstr ""

# d3df3f38702b47f79a324253abe2f22b
# 5fa670422cd241caaf6d5d73bc80485a
#: ../../java/lambda-persistence.rst:179 ../../java/persistence.rst:181
msgid "A persistent actor can query its own recovery status via the methods"
msgstr ""

# b706d26cade44477900886f67a7b8604
# 64c438a3f36c40eca1947f892a3716d9
#: ../../java/lambda-persistence.rst:183 ../../java/persistence.rst:185
msgid ""
"Sometimes there is a need for performing additional initialization when the "
"recovery has completed before processing any other message sent to the "
"persistent actor. The persistent actor will receive a special "
":class:`RecoveryCompleted` message right after recovery and before any other"
" received messages."
msgstr ""

# 6b8178a02653476a87e1c14bd55bc6b5
#: ../../java/lambda-persistence.rst:190
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal, ``onRecoveryFailure`` is called (logging the error by default), and"
" the actor will be stopped."
msgstr ""

# 5450725017c4410d845c6b3677978d9f
# e93abd4606874bad8610b87f98f360e2
#: ../../java/lambda-persistence.rst:196 ../../java/persistence.rst:198
msgid "Internal stash"
msgstr ""

# fc672c7ec0a243398ce43a2c297acd4e
#: ../../java/lambda-persistence.rst:198
msgid ""
"The persistent actor has a private :ref:`stash <stash-lambda>` for "
"internally caching incoming messages during :ref:`recovery <recovery-java-"
"lambda>` or the ``persist\\persistAll`` method persisting events. You can "
"still use/inherit from the ``Stash`` interface. The internal stash "
"cooperates with the normal stash by hooking into ``unstashAll`` method and "
"making sure messages are unstashed properly to the internal stash to "
"maintain ordering guarantees."
msgstr ""

# fb8393537f214d8abc233a22a04c3260
# dfd977aaccda402793a5d6d5a8e6f3f9
#: ../../java/lambda-persistence.rst:204 ../../java/persistence.rst:205
msgid ""
"You should be careful to not send more messages to a persistent actor than "
"it can keep up with, otherwise the number of stashed messages will grow "
"without bounds. It can be wise to protect against ``OutOfMemoryError`` by "
"defining a maximum stash capacity in the mailbox configuration::"
msgstr ""

# c918c3c7896d4c2c9b9ea8ab8835bc84
# 86a1692ccfc04a2b861177db9da2303e
#: ../../java/lambda-persistence.rst:210 ../../java/persistence.rst:211
msgid ""
"Note that the stash capacity is per actor. If you have many persistent "
"actors, e.g. when using cluster sharding, you may need to define a small "
"stash capacity to ensure that the total number of stashed messages in the "
"system don't consume too much memory. Additionally, The persistent actor "
"defines three strategies to handle failure when the internal stash capacity "
"is exceeded. The default overflow strategy is the "
"``ThrowOverflowExceptionStrategy``, which discards the current received "
"message and throws a ``StashOverflowException``, causing actor restart if "
"default supervision strategy is used. you can override the "
"``internalStashOverflowStrategy`` method to return "
"``DiscardToDeadLetterStrategy`` or ``ReplyToStrategy`` for any "
"\"individual\" persistent actor, or define the \"default\" for all "
"persistent actors by providing FQCN, which must be a subclass of "
"``StashOverflowStrategyConfigurator``, in the persistence configuration::"
msgstr ""

# 98a4b7779b944cbda6544a8d6a958735
# 3d8720d99fd64a81bce3543a6b183b29
#: ../../java/lambda-persistence.rst:223 ../../java/persistence.rst:224
msgid ""
"The ``DiscardToDeadLetterStrategy`` strategy also has a pre-packaged "
"companion configurator ``akka.persistence.DiscardConfigurator``."
msgstr ""

# 51feb251b22c4229bc55ce4415333922
# 2b2b4f5d01d54ce291910438d2e5a8dc
#: ../../java/lambda-persistence.rst:226 ../../java/persistence.rst:227
msgid ""
"You can also query default strategy via the Akka persistence extension "
"singleton::"
msgstr ""

# b8d1ece28fc945f48c4e970e3587a434
# d77bde5d05d64ca5b56d015dc6a398b6
#: ../../java/lambda-persistence.rst:231 ../../java/persistence.rst:232
msgid ""
"The bounded mailbox should be avoided in the persistent actor, by which the "
"messages come from storage backends may be discarded. You can use bounded "
"stash instead of it."
msgstr ""

# 2e6ceae53c8e418f82b3a207fed1366c
# 44de0cca778c4f93b3b00ca8395bca71
#: ../../java/lambda-persistence.rst:236 ../../java/persistence.rst:239
msgid "Relaxed local consistency requirements and high throughput use-cases"
msgstr ""

# f9661c9671454319b7321150a16a0460
# f120e74c7fc0433a8e7a41c58d0edf96
#: ../../java/lambda-persistence.rst:238 ../../java/persistence.rst:241
msgid ""
"If faced with relaxed local consistency requirements and high throughput "
"demands sometimes ``PersistentActor`` and its ``persist`` may not be enough "
"in terms of consuming incoming Commands at a high rate, because it has to "
"wait until all Events related to a given Command are processed in order to "
"start processing the next Command. While this abstraction is very useful for"
" most cases, sometimes you may be faced with relaxed requirements about "
"consistency – for example you may want to process commands as fast as you "
"can, assuming that the Event will eventually be persisted and handled "
"properly in the background, retroactively reacting to persistence failures "
"if needed."
msgstr ""

# 2d72645a28a94acaabcd2fe2d2a6912a
# 11f8259d294648d79a468506f9e55c82
#: ../../java/lambda-persistence.rst:245 ../../java/persistence.rst:248
msgid ""
"The ``persistAsync`` method provides a tool for implementing high-throughput"
" persistent actors. It will *not* stash incoming Commands while the Journal "
"is still working on persisting and/or user code is executing event "
"callbacks."
msgstr ""

# 969789e4d499447280aef4b17d2708f2
# 90e89f00c5dc42ae85908c5c46a6c983
#: ../../java/lambda-persistence.rst:248 ../../java/persistence.rst:251
msgid ""
"In the below example, the event callbacks may be called \"at any time\", "
"even after the next Command has been processed. The ordering between events "
"is still guaranteed (\"evt-b-1\" will be sent after \"evt-a-2\", which will "
"be sent after \"evt-a-1\" etc.)."
msgstr ""

# edc0deab2f2641e38df2efecb139bcf4
#: ../../java/lambda-persistence.rst:254
msgid ""
"In order to implement the pattern known as \"*command sourcing*\" simply "
"call ``persistAsync`` on all incoming messages right away and handle them in"
" the callback."
msgstr ""

# f97e29094d294721ae5b4aadec48606b
# a225ac0065494f4aa5d5afeddcb53020
#: ../../java/lambda-persistence.rst:258 ../../java/persistence.rst:261
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) in "
"between the call to ``persistAsync`` and the journal has confirmed the "
"write."
msgstr ""

# b67974e7ac534b76a1e0fa28fb98bfe4
# 9b84ad6536df43f6b78b64c368c21b19
#: ../../java/lambda-persistence.rst:264 ../../java/persistence.rst:267
msgid "Deferring actions until preceding persist handlers have executed"
msgstr ""

# e2bbd351ae014a2facf84bf90bd6db0b
# 230885c20b4641d78c19a367d1485599
#: ../../java/lambda-persistence.rst:266 ../../java/persistence.rst:269
msgid ""
"Sometimes when working with ``persistAsync`` you may find that it would be "
"nice to define some actions in terms of ''happens-after the previous "
"``persistAsync`` handlers have been invoked''. ``PersistentActor`` provides "
"an utility method called ``deferAsync``, which works similarly to "
"``persistAsync`` yet does not persist the passed in event. It is recommended"
" to use it for *read* operations, and actions which do not have "
"corresponding events in your domain model."
msgstr ""

# 1b5b4055b9524ac7b32a70a2d407a006
# afd589ef0e1d450e8673e7cb4b3e40a1
#: ../../java/lambda-persistence.rst:271 ../../java/persistence.rst:274
msgid ""
"Using this method is very similar to the persist family of methods, yet it "
"does **not** persist the passed in event. It will be kept in memory and used"
" when invoking the handler."
msgstr ""

# 3752a4adc6e6484cba9aa33ee8d846b6
# 42b1ad61c93a4875af98e3b3c27173fd
#: ../../java/lambda-persistence.rst:276 ../../java/persistence.rst:279
msgid ""
"Notice that the ``sender()`` is **safe** to access in the handler callback, "
"and will be pointing to the original sender of the command for which this "
"``deferAsync`` handler was called."
msgstr ""

# fa1510197974416f9719e1077bcc7459
# 2f44db02b2164910912d760ecbbc8218
#: ../../java/lambda-persistence.rst:282 ../../java/persistence.rst:285
msgid ""
"The callback will not be invoked if the actor is restarted (or stopped) in "
"between the call to ``deferAsync`` and the journal has processed and "
"confirmed all preceding writes."
msgstr ""

# 0ceb1551051e4bcaae5b8bd0f54ba5b0
# 3dd2d22dfc3c4ed9805ae6d28bec583e
#: ../../java/lambda-persistence.rst:288 ../../java/persistence.rst:291
msgid "Nested persist calls"
msgstr ""

# 6e4941113b1d45608ff8d75950c443ca
# 9a538dab3298495986b35556f0699a7e
#: ../../java/lambda-persistence.rst:289 ../../java/persistence.rst:292
msgid ""
"It is possible to call ``persist`` and ``persistAsync`` inside their "
"respective callback blocks and they will properly retain both the thread "
"safety (including the right value of ``sender()``) as well as stashing "
"guarantees."
msgstr ""

# 0a6225d8a1d1400c8d4c9ba959f4df3f
# 4948923964dd46a9b1b4340785255668
#: ../../java/lambda-persistence.rst:292 ../../java/persistence.rst:295
msgid ""
"In general it is encouraged to create command handlers which do not need to "
"resort to nested event persisting, however there are situations where it may"
" be useful. It is important to understand the ordering of callback execution"
" in those situations, as well as their implication on the stashing behaviour"
" (that ``persist()`` enforces). In the following example two persist calls "
"are issued, and each of them issues another persist inside its callback:"
msgstr ""

# 3a41664196f44537a024dd01e3528e5e
# 9fa73e35975a45e1a8f1e12107275bf8
#: ../../java/lambda-persistence.rst:299 ../../java/persistence.rst:302
msgid ""
"When sending two commands to this ``PersistentActor``, the persist handlers "
"will be executed in the following order:"
msgstr ""

# ec57ac8423e840cd922bcbde74ea3edd
# fc6c10f5d4ec43a3982e9994b29b6364
#: ../../java/lambda-persistence.rst:303 ../../java/persistence.rst:306
msgid ""
"First the \"outer layer\" of persist calls is issued and their callbacks are"
" applied. After these have successfully completed, the inner callbacks will "
"be invoked (once the events they are persisting have been confirmed to be "
"persisted by the journal). Only after all these handlers have been "
"successfully invoked will the next command be delivered to the persistent "
"Actor. In other words, the stashing of incoming commands that is guaranteed "
"by initially calling ``persist()`` on the outer layer is extended until all "
"nested ``persist`` callbacks have been handled."
msgstr ""

# 16a35cbe42ac447286c9089b6f8a16f3
# 2163ec074f31492ba2ad7c9f7a3da1d7
#: ../../java/lambda-persistence.rst:309 ../../java/persistence.rst:312
msgid ""
"It is also possible to nest ``persistAsync`` calls, using the same pattern:"
msgstr ""

# 8b283913ed95431cbcc3230b86a7e375
#: ../../java/lambda-persistence.rst:313
msgid ""
"In this case no stashing is happening, yet the events are still persisted "
"and callbacks executed in the expected order:"
msgstr ""

# 53062d059d154cb290694e806eb6666f
# 5bb87cb07cff43f6a20b74c5b4039c8f
#: ../../java/lambda-persistence.rst:317 ../../java/persistence.rst:320
msgid ""
"While it is possible to nest mixed ``persist`` and ``persistAsync`` with "
"keeping their respective semantics it is not a recommended practice, as it "
"may lead to overly complex nesting."
msgstr ""

# 1a9ee40de9f84f2289aa5536f3b06a71
# 5132dc23d2c940858e370c83b5d1e5ad
#: ../../java/lambda-persistence.rst:323 ../../java/persistence.rst:326
msgid "Failures"
msgstr ""

# 8a29675b28af47e880725a319a3531c8
# 73a28a7c03724844839ed2b8ebd66414
#: ../../java/lambda-persistence.rst:325 ../../java/persistence.rst:328
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped."
msgstr ""

# 3013c3fa652a487290731e1de3f1343e
#: ../../java/lambda-persistence.rst:328
msgid ""
"The reason that it cannot resume when persist fails is that it is unknown if"
" the even was actually persisted or not, and therefore it is in an "
"inconsistent state. Restarting on persistent failures will most likely fail "
"anyway, since the journal is probably unavailable. It is better to stop the "
"actor and after a back-off timeout start it again. The "
"``akka.pattern.BackoffSupervisor`` actor is provided to support such "
"restarts."
msgstr ""

# 18a8fed84dab4e6fa36c13206e3dd438
# 09968a2cfb8247c48eb62ab93bb9bba1
#: ../../java/lambda-persistence.rst:336 ../../java/persistence.rst:339
msgid ""
"If persistence of an event is rejected before it is stored, e.g. due to "
"serialization error, ``onPersistRejected`` will be invoked (logging a "
"warning by default), and the actor continues with next message."
msgstr ""

# d762ef165124423c97a7fe2a8076fc0c
# 756645887a7b4380b3c385d272a75c4d
#: ../../java/lambda-persistence.rst:340 ../../java/persistence.rst:343
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal when the actor is started, ``onRecoveryFailure`` is called (logging "
"the error by default), and the actor will be stopped."
msgstr ""

# 94e2a654bae6428eb31e05e163075b57
# 0ce01181d950402585e2eac9e10f384c
#: ../../java/lambda-persistence.rst:344 ../../java/persistence.rst:347
msgid "Atomic writes"
msgstr ""

# 235547172b22433ebdfc243d678c2203
# a49321ab33c04f7fbc67ff8b93a1123f
#: ../../java/lambda-persistence.rst:346 ../../java/persistence.rst:349
msgid ""
"Each event is of course stored atomically, but it is also possible to store "
"several events atomically by using the ``persistAll`` or ``persistAllAsync``"
" method. That means that all events passed to that method are stored or none"
" of them are stored if there is an error."
msgstr ""

# 0001abf8ae594abfba4d9ee06f9717c3
# 996eacaa84ec48069d6ec3291a76c392
#: ../../java/lambda-persistence.rst:350 ../../java/persistence.rst:353
msgid ""
"The recovery of a persistent actor will therefore never be done partially "
"with only a subset of events persisted by `persistAll`."
msgstr ""

# ee82de83ad3e4ac3ab40c4a34a72fb51
# 4df2b84fae434941a33051aedbc9e5ac
#: ../../java/lambda-persistence.rst:353 ../../java/persistence.rst:356
msgid ""
"Some journals may not support atomic writes of several events and they will "
"then reject the ``persistAll`` command, i.e. ``onPersistRejected`` is called"
" with an exception (typically ``UnsupportedOperationException``)."
msgstr ""

# cb15ae3c93f5412e9a51ab2a1bf252a0
# 5fcd879704aa4034abd161892d4efbf7
#: ../../java/lambda-persistence.rst:357 ../../java/persistence.rst:360
msgid "Batch writes"
msgstr ""

# c6dfe59702bc4a25a03571038939d80e
# 9f57ad00aa8c435ea850894a8270f8d2
#: ../../java/lambda-persistence.rst:359 ../../java/persistence.rst:362
msgid ""
"In order to optimize throughput when using ``persistAsync``, a persistent "
"actor internally batches events to be stored under high load before writing "
"them to the journal (as a single batch). The batch size is dynamically "
"determined by how many events are emitted during the time of a journal "
"round-trip: after sending a batch to the journal no further batch can be "
"sent before confirmation has been received that the previous batch has been "
"written. Batch writes are never timer-based which keeps latencies at a "
"minimum."
msgstr ""

# 42e20c47dedd40ae850ec29514ed8989
# e7d84c273bc24be28fc76a5887c7a9c4
#: ../../java/lambda-persistence.rst:368 ../../java/persistence.rst:371
msgid "Message deletion"
msgstr ""

# 668a06b9da0f47f485499b2c22d64a9b
# 3b631ff7baee46d5a0986d751b2b9b00
#: ../../java/lambda-persistence.rst:370 ../../java/persistence.rst:373
msgid ""
"It is possible to delete all messages (journaled by a single persistent "
"actor) up to a specified sequence number; Persistent actors may call the "
"``deleteMessages`` method to this end."
msgstr ""

# f19a7a3607494656b21255ad22d3c3ba
#: ../../java/lambda-persistence.rst:373
msgid ""
"Deleting messages in event sourcing based applications is typically either "
"not used at all or used in conjunction with :ref:`snapshotting <snapshots>`,"
" i.e. after a snapshot has been successfully stored, a "
"``deleteMessages(toSequenceNr)`` up until the sequence number of the data "
"held by that snapshot can be issued to safely delete the previous events "
"while still having access to the accumulated state during replays - by "
"loading the snapshot."
msgstr ""

# 33dee80f16b74ae195c0f4bbf448a67e
# fb3c96b6ae894eee9b75e67d55ea972f
#: ../../java/lambda-persistence.rst:378 ../../java/persistence.rst:381
msgid ""
"The result of the ``deleteMessages`` request is signaled to the persistent "
"actor with a ``DeleteMessagesSuccess`` message if the delete was successful "
"or a ``DeleteMessagesFailure`` message if it failed."
msgstr ""

# 89aff4badddf4845a5fe6da411abaa62
# a2b7137cf9834f82b217a9dada489a66
#: ../../java/lambda-persistence.rst:382 ../../java/persistence.rst:387
msgid "Persistence status handling"
msgstr ""

# c8ff904d2df345718a403ff1f287edd7
#: ../../java/lambda-persistence.rst:383
msgid ""
"Persisting, deleting and replaying messages can either succeed or fail."
msgstr ""

# 25c61da2619e4b069235d8ff05786a95
# 5a9b3fbd5e57495aa6b0f07bcda70ec2
# d12a84f6a70942a38617137c831d95f1
# bfeea1a5bcbe4280be65cdd927dc0206
#: ../../java/lambda-persistence.rst:386 ../../java/lambda-persistence.rst:583
#: ../../java/persistence.rst:391 ../../java/persistence.rst:589
msgid "**Method**"
msgstr ""

# cf1698df6b00462d9c24b5d4f3678fa7
# b86799af286f47118aa90e555d056b08
# 81824e8d102c41eaae466b25c0c3f9eb
# e9501e6982f740dd8d1eac764aaf0936
#: ../../java/lambda-persistence.rst:386 ../../java/lambda-persistence.rst:583
#: ../../java/persistence.rst:391 ../../java/persistence.rst:589
msgid "**Success**"
msgstr ""

# 3bce0b6a24c74c76a07ef93466cd1ab3
# 20b666ee178d4faea96ed9ebeb9c8b61
#: ../../java/lambda-persistence.rst:386 ../../java/persistence.rst:391
msgid "**Failure / Rejection**"
msgstr ""

# 34078148c1e04dbfbfc48d9999ef7065
# 3cbb6014c0744a63b6e61e46416d0e87
#: ../../java/lambda-persistence.rst:386 ../../java/persistence.rst:391
msgid "**After failure handler invoked**"
msgstr ""

# ba2059baa7e5497095c9288e19fbfcd7
# 49a5cf5a755748b98a062e6af84d3b9b
#: ../../java/lambda-persistence.rst:388 ../../java/persistence.rst:393
msgid "``persist`` / ``persistAsync``"
msgstr ""

# 807a836e7cbd40d1bcc0c00972a22880
# bd27ffc1e4a744b889f7a662fe9edf83
#: ../../java/lambda-persistence.rst:388 ../../java/persistence.rst:393
msgid "persist handler invoked"
msgstr ""

# 999b3528989d4546aae02e8505fcd3ef
# 6c6958eb410744cb90a92bc58e11b5d7
#: ../../java/lambda-persistence.rst:388 ../../java/persistence.rst:393
msgid "``onPersistFailure``"
msgstr ""

# fd5bfd1f1b694399aa3d53697d957ae6
# 77240e2a7b3b4de09fec8e83dbcb8c67
# af6687c304f14009a842a096582792d8
# 4407adc520284bf5829a8640eae88dcc
#: ../../java/lambda-persistence.rst:388 ../../java/lambda-persistence.rst:392
#: ../../java/persistence.rst:393 ../../java/persistence.rst:397
msgid "Actor is stopped."
msgstr ""

# beef0b660e174be09198ac5f7a9ca46a
# 6f2aa21beb3649a5a125e12c85c297c6
#: ../../java/lambda-persistence.rst:390 ../../java/persistence.rst:395
msgid "``onPersistRejected``"
msgstr ""

# bc2450d99d4346b8b68fc9ae3b1ee2a5
# 57df7f2471814938b323aefc311a403d
# cb387ff4e0b44c54ac3a0c05a5a6941d
# 01dd6f9746b74e2e9e1354eaf205af55
#: ../../java/lambda-persistence.rst:390 ../../java/lambda-persistence.rst:394
#: ../../java/persistence.rst:395 ../../java/persistence.rst:399
msgid "No automatic actions."
msgstr ""

# 9dbd17795a8e420d81494789d63b3021
# d2bedfe51436400dbd7e22391991783e
#: ../../java/lambda-persistence.rst:392 ../../java/persistence.rst:397
msgid "``recovery``"
msgstr ""

# cfd5c23e24474e82ab1bf80f410bd6d6
# 23083a4040bf4edaafa02afd1f98e9a1
#: ../../java/lambda-persistence.rst:392 ../../java/persistence.rst:397
msgid "``RecoverySuccess``"
msgstr ""

# 1c387f61a44a439ebf2d26ee5aa11a38
# 1ee3541ee0784f1d91e89fce53123ea4
#: ../../java/lambda-persistence.rst:392 ../../java/persistence.rst:397
msgid "``onRecoveryFailure``"
msgstr ""

# 86fcc9a5a0934a1f8aa08c3e348afa94
# 310b647fcad149ee993fe660a8941000
#: ../../java/lambda-persistence.rst:394 ../../java/persistence.rst:399
msgid "``deleteMessages``"
msgstr ""

# d72d9d73667d438a80fcadf7a10c245e
# 66e87be516324b188fe796d8523ea20e
#: ../../java/lambda-persistence.rst:394 ../../java/persistence.rst:399
msgid "``DeleteMessagesSuccess``"
msgstr ""

# e669a9ea1a00442c8afa3f02f90cc7e0
# 1170453dab214258aaba794f3a36d979
#: ../../java/lambda-persistence.rst:394 ../../java/persistence.rst:399
msgid "``DeleteMessagesFailure``"
msgstr ""

# 4579beef8ac245ba9127e8ede09c470f
# 231e7ae4f85a4b55a05a9b7269090861
#: ../../java/lambda-persistence.rst:397 ../../java/persistence.rst:402
msgid ""
"The most important operations (``persist`` and ``recovery``) have failure "
"handlers modelled as explicit callbacks which the user can override in the "
"``PersistentActor``. The default implementations of these handlers emit a "
"log message (``error`` for persist/recovery failures, and ``warning`` for "
"others), logging the failure cause and information about which message "
"caused the failure."
msgstr ""

# d153caed9e69422d9de76ec47aa74302
#: ../../java/lambda-persistence.rst:402
msgid ""
"For critical failures, such as recovery or persisting events failing, the "
"persistent actor will be stopped after the failure handler is invoked. This "
"is because if the underlying journal implementation is signalling "
"persistence failures it is most likely either failing completely or "
"overloaded and restarting right-away and trying to persist the event again "
"will most likely not help the journal recover – as it would likely cause a "
"`Thundering herd problem`_, as many persistent actors would restart and try "
"to persist their events again. Instead, using a ``BackoffSupervisor`` (as "
"described in :ref:`failures-lambda`) which implements an exponential-backoff"
" strategy which allows for more breathing room for the journal to recover "
"between restarts of the persistent actor."
msgstr ""

# 93c71a7fcede43f0b56db9be8ad284ff
# 2ff2568c5293440eae142d7bdecb02e1
#: ../../java/lambda-persistence.rst:411 ../../java/persistence.rst:416
msgid ""
"Journal implementations may choose to implement a retry mechanism, e.g. such"
" that only after a write fails N number of times a persistence failure is "
"signalled back to the user. In other words, once a journal returns a "
"failure, it is considered *fatal* by Akka Persistence, and the persistent "
"actor which caused the failure will be stopped."
msgstr ""

# 051fb353d6f04018ad58aef2f2c7758e
# bd6e2454f48c40b4a48a8a294febf01c
#: ../../java/lambda-persistence.rst:415 ../../java/persistence.rst:420
msgid ""
"Check the documentation of the journal implementation you are using for "
"details if/how it is using this technique."
msgstr ""

# f4ee611491ec4f5d8a0ac2927ff72573
# 67ad57c9b0404ce7ae11700f1705e373
#: ../../java/lambda-persistence.rst:422 ../../java/persistence.rst:427
msgid "Safely shutting down persistent actors"
msgstr ""

# 22807970660142ab9386876841377c23
#: ../../java/lambda-persistence.rst:424
msgid ""
"Special care should be given when when shutting down persistent actors from "
"the outside. With normal Actors it is often acceptable to use the special "
":ref:`PoisonPill <poison-pill-java>` message to signal to an Actor that it "
"should stop itself once it receives this message – in fact this message is "
"handled automatically by Akka, leaving the target actor no way to refuse "
"stopping itself when given a poison pill."
msgstr ""

# 3326dfbf957144bcaf78af5d22bea5d2
# 415cecf12e004e7cb056811522fbd185
#: ../../java/lambda-persistence.rst:429 ../../java/persistence.rst:434
msgid ""
"This can be dangerous when used with :class:`PersistentActor` due to the "
"fact that incoming commands are *stashed* while the persistent actor is "
"awaiting confirmation from the Journal that events have been written when "
"``persist()`` was used. Since the incoming commands will be drained from the"
" Actor's mailbox and put into its internal stash while awaiting the "
"confirmation (thus, before calling the persist handlers) the Actor **may "
"receive and (auto)handle the PoisonPill before it processes the other "
"messages which have been put into its stash**, causing a pre-mature shutdown"
" of the Actor."
msgstr ""

# 0d7d60a095094b3faac00e50a24dbb99
# 37be8fc559054c8d9e4671ded1b9ab4c
#: ../../java/lambda-persistence.rst:436 ../../java/persistence.rst:441
msgid ""
"Consider using explicit shut-down messages instead of :class:`PoisonPill` "
"when working with persistent actors."
msgstr ""

# d4fd024090c24037bf061db687727576
# ab600d65f85b4d9887f465e92f3d62bf
#: ../../java/lambda-persistence.rst:438 ../../java/persistence.rst:443
msgid ""
"The example below highlights how messages arrive in the Actor's mailbox and "
"how they interact with its internal stashing mechanism when ``persist()`` is"
" used. Notice the early stop behaviour that occurs when ``PoisonPill`` is "
"used:"
msgstr ""

# ea17dacc33c2477db5162c2a547451a2
# 1cd4968afdf34859a5bc67a8e2893630
#: ../../java/lambda-persistence.rst:448 ../../java/persistence.rst:453
msgid "Persistent Views"
msgstr ""

# 9e04b8cf0d164f3bb2a66b51d1e4d6ba
#: ../../java/lambda-persistence.rst:452
msgid ""
"``AbstractPersistentView`` is deprecated. Use :ref:`persistence-query-java` "
"instead. The corresponding query type is ``EventsByPersistenceId``. There "
"are several alternatives for connecting the ``Source`` to an actor "
"corresponding to a previous ``UntypedPersistentView`` actor:"
msgstr ""

# fc2d2d92c6ef42f2b80b34bd4438a1dc
# 546d118003254aa7929400e86692afaf
#: ../../java/lambda-persistence.rst:456 ../../java/persistence.rst:461
msgid ""
"`Sink.actorRef`_ is simple, but has the disadvantage that there is no back-"
"pressure signal from the destination actor, i.e. if the actor is not "
"consuming the messages fast enough the mailbox of the actor will grow"
msgstr ""

# ce42b4bccc2c4e9a83bca47e5216f8f3
# 730e868974d949edaae5b32641f1b2bb
#: ../../java/lambda-persistence.rst:458 ../../java/persistence.rst:463
msgid ""
"`mapAsync`_ combined with :ref:`actors-ask-lambda` is almost as simple with "
"the advantage of back-pressure being propagated all the way"
msgstr ""

# 928ec091a0274c6a93714e8e5733508e
# 94c70f05876d4e14b8456d96c74c6299
#: ../../java/lambda-persistence.rst:460 ../../java/persistence.rst:465
msgid "`ActorSubscriber`_ in case you need more fine grained control"
msgstr ""

# 2af52737587a40f4aed43812b2d1982f
#: ../../java/lambda-persistence.rst:462
msgid ""
"The consuming actor may be a plain ``AbstractActor`` or an "
"``AbstractPersistentActor`` if it needs to store its own state (e.g. "
"fromSequenceNr offset)."
msgstr ""

# 920bb610c24b4c278df8c593e73b7a1d
#: ../../java/lambda-persistence.rst:469
msgid ""
"Persistent views can be implemented by extending the ``AbstractView`` "
"abstract class, implement the ``persistenceId`` method and setting the "
"“initial behavior” in the constructor by calling the :meth:`receive` method."
msgstr ""

# 853d671b09774bc7a67dcc7237e41718
# 7f99e6061187449bb136e72a13024b1b
#: ../../java/lambda-persistence.rst:474 ../../java/persistence.rst:479
msgid ""
"The ``persistenceId`` identifies the persistent actor from which the view "
"receives journaled messages. It is not necessary that the referenced "
"persistent actor is actually running. Views read messages from a persistent "
"actor's journal directly. When a persistent actor is started later and "
"begins to write new messages, by default the corresponding view is updated "
"automatically."
msgstr ""

# acec639b548f4d42b298190d00602e08
# aa451667948944b489b69b7e2da2922f
#: ../../java/lambda-persistence.rst:478 ../../java/persistence.rst:484
msgid ""
"It is possible to determine if a message was sent from the Journal or from "
"another actor in user-land by calling the ``isPersistent`` method. Having "
"that said, very often you don't need this information at all and can simply "
"apply the same logic to both cases (skip the ``if isPersistent`` check)."
msgstr ""

# 1ee03d5425f7421499b8ffb71d341cfb
# 93dc979700db4b2e897d1b6b75de0de9
#: ../../java/lambda-persistence.rst:483 ../../java/persistence.rst:489
msgid "Updates"
msgstr ""

# 4512d5bc8fcd4f02bc94b14683795a52
# 658dff871d814fb9b959dd7c5ed0ac50
#: ../../java/lambda-persistence.rst:485 ../../java/persistence.rst:491
msgid ""
"The default update interval of all persistent views of an actor system is "
"configurable:"
msgstr ""

# 18d26b55bb6540f7b4fd31e20f77b7fb
#: ../../java/lambda-persistence.rst:489
msgid ""
"``AbstractPersistentView`` implementation classes may also override the "
"``autoUpdateInterval`` method to return a custom update interval for a "
"specific view class or view instance. Applications may also trigger "
"additional updates at any time by sending a view an ``Update`` message."
msgstr ""

# 33b5d7542fe14510b7c8f917d4967e5e
# 668467336fe440d388a8b29624c88c7a
#: ../../java/lambda-persistence.rst:495 ../../java/persistence.rst:501
msgid ""
"If the ``await`` parameter is set to ``true``, messages that follow the "
"``Update`` request are processed when the incremental message replay, "
"triggered by that update request, completed. If set to ``false`` (default), "
"messages following the update request may interleave with the replayed "
"message stream. Automated updates always run with ``await = false``."
msgstr ""

# 8037bbe137464f9ead3522392df2ddf5
# 8bcd6f80b7aa43f0bfe6a477d8c46e1f
#: ../../java/lambda-persistence.rst:500 ../../java/persistence.rst:506
msgid ""
"Automated updates of all persistent views of an actor system can be turned "
"off by configuration:"
msgstr ""

# e8aa7529d00c49d0b93ec80600729f2f
# e45df870f9f24ef3bf4aa63161882e0b
#: ../../java/lambda-persistence.rst:504 ../../java/persistence.rst:510
msgid ""
"Implementation classes may override the configured default value by "
"overriding the ``autoUpdate`` method. To limit the number of replayed "
"messages per update request, applications can configure a custom "
"``akka.persistence.view.auto-update-replay-max`` value or override the "
"``autoUpdateReplayMax`` method. The number of replayed messages for manual "
"updates can be limited with the ``replayMax`` parameter of the ``Update`` "
"message."
msgstr ""

# b34e31e49dd74c48b0c7cf842b36d637
# b9ba036474c54ced8b3d121de69d1963
#: ../../java/lambda-persistence.rst:512 ../../java/persistence.rst:518
msgid ""
"Initial recovery of persistent views works the very same way as for "
"persistent actors (i.e. by sending a ``Recover`` message to self). The "
"maximum number of replayed messages during initial recovery is determined by"
" ``autoUpdateReplayMax``. Further possibilities to customize initial "
"recovery are explained in section :ref:`recovery-java`."
msgstr ""

# a99abd6dc0ef4ba9ae09229348f72487
# fa459581e61c41a5a35451ffd6eb16bd
#: ../../java/lambda-persistence.rst:521 ../../java/persistence.rst:527
msgid ""
"A persistent view must have an identifier that doesn't change across "
"different actor incarnations. The identifier must be defined with the "
"``viewId`` method."
msgstr ""

# 7290f86c9b294f308b0a29d021d49caa
#: ../../java/lambda-persistence.rst:524
msgid ""
"The ``viewId`` must differ from the referenced ``persistenceId``, unless "
":ref:`snapshots-java-lambda` of a view and its persistent actor should be "
"shared (which is what applications usually do not want)."
msgstr ""

# 3e2f37afca3c4b3bb4503b51bd54658d
# 01f65537c7ca40778886b2365cd46838
#: ../../java/lambda-persistence.rst:530 ../../java/persistence.rst:536
msgid "Snapshots"
msgstr ""

# b517d5a5602e4a5b8ef442bd7fbab2a7
# ba936b021f3f470eb47aa7d6eaf0e3a4
#: ../../java/lambda-persistence.rst:532 ../../java/persistence.rst:538
msgid ""
"Snapshots can dramatically reduce recovery times of persistent actors and "
"views. The following discusses snapshots in context of persistent actors but"
" this is also applicable to persistent views."
msgstr ""

# 972b5e49c02441158464a8a65318763b
#: ../../java/lambda-persistence.rst:535
msgid ""
"Persistent actor can save snapshots of internal state by calling the  "
"``saveSnapshot`` method. If saving of a snapshot succeeds, the persistent "
"actor receives a ``SaveSnapshotSuccess`` message, otherwise a "
"``SaveSnapshotFailure`` message"
msgstr ""

# 4898528e7d5d4ede9976484133bbec34
# 487158cc4a1e4a0096f9bfd9393b4fc5
#: ../../java/lambda-persistence.rst:540 ../../java/persistence.rst:546
msgid ""
"During recovery, the persistent actor is offered a previously saved snapshot"
" via a ``SnapshotOffer`` message from which it can initialize internal "
"state."
msgstr ""

# e338cfc5afeb47049556af7bdce73f9e
# bad812ac33f548aabde62b1780ae962c
#: ../../java/lambda-persistence.rst:545 ../../java/persistence.rst:551
msgid ""
"The replayed messages that follow the ``SnapshotOffer`` message, if any, are"
" younger than the offered snapshot. They finally recover the persistent "
"actor to its current (i.e. latest) state."
msgstr ""

# 9aaa8e1b19b945a5a677a3562299d1ce
# cdf42487451440b893f4f43472d9aa15
#: ../../java/lambda-persistence.rst:548 ../../java/persistence.rst:554
msgid ""
"In general, a persistent actor is only offered a snapshot if that persistent"
" actor has previously saved one or more snapshots and at least one of these "
"snapshots matches the ``SnapshotSelectionCriteria`` that can be specified "
"for recovery."
msgstr ""

# bce504a2b3d04877aa3ca11544ce3136
# 8a732280587145289cfab1da0c4dbea7
#: ../../java/lambda-persistence.rst:553 ../../java/persistence.rst:559
msgid ""
"If not specified, they default to ``SnapshotSelectionCriteria.latest()`` "
"which selects the latest (= youngest) snapshot. To disable snapshot-based "
"recovery, applications should use ``SnapshotSelectionCriteria.none()``. A "
"recovery where no saved snapshot matches the specified "
"``SnapshotSelectionCriteria`` will replay all journaled messages."
msgstr ""

# fee3ae0b9db342ffb6bfb9ec2f3589f3
# b8089691c0084178bf45d2559b6728d3
#: ../../java/lambda-persistence.rst:558 ../../java/persistence.rst:564
msgid ""
"In order to use snapshots, a default snapshot-store (``akka.persistence"
".snapshot-store.plugin``) must be configured, or the persistent actor can "
"pick a snapshot store explicitly by overriding ``String "
"snapshotPluginId()``."
msgstr ""

# 5d4bda15b2d3404cbc1f5c5b6107a4c4
#: ../../java/lambda-persistence.rst:561
msgid ""
"Since it is acceptable for some applications to not use any snapshotting, it"
" is legal to not configure a snapshot store. However Akka will log a warning"
" message when this situation is detected and then continue to operate until "
"an actor tries to store a snapshot, at which point the operation will fail "
"(by replying with an ``SaveSnapshotFailure`` for example)."
msgstr ""

# d72dcd865fac4b5d82bc9b2661aa119b
# a1020b7ad98d4eac80a2413f2e7ae594
#: ../../java/lambda-persistence.rst:565 ../../java/persistence.rst:571
msgid ""
"Note that :ref:`cluster_sharding_java` is using snapshots, so if you use "
"Cluster Sharding you need to define a snapshot store plugin."
msgstr ""

# fee31e7e62b14bcb8179e42bd03d83e0
# 251d571001894ad3b16d261abd897cea
#: ../../java/lambda-persistence.rst:568 ../../java/persistence.rst:574
msgid "Snapshot deletion"
msgstr ""

# 9e87a2996f5749eaa27dd3a0cdff0af1
# 45f4b53cce894ec6bc3fc0eb4886ccd8
#: ../../java/lambda-persistence.rst:570 ../../java/persistence.rst:576
msgid ""
"A persistent actor can delete individual snapshots by calling the "
"``deleteSnapshot`` method with the sequence number of when the snapshot was "
"taken."
msgstr ""

# 4f3e5a3b71084c369f9274b544417609
# 660cccd2e5104c5494a4c1dd04c94b7b
#: ../../java/lambda-persistence.rst:573 ../../java/persistence.rst:579
msgid ""
"To bulk-delete a range of snapshots matching ``SnapshotSelectionCriteria``, "
"persistent actors should use the ``deleteSnapshots`` method."
msgstr ""

# 76aa7ca0516b4a709fbeecae564bcaee
# e9692ef54876440c8fdbace2cfd94754
#: ../../java/lambda-persistence.rst:577 ../../java/persistence.rst:583
msgid "Snapshot status handling"
msgstr ""

# 98af5068b6464020ba5515170ff3f908
# f824155641db4c7f8689dcd0288bba10
#: ../../java/lambda-persistence.rst:579 ../../java/persistence.rst:585
msgid ""
"Saving or deleting snapshots can either succeed or fail – this information "
"is reported back to the persistent actor via status messages as illustrated "
"in the following table."
msgstr ""

# 96d1b7b2ec614fb5a70240c5eedc9283
# 50cf54f097d94fde969e782b35fce901
#: ../../java/lambda-persistence.rst:583 ../../java/persistence.rst:589
msgid "**Failure message**"
msgstr ""

# 09d37b4066484f96be8d9564bca51d04
# 973142630418425f8f484bedb38d2419
#: ../../java/lambda-persistence.rst:585 ../../java/persistence.rst:591
msgid "``saveSnapshot(Any)``"
msgstr ""

# 0ab20200a6f74f8999be7d6f621441d1
# f1e8d862509440348583b9b5aa83ced7
#: ../../java/lambda-persistence.rst:585 ../../java/persistence.rst:591
msgid "``SaveSnapshotSuccess``"
msgstr ""

# 0196ebe1b2f34c03be5a1eacb9cfaa6b
# aadc5eeb44344834ab296e3156a12964
#: ../../java/lambda-persistence.rst:585 ../../java/persistence.rst:591
msgid "``SaveSnapshotFailure``"
msgstr ""

# 6f6b5ae09ead40b88dc49242693fe2b7
# 9fd3f53aa85a45f085ee5803fff8d153
#: ../../java/lambda-persistence.rst:586 ../../java/persistence.rst:592
msgid "``deleteSnapshot(Long)``"
msgstr ""

# 239722ed193e4779a53861ad391503c1
# 1a432b5874fe403c8ae77c90a3b82701
#: ../../java/lambda-persistence.rst:586 ../../java/persistence.rst:592
msgid "``DeleteSnapshotSuccess``"
msgstr ""

# 4ac86620fa3443f69ed1b7f4cc5c0fd9
# c2edb70d07dc4fa893ec016304f38fe7
#: ../../java/lambda-persistence.rst:586 ../../java/persistence.rst:592
msgid "``DeleteSnapshotFailure``"
msgstr ""

# fd1b21f10cd449af8f9b4539afd971c1
# 75ff350fdb124bfeb7b29f15707803be
#: ../../java/lambda-persistence.rst:587 ../../java/persistence.rst:593
msgid "``deleteSnapshots(SnapshotSelectionCriteria)``"
msgstr ""

# 4b1cd4a27fdc461abf902c126052662d
# c65887d21a524793bed04e705a5dccc1
#: ../../java/lambda-persistence.rst:587 ../../java/persistence.rst:593
msgid "``DeleteSnapshotsSuccess``"
msgstr ""

# 737dc4e13c2c480d91c7d5947caad556
# 866f7183b8354596a010613e20c8df6f
#: ../../java/lambda-persistence.rst:587 ../../java/persistence.rst:593
msgid "``DeleteSnapshotsFailure``"
msgstr ""

# 8250efb9b376444dbe7ba48ec02036f5
# 11caaf99118a41cc90ee16c28a1535c1
#: ../../java/lambda-persistence.rst:593 ../../java/persistence.rst:599
msgid "At-Least-Once Delivery"
msgstr ""

# 9bce5095e4ee4fb791ea2d6427488347
#: ../../java/lambda-persistence.rst:595
msgid ""
"To send messages with at-least-once delivery semantics to destinations you "
"can extend the ``AbstractPersistentActorWithAtLeastOnceDelivery`` class "
"instead of ``AbstractPersistentActor`` on the sending side.  It takes care "
"of re-sending messages when they have not been confirmed within a "
"configurable timeout."
msgstr ""

# 39649a2dacbf4b49aa6e78cefb751f56
#: ../../java/lambda-persistence.rst:599
msgid ""
"The state of the sending actor, including which messages have been sent that"
" have not been confirmed by the recepient must be persistent so that it can "
"survive a crash of the sending actor or JVM. The "
"``AbstractPersistentActorWithAtLeastOnceDelivery`` class does not persist "
"anything by itself. It is your responsibility to persist the intent that a "
"message is sent and that a confirmation has been received."
msgstr ""

# 185234bfec814ba3b7d44ea95e95fe32
#: ../../java/lambda-persistence.rst:607
msgid ""
"At-least-once delivery implies that original message send order is not "
"always preserved, and the destination may receive duplicate messages. "
"Semantics do not match those of a normal :class:`ActorRef` send operation:"
msgstr ""

# 04e913984cb24bfaad42f98989410ac5
# 5813eafaf67b4daca26e40536246f597
#: ../../java/lambda-persistence.rst:610 ../../java/persistence.rst:616
msgid "it is not at-most-once delivery"
msgstr ""

# f9a504dbb6b8480c99b759304466a395
# 9d1f3a69b56c48af9c50233b695fa51c
#: ../../java/lambda-persistence.rst:612 ../../java/persistence.rst:618
msgid ""
"message order for the same sender–receiver pair is not preserved due to "
"possible resends"
msgstr ""

# 725549368cc145008f490cdc569f1137
# 6f38487922fd4cbdaa47491efa2ed839
#: ../../java/lambda-persistence.rst:615 ../../java/persistence.rst:621
msgid ""
"after a crash and restart of the destination messages are still delivered to"
" the new actor incarnation"
msgstr ""

# 601e4b53702e44b9b5f0142729e33002
# cd8f7a29c9fd48ec9a58c1355f506ec9
#: ../../java/lambda-persistence.rst:618 ../../java/persistence.rst:624
msgid ""
"These semantics are similar to what an :class:`ActorPath` represents (see "
":ref:`actor-lifecycle-scala`), therefore you need to supply a path and not a"
" reference when delivering messages. The messages are sent to the path with "
"an actor selection."
msgstr ""

# fd8ee56f411c43079c3cedd113bd2dcc
# d7cbb780ee474f88836f4cc87c9e0cba
#: ../../java/lambda-persistence.rst:623 ../../java/persistence.rst:629
msgid ""
"Use the ``deliver`` method to send a message to a destination. Call the "
"``confirmDelivery`` method when the destination has replied with a "
"confirmation message."
msgstr ""

# 9c8246337eb647f59c38e1fbf4602452
# fd5699cedf8a4a22a48fd0e947f98b07
#: ../../java/lambda-persistence.rst:627 ../../java/persistence.rst:633
msgid "Relationship between deliver and confirmDelivery"
msgstr ""

# 14aedaf5173e435db083f9d89a33b175
# 6fd3df96980542e3a36b45c17823babd
#: ../../java/lambda-persistence.rst:629 ../../java/persistence.rst:635
msgid ""
"To send messages to the destination path, use the ``deliver`` method after "
"you have persisted the intent to send the message."
msgstr ""

# 54d4d8b4061e472fb2ea596e2e9c183a
# e9e34a3947784ebc964f0d6020d4fecf
#: ../../java/lambda-persistence.rst:632 ../../java/persistence.rst:638
msgid ""
"The destination actor must send back a confirmation message. When the "
"sending actor receives this confirmation message you should persist the fact"
" that the message was delivered successfully and then call the "
"``confirmDelivery`` method."
msgstr ""

# 14a0a9b775934230acb7dbbaec3dcb3c
# c7419041e94d41ea9bdfd7af85aac6dd
#: ../../java/lambda-persistence.rst:636 ../../java/persistence.rst:642
msgid ""
"If the persistent actor is not currently recovering, the ``deliver`` method "
"will send the message to the destination actor. When recovering, messages "
"will be buffered until they have been confirmed using ``confirmDelivery``. "
"Once recovery has completed, if there are outstanding messages that have not"
" been confirmed (during the message replay), the persistent actor will "
"resend these before sending any other messages."
msgstr ""

# 9590dddec27f49fdb38311812b18fc7a
#: ../../java/lambda-persistence.rst:641
msgid ""
"Deliver requires a ``deliveryIdToMessage`` function to pass the provided "
"``deliveryId`` into the message so that the correlation between ``deliver`` "
"and ``confirmDelivery`` is possible. The ``deliveryId`` must do the round "
"trip. Upon receipt of the message, the destination actor will send the "
"same``deliveryId`` wrapped in a confirmation message back to the sender. The"
" sender will then use it to call ``confirmDelivery`` method to complete the "
"delivery routine."
msgstr ""

# 9080c0736e9f40c29fcac376df8490de
# e4b7dbf9518e453ea247789d4f9528b1
#: ../../java/lambda-persistence.rst:648 ../../java/persistence.rst:654
msgid ""
"The ``deliveryId`` generated by the persistence module is a strictly "
"monotonically increasing sequence number without gaps. The same sequence is "
"used for all destinations of the actor, i.e. when sending to multiple "
"destinations the destinations will see gaps in the sequence. It is not "
"possible to use custom ``deliveryId``. However, you can send a custom "
"correlation identifier in the message to the destination. You must then "
"retain a mapping between the internal ``deliveryId`` (passed into the "
"``deliveryIdToMessage`` function) and your custom correlation id (passed "
"into the message). You can do this by storing such mapping in a "
"``Map(correlationId -> deliveryId)`` from which you can retrieve the "
"``deliveryId`` to be passed into the ``confirmDelivery`` method once the "
"receiver of your message has replied with your custom correlation id."
msgstr ""

# 18c854295c594f1cb7364d17dbe7293d
#: ../../java/lambda-persistence.rst:657
msgid ""
"The ``AbstractPersistentActorWithAtLeastOnceDelivery`` class has a state "
"consisting of unconfirmed messages and a sequence number. It does not store "
"this state itself. You must persist events corresponding to the ``deliver`` "
"and ``confirmDelivery`` invocations from your ``PersistentActor`` so that "
"the state can be restored by calling the same methods during the recovery "
"phase of the ``PersistentActor``. Sometimes these events can be derived from"
" other business level events, and sometimes you must create separate events."
" During recovery, calls to ``deliver`` will not send out messages, those "
"will be sent later if no matching ``confirmDelivery`` will have been "
"performed."
msgstr ""

# 061acb372e0f407a9915bcb9542e8c1b
# 7b295bddcc1448469ae24dfd6c56338e
#: ../../java/lambda-persistence.rst:665 ../../java/persistence.rst:671
msgid ""
"Support for snapshots is provided by ``getDeliverySnapshot`` and "
"``setDeliverySnapshot``. The ``AtLeastOnceDeliverySnapshot`` contains the "
"full delivery state, including unconfirmed messages. If you need a custom "
"snapshot for other parts of the actor state you must also include the "
"``AtLeastOnceDeliverySnapshot``. It is serialized using protobuf with the "
"ordinary Akka serialization mechanism. It is easiest to include the bytes of"
" the ``AtLeastOnceDeliverySnapshot`` as a blob in your custom snapshot."
msgstr ""

# 9d4b47f50ee543a797cc5510d1941bba
# 6086f16c914743409809a3d8b5691aac
#: ../../java/lambda-persistence.rst:672 ../../java/persistence.rst:678
msgid ""
"The interval between redelivery attempts is defined by the "
"``redeliverInterval`` method. The default value can be configured with the "
"``akka.persistence.at-least-once-delivery.redeliver-interval`` configuration"
" key. The method can be overridden by implementation classes to return non-"
"default values."
msgstr ""

# d8cf503c5d054e3aa36426d08e2f34ee
# 911466f7dac043d69842c4ee321f681d
#: ../../java/lambda-persistence.rst:676 ../../java/persistence.rst:689
msgid ""
"After a number of delivery attempts a "
"``AtLeastOnceDelivery.UnconfirmedWarning`` message will be sent to ``self``."
" The re-sending will still continue, but you can choose to call "
"``confirmDelivery`` to cancel the re-sending. The number of delivery "
"attempts before emitting the warning is defined by the "
"``warnAfterNumberOfUnconfirmedAttempts`` method. The default value can be "
"configured with the ``akka.persistence.at-least-once-delivery.warn-after-"
"number-of-unconfirmed-attempts`` configuration key. The method can be "
"overridden by implementation classes to return non-default values."
msgstr ""

# f771a73fb78840f581e6fc1afb608b43
#: ../../java/lambda-persistence.rst:683
msgid ""
"The ``AbstractPersistentActorWithAtLeastOnceDelivery`` class holds messages "
"in memory until their successful delivery has been confirmed. The maximum "
"number of unconfirmed messages that the actor is allowed to hold in memory "
"is defined by the ``maxUnconfirmedMessages`` method. If this limit is exceed"
" the ``deliver`` method will not accept more messages and it will throw "
"``AtLeastOnceDelivery.MaxUnconfirmedMessagesExceededException``. The default"
" value can be configured with the ``akka.persistence.at-least-once-delivery"
".max-unconfirmed-messages`` configuration key. The method can be overridden "
"by implementation classes to return non-default values."
msgstr ""

# 7258879dc6a24a77a309271b34b2b321
# eb62b7c5f17a47c6abc367cf841c6693
#: ../../java/lambda-persistence.rst:693 ../../java/persistence.rst:706
msgid "Event Adapters"
msgstr ""

# fa004eacf46a491a85477cdd663f5d42
# ddcb1f2481474600a7d6c9623ee90034
#: ../../java/lambda-persistence.rst:695 ../../java/persistence.rst:708
msgid ""
"In long running projects using event sourcing sometimes the need arises to "
"detach the data model from the domain model completely."
msgstr ""

# b258623d70f64c78a9f98657fe3c0142
# 44acba27cad147dd9a268a42cde73e04
#: ../../java/lambda-persistence.rst:698 ../../java/persistence.rst:711
msgid "Event Adapters help in situations where:"
msgstr ""

# bfb9c296e5354404ac532ec2f38bdbde
# 3bf6b303e7534b69a8037c1bd5f562f5
#: ../../java/lambda-persistence.rst:700 ../../java/persistence.rst:713
msgid ""
"**Version Migrations** – existing events stored in *Version 1* should be "
"\"upcasted\" to a new *Version 2* representation, and the process of doing "
"so involves actual code, not just changes on the serialization layer. For "
"these scenarios the ``toJournal`` function is usually an identity function, "
"however the ``fromJournal`` is implemented as ``v1.Event=>v2.Event``, "
"performing the neccessary mapping inside the fromJournal method. This "
"technique is sometimes refered to as \"upcasting\" in other CQRS libraries."
msgstr ""

# 3fdaefd1d4ec4b13bd51dd50a64e26a8
# 4c80fcf04439497b9dbdf0b9c14ce6ec
#: ../../java/lambda-persistence.rst:705 ../../java/persistence.rst:718
msgid ""
"**Separating Domain and Data models** – thanks to EventAdapters it is "
"possible to completely separate the domain model from the model used to "
"persist data in the Journals. For example one may want to use case classes "
"in the domain model, however persist their protocol-buffer (or any other "
"binary serialization format) counter-parts to the Journal. A simple "
"``toJournal:MyModel=>MyDataModel`` and ``fromJournal:MyDataModel=>MyModel`` "
"adapter can be used to implement this feature."
msgstr ""

# b8f7d13beebd4b5ea61f7dcd1889ad5f
# dadfd7292963439093603b864de67732
#: ../../java/lambda-persistence.rst:709 ../../java/persistence.rst:722
msgid ""
"**Journal Specialized Data Types** – exposing data types understood by the "
"underlying Journal, for example for data stores which understand JSON it is "
"possible to write an EventAdapter ``toJournal:Any=>JSON`` such that the "
"Journal can *directly* store the json instead of serializing the object to "
"its binary representation."
msgstr ""

# 001220c6789943abb02dd9b8ef43bd53
# 3aef8a7306a44a3a80833a1fbd18302c
#: ../../java/lambda-persistence.rst:713 ../../java/persistence.rst:726
msgid "Implementing an EventAdapter is rather stright forward:"
msgstr ""

# 24699f5429bb4845bb155ae84261bf40
# 2080997370034a849d570d8f8495c93f
#: ../../java/lambda-persistence.rst:717 ../../java/persistence.rst:730
msgid ""
"Then in order for it to be used on events coming to and from the journal you"
" must bind it using the below configuration syntax:"
msgstr ""

# 15e38fe3aa6e4404b31fd6537f09544d
# 03f02a3da4f241e8bf8c03899180ba43
#: ../../java/lambda-persistence.rst:721 ../../java/persistence.rst:734
msgid ""
"It is possible to bind multiple adapters to one class *for recovery*, in "
"which case the ``fromJournal`` methods of all bound adapters will be applied"
" to a given matching event (in order of definition in the configuration). "
"Since each adapter may return from ``0`` to ``n`` adapted events (called as "
"``EventSeq``), each adapter can investigate the event and if it should "
"indeed adapt it return the adapted event(s) for it. Other adapters which do "
"not have anything to contribute during this adaptation simply return "
"``EventSeq.empty``. The adapted events are then delivered in-order to the "
"``PersistentActor`` during replay."
msgstr ""

# 7d59583d6455464a8110e30def8586f5
# 7fcef00299504bee8e240924df9380a6
# 31da70b755df44708faaaf1f8579d400
# f04527d1e66a420a82d1363e75f40b4c
#: ../../java/lambda-persistence.rst:728
#: ../../java/lambda-persistence.rst:1036 ../../java/persistence.rst:741
#: ../../java/persistence.rst:1015
msgid ""
"For more advanced schema evolution techniques refer to the :ref"
":`persistence-schema-evolution-scala` documentation."
msgstr ""

# 5ec3ffe49e9d4c9eb9c35f4632f1222b
#: ../../java/lambda-persistence.rst:733
msgid "Persistent FSM"
msgstr ""

# 8c47fd9015534c1b879738d41336f92a
#: ../../java/lambda-persistence.rst:734
msgid ""
"``AbstractPersistentFSM`` handles the incoming messages in an FSM like "
"fashion. Its internal state is persisted as a sequence of changes, later "
"referred to as domain events. Relationship between incoming messages, FSM's "
"states and transitions, persistence of domain events is defined by a DSL."
msgstr ""

# 31c9dd3dff5d4739b8c79eb01796b8a7
#: ../../java/lambda-persistence.rst:740
msgid ""
"``AbstractPersistentFSM`` is marked as **“experimental”** as of its "
"introduction in Akka 2.4.0. We will continue to improve this API based on "
"our users’ feedback, which implies that while we try to keep incompatible "
"changes to a minimum the binary compatibility guarantee for maintenance "
"releases does not apply to the contents of the `classes related to "
"``AbstractPersistentFSM``."
msgstr ""

# b17acf2917a647b4a10a545902461841
#: ../../java/lambda-persistence.rst:747
msgid ""
"To demonstrate the features of the ``AbstractPersistentFSM``, consider an "
"actor which represents a Web store customer. The contract of our "
"\"WebStoreCustomerFSMActor\" is that it accepts the following commands:"
msgstr ""

# 6f8d8ebda14d4793a8ef59a0a1c142a2
#: ../../java/lambda-persistence.rst:752
msgid ""
"``AddItem`` sent when the customer adds an item to a shopping cart ``Buy`` -"
" when the customer finishes the purchase ``Leave`` - when the customer "
"leaves the store without purchasing anything ``GetCurrentCart`` allows to "
"query the current state of customer's shopping cart"
msgstr ""

# 2884d7a7b86a473ab549b3bde616525b
#: ../../java/lambda-persistence.rst:757
msgid "The customer can be in one of the following states:"
msgstr ""

# 074a20c0079f498abe4a15ffdbc1bc9b
#: ../../java/lambda-persistence.rst:761
msgid ""
"``LookingAround`` customer is browsing the site, but hasn't added anything "
"to the shopping cart ``Shopping`` customer has recently added items to the "
"shopping cart ``Inactive`` customer has items in the shopping cart, but "
"hasn't added anything recently ``Paid`` customer has purchased the items"
msgstr ""

# 815998beaa194e638424082069d8f869
#: ../../java/lambda-persistence.rst:768
msgid ""
"``AbstractPersistentFSM`` states must inherit from "
"``PersistentFSM.FSMState`` and implement the ``String identifier()`` method."
" This is required in order to simplify the serialization of FSM states. "
"String identifiers should be unique!"
msgstr ""

# 487a4439da7e494eaa8bb81f565e1f49
#: ../../java/lambda-persistence.rst:772
msgid ""
"Customer's actions are \"recorded\" as a sequence of \"domain events\" which"
" are persisted. Those events are replayed on actor's start in order to "
"restore the latest customer's state:"
msgstr ""

# aaeb7e8e89d548bda1dac0591ea4e79e
#: ../../java/lambda-persistence.rst:777
msgid "Customer state data represents the items in customer's shopping cart:"
msgstr ""

# b97765ac58954c8d9ac9ea847392add5
#: ../../java/lambda-persistence.rst:781
msgid "Here is how everything is wired together:"
msgstr ""

# d90ac0a824c941b7b731ad08c2b2013f
#: ../../java/lambda-persistence.rst:787
msgid ""
"State data can only be modified directly on initialization. Later it's "
"modified only as a result of applying domain events. Override the "
"``applyEvent`` method to define how state data is affected by domain events,"
" see the example below"
msgstr ""

# 0bf76c61be334688a0108c3865e538dc
#: ../../java/lambda-persistence.rst:792
msgid ""
"``andThen`` can be used to define actions which will be executed following "
"event's persistence - convenient for \"side effects\" like sending a message"
" or logging. Notice that actions defined in ``andThen`` block are not "
"executed on recovery:"
msgstr ""

# 0e67de2780eb4fc09ea30b000a2ce656
#: ../../java/lambda-persistence.rst:797
msgid ""
"A snapshot of state data can be persisted by calling the "
"``saveStateSnapshot()`` method:"
msgstr ""

# ed17d7fa123b4ebaa575641b098e3992
#: ../../java/lambda-persistence.rst:801
msgid ""
"On recovery state data is initialized according to the latest available "
"snapshot, then the remaining domain events are replayed, triggering the "
"``applyEvent`` method."
msgstr ""

# fee78be855464180af88806de83d589a
# 8d0bef0d436345909001ac48a0b69ab4
#: ../../java/lambda-persistence.rst:805 ../../java/persistence.rst:744
msgid "Storage plugins"
msgstr ""

# f716c00ed2d04dd891b73fe409d50ae8
# f61e572f03114bdcb86a8f337bfe3672
#: ../../java/lambda-persistence.rst:807 ../../java/persistence.rst:746
msgid ""
"Storage backends for journals and snapshot stores are pluggable in the Akka "
"persistence extension."
msgstr ""

# 6ba8fc7e7c764c0a8182b46be0940f7f
# fcd5e57f909c4ff6bd9dd7a37860a229
#: ../../java/lambda-persistence.rst:809 ../../java/persistence.rst:748
msgid ""
"A directory of persistence journal and snapshot store plugins is available "
"at the Akka Community Projects page, see `Community plugins`_"
msgstr ""

# 3a147bfd3b6b47b389b1fc5feee4be08
#: ../../java/lambda-persistence.rst:811
msgid ""
"Plugins can be selected either by \"default\", for all persistent actors and"
" views, or \"individually\", when persistent actor or view defines its own "
"set of plugins."
msgstr ""

# efbc0e8aedf744a4bb5dcf4f3b56ec80
#: ../../java/lambda-persistence.rst:814
msgid ""
"When persistent actor or view does NOT override ``journalPluginId`` and "
"``snapshotPluginId`` methods, persistence extension will use \"default\" "
"journal and snapshot-store plugins configured in the ``reference.conf``::"
msgstr ""

# 5dd9d6bd8f634e009170355577d51998
#: ../../java/lambda-persistence.rst:820
msgid ""
"However, these entries are provided as empty \"\", and require explicit user"
" configuration via override in the user ``application.conf``. For an example"
" of journal plugin which writes messages to LevelDB see :ref:`local-leveldb-"
"journal-java-lambda`. For an example of snapshot store plugin which writes "
"snapshots as individual files to the local filesystem see :ref:`local-"
"snapshot-store-java-lambda`."
msgstr ""

# 2b23e9cc869543b8b54c53c27364cea3
#: ../../java/lambda-persistence.rst:824
msgid ""
"Applications can provide their own plugins by implementing a plugin API and "
"activate them by configuration. Plugin development requires the following "
"imports:"
msgstr ""

# 5691f28c7b954c6383b088917d7da429
# 99ab7aa739de45d7b845f5a65014b1d4
#: ../../java/lambda-persistence.rst:830 ../../java/persistence.rst:769
msgid "Eager initialization of persistence plugin"
msgstr ""

# 3ece1f3953424f39a734abf542df0272
# f92356704b4d4b67993410ed2ec042bc
#: ../../java/lambda-persistence.rst:832 ../../java/persistence.rst:771
msgid ""
"By default, persistence plugins are started on-demand, as they are used. In "
"some case, however, it might be beneficial to start a certain plugin "
"eagerly. In order to do that, you should first add the "
"``akka.persistence.Persistence`` under the ``akka.extensions`` key. Then, "
"specify the IDs of plugins you wish to start automatically under "
"``akka.persistence.journal.auto-start-journals`` and ``akka.persistence"
".snapshot-store.auto-start-snapshot-stores``."
msgstr ""

# 52708408f25647d6ac8d7da0385b8933
# 038c0c7ce5c74a5eb43aa1c6b2130519
#: ../../java/lambda-persistence.rst:838 ../../java/persistence.rst:779
msgid "Journal plugin API"
msgstr ""

# 47725db66d214d688f4e0a2ec8e3b0bc
# 9ecc0d470526409eb99daa39e37c3fa5
#: ../../java/lambda-persistence.rst:840 ../../java/persistence.rst:781
msgid "A journal plugin extends ``AsyncWriteJournal``."
msgstr ""

# 0bacaa03a66048f6afa3aa0d91914626
# 7dadfbbe11e445db9a43e45958194357
#: ../../java/lambda-persistence.rst:842 ../../java/persistence.rst:783
msgid ""
"``AsyncWriteJournal`` is an actor and the methods to be implemented are:"
msgstr ""

# 321296d5977f42fb91348732c180b992
# 2ad18482e17f4d229d3f689a9f016b32
#: ../../java/lambda-persistence.rst:846 ../../java/persistence.rst:787
msgid ""
"If the storage backend API only supports synchronous, blocking writes, the "
"methods should be implemented as:"
msgstr ""

# c78caa1f8ec745438ef6a509f3a7a4c9
# 9ba57f11c9b84fdc83e2cb03333ff13a
#: ../../java/lambda-persistence.rst:850 ../../java/persistence.rst:791
msgid ""
"A journal plugin must also implement the methods defined in "
"``AsyncRecovery`` for replays and sequence number recovery:"
msgstr ""

# efb9e4e179924e2aaee98adf77aeb302
# cc444b4c6c594e3e84cd809a3418b1ad
#: ../../java/lambda-persistence.rst:854 ../../java/persistence.rst:795
msgid ""
"A journal plugin can be activated with the following minimal configuration:"
msgstr ""

# d2f27886687345e28f9f75e9619bb6e6
# fda94ae395354b08b340bcdaa9bbca51
# ff3256b487df4c1e9746d9b4b71f270e
# cadccefe463a4eb9bfc3a29eaf5428c4
#: ../../java/lambda-persistence.rst:858 ../../java/lambda-persistence.rst:881
#: ../../java/persistence.rst:799 ../../java/persistence.rst:822
msgid ""
"The specified plugin ``class`` must have a no-arg constructor. The ``plugin-"
"dispatcher`` is the dispatcher used for the plugin actor. If not specified, "
"it defaults to ``akka.persistence.dispatchers.default-plugin-dispatcher``."
msgstr ""

# ba36d8c0e7484ad4b717e5dbd76d1882
# ad347f23f6fb46d8be43d9756020a925
#: ../../java/lambda-persistence.rst:861 ../../java/persistence.rst:802
msgid ""
"The journal plugin instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may delegate "
"to asynchronous libraries, spawn futures, or delegate to other actors to "
"achive parallelism."
msgstr ""

# 9467c64ba7054b15aefd04f3a2d06ef5
# 81568e614d4c452d96934ca80a06d677
#: ../../java/lambda-persistence.rst:865 ../../java/persistence.rst:806
msgid ""
"The journal plugin class must have a constructor without parameters or a "
"constructor with one ``com.typesafe.config.Config`` parameter. The plugin "
"section of the actor system's config will be passed in the config "
"constructor parameter."
msgstr ""

# 68b637346aa94b55ae9e521c3bf9b45b
# 85f1e84eb4aa497ea0433b5c1be6f4fa
#: ../../java/lambda-persistence.rst:868 ../../java/persistence.rst:809
msgid ""
"Don't run journal tasks/futures on the system default dispatcher, since that"
" might starve other tasks."
msgstr ""

# b696c87b1d3347638c4fbf21b1f6b5a3
# bd8c94ab9c354ae39d4b966d0afec3f1
#: ../../java/lambda-persistence.rst:871 ../../java/persistence.rst:812
msgid "Snapshot store plugin API"
msgstr ""

# 3328bf1fb9514ef5bfcffd213bd249b5
# 5ec7f8bfabb84d8382979743c095b0fa
#: ../../java/lambda-persistence.rst:873 ../../java/persistence.rst:814
msgid ""
"A snapshot store plugin must extend the ``SnapshotStore`` actor and "
"implement the following methods:"
msgstr ""

# 4113d810b8a7410ead9d15db39d7eca2
# 5d914f89d78a4f799d09dc55cb35ef7a
#: ../../java/lambda-persistence.rst:877 ../../java/persistence.rst:818
msgid ""
"A snapshot store plugin can be activated with the following minimal "
"configuration:"
msgstr ""

# dd666e8abd364c85b4712e3ef007283f
# db73165d612844debcb85c01e26707df
#: ../../java/lambda-persistence.rst:884 ../../java/persistence.rst:825
msgid ""
"The snapshot store instance is an actor so the methods corresponding to "
"requests from persistent actors are executed sequentially. It may delegate "
"to asynchronous libraries, spawn futures, or delegate to other actors to "
"achive parallelism."
msgstr ""

# 3a13fbf4091545b688b51afffe83fdc0
# 0659df887aaf491089058687fae0c63d
#: ../../java/lambda-persistence.rst:888 ../../java/persistence.rst:829
msgid ""
"The snapshot store plugin class must have a constructor without parameters "
"or constructor with one ``com.typesafe.config.Config`` parameter. The plugin"
" section of the actor system's config will be passed in the config "
"constructor parameter."
msgstr ""

# b54d142bc1404918a99c081df7076077
# cdaf0a97be9642b0aac900bdd655e67c
#: ../../java/lambda-persistence.rst:891 ../../java/persistence.rst:832
msgid ""
"Don't run snapshot store tasks/futures on the system default dispatcher, "
"since that might starve other tasks."
msgstr ""

# ff8e8fa63e09449d8e0cdfd0b2ff042f
# 06252a05802946adada0c382f0e509d2
#: ../../java/lambda-persistence.rst:894 ../../java/persistence.rst:873
msgid "Pre-packaged plugins"
msgstr ""

# a6bcb44b1ca548baadddeb7ac6c4ac87
# 2be2411a14984743ac3e4f92ebb29ba2
#: ../../java/lambda-persistence.rst:899 ../../java/persistence.rst:878
msgid "Local LevelDB journal"
msgstr ""

# f6b4d721d75a409499a42b44bb279d02
# 77f8372c949e4842b1f66103216bfbd7
#: ../../java/lambda-persistence.rst:901 ../../java/persistence.rst:880
msgid ""
"The LevelDB journal plugin config entry is "
"``akka.persistence.journal.leveldb``. It writes messages to a local LevelDB "
"instance. Enable this plugin by defining config property:"
msgstr ""

# 65f7bb318bd44613927bad3a2ee17bd5
# bf6c53da50f74ad8a8a5e8d119958ddb
#: ../../java/lambda-persistence.rst:906 ../../java/persistence.rst:885
msgid ""
"LevelDB based plugins will also require the following additional dependency "
"declaration::"
msgstr ""

# ee408226599342cdb491014f41b6cfeb
#: ../../java/lambda-persistence.rst:919
msgid ""
"The default location of LevelDB files is a directory named ``journal`` in "
"the current working directory. This location can be changed by configuration"
" where the specified path can be relative or absolute:"
msgstr ""

# cefec91cc5be4803883e878265e266ef
# 2cfe9fd836aa453e88ef8581b53e2a97
#: ../../java/lambda-persistence.rst:924 ../../java/persistence.rst:903
msgid ""
"With this plugin, each actor system runs its own private LevelDB instance."
msgstr ""

# c9056da391d64e308df253bc5aa95be0
# 1568e72d772d4db2a521cf2756d13dbd
#: ../../java/lambda-persistence.rst:929 ../../java/persistence.rst:908
msgid "Shared LevelDB journal"
msgstr ""

# 5d1cf4dc055d4be1bccbd0eee1b02b23
# 2890ae5f2ed444f9adfbee0e3f8616a1
#: ../../java/lambda-persistence.rst:931 ../../java/persistence.rst:910
msgid ""
"A LevelDB instance can also be shared by multiple actor systems (on the same"
" or on different nodes). This, for example, allows persistent actors to "
"failover to a backup node and continue using the shared journal instance "
"from the backup node."
msgstr ""

# 48a5a73e93fe4ce581f8239e691dc52e
# 1bdf4bf77f98448281a3ee20e7017931
#: ../../java/lambda-persistence.rst:937 ../../java/persistence.rst:916
msgid ""
"A shared LevelDB instance is a single point of failure and should therefore "
"only be used for testing purposes. Highly-available, replicated journals are"
" available as `Community plugins`_."
msgstr ""

# 90b91811084c4fb49a74ef338e751886
#: ../../java/lambda-persistence.rst:942
msgid ""
"This plugin has been supplanted by :ref:`Persistence Plugin Proxy"
"<persistence-plugin-proxy-lambda>`."
msgstr ""

# 36ca14e1562c454fba9e92619d3aa053
# 5cc2b8423f0345bba8fffc3a7681e8aa
#: ../../java/lambda-persistence.rst:944 ../../java/persistence.rst:923
msgid ""
"A shared LevelDB instance is started by instantiating the "
"``SharedLeveldbStore`` actor."
msgstr ""

# 93176790e7e04b64a3231e981c537646
# c15410cc9b9c4a8fb8046819649fb0cd
#: ../../java/lambda-persistence.rst:948 ../../java/persistence.rst:927
msgid ""
"By default, the shared instance writes journaled messages to a local "
"directory named ``journal`` in the current working directory. The storage "
"location can be changed by configuration:"
msgstr ""

# 4d440b2bc7f243a28721bd2d6483fee0
# 5863d1c7c27449189e49cf293893f7a2
#: ../../java/lambda-persistence.rst:953 ../../java/persistence.rst:932
msgid ""
"Actor systems that use a shared LevelDB store must activate the "
"``akka.persistence.journal.leveldb-shared`` plugin."
msgstr ""

# 032e120633634dfbb827e102af68fed3
# cf29a16db9844b538d3e9b6e5dbb1ba9
#: ../../java/lambda-persistence.rst:958 ../../java/persistence.rst:937
msgid ""
"This plugin must be initialized by injecting the (remote) "
"``SharedLeveldbStore`` actor reference. Injection is done by calling the "
"``SharedLeveldbJournal.setStore`` method with the actor reference as "
"argument."
msgstr ""

# 28a5582d9faf451fb4fb0c47cd86d2b2
# d501471d088b4626a86852e4b7ba6919
#: ../../java/lambda-persistence.rst:963 ../../java/persistence.rst:942
msgid ""
"Internal journal commands (sent by persistent actors) are buffered until "
"injection completes. Injection is idempotent i.e. only the first injection "
"is used."
msgstr ""

# 05a7d2b029e04ea9ad408c03c9ec9639
# 1c7d545fa4554f6882a5dd0b05df2a5a
#: ../../java/lambda-persistence.rst:969 ../../java/persistence.rst:948
msgid "Local snapshot store"
msgstr ""

# 55eba5c5f421419b8aec14eeb732a31a
#: ../../java/lambda-persistence.rst:971
msgid ""
"Local snapshot store plugin config entry is ``akka.persistence.snapshot-"
"store.local``. It writes snapshot files to the local filesystem. Enable this"
" plugin by defining config property:"
msgstr ""

# 9628a7c62b804792b9530fded3884b6d
# eecf510a68004647b989fc4b412dc2eb
#: ../../java/lambda-persistence.rst:976 ../../java/persistence.rst:955
msgid ""
"The default storage location is a directory named ``snapshots`` in the "
"current working directory. This can be changed by configuration where the "
"specified path can be relative or absolute:"
msgstr ""

# 3f8a26e48c43457fbb05440d64dd08c0
# d3275c95ddd14909a1c31cd6a02e1279
#: ../../java/lambda-persistence.rst:981 ../../java/persistence.rst:960
msgid ""
"Note that it is not mandatory to specify a snapshot store plugin. If you "
"don't use snapshots you don't have to configure it."
msgstr ""

# 26f13151d0904e20aa6d4cf8fc5eab86
# 18dbb59c99b54e71ba81a57a65968e79
#: ../../java/lambda-persistence.rst:987 ../../java/persistence.rst:966
msgid "Persistence Plugin Proxy"
msgstr ""

# ca9e67cbabf34bfcb8c4a635f655177a
# 2cb790720cf3419cb13a5447e0358fc2
#: ../../java/lambda-persistence.rst:989 ../../java/persistence.rst:968
msgid ""
"A persistence plugin proxy allows sharing of journals and snapshot stores "
"across multiple actor systems (on the same or on different nodes). This, for"
" example, allows persistent actors to failover to a backup node and continue"
" using the shared journal instance from the backup node. The proxy works by "
"forwarding all the journal/snapshot store messages to a single, shared, "
"persistence plugin instance, and therefor supports any use case supported by"
" the proxied plugin."
msgstr ""

# 618600aec9b94a16a8037b08230487a2
# 5d2abfc1f7984f459c737ebd6f86e541
#: ../../java/lambda-persistence.rst:996 ../../java/persistence.rst:975
msgid ""
"A shared journal/snapshot store is a single point of failure and should "
"therefore only be used for testing purposes. Highly-available, replicated "
"persistence plugins are available as `Community plugins`_."
msgstr ""

# 81f15fb5ec064f9fab24ca597b504e42
# 3d59c75491594aa8a367ab02a6725cd9
#: ../../java/lambda-persistence.rst:999 ../../java/persistence.rst:978
msgid ""
"The journal and snapshot store proxies are controlled via the "
"``akka.persistence.journal.proxy`` and ``akka.persistence.snapshot-"
"store.proxy`` configuration entries, respectively. Set the ``target-journal-"
"plugin`` or ``target-snapshot-store-plugin`` keys to the underlying plugin "
"you wish to use (for example: ``akka.persistence.journal.leveldb``). The "
"``start-target-journal`` and ``start-target-snapshot-store`` keys should be "
"set to ``on`` in exactly one actor system - this is the system that will "
"instantiate the shared persistence plugin. Next, the proxy needs to be told "
"how to find the shared plugin. This can be done by setting the ``target-"
"journal-address`` and ``target-snapshot-store-address`` configuration keys, "
"or programmatically by calling the "
"``PersistencePluginProxy.setTargetLocation`` method."
msgstr ""

# 656351a7a37840aa98ac02d06c81c899
# 17762b38327743a598c707c5b3e17a39
#: ../../java/lambda-persistence.rst:1010 ../../java/persistence.rst:989
msgid ""
"Akka starts extensions lazily when they are required, and this includes the "
"proxy. This means that in order for the proxy to work, the persistence "
"plugin on the target node must be instantiated. This can be done by "
"instantiating the ``PersistencePluginProxyExtension`` :ref:`extension"
"<extending-akka-java>`, or by calling the ``PersistencePluginProxy.start`` "
"method."
msgstr ""

# 0df9c99992844e30846b3d29a5badc73
# 3c740accbdd94966abc7aa355d89e161
#: ../../java/lambda-persistence.rst:1016 ../../java/persistence.rst:995
msgid ""
"The proxied persistence plugin can (and should) be configured using its "
"original configuration keys."
msgstr ""

# 058a79bac4b34f409667d2534345e026
# 135d1396a97744be94d17c0cd113b713
#: ../../java/lambda-persistence.rst:1022 ../../java/persistence.rst:1001
msgid "Custom serialization"
msgstr ""

# 467bb033fa7b4b179ede527f5e3d4a61
# 906fcaa1198242cb83fdd5bb7833e678
#: ../../java/lambda-persistence.rst:1024 ../../java/persistence.rst:1003
msgid ""
"Serialization of snapshots and payloads of ``Persistent`` messages is "
"configurable with Akka's :ref:`serialization-java` infrastructure. For "
"example, if an application wants to serialize"
msgstr ""

# 1ec30531bad649e582bc27d1eb63d9ad
# 25b449cb739d40c9b65ec842a87d5a30
#: ../../java/lambda-persistence.rst:1027 ../../java/persistence.rst:1006
msgid ""
"payloads of type ``MyPayload`` with a custom ``MyPayloadSerializer`` and"
msgstr ""

# e1a39dd141ee40258d8ddd547e2e2e77
# ad82bd959e1d4f20865dfdfb51014a36
#: ../../java/lambda-persistence.rst:1028 ../../java/persistence.rst:1007
msgid ""
"snapshots of type ``MySnapshot`` with a custom ``MySnapshotSerializer``"
msgstr ""

# c5c786f417324f80b2411e39aab2d856
# 762162bbbd454ef49b91170394ecfa5a
#: ../../java/lambda-persistence.rst:1030 ../../java/persistence.rst:1009
msgid "it must add"
msgstr ""

# 370cab75c0784681b9b36b0a6efcd817
# 59252a175b934beda4bf19c89da564d6
#: ../../java/lambda-persistence.rst:1034 ../../java/persistence.rst:1013
msgid ""
"to the application configuration. If not specified, a default serializer is "
"used."
msgstr ""

# d94c858261c04d409cdda4b9513e6c50
# 33420abd1eff443786ac55d06fa0101d
#: ../../java/lambda-persistence.rst:1039 ../../java/persistence.rst:1018
msgid "Testing"
msgstr ""

# 1e109fde496046db8c161fd277fde0fb
# 67ae9b5f8e1a4023a1e716d627500ff4
#: ../../java/lambda-persistence.rst:1041 ../../java/persistence.rst:1020
msgid ""
"When running tests with LevelDB default settings in ``sbt``, make sure to "
"set ``fork := true`` in your sbt project. Otherwise, you'll see an "
"``UnsatisfiedLinkError``. Alternatively, you can switch to a LevelDB Java "
"port by setting"
msgstr ""

# 2e17e5d94a8d432da42ec500f9b84a03
# bf81183ef4064649b27355cb843210cc
#: ../../java/lambda-persistence.rst:1045 ../../java/persistence.rst:1025
msgid "or"
msgstr ""

# b8d4566242f94db3b98a4e5d51fcb050
# e51d20f5e4f845cf894fdae599af3d8a
#: ../../java/lambda-persistence.rst:1049 ../../java/persistence.rst:1029
msgid ""
"in your Akka configuration. The LevelDB Java port is for testing purposes "
"only."
msgstr ""

# 2495e5bcb3754a0bb7b26dc4073cbf23
# 495acb3a1990446197e9eec0f8d2d5ca
#: ../../java/lambda-persistence.rst:1052 ../../java/persistence.rst:1032
msgid ""
"It is not possible to test persistence provided classes (i.e. "
":ref:`PersistentActor <event-sourcing-java>` and :ref:`AtLeastOnceDelivery "
"<at-least-once-delivery-java>`) using ``TestActorRef`` due to its "
"*synchronous* nature. These traits need to be able to perform asynchronous "
"tasks in the background in order to handle internal persistence related "
"events."
msgstr ""

# 9fd0bc274b2941deb62ca2357bcb763f
# fa25631b56cd4643b7dd61673f823092
#: ../../java/lambda-persistence.rst:1057 ../../java/persistence.rst:1037
msgid ""
"When testing Persistence based projects always rely on :ref:`asynchronous "
"messaging using the TestKit <async-integration-testing-java>`."
msgstr ""

# ddcc9fdba152443d8e476f889aaf3877
# c54027694aa849fca912a9eeebe9a134
#: ../../java/lambda-persistence.rst:1060 ../../java/persistence.rst:1046
msgid "Multiple persistence plugin configurations"
msgstr ""

# 064c63114502411d9869c8cf74231d93
#: ../../java/lambda-persistence.rst:1062
msgid ""
"By default, a persistent actor or view will use \"default\" journal and "
"snapshot store plugins configured in the following sections of the "
"``reference.conf`` configuration resource:"
msgstr ""

# fc45747255d04e74b113ce5fa88def1b
# 208e91fe32f34c38b799a2be04dd7a54
#: ../../java/lambda-persistence.rst:1067 ../../java/persistence.rst:1053
msgid ""
"Note that in this case the actor or view overrides only ``persistenceId`` "
"method:"
msgstr ""

# 7387f6a3a99e42adb9268e0e0ca0d0fb
#: ../../java/lambda-persistence.rst:1071
msgid ""
"When a persistent actor or view overrides ``journalPluginId`` and "
"``snapshotPluginId`` methods, the actor or view will be serviced by these "
"specific persistence plugins instead of the defaults:"
msgstr ""

# d25abac7f0fc4beda4a0e384d7fda25c
# f43412cc5e934f408cac7cd35bcfb889
#: ../../java/lambda-persistence.rst:1076 ../../java/persistence.rst:1062
msgid ""
"Note that ``journalPluginId`` and ``snapshotPluginId`` must refer to "
"properly configured ``reference.conf`` plugin entries with a standard "
"``class`` property as well as settings which are specific for those plugins,"
" i.e.:"
msgstr ""

# 9479cf1a32ba44f88b48a2a70b015131
#: ../../java/logging.rst:5
msgid "Logging"
msgstr ""

# 6dce8be2392b4c66a543cd7b795840f4
#: ../../java/logging.rst:7
msgid ""
"Logging in Akka is not tied to a specific logging backend. By default log "
"messages are printed to STDOUT, but you can plug-in a SLF4J logger or your "
"own logger. Logging is performed asynchronously to ensure that logging has "
"minimal performance impact. Logging generally means IO and locks, which can "
"slow down the operations of your code if it was performed synchronously."
msgstr ""

# d5730e4f1aef461d901bbf6fbae8d10c
#: ../../java/logging.rst:15
msgid "How to Log"
msgstr ""

# 62a4931b9f1842a29b0b4fd546d08c84
#: ../../java/logging.rst:17
msgid ""
"Create a ``LoggingAdapter`` and use the ``error``, ``warning``, ``info``, or"
" ``debug`` methods, as illustrated in this example:"
msgstr ""

# 172c04e1375647f383cf5af792fa2b7e
#: ../../java/logging.rst:26
msgid ""
"The first parameter to ``Logging.getLogger`` could also be any "
":class:`LoggingBus`, specifically ``system.eventStream()``; in the "
"demonstrated case, the actor system’s address is included in the "
"``akkaSource`` representation of the log source (see `Logging Thread, Akka "
"Source and Actor System in MDC`_) while in the second case this is not "
"automatically done. The second parameter to ``Logging.getLogger`` is the "
"source of this logging channel.  The source object is translated to a String"
" according to the following rules:"
msgstr ""

# e21b5f2666cb4a62b6e324686102b996
#: ../../java/logging.rst:34
msgid "if it is an Actor or ActorRef, its path is used"
msgstr ""

# 9d1a94ecb7c04a139f2a56a76b36c063
#: ../../java/logging.rst:35
msgid "in case of a String it is used as is"
msgstr ""

# eb15ebb69c154385b4f2a3112145aba1
#: ../../java/logging.rst:36
msgid "in case of a class an approximation of its simpleName"
msgstr ""

# a9978f8c1b614fa3be7f11554aebafd0
#: ../../java/logging.rst:37
msgid "and in all other cases the simpleName of its class"
msgstr ""

# 0b353f2b50e64d0594a4201219e85712
#: ../../java/logging.rst:39
msgid ""
"The log message may contain argument placeholders ``{}``, which will be "
"substituted if the log level is enabled. Giving more arguments as there are "
"placeholders results in a warning being appended to the log statement (i.e. "
"on the same line with the same severity). You may pass a Java array as the "
"only substitution argument to have its elements be treated individually:"
msgstr ""

# d76e926cb0114f5188874cfc78be88a5
#: ../../java/logging.rst:47
msgid ""
"The Java :class:`Class` of the log source is also included in the generated "
":class:`LogEvent`. In case of a simple string this is replaced with a "
"“marker” class :class:`akka.event.DummyClassForStringSources` in order to "
"allow special treatment of this case, e.g. in the SLF4J event listener which"
" will then use the string instead of the class’ name for looking up the "
"logger instance to use."
msgstr ""

# 3ce6b75069b74dfcbde9989707fe2426
#: ../../java/logging.rst:55
msgid "Logging of Dead Letters"
msgstr ""

# 500a1d821fe84a918f48e79640843afa
#: ../../java/logging.rst:57
msgid ""
"By default messages sent to dead letters are logged at info level. Existence"
" of dead letters does not necessarily indicate a problem, but it might be, "
"and therefore they are logged by default. After a few messages this logging "
"is turned off, to avoid flooding the logs. You can disable this logging "
"completely or adjust how many dead letters that are logged. During system "
"shutdown it is likely that you see dead letters, since pending messages in "
"the actor mailboxes are sent to dead letters. You can also disable logging "
"of dead letters during shutdown."
msgstr ""

# c9576ced3146429a8c34b774c6190f66
#: ../../java/logging.rst:72
msgid ""
"To customize the logging further or take other actions for dead letters you "
"can subscribe to the :ref:`event-stream-java`."
msgstr ""

# b0a221707c774e6d804d10256b8c7394
#: ../../java/logging.rst:76
msgid "Auxiliary logging options"
msgstr ""

# 6dde622537cc498981b995a32afc448c
#: ../../java/logging.rst:78
msgid ""
"Akka has a couple of configuration options for very low level debugging, "
"that makes most sense in for developers and not for operations."
msgstr ""

# 6bb6f0d1fee041119e0e317bef538652
#: ../../java/logging.rst:81
msgid ""
"You almost definitely need to have logging set to DEBUG to use any of the "
"options below:"
msgstr ""

# 913992796c6748299cc8c677b509fbb3
#: ../../java/logging.rst:89
msgid ""
"This config option is very good if you want to know what config settings are"
" loaded by Akka:"
msgstr ""

# 09b80b46f9c344c7af16f06c891e642b
#: ../../java/logging.rst:99
msgid ""
"If you want very detailed logging of all automatically received messages "
"that are processed by Actors:"
msgstr ""

# a5df1c0646d94bcd99bb33aed906be4e
#: ../../java/logging.rst:113
msgid ""
"If you want very detailed logging of all lifecycle changes of Actors "
"(restarts, deaths etc):"
msgstr ""

# 99a74e99584a41ffba320d6ecf31f15e
#: ../../java/logging.rst:126
msgid "If you want unhandled messages logged at DEBUG:"
msgstr ""

# 3e18675a949d4146bc21e50b5b09554e
#: ../../java/logging.rst:139
msgid ""
"If you want very detailed logging of all events, transitions and timers of "
"FSM Actors that extend LoggingFSM:"
msgstr ""

# b738b38e7e174e599f46e99b9b8fb550
#: ../../java/logging.rst:152
msgid ""
"If you want to monitor subscriptions (subscribe/unsubscribe) on the "
"ActorSystem.eventStream:"
msgstr ""

# 9d7ab7994e5b4d0c9c397fb3e4828a5b
#: ../../java/logging.rst:168
msgid "Auxiliary remote logging options"
msgstr ""

# c3cb57b9eba847e08d0328a7cf5d7d2a
#: ../../java/logging.rst:170
msgid ""
"If you want to see all messages that are sent through remoting at DEBUG log "
"level: (This is logged as they are sent by the transport layer, not by the "
"Actor)"
msgstr ""

# 799fcd862265466d9ccc270880e18c2e
#: ../../java/logging.rst:183
msgid ""
"If you want to see all messages that are received through remoting at DEBUG "
"log level: (This is logged as they are received by the transport layer, not "
"by any Actor)"
msgstr ""

# 29525845d1e34e7f8d6bf145c2f0b7b8
#: ../../java/logging.rst:196
msgid ""
"If you want to see message types with payload size in bytes larger than a "
"specified limit at INFO log level:"
msgstr ""

# 5e38a29074ba4e60a67c2770dd4a79eb
#: ../../java/logging.rst:213
msgid "Also see the logging options for TestKit: :ref:`actor.logging-java`."
msgstr ""

# b40e4cb3f81b46a29b02ad39f15272d1
#: ../../java/logging.rst:216
msgid "Turn Off Logging"
msgstr ""

# ae79de9d860b468493ffdae58ac1fb36
#: ../../java/logging.rst:218
msgid ""
"To turn off logging you can configure the log levels to be ``OFF`` like "
"this."
msgstr ""

# 7a203a877fa54ef9a5b2124bd9d4153e
#: ../../java/logging.rst:227
msgid ""
"The ``stdout-loglevel`` is only in effect during system startup and "
"shutdown, and setting it to ``OFF`` as well, ensures that nothing gets "
"logged during system startup or shutdown."
msgstr ""

# 6cfb7a6b09774411801966656196e4f3
#: ../../java/logging.rst:231
msgid "Loggers"
msgstr ""

# 1279e998cc764016b3e1a8b69be14312
#: ../../java/logging.rst:233
msgid ""
"Logging is performed asynchronously through an event bus. Log events are "
"processed by an event handler actor and it will receive the log events in "
"the same order as they were emitted."
msgstr ""

# 38d54e9651a64bdaa669fa2580d8b8e4
#: ../../java/logging.rst:237
msgid ""
"The event handler actor does not have a bounded inbox and is run on the "
"default dispatcher. This means that logging extreme amounts of data may "
"affect your application badly. It can be somewhat mitigated by making sure "
"to use an async logging backend though. (See :ref:`slf4j-directly-java`)"
msgstr ""

# 703c8d0393c04a57aa54451f12c5679e
#: ../../java/logging.rst:241
msgid ""
"You can configure which event handlers are created at system start-up and "
"listen to logging events. That is done using the ``loggers`` element in the "
":ref:`configuration`. Here you can also define the log level. More fine "
"grained filtering based on the log source can be implemented in a custom "
"``LoggingFilter``, which can be defined in the ``logging-filter`` "
"configuration property."
msgstr ""

# 89fb81e79960400b83115feda925d0fd
#: ../../java/logging.rst:257
msgid ""
"The default one logs to STDOUT and is registered by default. It is not "
"intended to be used for production. There is also an :ref:`slf4j-java` "
"logger available in the 'akka-slf4j' module."
msgstr ""

# 5661ccbbdf3846cba5132380ca5b9896
#: ../../java/logging.rst:260
msgid "Example of creating a listener:"
msgstr ""

# 2ecc984fd4034e2c838ad9f56a631f3a
#: ../../java/logging.rst:269
msgid "Logging to stdout during startup and shutdown"
msgstr ""

# 5d1c94ccdd784e23a8d676966bceddc1
#: ../../java/logging.rst:271
msgid ""
"While the actor system is starting up and shutting down the configured "
"``loggers`` are not used. Instead log messages are printed to stdout "
"(System.out). The default log level for this stdout logger is ``WARNING`` "
"and it can be silenced completely by setting ``akka.stdout-loglevel=OFF``."
msgstr ""

# 72d76001b8ba4c7aa5d695b6e2ae2c32
#: ../../java/logging.rst:279
msgid "SLF4J"
msgstr ""

# 9b5910f1c10f43fca4130c858aa56039
#: ../../java/logging.rst:281
msgid ""
"Akka provides a logger for `SL4FJ <http://www.slf4j.org/>`_. This module is "
"available in the 'akka-slf4j.jar'. It has one single dependency; the slf4j-"
"api jar. In runtime you also need a SLF4J backend, we recommend `Logback "
"<http://logback.qos.ch/>`_:"
msgstr ""

# 227b86648bc54f01bb87c26d42ae90fb
#: ../../java/logging.rst:292
msgid ""
"You need to enable the Slf4jLogger in the ``loggers`` element in the "
":ref:`configuration`. Here you can also define the log level of the event "
"bus. More fine grained log levels can be defined in the configuration of the"
" SLF4J backend (e.g. logback.xml). You should also define "
"``akka.event.slf4j.Slf4jLoggingFilter`` in the ``logging-filter`` "
"configuration property. It will filter the log events using the backend "
"configuration (e.g. logback.xml) before they are published to the event bus."
msgstr ""

# 260676fef78743e69c0ef38620b2fdfc
#: ../../java/logging.rst:300
msgid ""
"If you set the ``loglevel`` to a higher level than \"DEBUG\", any DEBUG "
"events will be filtered out already at the source and will never reach the "
"logging backend, regardless of how the backend is configured."
msgstr ""

# 993179291f844abca981cd185971a758
#: ../../java/logging.rst:312
msgid ""
"One gotcha is that the timestamp is attributed in the event handler, not "
"when actually doing the logging."
msgstr ""

# 2083acd2aaf44b93ad978b9703a19813
#: ../../java/logging.rst:314
msgid ""
"The SLF4J logger selected for each log event is chosen based on the "
":class:`Class` of the log source specified when creating the "
":class:`LoggingAdapter`, unless that was given directly as a string in which"
" case that string is used (i.e. ``LoggerFactory.getLogger(Class c)`` is used"
" in the first case and ``LoggerFactory.getLogger(String s)`` in the second)."
msgstr ""

# abb7ace4c5bc4ecc9a19b94f319dbba1
#: ../../java/logging.rst:322
msgid ""
"Beware that the actor system’s name is appended to a :class:`String` log "
"source if the LoggingAdapter was created giving an :class:`ActorSystem` to "
"the factory. If this is not intended, give a :class:`LoggingBus` instead as "
"shown below:"
msgstr ""

# fd92bba8b8734d619e1dc911268624ca
#: ../../java/logging.rst:334
msgid "Using the SLF4J API directly"
msgstr ""

# 418d107bc82841f08001bdafcf62fe27
#: ../../java/logging.rst:335
msgid ""
"If you use the SLF4J API directly in your application, remember that the "
"logging operations will block while the underlying infrastructure writes the"
" log statements."
msgstr ""

# 969c233c0a3e48bdaafc1a11a648e3ac
#: ../../java/logging.rst:338
msgid ""
"This can be avoided by configuring the logging implementation to use a non-"
"blocking appender. Logback provides `AsyncAppender "
"<http://logback.qos.ch/manual/appenders.html#AsyncAppender>`_ that does "
"this. It also contains a feature which will drop ``INFO`` and ``DEBUG`` "
"messages if the logging load is high."
msgstr ""

# 2c549dd608b64b35b2a94b9795be71bd
#: ../../java/logging.rst:344
msgid "Logging Thread, Akka Source and Actor System in MDC"
msgstr ""

# 053ef5e65f8b43c4914489501f552b14
#: ../../java/logging.rst:346
msgid ""
"Since the logging is done asynchronously the thread in which the logging was"
" performed is captured in Mapped Diagnostic Context (MDC) with attribute "
"name ``sourceThread``. With Logback the thread name is available with "
"``%X{sourceThread}`` specifier within the pattern layout configuration::"
msgstr ""

# 706ebbcbe91b4d369122ebb3ffcea373
#: ../../java/logging.rst:358
msgid ""
"It will probably be a good idea to use the ``sourceThread`` MDC value also "
"in non-Akka parts of the application in order to have this property "
"consistently available in the logs."
msgstr ""

# 14a9f912c98a45d1bdbaffd3bd1d590b
#: ../../java/logging.rst:362
msgid ""
"Another helpful facility is that Akka captures the actor’s address when "
"instantiating a logger within it, meaning that the full instance "
"identification is available for associating log messages e.g. with members "
"of a router. This information is available in the MDC with attribute name "
"``akkaSource``::"
msgstr ""

# 629b8fcd417e48f8b68e9509098faee1
#: ../../java/logging.rst:373
msgid ""
"Finally, the actor system in which the logging was performed is available in"
" the MDC with attribute name ``sourceActorSystem``::"
msgstr ""

# ca2d6828c8d54175919ddbe0950d6d1f
#: ../../java/logging.rst:382
msgid ""
"For more details on what this attribute contains—also for non-actors—please "
"see `How to Log`_."
msgstr ""

# 2984c9892c764268a87a7ded1def16b8
#: ../../java/logging.rst:386
msgid "More accurate timestamps for log output in MDC"
msgstr ""

# 575838c07181491d83704f4851e6635b
#: ../../java/logging.rst:388
msgid ""
"Akka's logging is asynchronous which means that the timestamp of a log entry"
" is taken from when the underlying logger implementation is called, which "
"can be surprising at first. If you want to more accurately output the "
"timestamp, use the MDC attribute ``akkaTimestamp``::"
msgstr ""

# a57dd4a85608494a9e11465bc0ca7cd3
#: ../../java/logging.rst:400
msgid "MDC values defined by the application"
msgstr ""

# 6db6728eb167405f9cdd84ae8293e430
#: ../../java/logging.rst:402
msgid ""
"One useful feature available in Slf4j is `MDC "
"<http://logback.qos.ch/manual/mdc.html>`_, Akka has a way for let the "
"application specify custom values, you just need to get a specialized "
":class:`LoggingAdapter`, the :class:`DiagnosticLoggingAdapter`. In order to "
"get it you will use the factory receiving an UntypedActor as logSource:"
msgstr ""

# 719fee7de0e4427b83ab47a2c9c84d2a
#: ../../java/logging.rst:412
msgid ""
"Once you have the logger, you just need to add the custom values before you "
"log something. This way, the values will be put in the SLF4J MDC right "
"before appending the log and removed after."
msgstr ""

# 952953e0010d4bd7a7175d043d62ba7b
#: ../../java/logging.rst:417
msgid ""
"The cleanup (removal) should be done in the actor at the end, otherwise, "
"next message will log with same mdc values, if it is not set to a new map. "
"Use ``log.clearMDC()``."
msgstr ""

# 7765e9df1a404f77860dedc4440367c3
#: ../../java/logging.rst:427
msgid ""
"Now, the values will be available in the MDC, so you can use them in the "
"layout pattern::"
msgstr ""

# 220479d6749644fc8bdf2cabbe31e9e3
#: ../../java/mailboxes.rst:4
msgid "Mailboxes"
msgstr ""

# 9a5192c331044c65ad62e9983d07ab7b
#: ../../java/mailboxes.rst:6
msgid ""
"An Akka ``Mailbox`` holds the messages that are destined for an ``Actor``. "
"Normally each ``Actor`` has its own mailbox, but with for example a "
"``BalancingPool`` all routees will share a single mailbox instance."
msgstr ""

# 103b0c1af18249f5aa5575326cad39ea
#: ../../java/mailboxes.rst:11
msgid "Mailbox Selection"
msgstr ""

# d4f2950cec6c4f9a91760256d4e0a771
#: ../../java/mailboxes.rst:14
msgid "Requiring a Message Queue Type for an Actor"
msgstr ""

# b18fad8d2d614ce5b9481ee0ba57901c
#: ../../java/mailboxes.rst:16
msgid ""
"It is possible to require a certain type of message queue for a certain type"
" of actor by having that actor implement the parameterized interface "
":class:`RequiresMessageQueue`. Here is an example:"
msgstr ""

# 68c25820fa084e6c8837e7aca5086782
#: ../../java/mailboxes.rst:22
msgid ""
"The type parameter to the :class:`RequiresMessageQueue` interface needs to "
"be mapped to a mailbox in configuration like this:"
msgstr ""

# 6db692e917e84464abd054e5d42e3c01
#: ../../java/mailboxes.rst:28
msgid ""
"Now every time you create an actor of type :class:`MyBoundedUntypedActor` it"
" will try to get a bounded mailbox. If the actor has a different mailbox "
"configured in deployment, either directly or via a dispatcher with a "
"specified mailbox type, then that will override this mapping."
msgstr ""

# 99c7012a301f4de4a7e330603bb8a18b
#: ../../java/mailboxes.rst:34
msgid ""
"The type of the queue in the mailbox created for an actor will be checked "
"against the required type in the interface and if the queue doesn't "
"implement the required type then actor creation will fail."
msgstr ""

# f79ebcd868fa48b9bf6b556522c9194d
#: ../../java/mailboxes.rst:38
msgid "Requiring a Message Queue Type for a Dispatcher"
msgstr ""

# 5341e828e690407fbf373302f76ab898
#: ../../java/mailboxes.rst:40
msgid ""
"A dispatcher may also have a requirement for the mailbox type used by the "
"actors running on it. An example is the BalancingDispatcher which requires a"
" message queue that is thread-safe for multiple concurrent consumers. Such a"
" requirement is formulated within the dispatcher configuration section like "
"this::"
msgstr ""

# 6ec4b3aee7164fdb8203c2de1e36a592
#: ../../java/mailboxes.rst:50
msgid ""
"The given requirement names a class or interface which will then be ensured "
"to be a supertype of the message queue’s implementation. In case of a "
"conflict—e.g. if the actor requires a mailbox type which does not satisfy "
"this requirement—then actor creation will fail."
msgstr ""

# 37b2f5744b0a4493a399e558e4d8cfad
#: ../../java/mailboxes.rst:56
msgid "How the Mailbox Type is Selected"
msgstr ""

# ce4716d2284a460daa12183ecdd603fe
#: ../../java/mailboxes.rst:58
msgid ""
"When an actor is created, the :class:`ActorRefProvider` first determines the"
" dispatcher which will execute it. Then the mailbox is determined as "
"follows:"
msgstr ""

# 069331896de842d394809fcd49110ccd
#: ../../java/mailboxes.rst:61
msgid ""
"If the actor’s deployment configuration section contains a ``mailbox`` key "
"then that names a configuration section describing the mailbox type to be "
"used."
msgstr ""

# f7785fb4e5fa443aa5ff48f462f5066e
#: ../../java/mailboxes.rst:65
msgid ""
"If the actor’s ``Props`` contains a mailbox selection—i.e. ``withMailbox`` "
"was called on it—then that names a configuration section describing the "
"mailbox type to be used."
msgstr ""

# 2db67a2f064d481084abccf5f3d246fd
#: ../../java/mailboxes.rst:69
msgid ""
"If the dispatcher’s configuration section contains a ``mailbox-type`` key "
"the same section will be used to configure the mailbox type."
msgstr ""

# ce23391e14bf4071983a24067230af67
#: ../../java/mailboxes.rst:72
msgid ""
"If the actor requires a mailbox type as described above then the mapping for"
" that requirement will be used to determine the mailbox type to be used; if "
"that fails then the dispatcher’s requirement—if any—will be tried instead."
msgstr ""

# adb80220e36748e3a0049a87a7445099
#: ../../java/mailboxes.rst:76
msgid ""
"If the dispatcher requires a mailbox type as described above then the "
"mapping for that requirement will be used to determine the mailbox type to "
"be used."
msgstr ""

# a387f521e8dd4810aaa53fa350bf9140
#: ../../java/mailboxes.rst:80
msgid "The default mailbox ``akka.actor.default-mailbox`` will be used."
msgstr ""

# 308c35a5d0f24526919e94a95eca37ff
#: ../../java/mailboxes.rst:83
msgid "Default Mailbox"
msgstr ""

# 45ad99de22df44edb2c69bc792625c09
#: ../../java/mailboxes.rst:85
msgid ""
"When the mailbox is not specified as described above the default mailbox is "
"used. By default it is an unbounded mailbox, which is backed by a "
"``java.util.concurrent.ConcurrentLinkedQueue``."
msgstr ""

# 604affb8621d413392313b3b48d5c2bb
#: ../../java/mailboxes.rst:89
msgid ""
"``SingleConsumerOnlyUnboundedMailbox`` is an even more efficient mailbox, "
"and it can be used as the default mailbox, but it cannot be used with a "
"BalancingDispatcher."
msgstr ""

# 162c741c34774a5698fc1ff4b0f9f120
#: ../../java/mailboxes.rst:92
msgid ""
"Configuration of ``SingleConsumerOnlyUnboundedMailbox`` as default mailbox::"
msgstr ""

# d3ad08cd5ff543d1ac8b3a3087bef9a5
#: ../../java/mailboxes.rst:99
msgid "Which Configuration is passed to the Mailbox Type"
msgstr ""

# 20157fdf7ac7411eb0e17087e4a22aae
#: ../../java/mailboxes.rst:101
msgid ""
"Each mailbox type is implemented by a class which extends "
":class:`MailboxType` and takes two constructor arguments: a "
":class:`ActorSystem.Settings` object and a :class:`Config` section. The "
"latter is computed by obtaining the named configuration section from the "
"actor system’s configuration, overriding its ``id`` key with the "
"configuration path of the mailbox type and adding a fall-back to the default"
" mailbox configuration section."
msgstr ""

# 6b8b3f51f40e44ada1b926f9e6a76bdb
#: ../../java/mailboxes.rst:109
msgid "Builtin Mailbox Implementations"
msgstr ""

# 6c6c6f7f01fd4b4db564b9ef3e18c016
#: ../../java/mailboxes.rst:111
msgid "Akka comes shipped with a number of mailbox implementations:"
msgstr ""

# 3a59033be0b447dfafedf3b8902a6030
#: ../../java/mailboxes.rst:113
msgid "**UnboundedMailbox** (default)"
msgstr ""

# 720dff895c7e4c24b6fca74428e39a8f
#: ../../java/mailboxes.rst:115
msgid "The default mailbox"
msgstr ""

# 21aa696933d14beda076358911ff63cc
#: ../../java/mailboxes.rst:117
msgid "Backed by a ``java.util.concurrent.ConcurrentLinkedQueue``"
msgstr ""

# a49cc7a86c404c7b9ffaae921a0d78ec
# 11b74ed5d57149b0b04231930223f813
# 785ad000dbe84ca2a57cb171b5fd1997
# 0070e72c18af4a3c8d25e3b5669444eb
# 828603dc933f4935a70232975ca18c87
#: ../../java/mailboxes.rst:119 ../../java/mailboxes.rst:131
#: ../../java/mailboxes.rst:153 ../../java/mailboxes.rst:165
#: ../../java/mailboxes.rst:177
msgid "Blocking: No"
msgstr ""

# d2a6c723e69e4d65a516443d489ffbe4
# 7da93ad03d4742b58445510d8afb8618
# 4d2ccf04364e49829ff80423c6416251
# 5213177ec8554c928a2f5c5fa9efa0c3
# 8c2f61157ee3454c8f9a2a45a98e2f14
#: ../../java/mailboxes.rst:121 ../../java/mailboxes.rst:133
#: ../../java/mailboxes.rst:155 ../../java/mailboxes.rst:167
#: ../../java/mailboxes.rst:179
msgid "Bounded: No"
msgstr ""

# ef65a0de7d4b46749b43a0f1548fb82d
#: ../../java/mailboxes.rst:123
msgid ""
"Configuration name: ``\"unbounded\"`` or "
"``\"akka.dispatch.UnboundedMailbox\"``"
msgstr ""

# 56a355310da745bb9f0ab7d9924ac063
#: ../../java/mailboxes.rst:125
msgid "**SingleConsumerOnlyUnboundedMailbox**"
msgstr ""

# dc8e18e3a50e4997a8687392eaad8b35
#: ../../java/mailboxes.rst:127
msgid ""
"This queue may or may not be faster than the default one depending on your "
"use-case—be sure to benchmark properly!"
msgstr ""

# f875282c5eb44a2fb63961ab8199926e
#: ../../java/mailboxes.rst:129
msgid ""
"Backed by a Multiple-Producer Single-Consumer queue, cannot be used with "
"``BalancingDispatcher``"
msgstr ""

# 1f4de1b0bab04da5901c9c90660aad85
#: ../../java/mailboxes.rst:135
msgid ""
"Configuration name: ``\"akka.dispatch.SingleConsumerOnlyUnboundedMailbox\"``"
msgstr ""

# a038762c20d14beb9ae5fc0e6218a0fe
#: ../../java/mailboxes.rst:137
msgid "**NonBlockingBoundedMailbox**"
msgstr ""

# d73c73bc3d594bffbaec99360af989ee
#: ../../java/mailboxes.rst:139
msgid "Backed by a very efficient Multiple-Producer Single-Consumer queue"
msgstr ""

# 7ca1a016d2da484eb438539ccb378172
#: ../../java/mailboxes.rst:141
msgid "Blocking: No (discards overflowing messages into deadLetters)"
msgstr ""

# 4805a61b6ecc43c8a4085af0b8f00c98
# 98af7ac605b948f7bcfd9a61a3f47569
# c560a61d0ebf49eabb4095d4193c6eed
# 68043f1942484f79b09212c2dd4e590a
# b8da77c7cd304e0886447e686d17030e
#: ../../java/mailboxes.rst:143 ../../java/mailboxes.rst:194
#: ../../java/mailboxes.rst:206 ../../java/mailboxes.rst:218
#: ../../java/mailboxes.rst:230
msgid "Bounded: Yes"
msgstr ""

# 27c1ef1048ce4f3cb2548e5c9232067c
#: ../../java/mailboxes.rst:145
msgid "Configuration name: ``\"akka.dispatch.NonBlockingBoundedMailbox\"``"
msgstr ""

# 76b0d0b0e8334180abb9a7245b343695
#: ../../java/mailboxes.rst:147
msgid "**UnboundedControlAwareMailbox**"
msgstr ""

# 9fc17b6afa5e442ba90a32bd06700f37
# 2120d1e0f8684aaa8ead34702f8d7e5a
#: ../../java/mailboxes.rst:149 ../../java/mailboxes.rst:224
msgid ""
"Delivers messages that extend ``akka.dispatch.ControlMessage`` with higher "
"priority"
msgstr ""

# ef2a61a0d8304714bcefa4514d66557f
#: ../../java/mailboxes.rst:151
msgid "Backed by two ``java.util.concurrent.ConcurrentLinkedQueue``"
msgstr ""

# 1fd852734b944a00b7ffa54b000a4ef3
#: ../../java/mailboxes.rst:157
msgid "Configuration name: \"akka.dispatch.UnboundedControlAwareMailbox\""
msgstr ""

# 04bb2b56debd45f5ab4e6869d4f28a69
#: ../../java/mailboxes.rst:159
msgid "**UnboundedPriorityMailbox**"
msgstr ""

# eebfa8a5fb124d438336f9e9d68ae7ab
#: ../../java/mailboxes.rst:161
msgid "Backed by a ``java.util.concurrent.PriorityBlockingQueue``"
msgstr ""

# 87d8ecf1e2e9419796a8ab21f0c4bb4e
#: ../../java/mailboxes.rst:163
msgid ""
"Delivery order for messages of equal priority is undefined - contrast with "
"the UnboundedStablePriorityMailbox"
msgstr ""

# b4c1fa32bd7144daa63595bae62c3fc3
#: ../../java/mailboxes.rst:169
msgid "Configuration name: \"akka.dispatch.UnboundedPriorityMailbox\""
msgstr ""

# a4856981b26149a6bc9ba93fd94fc675
#: ../../java/mailboxes.rst:171
msgid "**UnboundedStablePriorityMailbox**"
msgstr ""

# 2e5d0b28468a49ecabe014ef751c2f0c
#: ../../java/mailboxes.rst:173
msgid ""
"Backed by a ``java.util.concurrent.PriorityBlockingQueue`` wrapped in an "
"``akka.util.PriorityQueueStabilizer``"
msgstr ""

# cd26feb6baf54fd68b3baf07956b6821
#: ../../java/mailboxes.rst:175
msgid ""
"FIFO order is preserved for messages of equal priority - contrast with the "
"UnboundedPriorityMailbox"
msgstr ""

# f752e580a7544b34af5013f785f51d34
#: ../../java/mailboxes.rst:181
msgid "Configuration name: \"akka.dispatch.UnboundedStablePriorityMailbox\""
msgstr ""

# 6ef67e86e8564af19b03f3cc7c84f225
#: ../../java/mailboxes.rst:183
msgid ""
"Other bounded mailbox implementations which will block the sender if the "
"capacity is reached and configured with non-zero ``mailbox-push-timeout-"
"time``."
msgstr ""

# b2910cf5b78542cf850d75dd9a5d20a2
#: ../../java/mailboxes.rst:186
msgid ""
"The following mailboxes should only be used with zero ``mailbox-push-"
"timeout-time``."
msgstr ""

# ddd4d3d1234e441f87f3b58ba49ece59
#: ../../java/mailboxes.rst:188
msgid "**BoundedMailbox**"
msgstr ""

# 5d7c6c07e67f403bb2a4838b50d873d5
#: ../../java/mailboxes.rst:190
msgid "Backed by a ``java.util.concurrent.LinkedBlockingQueue``"
msgstr ""

# 98ebfe5fd8634f40b12c7d7e591e6171
# 4ffd4e586be24ed3a276241ba54a8d16
# 2718222a273a42b595d226fd9c6502ef
# b526bc2b92804efabfd6dfcfe64b71e2
#: ../../java/mailboxes.rst:192 ../../java/mailboxes.rst:204
#: ../../java/mailboxes.rst:216 ../../java/mailboxes.rst:228
msgid ""
"Blocking: Yes if used with non-zero ``mailbox-push-timeout-time``, otherwise"
" No"
msgstr ""

# cfad5bef9ac94db9a0b4c57cde545a29
#: ../../java/mailboxes.rst:196
msgid "Configuration name: \"bounded\" or \"akka.dispatch.BoundedMailbox\""
msgstr ""

# 309d1ebaa7d34cc3b16f242cce773a38
#: ../../java/mailboxes.rst:198
msgid "**BoundedPriorityMailbox**"
msgstr ""

# c65d3a47f43842fc8839a56619aa135b
#: ../../java/mailboxes.rst:200
msgid ""
"Backed by a ``java.util.PriorityQueue`` wrapped in an "
"``akka.util.BoundedBlockingQueue``"
msgstr ""

# 6b3e79002cb5444ea1bc0247aca67089
#: ../../java/mailboxes.rst:202
msgid ""
"Delivery order for messages of equal priority is undefined - contrast with "
"the ``BoundedStablePriorityMailbox``"
msgstr ""

# 832bb4b6d1e14444986ab1fd4601e024
#: ../../java/mailboxes.rst:208
msgid "Configuration name: ``\"akka.dispatch.BoundedPriorityMailbox\"``"
msgstr ""

# 8d1b058b565049cfbdb17223f1625750
#: ../../java/mailboxes.rst:210
msgid "**BoundedStablePriorityMailbox**"
msgstr ""

# 73e19518c2144549b3933a3e05e6f48a
#: ../../java/mailboxes.rst:212
msgid ""
"Backed by a ``java.util.PriorityQueue`` wrapped in an "
"``akka.util.PriorityQueueStabilizer`` and an "
"``akka.util.BoundedBlockingQueue``"
msgstr ""

# 86fc19c672094aee995a1cae28447609
#: ../../java/mailboxes.rst:214
msgid ""
"FIFO order is preserved for messages of equal priority - contrast with the "
"BoundedPriorityMailbox"
msgstr ""

# d151d40c262040a98b1830c1181110df
#: ../../java/mailboxes.rst:220
msgid "Configuration name: \"akka.dispatch.BoundedStablePriorityMailbox\""
msgstr ""

# 945797af22774e70b6595fcd57288595
#: ../../java/mailboxes.rst:222
msgid "**BoundedControlAwareMailbox**"
msgstr ""

# 6d5d7a18e63f41938a1f359fce948d77
#: ../../java/mailboxes.rst:226
msgid ""
"Backed by two ``java.util.concurrent.ConcurrentLinkedQueue`` and blocking on"
" enqueue if capacity has been reached"
msgstr ""

# 8f9f899110be40eb85f85b9e89f0f764
#: ../../java/mailboxes.rst:232
msgid "Configuration name: \"akka.dispatch.BoundedControlAwareMailbox\""
msgstr ""

# 4b54754163024731a78151732797b8f9
#: ../../java/mailboxes.rst:235
msgid "Mailbox configuration examples"
msgstr ""

# a7408c8d048941d6aaf6a1b35502b359
#: ../../java/mailboxes.rst:238
msgid "PriorityMailbox"
msgstr ""

# 6e49c43c85db4d2f82c44cee0f2e4e59
#: ../../java/mailboxes.rst:240
msgid "How to create a PriorityMailbox:"
msgstr ""

# 30a72e72c8a84581a9b3039347b86f1a
#: ../../java/mailboxes.rst:244
msgid "And then add it to the configuration:"
msgstr ""

# 283dc47adbf140baa9418a523ad83864
# d294eace218e4ac79b013f1f297a7b1a
#: ../../java/mailboxes.rst:248 ../../java/mailboxes.rst:279
msgid "And then an example on how you would use it:"
msgstr ""

# b8ad39d7c3d944228a68abc27519a7c7
#: ../../java/mailboxes.rst:252
msgid "It is also possible to configure a mailbox type directly like this:"
msgstr ""

# 59aabd421cfa495bab704c1947266367
#: ../../java/mailboxes.rst:257
msgid "And then use it either from deployment like this:"
msgstr ""

# 030061fea7e347edad38dab4b73c1b5c
#: ../../java/mailboxes.rst:261
msgid "Or code like this:"
msgstr ""

# f1bcd480993e410aa572b03c2dc89c2f
#: ../../java/mailboxes.rst:266
msgid "ControlAwareMailbox"
msgstr ""

# ddd4ce6ddcda42968b47b96ce80e1682
#: ../../java/mailboxes.rst:268
msgid ""
"A ``ControlAwareMailbox`` can be very useful if an actor needs to be able to"
" receive control messages immediately no matter how many other messages are "
"already in its mailbox."
msgstr ""

# 2025ed966cd24ad2b891e210201110f3
#: ../../java/mailboxes.rst:271
msgid "It can be configured like this:"
msgstr ""

# df93cd544f094ef5975e7f68c69ddfa9
#: ../../java/mailboxes.rst:275
msgid "Control messages need to extend the ``ControlMessage`` trait:"
msgstr ""

# 9c18cc0343a840cc876f80c8b6e26184
#: ../../java/mailboxes.rst:284
msgid "Creating your own Mailbox type"
msgstr ""

# b571aa95172849f1bce8845adb3369a0
#: ../../java/mailboxes.rst:286
msgid "An example is worth a thousand quacks:"
msgstr ""

# 3d4c23e2c15c456080f83ad90af39146
#: ../../java/mailboxes.rst:292
msgid ""
"And then you just specify the FQCN of your MailboxType as the value of the "
"\"mailbox-type\" in the dispatcher configuration, or the mailbox "
"configuration."
msgstr ""

# 42f47cdc8de3400dbdd0e45aeb5176b8
#: ../../java/mailboxes.rst:297
msgid ""
"Make sure to include a constructor which takes "
"``akka.actor.ActorSystem.Settings`` and ``com.typesafe.config.Config`` "
"arguments, as this constructor is invoked reflectively to construct your "
"mailbox type. The config passed in as second argument is that section from "
"the configuration which describes the dispatcher or mailbox setting using "
"this mailbox type; the mailbox type will be instantiated once for each "
"dispatcher or mailbox setting using it."
msgstr ""

# d40bf450a1c245b395c17685424d77bd
#: ../../java/mailboxes.rst:305
msgid ""
"You can also use the mailbox as a requirement on the dispatcher like this:"
msgstr ""

# bb28ddff3715404699b3277eb4fee91e
#: ../../java/mailboxes.rst:310
msgid "Or by defining the requirement on your actor class like this:"
msgstr ""

# 66912e9d76d9450cb3a4c4e3a5aa4dd9
#: ../../java/mailboxes.rst:316
msgid "Special Semantics of ``system.actorOf``"
msgstr ""

# 4ed510d024594697888c38d696477ef6
#: ../../java/mailboxes.rst:318
msgid ""
"In order to make ``system.actorOf`` both synchronous and non-blocking while "
"keeping the return type :class:`ActorRef` (and the semantics that the "
"returned ref is fully functional), special handling takes place for this "
"case. Behind the scenes, a hollow kind of actor reference is constructed, "
"which is sent to the system’s guardian actor who actually creates the actor "
"and its context and puts those inside the reference. Until that has "
"happened, messages sent to the :class:`ActorRef` will be queued locally, and"
" only upon swapping the real filling in will they be transferred into the "
"real mailbox. Thus,"
msgstr ""

# 0b36a6da3ae340e0916368ed1736063c
#: ../../java/mailboxes.rst:334
msgid ""
"will probably fail; you will have to allow for some time to pass and retry "
"the check à la :meth:`TestKit.awaitCond`."
msgstr ""

# dd46341c81c8488d9b5a00666fa55a66
#: ../../java/persistence.rst:5
msgid "Persistence"
msgstr "永続化"

# 0ff62a09050546bd8f5ca597df949554
#: ../../java/persistence.rst:18
msgid ""
"Java 8 lambda expressions are also supported. (See section :ref"
":`persistence-lambda-java`)"
msgstr ""

# 9e9f12f8a4a7404bb4e84e0a3f8f2449
#: ../../java/persistence.rst:20
msgid ""
"Akka persistence is inspired by and the official replacement of the "
"`eventsourced`_ library. It follows the same concepts and architecture of "
"`eventsourced`_ but significantly differs on API and implementation level. "
"See also :ref:`migration-eventsourced-2.3`"
msgstr ""

# 2a49aaa7f3ce4805b198804447da648a
#: ../../java/persistence.rst:56
msgid ""
"*UntypedPersistentActor*: Is a persistent, stateful actor. It is able to "
"persist events to a journal and can react to them in a thread-safe manner. "
"It can be used to implement both *command* as well as *event sourced* "
"actors. When a persistent actor is started or restarted, journaled messages "
"are replayed to that actor so that it can recover internal state from these "
"messages."
msgstr ""

# 9f2d40796cfd46f0ab57c5239698cb04
#: ../../java/persistence.rst:61
msgid ""
"*UntypedPersistentView*: A view is a persistent, stateful actor that "
"receives journaled messages that have been written by another persistent "
"actor. A view itself does not journal new messages, instead, it updates "
"internal state only from a persistent actor's replicated message stream."
msgstr ""

# 68934fd5f0e0490194b1f58686329eb2
#: ../../java/persistence.rst:65
msgid ""
"*UntypedPersistentActorAtLeastOnceDelivery*: To send messages with at-least-"
"once delivery semantics to destinations, also in case of sender and receiver"
" JVM crashes."
msgstr ""

# bf8e2621b7f24b64a859357bd4e0e9b4
#: ../../java/persistence.rst:68
msgid ""
"*AsyncWriteJournal*: A journal stores the sequence of messages sent to a "
"persistent actor. An application can control which messages are journaled "
"and which are received by the persistent actor without being journaled. "
"Journal maintains *highestSequenceNr* that is increased on each message. The"
" storage backend of a journal is pluggable. The persistence extension comes "
"with a \"leveldb\" journal plugin, which writes to the local filesystem. "
"Replicated journals are available as `Community plugins`_."
msgstr ""

# 5d1f391099394dd1bd644b663fa5f53f
#: ../../java/persistence.rst:73
msgid ""
"*Snapshot store*: A snapshot store persists snapshots of a persistent "
"actor's or a view's internal state. Snapshots are used for optimizing "
"recovery times. The storage backend of a snapshot store is pluggable. The "
"persistence extension comes with a \"local\" snapshot storage plugin, which "
"writes to the local filesystem. Replicated snapshot stores are available as "
"`Community plugins`_."
msgstr ""

# 280a2ad59a9842ef9e4cb7a57c51fd59
#: ../../java/persistence.rst:85
msgid ""
"The basic idea behind `Event Sourcing`_ is quite simple. A persistent actor "
"receives a (non-persistent) command which is first validated if it can be "
"applied to the current state. Here validation can mean anything from simple "
"inspection of a command message's fields up to a conversation with several "
"external services, for example. If validation succeeds, events are generated"
" from the command, representing the effect of the command. These events are "
"then persisted and, after successful persistence, used to change the actor's"
" state. When the persistent actor needs to be recovered, only the persisted "
"events are replayed of which we know that they can be successfully applied. "
"In other words, events cannot fail when being replayed to a persistent "
"actor, in contrast to commands. Event sourced actors may of course also "
"process commands that do not change application state such as query commands"
" for example."
msgstr ""

# 1cf8048ab5aa44ec828bd5e37a11240b
#: ../../java/persistence.rst:96
msgid ""
"Akka persistence supports event sourcing with the ``UntypedPersistentActor``"
" abstract class. An actor that extends this class uses the ``persist`` "
"method to persist and handle events. The behavior of an "
"``UntypedPersistentActor`` is defined by implementing ``receiveRecover`` and"
" ``receiveCommand``. This is demonstrated in the following example."
msgstr ""

# fe100b7f1af0455d96fb637e4f1beebf
#: ../../java/persistence.rst:105
msgid ""
"The persistent actor's ``onReceiveRecover`` method defines how ``state`` is "
"updated during recovery by handling ``Evt`` and ``SnapshotOffer`` messages. "
"The persistent actor's ``onReceiveCommand`` method is a command handler. In "
"this example, a command is handled by generating two events which are then "
"persisted and handled. Events are persisted by calling ``persist`` with an "
"event (or a sequence of events) as first argument and an event handler as "
"second argument."
msgstr ""

# 93470085338540db9269150dded56600
#: ../../java/persistence.rst:119
msgid ""
"When persisting events with ``persist`` it is guaranteed that the persistent"
" actor will not receive further commands between the ``persist`` call and "
"the execution(s) of the associated event handler. This also holds for "
"multiple ``persist`` calls in context of a single command. Incoming messages"
" are :ref:`stashed <internal-stash-java>` until the ``persist`` is "
"completed."
msgstr ""

# b7e5c93568fb4267930baf8bfc357d86
#: ../../java/persistence.rst:124
msgid ""
"If persistence of an event fails, ``onPersistFailure`` will be invoked "
"(logging the error by default), and the actor will unconditionally be "
"stopped. If persistence of an event is rejected before it is stored, e.g. "
"due to serialization error, ``onPersistRejected`` will be invoked (logging a"
" warning by default), and the actor continues with the next message."
msgstr ""

# dd2fc7866eba401c9a727aa545536f59
#: ../../java/persistence.rst:129
msgid ""
"The easiest way to run this example yourself is to download `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_ and open the "
"tutorial named `Akka Persistence Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-persistence-"
"java>`_. It contains instructions on how to run the "
"``PersistentActorExample``."
msgstr ""

# 635ab17e9fa14018a8890b871f91b6a2
#: ../../java/persistence.rst:135
msgid ""
"It's also possible to switch between different command handlers during "
"normal processing and recovery with ``getContext().become()`` and "
"``getContext().unbecome()``. To get the actor into the same state after "
"recovery you need to take special care to perform the same state transitions"
" with ``become`` and ``unbecome`` in the ``receiveRecover`` method as you "
"would have done in the command handler. Note that when using ``become`` from"
" ``receiveRecover`` it will still only use the ``receiveRecover`` behavior "
"when replaying the events. When replay is completed it will use the new "
"behavior."
msgstr ""

# b0082919dabe49c599533e68c80e5372
#: ../../java/persistence.rst:156
msgid ""
"By default, a persistent actor is automatically recovered on start and on "
"restart by replaying journaled messages. New messages sent to a persistent "
"actor during recovery do not interfere with replayed messages. They are "
"cached and received by a persistent actor after recovery phase completes."
msgstr ""

# 9e66d48f11ee4a1cb7ad0896f249d6e2
#: ../../java/persistence.rst:168
msgid ""
"Applications may also customise how recovery is performed by returning a "
"customised ``Recovery`` object in the ``recovery`` method of a "
"``UntypedPersistentActor``, for example setting an upper bound to the replay"
" which allows the actor to be replayed to a certain point \"in the past\" "
"instead to its most up to date state:"
msgstr ""

# 4e50d8f9b84c43889fcf1bff4abf893a
#: ../../java/persistence.rst:174
msgid ""
"Recovery can be disabled by returning ``Recovery.none()`` in the "
"``recovery`` method of a ``PersistentActor``:"
msgstr ""

# fae48b62d7ab43ecb7c4e6b506e023e1
#: ../../java/persistence.rst:192
msgid ""
"If there is a problem with recovering the state of the actor from the "
"journal, ``onRecoveryFailure`` is called (logging the error by default) and "
"the actor will be stopped."
msgstr ""

# 1160f06a15a547a797b5cd7fcc7ae61e
#: ../../java/persistence.rst:200
msgid ""
"The persistent actor has a private :ref:`stash <stash-java>` for internally "
"caching incoming messages during :ref:`recovery <recovery-java>` or the "
"``persist\\persistAll`` method persisting events. You can still use/inherit "
"from the ``Stash`` interface. The internal stash cooperates with the normal "
"stash by hooking into ``unstashAll`` method and making sure messages are "
"unstashed properly to the internal stash to maintain ordering guarantees."
msgstr ""

# 88ef33e9f959488f9c71a17440148766
#: ../../java/persistence.rst:257
msgid ""
"In order to implement the pattern known as \"*command sourcing*\" simply "
"``persistAsync`` all incoming messages right away and handle them in the "
"callback."
msgstr ""

# 7c63adc15ede40b28a69652a465e829c
#: ../../java/persistence.rst:316
msgid ""
"In this case no stashing is happening, yet events are still persisted and "
"callbacks are executed in the expected order:"
msgstr ""

# 5fdaa5f52a7840f787a1f790ea019b2f
#: ../../java/persistence.rst:331
msgid ""
"The reason that it cannot resume when persist fails is that it is unknown if"
" the event was actually persisted or not, and therefore it is in an "
"inconsistent state. Restarting on persistent failures will most likely fail "
"anyway since the journal is probably unavailable. It is better to stop the "
"actor and after a back-off timeout start it again. The "
"``akka.pattern.BackoffSupervisor`` actor is provided to support such "
"restarts."
msgstr ""

# 80ac623da52c429b8a42d9eed2359496
#: ../../java/persistence.rst:376
msgid ""
"Deleting messages in event sourcing based applications is typically either "
"not used at all, or used in conjunction with :ref:`snapshotting "
"<snapshots>`, i.e. after a snapshot has been successfully stored, a "
"``deleteMessages(toSequenceNr)`` up until the sequence number of the data "
"held by that snapshot can be issued to safely delete the previous events "
"while still having access to the accumulated state during replays - by "
"loading the snapshot."
msgstr ""

# f732292502d04103be4bfd5db63254d4
#: ../../java/persistence.rst:384
msgid ""
"Message deletion doesn't affect the highest sequence number of the journal, "
"even if all messages were deleted from it after ``deleteMessages`` "
"invocation."
msgstr ""

# c334395e7ec44a81beb64127846ef1a6
#: ../../java/persistence.rst:388
msgid ""
"Persisting, deleting, and replaying messages can either succeed or fail."
msgstr ""

# d4e9ff9be3bd40e393470f196900ab21
#: ../../java/persistence.rst:407
msgid ""
"For critical failures such as recovery or persisting events failing the "
"persistent actor will be stopped after the failure handler is invoked. This "
"is because if the underlying journal implementation is signalling "
"persistence failures it is most likely either failing completely or "
"overloaded and restarting right-away and trying to persist the event again "
"will most likely not help the journal recover – as it would likely cause a "
"`Thundering herd problem`_, as many persistent actors would restart and try "
"to persist their events again. Instead, using a ``BackoffSupervisor`` (as "
"described in :ref:`failures-java`) which implements an exponential-backoff "
"strategy which allows for more breathing room for the journal to recover "
"between restarts of the persistent actor."
msgstr ""

# 18a57c6e19164168b40c27e76895ffff
#: ../../java/persistence.rst:429
msgid ""
"Special care should be given when shutting down persistent actors from the "
"outside. With normal Actors it is often acceptable to use the special "
":ref:`PoisonPill <poison-pill-java>` message to signal to an Actor that it "
"should stop itself once it receives this message – in fact this message is "
"handled automatically by Akka, leaving the target actor no way to refuse "
"stopping itself when given a poison pill."
msgstr ""

# 9c38656d52724d2393f6bf09b7766aba
#: ../../java/persistence.rst:457
msgid ""
"``UntypedPersistentView`` is deprecated. Use :ref:`persistence-query-java` "
"instead. The corresponding query type is ``EventsByPersistenceId``. There "
"are several alternatives for connecting the ``Source`` to an actor "
"corresponding to a previous ``UntypedPersistentView`` actor:"
msgstr ""

# d2f0c5a4fe064b4a9eadf978a224c228
#: ../../java/persistence.rst:467
msgid ""
"The consuming actor may be a plain ``UntypedActor`` or an "
"``UntypedPersistentActor`` if it needs to store its own state (e.g. "
"fromSequenceNr offset)."
msgstr ""

# a5420413cc12408e8338819a4168bbe2
#: ../../java/persistence.rst:474
msgid ""
"Persistent views can be implemented by extending the "
"``UntypedPersistentView`` trait  and implementing the ``onReceive`` and the "
"``persistenceId`` methods."
msgstr ""

# 5518c2e123c24a64bfa9bedc1703a8cb
#: ../../java/persistence.rst:495
msgid ""
"``UntypedPersistentView`` implementation classes may also override the "
"``autoUpdateInterval`` method to return a custom update interval for a "
"specific view class or view instance. Applications may also trigger "
"additional updates at any time by sending a view an ``Update`` message."
msgstr ""

# fc41af8b97654b79ad4291375dc23a18
#: ../../java/persistence.rst:530
msgid ""
"The ``viewId`` must differ from the referenced ``persistenceId``, unless "
":ref:`snapshots-java` of a view and its persistent actor should be shared "
"(which is what applications usually do not want)."
msgstr ""

# 2dd4b457c9404c32a16b1345a9c81ed3
#: ../../java/persistence.rst:541
msgid ""
"Persistent actors can save snapshots of internal state by calling the  "
"``saveSnapshot`` method. If saving of a snapshot succeeds, the persistent "
"actor receives a ``SaveSnapshotSuccess`` message, otherwise a "
"``SaveSnapshotFailure`` message."
msgstr ""

# d275b0c46e4c49e290300c1dab8fd409
#: ../../java/persistence.rst:567
msgid ""
"Since it is acceptable for some applications to not use any snapshotting, it"
" is legal to not configure a snapshot store. However, Akka will log a "
"warning message when this situation is detected and then continue to operate"
" until an actor tries to store a snapshot, at which point the operation will"
" fail (by replying with an ``SaveSnapshotFailure`` for example)."
msgstr ""

# f45fc309abe247a08b7529b588854a1f
#: ../../java/persistence.rst:601
msgid ""
"To send messages with at-least-once delivery semantics to destinations you "
"can extend the ``UntypedPersistentActorWithAtLeastOnceDelivery`` class "
"instead of ``UntypedPersistentActor`` on the sending side.  It takes care of"
" re-sending messages when they have not been confirmed within a configurable"
" timeout."
msgstr ""

# 97a5f4d6fa184159b694b342982b1a57
#: ../../java/persistence.rst:605
msgid ""
"The state of the sending actor, including which messages have been sent that"
" have not been confirmed by the recipient must be persistent so that it can "
"survive a crash of the sending actor or JVM. The "
"``UntypedPersistentActorWithAtLeastOnceDelivery`` class does not persist "
"anything by itself. It is your responsibility to persist the intent that a "
"message is sent and that a confirmation has been received."
msgstr ""

# 8232ddab759e4bdaaa9c8174a27168a7
#: ../../java/persistence.rst:613
msgid ""
"At-least-once delivery implies that original message sending order is not "
"always preserved, and the destination may receive duplicate messages. "
"Semantics do not match those of a normal :class:`ActorRef` send operation:"
msgstr ""

# c34701169a3d424f9b12eee84141b611
#: ../../java/persistence.rst:647
msgid ""
"Deliver requires a ``deliveryIdToMessage`` function to pass the provided "
"``deliveryId`` into the message so that the correlation between ``deliver`` "
"and ``confirmDelivery`` is possible. The ``deliveryId`` must do the round "
"trip. Upon receipt of the message, the destination actor will send the "
"same``deliveryId`` wrapped in a confirmation message back to the sender. The"
" sender will then use it to call the ``confirmDelivery`` method to complete "
"the delivery routine."
msgstr ""

# 715bbc7ff6254444ad51c751a84ac7ff
#: ../../java/persistence.rst:663
msgid ""
"The ``UntypedPersistentActorWithAtLeastOnceDelivery`` class has a state "
"consisting of unconfirmed messages and a sequence number. It does not store "
"this state itself. You must persist events corresponding to the ``deliver`` "
"and ``confirmDelivery`` invocations from your ``PersistentActor`` so that "
"the state can be restored by calling the same methods during the recovery "
"phase of the ``PersistentActor``. Sometimes these events can be derived from"
" other business level events, and sometimes you must create separate events."
" During recovery, calls to ``deliver`` will not send out messages, those "
"will be sent later if no matching ``confirmDelivery`` will have been "
"performed."
msgstr ""

# 9355e40f80bd4f389b025569e8b8a9f0
#: ../../java/persistence.rst:682
msgid ""
"The maximum number of messages that will be sent at each redelivery burst is"
" defined by the ``redeliveryBurstLimit`` method (burst frequency is half of "
"the redelivery interval). If there's a lot of unconfirmed messages (e.g. if "
"the destination is not available for a long time), this helps to prevent an "
"overwhelming amount of messages to be sent at once. The default value can be"
" configured with the ``akka.persistence.at-least-once-delivery.redelivery-"
"burst-limit`` configuration key. The method can be overridden by "
"implementation classes to return non-default values."
msgstr ""

# 2fdd7b3674944cf98fba7998eba59f3d
#: ../../java/persistence.rst:696
msgid ""
"The ``UntypedPersistentActorWithAtLeastOnceDelivery`` class holds messages "
"in memory until their successful delivery has been confirmed. The maximum "
"number of unconfirmed messages that the actor is allowed to hold in memory "
"is defined by the ``maxUnconfirmedMessages`` method. If this limit is exceed"
" the ``deliver`` method will not accept more messages and it will throw "
"``AtLeastOnceDelivery.MaxUnconfirmedMessagesExceededException``. The default"
" value can be configured with the ``akka.persistence.at-least-once-delivery"
".max-unconfirmed-messages`` configuration key. The method can be overridden "
"by implementation classes to return non-default values."
msgstr ""

# 456a76be75074f40a106de4b1f5f8e64
#: ../../java/persistence.rst:750
msgid ""
"Plugins can be selected either by \"default\", for all persistent actors and"
" views, or \"individually\", when a persistent actor or view defines its own"
" set of plugins."
msgstr ""

# 884975dbbbd848749207deebf2efa69a
#: ../../java/persistence.rst:753
msgid ""
"When a persistent actor or view does NOT override the ``journalPluginId`` "
"and ``snapshotPluginId`` methods, the persistence extension will use the "
"\"default\" journal and snapshot-store plugins configured in the "
"``reference.conf``::"
msgstr ""

# 012b1f3379e541d1a3cbd53cb4903a68
#: ../../java/persistence.rst:759
msgid ""
"However, these entries are provided as empty \"\", and require explicit user"
" configuration via override in the user ``application.conf``. For an example"
" of a journal plugin which writes messages to LevelDB see :ref:`local-"
"leveldb-journal-java`. For an example of a snapshot store plugin which "
"writes snapshots as individual files to the local filesystem see :ref"
":`local-snapshot-store-java`."
msgstr ""

# d6dd02c7f0b54ee48a82061ca7a3722e
#: ../../java/persistence.rst:763
msgid ""
"Applications can provide their own plugins by implementing a plugin API and "
"activating them by configuration. Plugin development requires the following "
"imports:"
msgstr ""

# de23c6efbb3a40129c20006d357f5ee2
# 65717f643b69465f9c053e0bf302c129
#: ../../java/persistence.rst:835 ../../java/persistence-query.rst:265
msgid "Plugin TCK"
msgstr ""

# 3169b5abe28e4917beeb3bba253af85f
#: ../../java/persistence.rst:836
msgid ""
"In order to help developers build correct and high quality storage plugins, "
"we provide a Technology Compatibility Kit (`TCK "
"<http://en.wikipedia.org/wiki/Technology_Compatibility_Kit>`_ for short)."
msgstr ""

# a51cd85dfb2b4bb889a9bc0f3e1b99d2
#: ../../java/persistence.rst:838
msgid ""
"The TCK is usable from Java as well as Scala projects. For Java you need to "
"include the akka-persistence-tck dependency::"
msgstr ""

# f332070a0d654a89a347672076b54c05
#: ../../java/persistence.rst:847
msgid ""
"To include the Journal TCK tests in your test suite simply extend the "
"provided ``JavaJournalSpec``:"
msgstr ""

# aeb0a78b892e4abea0541ed4f8c08dcd
#: ../../java/persistence.rst:851
msgid ""
"Please note that some of the tests are optional, and by overriding the "
"``supports...`` methods you give the TCK the needed information about which "
"tests to run. You can implement these methods using  the provided "
"``CapabilityFlag.on`` / ``CapabilityFlag.off`` values."
msgstr ""

# 514dee14a8be40faba3856af00cc91f6
#: ../../java/persistence.rst:855
msgid ""
"We also provide a simple benchmarking class ``JavaJournalPerfSpec`` which "
"includes all the tests that ``JavaJournalSpec`` has, and also performs some "
"longer operations on the Journal while printing its performance stats. While"
" it is NOT aimed to provide a proper benchmarking environment it can be used"
" to get a rough feel about your journal's performance in the most typical "
"scenarios."
msgstr ""

# 71bcd07d6ab9419fb74e4d934bc74a8a
#: ../../java/persistence.rst:860
msgid ""
"In order to include the ``SnapshotStore`` TCK tests in your test suite "
"simply extend the ``SnapshotStoreSpec``:"
msgstr ""

# 77df18bff4274a3a913b399c36a1bf1a
#: ../../java/persistence.rst:864
msgid ""
"In case your plugin requires some setting up (starting a mock database, "
"removing temporary files etc.) you can override the ``beforeAll`` and "
"``afterAll`` methods to hook into the tests lifecycle:"
msgstr ""

# 63db978c0c0444c3b70c88d64465ad01
#: ../../java/persistence.rst:869
msgid ""
"We *highly recommend* including these specifications in your test suite, as "
"they cover a broad range of cases you might have otherwise forgotten to test"
" for when writing a plugin from scratch."
msgstr ""

# e21e5ec6715d430096cc18c72da8e824
#: ../../java/persistence.rst:898
msgid ""
"The default location of the LevelDB files is a directory named ``journal`` "
"in the current working directory. This location can be changed by "
"configuration where the specified path can be relative or absolute:"
msgstr ""

# 756c1597e09743e99a7a75277dffcd67
#: ../../java/persistence.rst:921
msgid ""
"This plugin has been supplanted by :ref:`Persistence Plugin Proxy"
"<persistence-plugin-proxy-java>`."
msgstr ""

# 63ec5bfb304246daa076bfd471a94e61
#: ../../java/persistence.rst:950
msgid ""
"The local snapshot store plugin config entry is ``akka.persistence.snapshot-"
"store.local``. It writes snapshot files to the local filesystem. Enable this"
" plugin by defining config property:"
msgstr ""

# ffdb43a5719b479ea4eb5213f62c622c
#: ../../java/persistence.rst:1042
msgid ""
"There are several configuration properties for the persistence module, "
"please refer to the :ref:`reference configuration <config-akka-"
"persistence>`."
msgstr ""

# 335179d24e9d4c1bb1395f654e97d42c
#: ../../java/persistence.rst:1048
msgid ""
"By default, a persistent actor or view will use the \"default\" journal and "
"snapshot store plugins configured in the following sections of the "
"``reference.conf`` configuration resource:"
msgstr ""

# c106a9868e0044b6a4aa3f230eea52e8
#: ../../java/persistence.rst:1057
msgid ""
"When a persistent actor or view overrides the ``journalPluginId`` and "
"``snapshotPluginId`` methods, the actor or view will be serviced by these "
"specific persistence plugins instead of the defaults:"
msgstr ""

# 6d1ebf9348944e97bb98ad34a24ba652
#: ../../java/persistence-query.rst:5
msgid "Persistence Query"
msgstr ""

# 4da6fe9e0ea3442a924c516f40d28291
#: ../../java/persistence-query.rst:7
msgid ""
"Akka persistence query complements :ref:`persistence-java` by providing a "
"universal asynchronous stream based query interface that various journal "
"plugins can implement in order to expose their query capabilities."
msgstr ""

# 0dd0c89ea2a74814ae884e7ac38161e4
#: ../../java/persistence-query.rst:10
msgid ""
"The most typical use case of persistence query is implementing the so-called"
" query side (also known as \"read side\") in the popular CQRS architecture "
"pattern - in which the writing side of the application (e.g. implemented "
"using akka persistence) is completely separated from the \"query side\". "
"Akka Persistence Query itself is *not* directly the query side of an "
"application, however it can help to migrate data from the write side to the "
"query side database. In very simple scenarios Persistence Query may be "
"powerful enough to fulfill the query needs of your app, however we highly "
"recommend (in the spirit of CQRS) of splitting up the write/read sides into "
"separate datastores as the need arises."
msgstr ""

# c905d87c50bf47039827e9e1061633f6
# 1eb3576b16a6432d81e82810d2ce9ce3
#: ../../java/persistence-query.rst:19
#: ../../java/persistence-query-leveldb.rst:12
msgid ""
"This module is marked as **“experimental”** as of its introduction in Akka "
"2.4.0. We will continue to improve this API based on our users’ feedback, "
"which implies that while we try to keep incompatible changes to a minimum "
"the binary compatibility guarantee for maintenance releases does not apply "
"to the contents of the ``akka.persistence.query`` package."
msgstr ""

# 52c4e829733e4337a61a2ba322ad1d07
#: ../../java/persistence-query.rst:27
msgid ""
"Akka persistence query is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

# a12ede48ac5e4dd3b9b289fdd40038d6
#: ../../java/persistence-query.rst:36
msgid "Design overview"
msgstr ""

# a8c74ec84c2544dd8dacb32dce26e038
#: ../../java/persistence-query.rst:38
msgid ""
"Akka persistence query is purposely designed to be a very loosely specified "
"API. This is in order to keep the provided APIs general enough for each "
"journal implementation to be able to expose its best features, e.g. a SQL "
"journal can use complex SQL queries or if a journal is able to subscribe to "
"a live event stream this should also be possible to expose the same API - a "
"typed stream of events."
msgstr ""

# a7977d37e8554edf97ef119fea0b7126
#: ../../java/persistence-query.rst:43
msgid ""
"**Each read journal must explicitly document which types of queries it "
"supports.** Refer to your journal's plugins documentation for details on "
"which queries and semantics it supports."
msgstr ""

# 6cf2dde0688d4f92b3966d30d8c83b1e
#: ../../java/persistence-query.rst:46
msgid ""
"While Akka Persistence Query does not provide actual implementations of "
"ReadJournals, it defines a number of pre-defined query types for the most "
"common query scenarios, that most journals are likely to implement (however "
"they are not required to)."
msgstr ""

# 9addf03b0c4c407d8baa66099a761869
#: ../../java/persistence-query.rst:50
msgid "Read Journals"
msgstr ""

# 8361aea9b1394a438238379485fbcbf4
#: ../../java/persistence-query.rst:52
msgid ""
"In order to issue queries one has to first obtain an instance of a "
"``ReadJournal``. Read journals are implemented as `Community plugins`_, each"
" targeting a specific datastore (for example Cassandra or JDBC databases). "
"For example, given a library that provides a ``akka.persistence.query.my-"
"read-journal`` obtaining the related journal is as simple as:"
msgstr ""

# 8cd2afdf8a3f4838a335b61cbb599795
#: ../../java/persistence-query.rst:59
msgid ""
"Journal implementers are encouraged to put this identifier in a variable "
"known to the user, such that one can access it via "
"``getJournalFor(NoopJournal.class, NoopJournal.identifier)``, however this "
"is not enforced."
msgstr ""

# 4cfe4006e4cb487d95089a8572272203
#: ../../java/persistence-query.rst:62
msgid "Read journal implementations are available as `Community plugins`_."
msgstr ""

# a4cc03744c864df0a0bbd523237297c1
#: ../../java/persistence-query.rst:66
msgid "Predefined queries"
msgstr ""

# 011e70118249411ab3f624faa96c9625
#: ../../java/persistence-query.rst:67
msgid ""
"Akka persistence query comes with a number of query interfaces built in and "
"suggests Journal implementors to implement them according to the semantics "
"described below. It is important to notice that while these query types are "
"very common a journal is not obliged to implement all of them - for example "
"because in a given journal such query would be significantly inefficient."
msgstr ""

# c080467039724af5813a83178cd85da5
#: ../../java/persistence-query.rst:73
msgid ""
"Refer to the documentation of the :class:`ReadJournal` plugin you are using "
"for a specific list of supported query types. For example, Journal plugins "
"should document their stream completion strategies."
msgstr ""

# cb33173e282b455481d285503df1f067
#: ../../java/persistence-query.rst:76
msgid "The predefined queries are:"
msgstr ""

# 7564108d22374eaebce52a2a01d95e51
# df1178bf03ba4ae79775e36ae1021228
#: ../../java/persistence-query.rst:79
#: ../../java/persistence-query-leveldb.rst:72
msgid "AllPersistenceIdsQuery and CurrentPersistenceIdsQuery"
msgstr ""

# 0abbae2dc6714aaca9c2de633bc85f5f
#: ../../java/persistence-query.rst:81
msgid ""
"``allPersistenceIds`` which is designed to allow users to subscribe to a "
"stream of all persistent ids in the system. By default this stream should be"
" assumed to be a \"live\" stream, which means that the journal should keep "
"emitting new persistence ids as they come into the system:"
msgstr ""

# 76035b8c676247f9a21165b9d90858e1
#: ../../java/persistence-query.rst:87
msgid ""
"If your usage does not require a live stream, you can use the "
"``currentPersistenceIds`` query:"
msgstr ""

# ce1cf39a59ba4af2a08ef5406b92f6dd
# 965346e5042649019b95a3e693dcd492
#: ../../java/persistence-query.rst:92
#: ../../java/persistence-query-leveldb.rst:42
msgid "EventsByPersistenceIdQuery and CurrentEventsByPersistenceIdQuery"
msgstr ""

# c5863d0f9e4847519e58e96cbb8f6d15
#: ../../java/persistence-query.rst:94
msgid ""
"``eventsByPersistenceId``  is a query equivalent to replaying a "
":ref:`PersistentActor <event-sourcing-java>`, however, since it is a stream "
"it is possible to keep it alive and watch for additional incoming events "
"persisted by the persistent actor identified by the given ``persistenceId``."
msgstr ""

# 97af44b76fa14e15885a6998897e3b81
#: ../../java/persistence-query.rst:100
msgid ""
"Most journals will have to revert to polling in order to achieve this, which"
" can typically be configured with a ``refresh-interval`` configuration "
"property."
msgstr ""

# 3adbea795bd048de92c88af99259065f
#: ../../java/persistence-query.rst:103
msgid ""
"If your usage does not require a live stream, you can use the "
"``currentEventsByPersistenceId`` query."
msgstr ""

# 3b53a6352d1647bfa1d62c4c4904123a
# 224b95f6191a4d118ec399fcb3c06be1
#: ../../java/persistence-query.rst:106
#: ../../java/persistence-query-leveldb.rst:93
msgid "EventsByTag and CurrentEventsByTag"
msgstr ""

# e0920c7f42c34c929e9a4e28da6215a9
#: ../../java/persistence-query.rst:108
msgid ""
"``eventsByTag`` allows querying events regardless of which ``persistenceId``"
" they are associated with. This query is hard to implement in some journals "
"or may need some additional preparation of the used data store to be "
"executed efficiently. The goal of this query is to allow querying for all "
"events which are \"tagged\" with a specific tag. That includes the use case "
"to query all domain events of an Aggregate Root type. Please refer to your "
"read journal plugin's documentation to find out if and how it is supported."
msgstr ""

# eeb7c92bd4af4b2b9bff296295ed9bb6
#: ../../java/persistence-query.rst:114
msgid ""
"Some journals may support tagging of events via an :ref:`event-adapters-"
"java` that wraps the events in a ``akka.persistence.journal.Tagged`` with "
"the given ``tags``. The journal may support other ways of doing tagging - "
"again, how exactly this is implemented depends on the used journal. Here is "
"an example of such a tagging event adapter:"
msgstr ""

# ca304250b46343c6adf89f8610a48258
#: ../../java/persistence-query.rst:121
msgid ""
"A very important thing to keep in mind when using queries spanning multiple "
"persistenceIds, such as ``EventsByTag`` is that the order of events at which"
" the events appear in the stream rarely is guaranteed (or stable between "
"materializations)."
msgstr ""

# cd6e8cd3419f4307b029d1cf0528b72d
#: ../../java/persistence-query.rst:124
msgid ""
"Journals *may* choose to opt for strict ordering of the events, and should "
"then document explicitly what kind of ordering guarantee they provide - for "
"example \"*ordered by timestamp ascending, independently of persistenceId*\""
" is easy to achieve on relational databases, yet may be hard to implement "
"efficiently on plain key-value datastores."
msgstr ""

# 86597af06f6e4646988e25f43900dfe3
#: ../../java/persistence-query.rst:128
msgid ""
"In the example below we query all events which have been tagged (we assume "
"this was performed by the write-side using an :ref:`EventAdapter <event-"
"adapters-java>`, or that the journal is smart enough that it can figure out "
"what we mean by this tag - for example if the journal stored the events as "
"json it may try to find those with the field ``tag`` set to this value "
"etc.)."
msgstr ""

# 4739fd8c221c49cd9912a2af79b5d6ee
#: ../../java/persistence-query.rst:134
msgid ""
"As you can see, we can use all the usual stream combinators available from "
"`Akka Streams`_ on the resulting query stream, including for example taking "
"the first 10 and cancelling the stream. It is worth pointing out that the "
"built-in ``EventsByTag`` query has an optionally supported offset parameter "
"(of type ``Long``) which the journals can use to implement resumable-"
"streams. For example a journal may be able to use a WHERE clause to begin "
"the read starting from a specific row, or in a datastore that is able to "
"order events by insertion time it could treat the Long as a timestamp and "
"select only older events."
msgstr ""

# 36bc37e6f74b4cbd9a2ebe516767076f
#: ../../java/persistence-query.rst:140
msgid ""
"If your usage does not require a live stream, you can use the "
"``currentEventsByTag`` query."
msgstr ""

# d435a88905ca4cd08619bf180c79f972
#: ../../java/persistence-query.rst:143
msgid "Materialized values of queries"
msgstr ""

# 197a613bf7414bf3b67262a49e8a69b3
#: ../../java/persistence-query.rst:144
msgid ""
"Journals are able to provide additional information related to a query by "
"exposing `materialized values`_, which are a feature of `Akka Streams`_ that"
" allows to expose additional values at stream materialization time."
msgstr ""

# 988741601ae340a89a68191d7beeb44c
#: ../../java/persistence-query.rst:147
msgid ""
"More advanced query journals may use this technique to expose information "
"about the character of the materialized stream, for example if it's finite "
"or infinite, strictly ordered or not ordered at all. The materialized value "
"type is defined as the second type parameter of the returned ``Source``, "
"which allows journals to provide users with their specialised query object, "
"as demonstrated in the sample below:"
msgstr ""

# 6e8877902b914fcba87793c38600f732
#: ../../java/persistence-query.rst:163
msgid "Performance and denormalization"
msgstr ""

# 06cec9f6621b4bb1a0b4e0e9247218a3
#: ../../java/persistence-query.rst:164
msgid ""
"When building systems using :ref:`event-sourcing-java` and CQRS (`Command & "
"Query Responsibility Segregation`_) techniques it is tremendously important "
"to realise that the write-side has completely different needs from the read-"
"side, and separating those concerns into datastores that are optimised for "
"either side makes it possible to offer the best experience for the write and"
" read sides independently."
msgstr ""

# f68da816b5264852ad107bbfa48df565
#: ../../java/persistence-query.rst:169
msgid ""
"For example, in a bidding system it is important to \"take the write\" and "
"respond to the bidder that we have accepted the bid as soon as possible, "
"which means that write-throughput is of highest importance for the write-"
"side – often this means that data stores which are able to scale to "
"accommodate these requirements have a less expressive query side."
msgstr ""

# c7ac716adc0b4e52844b7da1ca0a4d45
#: ../../java/persistence-query.rst:173
msgid ""
"On the other hand the same application may have some complex statistics view"
" or we may have analysts working with the data to figure out best bidding "
"strategies and trends – this often requires some kind of expressive query "
"capabilities like for example SQL or writing Spark jobs to analyse the data."
" Therefore the data stored in the write-side needs to be projected into the "
"other read-optimised datastore."
msgstr ""

# 211ada69dabb48ea83285c940441a646
#: ../../java/persistence-query.rst:179
msgid ""
"When referring to **Materialized Views** in Akka Persistence think of it as "
"\"some persistent storage of the result of a Query\". In other words, it "
"means that the view is created once, in order to be afterwards queried "
"multiple times, as in this format it may be more efficient or interesting to"
" query it (instead of the source events directly)."
msgstr ""

# 45da6877c2da4a8b914fd8376828d7f7
#: ../../java/persistence-query.rst:184
msgid "Materialize view to Reactive Streams compatible datastore"
msgstr ""

# a6c5d2517cf645db9a0e597fde765fa1
#: ../../java/persistence-query.rst:186
msgid ""
"If the read datastore exposes a `Reactive Streams`_ interface then "
"implementing a simple projection is as simple as, using the read-journal and"
" feeding it into the databases driver interface, for example like so:"
msgstr ""

# 703b6e0af8b24ef98e6ca783e7b56b41
#: ../../java/persistence-query.rst:194
msgid "Materialize view using mapAsync"
msgstr ""

# 9e99041750f54084904ad2f110b87f36
#: ../../java/persistence-query.rst:196
msgid ""
"If the target database does not provide a reactive streams ``Subscriber`` "
"that can perform writes, you may have to implement the write logic using "
"plain functions or Actors instead."
msgstr ""

# 990fdb6e44e748ae9f27b372847c30d1
#: ../../java/persistence-query.rst:199
msgid ""
"In case your write logic is state-less and you just need to convert the "
"events from one data type to another before writing into the alternative "
"datastore, then the projection is as simple as:"
msgstr ""

# 0239c65810224759a3ce366b70249792
#: ../../java/persistence-query.rst:206
msgid "Resumable projections"
msgstr ""

# 31a0b210000a4b218d7a65c592205872
#: ../../java/persistence-query.rst:208
msgid ""
"Sometimes you may need to implement \"resumable\" projections, that will not"
" start from the beginning of time each time when run. In this case you will "
"need to store the sequence number (or ``offset``) of the processed event and"
" use it the next time this projection is started. This pattern is not built-"
"in, however is rather simple to implement yourself."
msgstr ""

# 76028836915f4cd288f38d98b2ad38eb
#: ../../java/persistence-query.rst:212
msgid ""
"The example below additionally highlights how you would use Actors to "
"implement the write side, in case you need to do some complex logic that "
"would be best handled inside an Actor before persisting the event into the "
"other datastore:"
msgstr ""

# f0e6f9fca62b49f99f3a9c2322522a91
#: ../../java/persistence-query.rst:225
msgid "Query plugins"
msgstr ""

# c2572a7e616747709f4504f8dcf4f446
#: ../../java/persistence-query.rst:227
msgid ""
"Query plugins are various (mostly community driven) :class:`ReadJournal` "
"implementations for all kinds of available datastores. The complete list of "
"available plugins is maintained on the Akka Persistence Query `Community "
"Plugins`_ page."
msgstr ""

# 74e89f65cab84600b90f72d0c6a7de84
#: ../../java/persistence-query.rst:230
msgid ""
"The plugin for LevelDB is described in :ref:`persistence-query-leveldb-"
"java`."
msgstr ""

# 10f6929f43324c8abd3a2617ee9508f7
#: ../../java/persistence-query.rst:232
msgid ""
"This section aims to provide tips and guide plugin developers through "
"implementing a custom query plugin. Most users will not need to implement "
"journals themselves, except if targeting a not yet supported datastore."
msgstr ""

# 2335bfb068e34f6aabcde0a6d2fde70d
#: ../../java/persistence-query.rst:236
msgid ""
"Since different data stores provide different query capabilities journal "
"plugins **must extensively document** their exposed semantics as well as "
"handled query scenarios."
msgstr ""

# fe09118b54b6408c9c50ecc5c79cad7e
#: ../../java/persistence-query.rst:240
msgid "ReadJournal plugin API"
msgstr ""

# c4ab1235fe0e41ae9c8c4f679a526fda
#: ../../java/persistence-query.rst:242
msgid ""
"A read journal plugin must implement "
"``akka.persistence.query.ReadJournalProvider`` which creates instances of "
"``akka.persistence.query.scaladsl.ReadJournal`` and "
"``akka.persistence.query.javaadsl.ReadJournal``. The plugin must implement "
"both the ``scaladsl`` and the ``javadsl`` interfaces because the "
"``akka.stream.scaladsl.Source`` and ``akka.stream.javadsl.Source`` are "
"different types and even though those types can easily be converted to each "
"other it is most convenient for the end user to get access to the Java or "
"Scala ``Source`` directly. As illustrated below one of the implementations "
"can delegate to the other."
msgstr ""

# 724f02bb7e514dac87388b25e6d8fae0
#: ../../java/persistence-query.rst:250
msgid "Below is a simple journal implementation:"
msgstr ""

# a9fdc318011c4e27895024f3c34d8956
#: ../../java/persistence-query.rst:254
msgid "And the ``EventsByTag`` could be backed by such an Actor for example:"
msgstr ""

# b6a661584cb24a08b6256d97f6c3f2a7
#: ../../java/persistence-query.rst:258
msgid ""
"If the underlying datastore only supports queries that are completed when "
"they reach the end of the \"result set\", the journal has to submit new "
"queries after a while in order to support \"infinite\" event streams that "
"include events stored after the initial query has completed. It is "
"recommended that the plugin use a configuration property named ``refresh-"
"interval`` for defining such a refresh interval."
msgstr ""

# 2ed08c258d504f9bbbe35afd0292f172
#: ../../java/persistence-query.rst:267
msgid "TODO, not available yet."
msgstr ""

# 10c13c56ad0343b1a34a21d738ddff9f
#: ../../java/persistence-query-leveldb.rst:5
msgid "Persistence Query for LevelDB"
msgstr ""

# 1e2ddf32b8ee457daa950d45e3bbec82
#: ../../java/persistence-query-leveldb.rst:7
msgid ""
"This is documentation for the LevelDB implementation of the :ref"
":`persistence-query-java` API. Note that implementations for other journals "
"may have different semantics."
msgstr ""

# 9186ff9220054dfc9dab3323d01719c4
#: ../../java/persistence-query-leveldb.rst:20
msgid ""
"Akka persistence LevelDB query implementation is bundled in the ``akka-"
"persistence-query-experimental`` artifact. Make sure that you have the "
"following dependency in your project::"
msgstr ""

# 3e936e5152bd43539fbd4d7e1d32f628
#: ../../java/persistence-query-leveldb.rst:31
msgid "How to get the ReadJournal"
msgstr ""

# 70cc4ba3b7254a9ea86a5eb90d123f4f
#: ../../java/persistence-query-leveldb.rst:33
msgid ""
"The ``ReadJournal`` is retrieved via the "
"``akka.persistence.query.PersistenceQuery`` extension:"
msgstr ""

# 36db3a339ca144c79509f20902581b2d
#: ../../java/persistence-query-leveldb.rst:39
msgid "Supported Queries"
msgstr ""

# f471483ea0f1468ca958aa745e6c339b
#: ../../java/persistence-query-leveldb.rst:44
msgid ""
"``eventsByPersistenceId`` is used for retrieving events for a specific "
"``PersistentActor`` identified by ``persistenceId``."
msgstr ""

# fd064ad530f94f34a48bbe1adcf821e4
#: ../../java/persistence-query-leveldb.rst:49
msgid ""
"You can retrieve a subset of all events by specifying ``fromSequenceNr`` and"
" ``toSequenceNr`` or use ``0L`` and ``Long.MAX_VALUE`` respectively to "
"retrieve all events. Note that the corresponding sequence number of each "
"event is provided in the ``EventEnvelope``, which makes it possible to "
"resume the stream at a later point from a given sequence number."
msgstr ""

# 0a2002ae3f4b4ecab034a5cb7bfc8826
#: ../../java/persistence-query-leveldb.rst:54
msgid ""
"The returned event stream is ordered by sequence number, i.e. the same order"
" as the ``PersistentActor`` persisted the events. The same prefix of stream "
"elements (in same order) are returned for multiple executions of the query, "
"except for when events have been deleted."
msgstr ""

# 1a66191ec67744d1a33b39ceddfa8607
#: ../../java/persistence-query-leveldb.rst:58
msgid ""
"The stream is not completed when it reaches the end of the currently stored "
"events, but it continues to push new events when new events are persisted. "
"Corresponding query that is completed when it reaches the end of the "
"currently stored events is provided by ``currentEventsByPersistenceId``."
msgstr ""

# a76c26fe96114082ac9a011e719bd454
#: ../../java/persistence-query-leveldb.rst:63
msgid ""
"The LevelDB write journal is notifying the query side as soon as events are "
"persisted, but for efficiency reasons the query side retrieves the events in"
" batches that sometimes can be delayed up to the configured ``refresh-"
"interval`` or given ``RefreshInterval`` hint."
msgstr ""

# 2a23bf323b884dfea52eee93b644378b
# 7235279b19c14338a3296801d430222c
# 1a94db8eeb0c4ef6848621795ce0ddc7
#: ../../java/persistence-query-leveldb.rst:68
#: ../../java/persistence-query-leveldb.rst:89
#: ../../java/persistence-query-leveldb.rst:134
msgid ""
"The stream is completed with failure if there is a failure in executing the "
"query in the backend journal."
msgstr ""

# 04e19d1bc85e4597b1e7b6034b5a3183
#: ../../java/persistence-query-leveldb.rst:74
msgid ""
"``allPersistenceIds`` is used for retrieving all ``persistenceIds`` of all "
"persistent actors."
msgstr ""

# aac7c34bb096411cb27b80850bcf3602
#: ../../java/persistence-query-leveldb.rst:78
msgid ""
"The returned event stream is unordered and you can expect different order "
"for multiple executions of the query."
msgstr ""

# 4a97e23b022345429b0001f4b2e8b84e
#: ../../java/persistence-query-leveldb.rst:81
msgid ""
"The stream is not completed when it reaches the end of the currently used "
"`persistenceIds`, but it continues to push new `persistenceIds` when new "
"persistent actors are created. Corresponding query that is completed when it"
" reaches the end of the currently used `persistenceIds` is provided by "
"``currentPersistenceIds``."
msgstr ""

# aebe2924fcbe45cc9b6639064b7b43cf
#: ../../java/persistence-query-leveldb.rst:86
msgid ""
"The LevelDB write journal is notifying the query side as soon as new "
"``persistenceIds`` are created and there is no periodic polling or batching "
"involved in this query."
msgstr ""

# 30f82f0630d64561a41ef88428f21b4f
#: ../../java/persistence-query-leveldb.rst:95
msgid ""
"``eventsByTag`` is used for retrieving events that were marked with a given "
"tag, e.g. all domain events of an Aggregate Root type."
msgstr ""

# 4a7f9f3f3b6b4a38b6ca06e9f22f601d
#: ../../java/persistence-query-leveldb.rst:100
msgid ""
"To tag events you create an :ref:`event-adapters-java` that wraps the events"
" in a ``akka.persistence.journal.Tagged`` with the given ``tags``."
msgstr ""

# d632f7609124424d94c3fd41a775435e
#: ../../java/persistence-query-leveldb.rst:105
msgid ""
"You can retrieve a subset of all events by specifying ``offset``, or use "
"``0L`` to retrieve all events with a given tag. The ``offset`` corresponds "
"to an ordered sequence number for the specific tag. Note that the "
"corresponding offset of each event is provided in the ``EventEnvelope``, "
"which makes it possible to resume the stream at a later point from a given "
"offset."
msgstr ""

# 1ecf367b7c7240a599a78fa518dbbf1b
#: ../../java/persistence-query-leveldb.rst:110
msgid ""
"In addition to the ``offset`` the ``EventEnvelope`` also provides "
"``persistenceId`` and ``sequenceNr`` for each event. The ``sequenceNr`` is "
"the sequence number for the persistent actor with the ``persistenceId`` that"
" persisted the event. The ``persistenceId`` + ``sequenceNr`` is an unique "
"identifier for the event."
msgstr ""

# 4eda068ce96d4fc2bc28c04a98fd6be1
#: ../../java/persistence-query-leveldb.rst:115
msgid ""
"The returned event stream is ordered by the offset (tag sequence number), "
"which corresponds to the same order as the write journal stored the events. "
"The same stream elements (in same order) are returned for multiple "
"executions of the query. Deleted events are not deleted from the tagged "
"event stream."
msgstr ""

# 518a3628d1a748be814bbcc2ce9e831c
#: ../../java/persistence-query-leveldb.rst:122
msgid ""
"Events deleted using ``deleteMessages(toSequenceNr)`` are not deleted from "
"the \"tagged stream\"."
msgstr ""

# a4993a236cf042ac8fa58fb8f7290b01
#: ../../java/persistence-query-leveldb.rst:124
msgid ""
"The stream is not completed when it reaches the end of the currently stored "
"events, but it continues to push new events when new events are persisted. "
"Corresponding query that is completed when it reaches the end of the "
"currently stored events is provided by ``currentEventsByTag``."
msgstr ""

# a42d8590b5274b9d87b90cf89c30d6ac
#: ../../java/persistence-query-leveldb.rst:129
msgid ""
"The LevelDB write journal is notifying the query side as soon as tagged "
"events are persisted, but for efficiency reasons the query side retrieves "
"the events in batches that sometimes can be delayed up to the configured "
"``refresh-interval`` or given ``RefreshInterval`` hint."
msgstr ""

# 1480b2aa861243d888561e3a8f3af54d
#: ../../java/persistence-query-leveldb.rst:140
msgid ""
"Configuration settings can be defined in the configuration section with the "
"absolute path corresponding to the identifier, which is "
"``\"akka.persistence.query.journal.leveldb\"`` for the default "
"``LeveldbReadJournal.Identifier``."
msgstr ""

# fb7e5f4bd4fb4151bdfee0b1141a2f72
#: ../../java/persistence-query-leveldb.rst:144
msgid "It can be configured with the following properties:"
msgstr ""

# 36a66cb1e2c7485dbb6f06115f840ae1
#: ../../java/persistence-schema-evolution.rst:5
msgid "Persistence - Schema Evolution"
msgstr ""

# d15149bff75f46af9f03fb384d447db7
#: ../../java/persistence-schema-evolution.rst:7
msgid ""
"When working on long running projects using :ref:`persistence-java`, or any "
"kind of `Event Sourcing`_ architectures, schema evolution becomes one of the"
" more important technical aspects of developing your application. The "
"requirements as well as our own understanding of the business domain may "
"(and will) change in time."
msgstr ""

# 6983eca9d2aa4ec8893c609cec240c03
#: ../../java/persistence-schema-evolution.rst:11
msgid ""
"In fact, if a project matures to the point where you need to evolve its "
"schema to adapt to changing business requirements you can view this as first"
" signs of its success – if you wouldn't need to adapt anything over an apps "
"lifecycle that could mean that no-one is really using it actively."
msgstr ""

# 330be9c3fd3f4b5691bb3ad4da17a639
#: ../../java/persistence-schema-evolution.rst:15
msgid ""
"In this chapter we will investigate various schema evolution strategies and "
"techniques from which you can pick and choose the ones that match your "
"domain and challenge at hand."
msgstr ""

# 4e266138f03347cf9167b0e540a50e7e
#: ../../java/persistence-schema-evolution.rst:19
msgid ""
"This page proposes a number of possible solutions to the schema evolution "
"problem and explains how some of the utilities Akka provides can be used to "
"achieve this, it is by no means a complete (closed) set of solutions."
msgstr ""

# 969e18f727f643e5b400a7df365d7dca
#: ../../java/persistence-schema-evolution.rst:22
msgid ""
"Sometimes, based on the capabilities of your serialization formats, you may "
"be able to evolve your schema in different ways than outlined in the "
"sections below. If you discover useful patterns or techniques for schema "
"evolution feel free to submit Pull Requests to this page to extend it."
msgstr ""

# f01ed2a19a024dbd86111726b68695ff
#: ../../java/persistence-schema-evolution.rst:28
msgid "Schema evolution in event-sourced systems"
msgstr ""

# 5e1fb2969000436ea6a97927d8486509
#: ../../java/persistence-schema-evolution.rst:30
msgid ""
"In recent years we have observed a tremendous move towards immutable append-"
"only datastores, with event-sourcing being the prime technique successfully "
"being used in these settings. For an excellent overview why and how "
"immutable data makes scalability and systems design much simpler you may "
"want to read Pat Helland's excellent `Immutability Changes Everything`_ "
"whitepaper."
msgstr ""

# 04cf188e6f73432d93252eb7efd70857
#: ../../java/persistence-schema-evolution.rst:34
msgid ""
"Since with `Event Sourcing`_ the **events are immutable** and usually never "
"deleted – the way schema evolution is handled differs from how one would go "
"about it in a mutable database setting (e.g. in typical CRUD database "
"applications)."
msgstr ""

# d8ee3ec3a36a47d1acbeb7e473a1dd0d
#: ../../java/persistence-schema-evolution.rst:37
msgid ""
"The system needs to be able to continue to work in the presence of \"old\" "
"events which were stored under the \"old\" schema. We also want to limit "
"complexity in the business logic layer, exposing a consistent view over all "
"of the events of a given type to :class:`PersistentActor` s and "
":ref:`persistence queries <persistence-query-java>`. This allows the "
"business logic layer to focus on solving business problems instead of having"
" to explicitly deal with different schemas."
msgstr ""

# 80dc142b0add4745a090ac819bf9c1dd
#: ../../java/persistence-schema-evolution.rst:44
msgid ""
"Allow the system to continue operating without large scale migrations to be "
"applied,"
msgstr ""

# ea31c8dbdb4843c0bd3394db943c26a1
#: ../../java/persistence-schema-evolution.rst:45
msgid ""
"Allow the system to read \"old\" events from the underlying storage, however"
" present them in a \"new\" view to the application logic,"
msgstr ""

# 24a278cba3064cca9a86ae769c7397e4
#: ../../java/persistence-schema-evolution.rst:46
msgid ""
"Transparently promote events to the latest versions during recovery (or "
"queries) such that the business logic need not consider multiple versions of"
" events"
msgstr ""

# a6844dac206441bdb30508116385e7ef
#: ../../java/persistence-schema-evolution.rst:52
msgid "Types of schema evolution"
msgstr ""

# 897b6d6dc3f1499fa1e8abe851254ab4
#: ../../java/persistence-schema-evolution.rst:53
msgid ""
"Before we explain the various techniques that can be used to safely evolve "
"the schema of your persistent events over time, we first need to define what"
" the actual problem is, and what the typical styles of changes are."
msgstr ""

# 4c7cdf611c1e4a56842b11432211bdd7
#: ../../java/persistence-schema-evolution.rst:56
msgid ""
"Since events are never deleted, we need to have a way to be able to replay "
"(read) old events, in such way that does not force the ``PersistentActor`` "
"to be aware of all possible versions of an event that it may have persisted "
"in the past. Instead, we want the Actors to work on some form of \"latest\" "
"version of the event and provide some means of either converting old "
"\"versions\" of stored events into this \"latest\" event type, or constantly"
" evolve the event definition - in a backwards compatible way - such that the"
" new deserialization code can still read old events."
msgstr ""

# e07bd55c801b4ecb88dbd93caecca009
#: ../../java/persistence-schema-evolution.rst:62
msgid "The most common schema changes you will likely are:"
msgstr ""

# be16c4b06cc942cb940a5755123d0223
#: ../../java/persistence-schema-evolution.rst:64
msgid ":ref:`adding a field to an event type <add-field-java>`,"
msgstr ""

# 0570548d9b704846ad0ba244200ac1a3
#: ../../java/persistence-schema-evolution.rst:65
msgid ":ref:`remove or rename field in event type <rename-field-java>`,"
msgstr ""

# bd960f03f6e047fab1746bf21ac37f3f
#: ../../java/persistence-schema-evolution.rst:66
msgid ":ref:`remove event type <remove-event-class-java>`,"
msgstr ""

# c8e696a015be4fc09db5031f924f4b62
#: ../../java/persistence-schema-evolution.rst:67
msgid ""
":ref:`split event into multiple smaller events <split-large-event-into-"
"smaller-java>`."
msgstr ""

# db2ddf897216478889eb598f0d45e793
#: ../../java/persistence-schema-evolution.rst:69
msgid ""
"The following sections will explain some patterns which can be used to "
"safely evolve your schema when facing those changes."
msgstr ""

# 015ab48fc0864c9995de3a50d5f7b962
#: ../../java/persistence-schema-evolution.rst:72
msgid "Picking the right serialization format"
msgstr ""

# 42eb2ff2dca54840bc866e11e49c6bc9
#: ../../java/persistence-schema-evolution.rst:74
msgid ""
"Picking the serialization format is a very important decision you will have "
"to make while building your application. It affects which kind of evolutions"
" are simple (or hard) to do, how much work is required to add a new "
"datatype, and, last but not least, serialization performance."
msgstr ""

# 23c0193af9d24bfead3b5b213b864c3f
#: ../../java/persistence-schema-evolution.rst:78
msgid ""
"If you find yourself realising you have picked \"the wrong\" serialization "
"format, it is always possible to change the format used for storing new "
"events, however you would have to keep the old deserialization code in order"
" to be able to replay events that were persisted using the old serialization"
" scheme. It is possible to \"rebuild\" an event-log from one serialization "
"format to another one, however it may be a more involved process if you need"
" to perform this on a live system."
msgstr ""

# cd1e7b580b13470fbe809973fdd3f36a
#: ../../java/persistence-schema-evolution.rst:84
msgid ""
"Binary serialization formats that we have seen work well for long-lived "
"applications include the very flexible IDL based: `Google Protobuf`_, "
"`Apache Thrift`_ or `Apache Avro`_. Avro schema evolution is more \"entire "
"schema\" based, instead of single fields focused like in protobuf or thrift,"
" and usually requires using some kind of schema registry."
msgstr ""

# 76496cf5ddc94f41840f94e0c2cf860a
#: ../../java/persistence-schema-evolution.rst:88
msgid ""
"Users who want their data to be human-readable directly in the write-side "
"datastore may opt to use plain-old `JSON`_ as the storage format, though "
"that comes at a cost of lacking support for schema evolution and relatively "
"large marshalling latency."
msgstr ""

# b1e7852d6926442d8ed47e12f43f7250
#: ../../java/persistence-schema-evolution.rst:92
msgid ""
"There are plenty excellent blog posts explaining the various trade-offs "
"between popular serialization formats, one post we would like to highlight "
"is the very well illustrated `Schema evolution in Avro, Protocol Buffers and"
" Thrift`_ by Martin Kleppmann."
msgstr ""

# 177ab694f14d41f6b50fe826e74d2e43
#: ../../java/persistence-schema-evolution.rst:102
msgid "Provided default serializers"
msgstr ""

# 11500e35b62b44ac9467cd5d4a652543
#: ../../java/persistence-schema-evolution.rst:104
msgid ""
"Akka Persistence provides `Google Protocol Buffers`_ based serializers "
"(using :ref:`Akka Serialization <serialization-java>`) for it's own message "
"types such as ``PersistentRepr``, ``AtomicWrite`` and snapshots. Journal "
"plugin implementations *may* choose to use those provided serializers, or "
"pick a serializer which suits the underlying database better."
msgstr ""

# 6bf1faa27d9448e4b124bcdbccb43711
#: ../../java/persistence-schema-evolution.rst:109
msgid ""
"Serialization is **NOT** handled automatically by Akka Persistence itself. "
"Instead, it only provides the above described serializers, and in case a "
"``AsyncWriteJournal`` plugin implementation chooses to use them directly, "
"the above serialization scheme will be used."
msgstr ""

# 54605c3198f54ccc8e0ce251f8f42358
#: ../../java/persistence-schema-evolution.rst:113
msgid ""
"Please refer to your write journal's documentation to learn more about how "
"it handles serialization!"
msgstr ""

# ba8ed4b6ab7b4f8a977622821e5b820b
#: ../../java/persistence-schema-evolution.rst:115
msgid ""
"For example, some journals may choose to not use Akka Serialization *at all*"
" and instead store the data in a format that is more \"native\" for the "
"underlying datastore, e.g. using JSON or some other kind of format that the "
"target datastore understands directly."
msgstr ""

# 3f6bec8d265343e38f0ca770e6c2b499
#: ../../java/persistence-schema-evolution.rst:119
msgid ""
"The below figure explains how the default serialization scheme works, and "
"how it fits together with serializing the user provided message itself, "
"which we will from here on refer to as the ``payload`` (highlighted in "
"yellow):"
msgstr ""

# 20012894186a4e0888f3e24d12ef3cd3
#: ../../java/persistence-schema-evolution.rst:129
msgid ""
"The blue colored regions of the ``PersistentMessage`` indicate what is "
"serialized using the generated protocol buffers serializers, and the yellow "
"payload indicates the user provided event (by calling "
"``persist(payload)(...)``). As you can see, the ``PersistentMessage`` acts "
"as an envelope around the payload, adding various fields related to the "
"origin of the event (``persistenceId``, ``sequenceNr`` and more)."
msgstr ""

# 165707e2ab3d4b50981f21e9ea7a3f14
#: ../../java/persistence-schema-evolution.rst:134
msgid ""
"More advanced techniques (e.g. :ref:`remove-event-class-java`) will dive "
"into using the manifests for increasing the flexibility of the persisted vs."
" exposed types even more. However for now we will focus on the simpler "
"evolution techniques, concerning simply configuring the payload serializers."
msgstr ""

# ef3a52e5fd5f49f9b54b296f587db2c9
#: ../../java/persistence-schema-evolution.rst:138
msgid ""
"By default the ``payload`` will be serialized using Java Serialization. This"
" is fine for testing and initial phases of your development (while you're "
"still figuring out things and the data will not need to stay persisted "
"forever). However, once you move to production you should really *pick a "
"different serializer for your payloads*."
msgstr ""

# d4eaff28f57a4992b3d8e7ee835b1fa2
#: ../../java/persistence-schema-evolution.rst:143
msgid ""
"Do not rely on Java serialization (which will be picked by Akka by default "
"if you don't specify any serializers) for *serious* application development!"
" It does not lean itself well to evolving schemas over long periods of time,"
" and its performance is also not very high (it never was designed for high-"
"throughput scenarios)."
msgstr ""

# 0e73785542654c7d9fe54cfbdaa364e6
#: ../../java/persistence-schema-evolution.rst:151
msgid "Configuring payload serializers"
msgstr ""

# 4ebedbe2381f4541a0c562f56b29b0c8
#: ../../java/persistence-schema-evolution.rst:152
msgid ""
"This section aims to highlight the complete basics on how to define custom "
"serializers using :ref:`Akka Serialization <serialization-java>`. Many "
"journal plugin implementations use Akka Serialization, thus it is "
"tremendously important to understand how to configure it to work with your "
"event classes."
msgstr ""

# 681f1bb9492c47bfbb4101b41be96350
#: ../../java/persistence-schema-evolution.rst:157
msgid ""
"Read the :ref:`Akka Serialization <serialization-java>` docs to learn more "
"about defining custom serializers, to improve performance and "
"maintainability of your system. Do not depend on Java serialization for "
"production deployments."
msgstr ""

# a6a00765443c4e548e84240ee9338918
#: ../../java/persistence-schema-evolution.rst:160
msgid ""
"The below snippet explains in the minimal amount of lines how a custom "
"serializer can be registered. For more in-depth explanations on how "
"serialization picks the serializer to use etc, please refer to its "
"documentation."
msgstr ""

# ce7e3c1e841f4e499c397a86547bf6b8
#: ../../java/persistence-schema-evolution.rst:163
msgid ""
"First we start by defining our domain model class, here representing a "
"person:"
msgstr ""

# 1b44a3e877fb406ea41c1cc52a47703b
#: ../../java/persistence-schema-evolution.rst:167
msgid ""
"Next we implement a serializer (or extend an existing one to be able to "
"handle the new ``Person`` class):"
msgstr ""

# ecdca2571b4c497aa2a0a3daaa2a046c
#: ../../java/persistence-schema-evolution.rst:171
msgid ""
"And finally we register the serializer and bind it to handle the "
"``docs.persistence.Person`` class:"
msgstr ""

# d33d1a5e2db248579a5dee8e42bd212d
#: ../../java/persistence-schema-evolution.rst:175
msgid ""
"Deserialization will be performed by the same serializer which serialized "
"the message initially because of the ``identifier`` being stored together "
"with the message."
msgstr ""

# 4d0be2b1dbee460492b6e52e555b3bba
#: ../../java/persistence-schema-evolution.rst:178
msgid ""
"Please refer to the :ref:`Akka Serialization <serialization-java>` "
"documentation for more advanced use of serializers, especially the :ref"
":`string-manifest-serializer-java` section since it is very useful for "
"Persistence based applications dealing with schema evolutions, as we will "
"see in some of the examples below."
msgstr ""

# ab58e0bb7a0c4fabba3050e821c15767
#: ../../java/persistence-schema-evolution.rst:183
msgid "Schema evolution in action"
msgstr ""

# 8ee1ae82e87e4ffc9dfb4add174f369a
#: ../../java/persistence-schema-evolution.rst:185
msgid ""
"In this section we will discuss various schema evolution techniques using "
"concrete examples and explaining some of the various options one might go "
"about handling the described situation. The list below is by no means a "
"complete guide, so feel free to adapt these techniques depending on your "
"serializer's capabilities and/or other domain specific limitations."
msgstr ""

# a85bb9652b2d4ac0bcf06fb436961eea
#: ../../java/persistence-schema-evolution.rst:193
msgid "Add fields"
msgstr ""

# a97481020bea483f9b1cfed20339269c
#: ../../java/persistence-schema-evolution.rst:195
msgid ""
"**Situation:** You need to add a field to an existing message type. For "
"example, a ``SeatReservation(String letter, int row)`` now needs to have an "
"associated code which indicates if it is a window or aisle seat."
msgstr ""

# e8a36a8b1f004cd8bc0f58a38e7c5453
#: ../../java/persistence-schema-evolution.rst:199
msgid ""
"**Solution:** Adding fields is the most common change you'll need to apply "
"to your messages so make sure the serialization format you picked for your "
"payloads can handle it apropriately, i.e. such changes should be *binary "
"compatible*. This is easily achieved using the right serializer toolkit – we"
" recommend something like `Google Protocol Buffers`_ or `Apache Thrift`_ "
"however other tools may fit your needs just as well – picking a serializer "
"backend is something you should research before picking one to run with. In "
"the following examples we will be using protobuf, mostly because we are "
"familiar with it, it does its job well and Akka is using it internally as "
"well."
msgstr ""

# 139a142cd1e046a0ac07d2a366a49468
#: ../../java/persistence-schema-evolution.rst:207
msgid ""
"While being able to read messages with missing fields is half of the "
"solution, you also need to deal with the missing values somehow. This is "
"usually modeled as some kind of default value, or by representing the field "
"as an ``Optional<T>`` See below for an example how reading an optional field"
" from a serialized protocol buffers message might look like."
msgstr ""

# 274b614365d544e69c5ebe74005f2b06
#: ../../java/persistence-schema-evolution.rst:213
msgid ""
"Next we prepare an protocol definition using the protobuf Interface "
"Description Language, which we'll use to generate the serializer code to be "
"used on the Akka Serialization layer (notice that the schema aproach allows "
"us to easily rename fields, as long as the numeric identifiers of the fields"
" do not change):"
msgstr ""

# cac9d315f9d6456a8a6a816776917fff
#: ../../java/persistence-schema-evolution.rst:219
msgid ""
"The serializer implementation uses the protobuf generated classes to "
"marshall the payloads. Optional fields can be handled explicitly or missing "
"values by calling the ``has...`` methods on the protobuf object, which we do"
" for ``seatType`` in order to use a ``Unknown`` type in case the event was "
"stored before we had introduced the field to this event type:"
msgstr ""

# 8a64bb6e44dc4fde81ea9c100dfb4dac
#: ../../java/persistence-schema-evolution.rst:229
msgid "Rename fields"
msgstr ""

# be24134f7d464d9bb0c8cb9f768d89f7
#: ../../java/persistence-schema-evolution.rst:231
msgid ""
"**Situation:** When first designing the system the ``SeatReverved`` event "
"featured an ``code`` field. After some time you discover that what was "
"originally called ``code`` actually means ``seatNr``, thus the model should "
"be changed to reflect this concept more accurately."
msgstr ""

# c9d67bcbcbdb4b67a40338fa31c9e230
#: ../../java/persistence-schema-evolution.rst:237
msgid ""
"**Solution 1 - using IDL based serializers:** First, we will discuss the "
"most efficient way of dealing with such kinds of schema changes – IDL based "
"serializers."
msgstr ""

# be6e4da7a1ae4f35bef833fc289207a9
#: ../../java/persistence-schema-evolution.rst:240
msgid ""
"IDL stands for Interface Description Language, and means that the schema of "
"the messages that will be stored is based on this description. Most IDL "
"based serializers also generate the serializer / deserializer code so that "
"using them is not too hard. Examples of such serializers are protobuf or "
"thrift."
msgstr ""

# 7381e74679af48cc92335d184413abfc
#: ../../java/persistence-schema-evolution.rst:244
msgid ""
"Using these libraries rename operations are \"free\", because the field name"
" is never actually stored in the binary representation of the message. This "
"is one of the advantages of schema based serializers, even though that they "
"add the overhead of having to maintain the schema. When using serializers "
"like this, no additional code change (except renaming the field and method "
"used during serialization) is needed to perform such evolution:"
msgstr ""

# c606bf4741a3463da33289dde6317222
#: ../../java/persistence-schema-evolution.rst:252
msgid "This is how such a rename would look in protobuf:"
msgstr ""

# b86afdcfa384467ba4004faddae3e3d3
#: ../../java/persistence-schema-evolution.rst:256
msgid ""
"It is important to learn about the strengths and limitations of your "
"serializers, in order to be able to move swiftly and refactor your models "
"fearlessly as you go on with the project."
msgstr ""

# 5eb29c4b6d1047c390cfdd4c3f8b516f
#: ../../java/persistence-schema-evolution.rst:260
msgid ""
"Learn in-depth about the serialization engine you're using as it will impact"
" how you can aproach schema evolution."
msgstr ""

# 894cd9f645454c77ba6c335c3a2a5b73
#: ../../java/persistence-schema-evolution.rst:262
msgid ""
"Some operations are \"free\" in certain serialization formats (more often "
"than not: removing/adding optional fields, sometimes renaming fields etc.), "
"while some other operations are strictly not possible."
msgstr ""

# a5aaaac585dd4a599659f7c9d3054094
#: ../../java/persistence-schema-evolution.rst:265
msgid ""
"**Solution 2 - by manually handling the event versions:** Another solution, "
"in case your serialization format does not support renames as easily as the "
"above mentioned formats, is versioning your schema. For example, you could "
"have made your events carry an additional field called ``_version`` which "
"was set to ``1`` (because it was the initial schema), and once you change "
"the schema you bump this number to ``2``, and write an adapter which can "
"perform the rename."
msgstr ""

# ef15a7e4dc564fb6a81a9f1ac70a3472
#: ../../java/persistence-schema-evolution.rst:271
msgid ""
"This approach is popular when your serialization format is something like "
"JSON, where renames can not be performed automatically by the serializer. "
"You can do these kinds of \"promotions\" either manually (as shown in the "
"example below) or using a library like `Stamina`_ which helps to create "
"those ``V1->V2->V3->...->Vn`` promotion chains without much boilerplate."
msgstr ""

# 19fc7cf0ed134129a854b27d4530b31e
#: ../../java/persistence-schema-evolution.rst:278
msgid ""
"The following snippet showcases how one could apply renames if working with "
"plain JSON (using a ``JsObject`` as an example JSON representation):"
msgstr ""

# 5d9b4a0528c546f8a4dc6eb1d1101704
#: ../../java/persistence-schema-evolution.rst:283
msgid ""
"As you can see, manually handling renames induces some boilerplate onto the "
"EventAdapter, however much of it you will find is common infrastructure code"
" that can be either provided by an external library (for promotion "
"management) or put together in a simple helper class."
msgstr ""

# 83a8672ae8d44b1998ebdacddec33cb1
#: ../../java/persistence-schema-evolution.rst:288
msgid ""
"The technique of versioning events and then promoting them to the latest "
"version using JSON transformations can of course be applied to more than "
"just field renames – it also applies to adding fields and all kinds of "
"changes in the message format."
msgstr ""

# 9ad8ed99ccf74b7b8b0fc6eceb6a8f40
#: ../../java/persistence-schema-evolution.rst:297
msgid "Remove event class and ignore events"
msgstr ""

# 765e5dcc146d42f6af3393de0f4c141c
#: ../../java/persistence-schema-evolution.rst:299
msgid ""
"**Situation:** While investigating app performance you notice that insane "
"amounts of ``CustomerBlinked`` events are being stored for every customer "
"each time he/she blinks. Upon investigation you decide that the event does "
"not add any value and should be deleted. You still have to be able to replay"
" from a journal which contains those old CustomerBlinked events though."
msgstr ""

# e3302fd6d67a4915bce5c88aa6d8c8d2
#: ../../java/persistence-schema-evolution.rst:304
msgid "**Naive solution - drop events in EventAdapter:**"
msgstr ""

# e24025bbe3d84abc9a8f4a9db99e2ffe
#: ../../java/persistence-schema-evolution.rst:306
msgid ""
"The problem of removing an event type from the domain model is not as much "
"its removal, as the implications for the recovery mechanisms that this "
"entails. For example, a naive way of filtering out certain kinds of events "
"from being delivered to a recovering ``PersistentActor`` is pretty simple, "
"as one can simply filter them out in an :ref:`EventAdapter <event-adapters-"
"java>`:"
msgstr ""

# ef25b5e4689f4e958b0519dcdb8ef921
#: ../../java/persistence-schema-evolution.rst:317
msgid ""
"This however does not address the underlying cost of having to deserialize "
"all the events during recovery, even those which will be filtered out by the"
" adapter. In the next section we will improve the above explained mechanism "
"to avoid deserializing events which would be filtered out by the adapter "
"anyway, thus allowing to save precious time during a recovery containing "
"lots of such events (without actually having to delete them)."
msgstr ""

# 6210b0e7704144bd9fd82ee4fecbb132
#: ../../java/persistence-schema-evolution.rst:322
msgid "**Improved solution - deserialize into tombstone:**"
msgstr ""

# ca20568242974c728363c9fa9740adb0
#: ../../java/persistence-schema-evolution.rst:324
msgid ""
"In the just described technique we have saved the PersistentActor from "
"receiving un-wanted events by filtering them out in the ``EventAdapter``, "
"however the event itself still was deserialized and loaded into memory. This"
" has two notable *downsides*:"
msgstr ""

# 92b9f491341e4d25b62cba1683aaf74e
#: ../../java/persistence-schema-evolution.rst:328
msgid ""
"first, that the deserialization was actually performed, so we spent some of "
"out time budget on the deserialization, even though the event does not "
"contribute anything to the persistent actors state."
msgstr ""

# b4ff1ca2061b49c5967f3866a76cb9df
#: ../../java/persistence-schema-evolution.rst:330
msgid ""
"second, that we are *unable to remove the event class* from the system – "
"since the serializer still needs to create the actuall instance of it, as it"
" does not know it will not be used."
msgstr ""

# 4d0b417ec283445f90ec17f79d10142f
#: ../../java/persistence-schema-evolution.rst:333
msgid ""
"The solution to these problems is to use a serializer that is aware of that "
"event being no longer needed, and can notice this before starting to "
"deserialize the object."
msgstr ""

# 382039d6ab5645b88e24ac83063e48b7
#: ../../java/persistence-schema-evolution.rst:336
msgid ""
"This aproach allows us to *remove the original class from our classpath*, "
"which makes for less \"old\" classes lying around in the project. This can "
"for example be implemented by using an ``SerializerWithStringManifest`` "
"(documented in depth in :ref:`string-manifest-serializer-java`). By looking "
"at the string manifest, the serializer can notice that the type is no longer"
" needed, and skip the deserialization all-together:"
msgstr ""

# 559488ee3e3d4788b978e435c6d29f08
#: ../../java/persistence-schema-evolution.rst:348
msgid ""
"The serializer detects that the string manifest points to a removed event "
"type and skips attempting to deserialize it:"
msgstr ""

# 986cd244a001460ba32cf9e762882155
#: ../../java/persistence-schema-evolution.rst:352
msgid ""
"The EventAdapter we implemented is aware of ``EventDeserializationSkipped`` "
"events (our \"Tombstones\"), and emits and empty ``EventSeq`` whenever such "
"object is encoutered:"
msgstr ""

# 6eb2267c453e4cd7b1e66028dea74385
#: ../../java/persistence-schema-evolution.rst:360
msgid "Detach domain model from data model"
msgstr ""

# a2e5d6ede9384bfbb95f66ec09d5538c
#: ../../java/persistence-schema-evolution.rst:362
msgid ""
"**Situation:** You want to separate the application model (often called the "
"\"*domain model*\") completely from the models used to persist the "
"corresponding events (the \"*data model*\"). For example because the data "
"representation may change independently of the domain model."
msgstr ""

# c7f3cc38f7404c2e8cfdb24b83496a27
#: ../../java/persistence-schema-evolution.rst:367
msgid ""
"Another situation where this technique may be useful is when your "
"serialization tool of choice requires generated classes to be used for "
"serialization and deserialization of objects, like for example `Google "
"Protocol Buffers`_ do, yet you do not want to leak this implementation "
"detail into the domain model itself, which you'd like to model as plain Java"
" classes."
msgstr ""

# 1821c833d4ff425889407a13d48b4192
#: ../../java/persistence-schema-evolution.rst:372
msgid ""
"**Solution:** In order to detach the domain model, which is often "
"represented using pure java (case) classes, from the data model classes "
"which very often may be less user-friendly yet highly optimised for "
"throughput and schema evolution (like the classes generated by protobuf for "
"example), it is possible to use a simple EventAdapter which maps between "
"these types in a 1:1 style as illustrated below:"
msgstr ""

# 8f613d5fe5bf42f9a7b45c238881b312
#: ../../java/persistence-schema-evolution.rst:385
msgid ""
"We will use the following domain and data models to showcase how the "
"separation can be implemented by the adapter:"
msgstr ""

# 90f4cb78d70f4c1a8a634ebded5516e6
#: ../../java/persistence-schema-evolution.rst:389
msgid ""
"The :class:`EventAdapter` takes care of converting from one model to the "
"other one (in both directions), alowing the models to be completely detached"
" from each other, such that they can be optimised independently as long as "
"the mapping logic is able to convert between them:"
msgstr ""

# e2fbe29539d34b44925f788e4ff042ac
#: ../../java/persistence-schema-evolution.rst:395
msgid ""
"The same technique could also be used directly in the Serializer if the end "
"result of marshalling is bytes. Then the serializer can simply convert the "
"bytes do the domain object by using the generated protobuf builders."
msgstr ""

# e0c7b14426cb40deba7fd426b167954e
#: ../../java/persistence-schema-evolution.rst:401
msgid "Store events as human-readable data model"
msgstr ""

# d7232f8fd2e7497fa2b8f83843f49e81
#: ../../java/persistence-schema-evolution.rst:402
msgid ""
"**Situation:** You want to keep your persisted events in a human-readable "
"format, for example JSON."
msgstr ""

# b0cae9a448ae4cb6bac645bb26ccdc57
#: ../../java/persistence-schema-evolution.rst:405
msgid ""
"**Solution:** This is a special case of the :ref:`detach-domain-from-data-"
"model-java` pattern, and thus requires some co-operation from the Journal "
"implementation to achieve this."
msgstr ""

# c76c7eb1813b4e638d9694d31ba398ec
#: ../../java/persistence-schema-evolution.rst:409
msgid ""
"An example of a Journal which may implement this pattern is MongoDB, however"
" other databases such as PostgreSQL and Cassandra could also do it because "
"of their built-in JSON capabilities."
msgstr ""

# bbc1e1aceefe46a08ffcf0cb8a490d9e
#: ../../java/persistence-schema-evolution.rst:412
msgid ""
"In this aproach, the :class:`EventAdapter` is used as the marshalling layer:"
" it serializes the events to/from JSON. The journal plugin notices that the "
"incoming event type is JSON (for example by performing a ``match`` on the "
"incoming event) and stores the incoming object directly."
msgstr ""

# 9a80452a7c664b6dba2c674526e7db84
#: ../../java/persistence-schema-evolution.rst:419
msgid ""
"This technique only applies if the Akka Persistence plugin you are using "
"provides this capability. Check the documentation of your favourite plugin "
"to see if it supports this style of persistence."
msgstr ""

# 6d29a9687bb44395975b277b031e3e52
#: ../../java/persistence-schema-evolution.rst:422
msgid ""
"If it doesn't, you may want to skim the `list of existing journal plugins`_,"
" just in case some other plugin for your favourite datastore *does* provide "
"this capability."
msgstr ""

# 7f6e67cdb0b34bf68171ee7ad4d3fa26
#: ../../java/persistence-schema-evolution.rst:425
msgid "**Alternative solution:**"
msgstr ""

# b316497ac7f143fc840fe2f59bea643b
#: ../../java/persistence-schema-evolution.rst:427
msgid ""
"In fact, an AsyncWriteJournal implementation could natively decide to not "
"use binary serialization at all, and *always* serialize the incoming "
"messages as JSON - in which case the ``toJournal`` implementation of the "
":class:`EventAdapter` would be an identity function, and the ``fromJournal``"
" would need to de-serialize messages from JSON."
msgstr ""

# bce90c5c2d62470caf6fa8216e2512ef
#: ../../java/persistence-schema-evolution.rst:433
msgid ""
"If in need of human-readable events on the *write-side* of your application "
"reconsider whether preparing materialized views using :ref:`persistence-"
"query-java` would not be an efficient way to go about this, without "
"compromising the write-side's throughput characteristics."
msgstr ""

# 2481ba38c77042f9aecf890238f9220f
#: ../../java/persistence-schema-evolution.rst:437
msgid ""
"If indeed you want to use a human-readable representation on the write-side,"
" pick a Persistence plugin that provides that functionality, or – implement "
"one yourself."
msgstr ""

# bc2180723c8f404b94a39ac16352ec65
#: ../../java/persistence-schema-evolution.rst:446
msgid "Split large event into fine-grained events"
msgstr ""

# d1566c46b705416ba5df9f90d64c6630
#: ../../java/persistence-schema-evolution.rst:448
msgid ""
"**Situation:** While refactoring your domain events, you find that one of "
"the events has become too large (coarse-grained) and needs to be split up "
"into multiple fine-grained events."
msgstr ""

# e5c3ed758b9d4699abc8a19d15c32a21
#: ../../java/persistence-schema-evolution.rst:452
msgid ""
"**Solution:** Let us consider a situation where an event represents \"user "
"details changed\". After some time we discover that this event is too "
"coarse, and needs to be split into \"user name changed\" and \"user address "
"changed\", because somehow users keep changing their usernames a lot and "
"we'd like to keep this as a separate event."
msgstr ""

# 10ce4be11292422fbbfeda6636dd4c05
#: ../../java/persistence-schema-evolution.rst:457
msgid ""
"The write side change is very simple, we simply persist ``UserNameChanged`` "
"or ``UserAddressChanged`` depending on what the user actually intended to "
"change (instead of the composite ``UserDetailsChanged`` that we had in "
"version 1 of our model)."
msgstr ""

# 9dc01963292b4b61a4244147c7156882
#: ../../java/persistence-schema-evolution.rst:466
msgid ""
"During recovery however, we now need to convert the old ``V1`` model into "
"the ``V2`` representation of the change. Depending if the old event contains"
" a name change, we either emit the ``UserNameChanged`` or we don't, and the "
"address change is handled similarily:"
msgstr ""

# 48870e582e364d45a6cad9d35b816bf1
#: ../../java/persistence-schema-evolution.rst:472
msgid ""
"By returning an :class:`EventSeq` from the event adapter, the recovered "
"event can be converted to multiple events before being delivered to the "
"persistent actor."
msgstr ""

# 534063ae54db407394708e3bd2160bb6
#: ../../java/remoting.rst:5
msgid "Remoting"
msgstr ""

# 5f50ba7e30984863b6677d8160f4e2c6
#: ../../java/remoting.rst:7
msgid ""
"For an introduction of remoting capabilities of Akka please see "
":ref:`remoting`."
msgstr ""

# 1dbeb173af5d4a139cde6ce65d7a22df
#: ../../java/remoting.rst:11
msgid ""
"As explained in that chapter Akka remoting is designed for communication in "
"a peer-to-peer fashion and it has limitations for client-server setups. In "
"particular Akka Remoting does not work transparently with Network Address "
"Translation, Load Balancers, or in Docker containers. For symmetric "
"communication in these situations network and/or Akka configuration will "
"have to be changed as described in :ref:`symmetric-communication`."
msgstr ""

# 607bc20ddea144de8d0d4ae5ff13a281
#: ../../java/remoting.rst:19
msgid "Preparing your ActorSystem for Remoting"
msgstr ""

# 690365097595432d977c09805411037d
#: ../../java/remoting.rst:21
msgid ""
"The Akka remoting is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

# 8a946cfb2a9a44ad92cb529d153bea68
#: ../../java/remoting.rst:29
msgid ""
"To enable remote capabilities in your Akka project you should, at a minimum,"
" add the following changes to your ``application.conf`` file::"
msgstr ""

# 23ec3ed3c3cd4a7b95e01a99e92560c1
#: ../../java/remoting.rst:45
msgid ""
"As you can see in the example above there are four things you need to add to"
" get started:"
msgstr ""

# f893fecc09e546709b11b1e81e3e4d55
#: ../../java/remoting.rst:47
msgid ""
"Change provider from ``akka.actor.LocalActorRefProvider`` to "
"``akka.remote.RemoteActorRefProvider``"
msgstr ""

# d75c549767ce47d580c42c837fce9eef
#: ../../java/remoting.rst:48
msgid ""
"Add host name - the machine you want to run the actor system on; this host "
"name is exactly what is passed to remote systems in order to identify this "
"system and consequently used for connecting back to this system if need be, "
"hence set it to a reachable IP address or resolvable name in case you want "
"to communicate across the network."
msgstr ""

# be8ac60c7f8f4490ae060ba23122dbf1
#: ../../java/remoting.rst:53
msgid ""
"Add port number - the port the actor system should listen on, set to 0 to "
"have it chosen automatically"
msgstr ""

# d89110261a034d07b11bd8d848c712fd
#: ../../java/remoting.rst:56
msgid ""
"The port number needs to be unique for each actor system on the same machine"
" even if the actor systems have different names. This is because each actor "
"system has its own network subsystem listening for connections and handling "
"messages as not to interfere with other actor systems."
msgstr ""

# b73703770b99448db7a52b6291f6cb62
#: ../../java/remoting.rst:60
msgid ""
"The example above only illustrates the bare minimum of properties you have "
"to add to enable remoting. All settings are described in :ref:`remote-"
"configuration-java`."
msgstr ""

# 0d7f9b7da4544532a15cbf8c14beb3d8
#: ../../java/remoting.rst:64
msgid "Looking up Remote Actors"
msgstr ""

# a6e2099c41784d1dbc546d60fc7faea7
#: ../../java/remoting.rst:66
msgid ""
"``actorSelection(path)`` will obtain an ``ActorSelection`` to an Actor on a "
"remote node::"
msgstr ""

# d26c0c4c599e471383a13412b27d9d79
#: ../../java/remoting.rst:71
msgid ""
"As you can see from the example above the following pattern is used to find "
"an actor on a remote node::"
msgstr ""

# 0092d993fdc24a2599d936b87b16c65c
#: ../../java/remoting.rst:75
msgid ""
"Once you obtained a selection to the actor you can interact with it they "
"same way you would with a local actor, e.g.::"
msgstr ""

# be96fddea43c4dad91d7afa70acf6e96
#: ../../java/remoting.rst:79
msgid ""
"To acquire an :class:`ActorRef` for an :class:`ActorSelection` you need to "
"send a message to the selection and use the ``getSender`` reference of the "
"reply from the actor. There is a built-in ``Identify`` message that all "
"Actors will understand and automatically reply to with a ``ActorIdentity`` "
"message containing the :class:`ActorRef`. This can also be done with the "
"``resolveOne`` method of the :class:`ActorSelection`, which returns a "
"``Future`` of the matching :class:`ActorRef`."
msgstr ""

# c000d005bef0423eb60f538b5ed48bde
#: ../../java/remoting.rst:89
msgid ""
"For more details on how actor addresses and paths are formed and used, "
"please refer to :ref:`addressing`."
msgstr ""

# 652e1940d87347ecb68b9df07f3bdff7
#: ../../java/remoting.rst:93
msgid ""
"Message sends to actors that are actually in the sending actor system do not"
" get delivered via the remote actor ref provider. They're delivered "
"directly, by the local actor ref provider."
msgstr ""

# 8f350740cb4348779d69cc3aebd9ff51
#: ../../java/remoting.rst:97
msgid ""
"Aside from providing better performance, this also means that if the "
"hostname you configure remoting to listen as cannot actually be resolved "
"from within the very same actor system, such messages will (perhaps "
"counterintuitively) be delivered just fine."
msgstr ""

# 5f58ecb82482469888638cdc5140fb04
#: ../../java/remoting.rst:103
msgid "Creating Actors Remotely"
msgstr ""

# 2b94140fcf6342fb9beb75dbbb7463ca
#: ../../java/remoting.rst:105
msgid ""
"If you want to use the creation functionality in Akka remoting you have to "
"further amend the ``application.conf`` file in the following way (only "
"showing deployment section)::"
msgstr ""

# 5619a341ddcb48f29d075e5b8622ed80
#: ../../java/remoting.rst:118
msgid ""
"The configuration above instructs Akka to react when an actor with path "
"``/sampleActor`` is created, i.e. using ``system.actorOf(new Props(...), "
"\"sampleActor\")``. This specific actor will not be directly instantiated, "
"but instead the remote daemon of the remote system will be asked to create "
"the actor, which in this sample corresponds to "
"``sampleActorSystem@127.0.0.1:2553``."
msgstr ""

# 5ac2cda966e245a8ac5f4c1401208152
#: ../../java/remoting.rst:123
msgid ""
"Once you have configured the properties above you would do the following in "
"code:"
msgstr ""

# 23b07932da174eb19f9f3457741b42ec
#: ../../java/remoting.rst:127
msgid ""
"The actor class ``SampleActor`` has to be available to the runtimes using "
"it, i.e. the classloader of the actor systems has to have a JAR containing "
"the class."
msgstr ""

# 9d9217da0a134f2b8c9773619a3c9dd9
#: ../../java/remoting.rst:132
msgid ""
"In order to ensure serializability of ``Props`` when passing constructor "
"arguments to the actor being created, do not make the factory a non-static "
"inner class: this will inherently capture a reference to its enclosing "
"object, which in most cases is not serializable. It is best to make a static"
" inner class which implements :class:`Creator<T extends Actor>`."
msgstr ""

# c33fefdf36e7452c98d276dcdaee8502
#: ../../java/remoting.rst:138
msgid ""
"Serializability of all Props can be tested by setting the configuration item"
" ``akka.actor.serialize-creators=on``. Only Props whose ``deploy`` has "
"``LocalScope`` are exempt from this check."
msgstr ""

# 6cec44946f784ff987182f95b3e16f9f
#: ../../java/remoting.rst:144
msgid ""
"You can use asterisks as wildcard matches for the actor path sections, so "
"you could specify: ``/*/sampleActor`` and that would match all "
"``sampleActor`` on that level in the hierarchy. You can also use wildcard in"
" the last position to match all actors at a certain level: "
"``/someParent/*``. Non-wildcard matches always have higher priority to match"
" than wildcards, so: ``/foo/bar`` is considered **more specific** than "
"``/foo/*`` and only the highest priority match is used. Please note that it "
"**cannot** be used to partially match section, like this: ``/foo*/bar``, "
"``/f*o/bar`` etc."
msgstr ""

# b6a6168b9e3349a2939fd958627cb65f
#: ../../java/remoting.rst:152
msgid "Programmatic Remote Deployment"
msgstr ""

# 43d9eb6bd43142449830e10faf9495e1
#: ../../java/remoting.rst:154
msgid ""
"To allow dynamically deployed systems, it is also possible to include "
"deployment configuration in the :class:`Props` which are used to create an "
"actor: this information is the equivalent of a deployment section from the "
"configuration file, and if both are given, the external configuration takes "
"precedence."
msgstr ""

# 095299af8a7540168fb17eccdf45900e
#: ../../java/remoting.rst:160
msgid "With these imports:"
msgstr ""

# 7490455b7f5342a28c906256d9314803
#: ../../java/remoting.rst:164
msgid "and a remote address like this:"
msgstr ""

# 929e2ec1988f4cdaac185502bfecb3f5
#: ../../java/remoting.rst:168
msgid ""
"you can advise the system to create a child on that remote node like so:"
msgstr ""

# c5eef890f84148d69330a9e86bbdedfb
#: ../../java/remoting.rst:174
msgid "Lifecycle and Failure Recovery Model"
msgstr ""

# 0d02707840294357aa3d8a22658c5b7f
#: ../../java/remoting.rst:180
msgid ""
"Each link with a remote system can be in one of the four states as "
"illustrated above. Before any communication happens with a remote system at "
"a given ``Address`` the state of the association is ``Idle``. The first time"
" a message is attempted to be sent to the remote system or an inbound "
"connection is accepted the state of the link transitions to ``Active`` "
"denoting that the two systems has messages to send or receive and no "
"failures were encountered so far. When a communication failure happens and "
"the connection is lost between the two systems the link becomes ``Gated``."
msgstr ""

# e45cc125acd546fca3e02c72a4a10bb2
#: ../../java/remoting.rst:186
msgid ""
"In this state the system will not attempt to connect to the remote host and "
"all outbound messages will be dropped. The time while the link is in the "
"``Gated`` state is controlled by the setting ``akka.remote.retry-gate-"
"closed-for``: after this time elapses the link state transitions to ``Idle``"
" again. ``Gate`` is one-sided in the sense that whenever a successful "
"*inbound* connection is accepted from a remote system during ``Gate`` it "
"automatically transitions to ``Active`` and communication resumes "
"immediately."
msgstr ""

# 57cd077ac0614dc99498207311b5c8fd
#: ../../java/remoting.rst:192
msgid ""
"In the face of communication failures that are unrecoverable because the "
"state of the participating systems are inconsistent, the remote system "
"becomes ``Quarantined``. Unlike ``Gate``, quarantining is permanent and "
"lasts until one of the systems is restarted. After a restart communication "
"can be resumed again and the link can become ``Active`` again."
msgstr ""

# 625960d6edda41b7a87bd4d139bc3349
#: ../../java/remoting.rst:197
msgid "Watching Remote Actors"
msgstr ""

# 503815bc07a14589a04f0a4fdc752a6e
#: ../../java/remoting.rst:199
msgid ""
"Watching a remote actor is not different than watching a local actor, as "
"described in :ref:`deathwatch-java`."
msgstr ""

# a99cfd7f9fa8445aba3e3d5816cabc25
#: ../../java/remoting.rst:205
msgid ""
"Under the hood remote death watch uses heartbeat messages and a failure "
"detector to generate ``Terminated`` message from network failures and JVM "
"crashes, in addition to graceful termination of watched actor."
msgstr ""

# 8f90f49bd70a42a4a70472de02e9a213
#: ../../java/remoting.rst:209
msgid ""
"The heartbeat arrival times is interpreted by an implementation of `The Phi "
"Accrual Failure Detector "
"<http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf>`_."
msgstr ""

# c793b59a6e2445ae9bc3c145b2fb1167
#: ../../java/remoting.rst:223
msgid ""
"In the :ref:`remote-configuration-java` you can adjust the ``akka.remote"
".watch-failure-detector.threshold`` to define when a *phi* value is "
"considered to be a failure."
msgstr ""

# 30e7682af4d7483d9abc669c8f39bc5c
#: ../../java/remoting.rst:226
msgid ""
"A low ``threshold`` is prone to generate many false positives but ensures a "
"quick detection in the event of a real crash. Conversely, a high "
"``threshold`` generates fewer mistakes but needs more time to detect actual "
"crashes. The default ``threshold`` is 10 and is appropriate for most "
"situations. However in cloud environments, such as Amazon EC2, the value "
"could be increased to 12 in order to account for network issues that "
"sometimes occur on such platforms."
msgstr ""

# 8424956214d445a9aa352509367bf61b
#: ../../java/remoting.rst:246
msgid ""
"To be able to survive sudden abnormalities, such as garbage collection "
"pauses and transient network failures the failure detector is configured "
"with a margin, ``akka.remote.watch-failure-detector.acceptable-heartbeat-"
"pause``. You may want to adjust the :ref:`remote-configuration-java` of this"
" depending on you environment. This is how the curve looks like for "
"``acceptable-heartbeat-pause`` configured to 3 seconds."
msgstr ""

# 5b6b5b1fa2fc4ff89f35d1e201695d7b
#: ../../java/remoting.rst:258
msgid ""
"When using remoting for actors you must ensure that the ``props`` and "
"``messages`` used for those actors are serializable. Failing to do so will "
"cause the system to behave in an unintended way."
msgstr ""

# 7eb509bd765347499e22c9ba52c0e6bb
#: ../../java/remoting.rst:261
msgid "For more information please see :ref:`serialization-java`."
msgstr ""

# 2b2e911963934736bbfa1eb04faa0d68
#: ../../java/remoting.rst:264
msgid "Routers with Remote Destinations"
msgstr ""

# 4c94146f05224679b27ea137428c40b8
#: ../../java/remoting.rst:266
msgid ""
"It is absolutely feasible to combine remoting with :ref:`routing-java`."
msgstr ""

# 9de377567da243d89ae2a7e953cec20a
#: ../../java/remoting.rst:268
msgid "A pool of remote deployed routees can be configured as:"
msgstr ""

# 7ec73a2f077f43ee83cf80f44ed665e6
#: ../../java/remoting.rst:272
msgid ""
"This configuration setting will clone the actor defined in the ``Props`` of "
"the ``remotePool`` 10 times and deploy it evenly distributed across the two "
"given target nodes."
msgstr ""

# a28bec1ecb874d1eb9fd7bd064dd90aa
#: ../../java/remoting.rst:275
msgid "A group of remote actors can be configured as:"
msgstr ""

# dbe8e6ef719b4501bdc1ec10a06067dd
#: ../../java/remoting.rst:279
msgid ""
"This configuration setting will send messages to the defined remote actor "
"paths. It requires that you create the destination actors on the remote "
"nodes with matching paths. That is not done by the router."
msgstr ""

# ed3f4ad675e04fe29f3eba2189b3c556
#: ../../java/remoting.rst:286
msgid "Remoting Sample"
msgstr ""

# cea3327a24de41729cd1fa0e1c00034d
#: ../../java/remoting.rst:288
msgid ""
"There is a more extensive remote example that comes with `Lightbend "
"Activator <http://www.lightbend.com/platform/getstarted>`_. The tutorial "
"named `Akka Remote Samples with Java "
"<http://www.lightbend.com/activator/template/akka-sample-remote-java>`_ "
"demonstrates both remote deployment and look-up of remote actors."
msgstr ""

# 172bbfd21fb54212bdd5853aa54de9f3
#: ../../java/remoting.rst:293
msgid "Pluggable transport support"
msgstr ""

# cba05ef33570439b9dd0e3572670b16a
#: ../../java/remoting.rst:295
msgid ""
"Akka can be configured to use various transports to communicate with remote "
"systems. The core component of this feature is the "
":meth:`akka.remote.transport.Transport` SPI. Transport implementations must "
"extend this trait. Transports can be loaded by setting the ``akka.remote"
".enabled-transports`` configuration key to point to one or more "
"configuration sections containing driver descriptions."
msgstr ""

# d886dd533fe04b9bac1fa6d6cbedbf43
#: ../../java/remoting.rst:300
msgid ""
"An example of setting up the default Netty based SSL driver as default::"
msgstr ""

# 2fd72460a2554f3197b211fbdbf2611a
#: ../../java/remoting.rst:319
msgid "An example of setting up a custom transport implementation::"
msgstr ""

# 4abd988957dd47ca8faa74a03835ced1
#: ../../java/remoting.rst:346
msgid "Remote Events"
msgstr ""

# 7677c6603239405db60eec33f303dfdc
#: ../../java/remoting.rst:348
msgid ""
"It is possible to listen to events that occur in Akka Remote, and to "
"subscribe/unsubscribe to these events you simply register as listener to the"
" below described types in on the ``ActorSystem.eventStream``."
msgstr ""

# a7e5c08ecf6a4b178f7c3a33f6d316c0
#: ../../java/remoting.rst:353
msgid ""
"To subscribe to any remote event, subscribe to "
":meth:`RemotingLifecycleEvent`.  To subscribe to events related only to the "
"lifecycle of associations, subscribe to "
":meth:`akka.remote.AssociationEvent`."
msgstr ""

# feeb3cb4a472418f82612be3c3a08c9b
#: ../../java/remoting.rst:360
msgid ""
"The use of term \"Association\" instead of \"Connection\" reflects that the "
"remoting subsystem may use connectionless transports, but an association "
"similar to transport layer connections is maintained between endpoints by "
"the Akka protocol."
msgstr ""

# aa3922f2275445f5b44c13bf5929b3f9
#: ../../java/remoting.rst:365
msgid ""
"By default an event listener is registered which logs all of the events "
"described below. This default was chosen to help setting up a system, but it"
" is quite common to switch this logging off once that phase of the project "
"is finished."
msgstr ""

# 8baf453728e342be904901156735cb28
#: ../../java/remoting.rst:372
msgid ""
"In order to switch off the logging, set ``akka.remote.log-remote-lifecycle-"
"events = off`` in your ``application.conf``."
msgstr ""

# d45de6e4edad4a659f7978951591971e
#: ../../java/remoting.rst:376
msgid ""
"To be notified when an association is over (\"disconnected\") listen to "
"``DisassociatedEvent`` which holds the direction of the association (inbound"
" or outbound) and the addresses of the involved parties."
msgstr ""

# ae1723229f0f4382a4403848a19871ae
#: ../../java/remoting.rst:379
msgid ""
"To be notified  when an association is successfully established "
"(\"connected\") listen to ``AssociatedEvent`` which holds the direction of "
"the association (inbound or outbound) and the addresses of the involved "
"parties."
msgstr ""

# 435399614f544aa4bf60ad9c38434843
#: ../../java/remoting.rst:382
msgid ""
"To intercept errors directly related to associations, listen to "
"``AssociationErrorEvent`` which holds the direction of the association "
"(inbound or outbound), the addresses of the involved parties and the "
"``Throwable`` cause."
msgstr ""

# f82e22de617c45a48fe829b751bfaa21
#: ../../java/remoting.rst:386
msgid ""
"To be notified  when the remoting subsystem is ready to accept associations,"
" listen to ``RemotingListenEvent`` which contains the addresses the remoting"
" listens on."
msgstr ""

# 4ba2e890bb5e46f4b1c68e10f5bb624d
#: ../../java/remoting.rst:389
msgid ""
"To be notified  when the remoting subsystem has been shut down, listen to "
"``RemotingShutdownEvent``."
msgstr ""

# ef064c813ef8403aba55ca4e4af8768e
#: ../../java/remoting.rst:391
msgid ""
"To be notified when the current system is quarantined by the remote system, "
"listen to ``ThisActorSystemQuarantinedEvent``, which includes the addresses "
"of local and remote ActorSystems."
msgstr ""

# 54ad78edc3bd4d618ae051955dac8902
#: ../../java/remoting.rst:394
msgid ""
"To intercept generic remoting related errors, listen to "
"``RemotingErrorEvent`` which holds the ``Throwable`` cause."
msgstr ""

# 40af5cb554e04346867ea38ab0747625
#: ../../java/remoting.rst:397
msgid "Remote Security"
msgstr ""

# 6ef0231e8d2d416e8b04e2a1a6e15c47
#: ../../java/remoting.rst:399
msgid ""
"Akka provides a couple of ways to enhance security between remote nodes "
"(client/server):"
msgstr ""

# 8b6001348580445698c527a1ee538569
# 011c1c2c04d0424192126db007eba524
#: ../../java/remoting.rst:401 ../../java/remoting.rst:405
msgid "Untrusted Mode"
msgstr ""

# 6eeb4e20bb9c423eb0dc93388e1520ad
#: ../../java/remoting.rst:402
msgid "Security Cookie Handshake"
msgstr ""

# 84d1758b9ed24c14b8d04a1be9fe89ad
#: ../../java/remoting.rst:407
msgid ""
"As soon as an actor system can connect to another remotely, it may in "
"principle send any possible message to any actor contained within that "
"remote system. One example may be sending a :class:`PoisonPill` to the "
"system guardian, shutting that system down. This is not always desired, and "
"it can be disabled with the following setting::"
msgstr ""

# 28da0157f0a14866893172824026d349
#: ../../java/remoting.rst:415
msgid ""
"This disallows sending of system messages (actor life-cycle commands, "
"DeathWatch, etc.) and any message extending :class:`PossiblyHarmful` to the "
"system on which this flag is set. Should a client send them nonetheless they"
" are dropped and logged (at DEBUG level in order to reduce the possibilities"
" for a denial of service attack). :class:`PossiblyHarmful` covers the "
"predefined messages like :class:`PoisonPill` and :class:`Kill`, but it can "
"also be added as a marker trait to user-defined messages."
msgstr ""

# ce41d81604cc409a990f4ecf7cab2e6e
#: ../../java/remoting.rst:423
msgid ""
"Messages sent with actor selection are by default discarded in untrusted "
"mode, but permission to receive actor selection messages can be granted to "
"specific actors defined in configuration::"
msgstr ""

# cef2e0cdf88c46309fb55c4194ae4914
#: ../../java/remoting.rst:429
msgid "The actual message must still not be of type :class:`PossiblyHarmful`."
msgstr ""

# 63e7d1b77d4547e8a822301619904031
#: ../../java/remoting.rst:431
msgid ""
"In summary, the following operations are ignored by a system configured in "
"untrusted mode when incoming via the remoting layer:"
msgstr ""

# bb612a514dcf42559f9cc7c3c224044c
#: ../../java/remoting.rst:434
msgid "remote deployment (which also means no remote supervision)"
msgstr ""

# 9cc30bc9f4c44d30938f65f3d0d911f3
#: ../../java/remoting.rst:435
msgid "remote DeathWatch"
msgstr ""

# c6f2852c7d9444229cf709b5e15121ec
#: ../../java/remoting.rst:436
msgid "``system.stop()``, :class:`PoisonPill`, :class:`Kill`"
msgstr ""

# 855ee04c6cd9434b95e0b008c36c4bd2
#: ../../java/remoting.rst:437
msgid ""
"sending any message which extends from the :class:`PossiblyHarmful` marker "
"interface, which includes :class:`Terminated`"
msgstr ""

# b8a63dc793c349f29aabb4698b3b0cee
#: ../../java/remoting.rst:439
msgid ""
"messages sent with actor selection, unless destination defined in ``trusted-"
"selection-paths``."
msgstr ""

# a28695bd31ca49abab2ed32240e4d161
#: ../../java/remoting.rst:443
msgid ""
"Enabling the untrusted mode does not remove the capability of the client to "
"freely choose the target of its message sends, which means that messages not"
" prohibited by the above rules can be sent to any actor in the remote "
"system. It is good practice for a client-facing system to only contain a "
"well-defined set of entry point actors, which then forward requests "
"(possibly after performing validation) to another actor system containing "
"the actual worker actors. If messaging between these two server-side systems"
" is done using local :class:`ActorRef` (they can be exchanged safely between"
" actor systems within the same JVM), you can restrict the messages on this "
"interface by marking them :class:`PossiblyHarmful` so that a client cannot "
"forge them."
msgstr ""

# 9b1727d0f5404948801808e60d7ff456
#: ../../java/remoting.rst:455
msgid "SSL"
msgstr ""

# 26f1fcf1929647f29e9f74de19bc57fa
#: ../../java/remoting.rst:457
msgid ""
"SSL can be used as the remote transport by adding ``akka.remote.netty.ssl`` "
"to the ``enabled-transport`` configuration section. See a description of the"
" settings in the :ref:`remote-configuration-java` section."
msgstr ""

# 261e24152b1446b59263cb2765021c05
#: ../../java/remoting.rst:461
msgid ""
"The SSL support is implemented with Java Secure Socket Extension, please "
"consult the official `Java Secure Socket Extension documentation "
"<http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html>`_"
" and related resources for troubleshooting."
msgstr ""

# d9951d4f36f34ee2af807f181c44ff43
#: ../../java/remoting.rst:467
msgid ""
"When using SHA1PRNG on Linux it's recommended specify "
"``-Djava.security.egd=file:/dev/./urandom`` as argument to the JVM to "
"prevent blocking. It is NOT as secure because it reuses the seed. Use "
"'/dev/./urandom', not '/dev/urandom' as that doesn't work according to `Bug "
"ID: 6202721 <http://bugs.sun.com/view_bug.do?bug_id=6202721>`_."
msgstr ""

# fa650da7e90f4e269a121896be9332f3
#: ../../java/remoting.rst:475
msgid "Remote Configuration"
msgstr ""

# bcdd2d3085f8423a8ec4a31a15540c60
#: ../../java/remoting.rst:477
msgid ""
"There are lots of configuration properties that are related to remoting in "
"Akka. We refer to the :ref:`reference configuration <config-akka-remote>` "
"for more information."
msgstr ""

# a5aca21d8cdf40918379d594b71c4875
#: ../../java/remoting.rst:482
msgid ""
"Setting properties like the listening IP and port number programmatically is"
" best done by using something like the following:"
msgstr ""

# 1e4df7108f814701bf8b8fe2dce5a0a7
#: ../../java/remoting.rst:490
msgid "Akka behind NAT or in a Docker container"
msgstr ""

# e6fb2143c25343dca0f3368dc243ffca
#: ../../java/remoting.rst:492
msgid ""
"In setups involving Network Address Translation (NAT), Load Balancers or "
"Docker containers the hostname and port pair that Akka binds to will be "
"different than the \"logical\" host name and port pair that is used to "
"connect to the system from the outside. This requires special configuration "
"that sets both the logical and the bind pairs for remoting."
msgstr ""

# c3ec8d452e8c4dae818e1ecb928a6f2d
#: ../../java/routing.rst:5
msgid "Routing"
msgstr ""

# 367a205413aa44a99c3a7ac879ce6800
#: ../../java/routing.rst:7
msgid ""
"Messages can be sent via a router to efficiently route them to destination "
"actors, known as its *routees*. A ``Router`` can be used inside or outside "
"of an actor, and you can manage the routees yourselves or use a self "
"contained router actor with configuration capabilities."
msgstr ""

# d6bcd791984c404e9582f7b5466c275f
#: ../../java/routing.rst:11
msgid ""
"Different routing strategies can be used, according to your application's "
"needs. Akka comes with several useful routing strategies right out of the "
"box. But, as you will see in this chapter, it is also possible to "
":ref:`create your own <custom-router-java>`."
msgstr ""

# 4c6b1300696e413fa112b7d0a999f975
#: ../../java/routing.rst:18
msgid "A Simple Router"
msgstr ""

# 722e2111e75e4dc390db73b684ecd91a
#: ../../java/routing.rst:20
msgid ""
"The following example illustrates how to use a ``Router`` and manage the "
"routees from within an actor."
msgstr ""

# d80847b88dbd47c49042c8594efeb259
#: ../../java/routing.rst:24
msgid ""
"We create a ``Router`` and specify that it should use "
"``RoundRobinRoutingLogic`` when routing the messages to the routees."
msgstr ""

# c85e257ec65a47e3a073e34375f60977
#: ../../java/routing.rst:27
msgid "The routing logic shipped with Akka are:"
msgstr ""

# c505938302094c4ab486f8c46353ec48
#: ../../java/routing.rst:29
msgid "``akka.routing.RoundRobinRoutingLogic``"
msgstr ""

# b938acefb19c4a3082eba373c6f25f6b
#: ../../java/routing.rst:30
msgid "``akka.routing.RandomRoutingLogic``"
msgstr ""

# 12e6278931734652bfd4fb2978b7bf7d
#: ../../java/routing.rst:31
msgid "``akka.routing.SmallestMailboxRoutingLogic``"
msgstr ""

# 1b0e5fd4d1eb46efa44ee83f6ad4eac3
#: ../../java/routing.rst:32
msgid "``akka.routing.BroadcastRoutingLogic``"
msgstr ""

# 0e879b1b3eb046188a7b1259d75fffbc
#: ../../java/routing.rst:33
msgid "``akka.routing.ScatterGatherFirstCompletedRoutingLogic``"
msgstr ""

# 4589c1ca2af84521b7debd0f15c9224b
#: ../../java/routing.rst:34
msgid "``akka.routing.TailChoppingRoutingLogic``"
msgstr ""

# c136efef7688447d9d5be463bb94d008
#: ../../java/routing.rst:35
msgid "``akka.routing.ConsistentHashingRoutingLogic``"
msgstr ""

# df2be331208a491cb332e2533e159448
#: ../../java/routing.rst:37
msgid ""
"We create the routees as ordinary child actors wrapped in "
"``ActorRefRoutee``. We watch the routees to be able to replace them if they "
"are terminated."
msgstr ""

# 2b98cc50aba4478ebb0f928fa7d0917b
#: ../../java/routing.rst:40
msgid ""
"Sending messages via the router is done with the ``route`` method, as is "
"done for the ``Work`` messages in the example above."
msgstr ""

# e55b5d290c984f72962f8ff028dee979
#: ../../java/routing.rst:43
msgid ""
"The ``Router`` is immutable and the ``RoutingLogic`` is thread safe; meaning"
" that they can also be used outside of actors."
msgstr ""

# 9629f17832684c78bcd58f7f15a24159
#: ../../java/routing.rst:48
msgid ""
"In general, any message sent to a router will be sent onwards to its "
"routees, but there is one exception. The special :ref:`broadcast-messages-"
"java` will send to *all* of a router's routees. However, do not use :ref"
":`broadcast-messages-java` when you use :ref:`balancing-pool-java` for "
"routees as described in :ref:`router-special-messages-java`."
msgstr ""

# aa9d3b16b85e4281b5afa55e0ba51f41
#: ../../java/routing.rst:54
msgid "A Router Actor"
msgstr ""

# 7385d7ff968249deb7245167d0eeacf7
#: ../../java/routing.rst:56
msgid ""
"A router can also be created as a self contained actor that manages the "
"routees itself and loads routing logic and other settings from "
"configuration."
msgstr ""

# ed8907bb28b44284a81de68cf8cf636a
#: ../../java/routing.rst:59
msgid "This type of router actor comes in two distinct flavors:"
msgstr ""

# dda448a199904a10a335e9db3fc75eaa
#: ../../java/routing.rst:61
msgid ""
"Pool - The router creates routees as child actors and removes them from the "
"router if they terminate."
msgstr ""

# 654adabefa134cac8328fc52893755ad
#: ../../java/routing.rst:64
msgid ""
"Group - The routee actors are created externally to the router and the "
"router sends messages to the specified path using actor selection, without "
"watching for termination."
msgstr ""

# 7e03fd5c231a455a8cf2c1dec17326bf
#: ../../java/routing.rst:67
msgid ""
"The settings for a router actor can be defined in configuration or "
"programmatically. In order to make an actor to make use of an externally "
"configurable router the ``FromConfig`` props wrapper must be used to denote "
"that the actor accepts routing settings from configuration. This is in "
"contrast with Remote Deployment where such marker props is not necessary. If"
" the props of an actor is NOT wrapped in ``FromConfig`` it will ignore the "
"router section of the deployment configuration."
msgstr ""

# 60bff193681a4569a08a9762c2545b8b
#: ../../java/routing.rst:73
msgid ""
"You send messages to the routees via the router actor in the same way as for"
" ordinary actors, i.e. via its ``ActorRef``. The router actor forwards "
"messages onto its routees without changing the original sender. When a "
"routee replies to a routed message, the reply will be sent to the original "
"sender, not to the router actor."
msgstr ""

# 1ec80ab66f56437b9d2ad41134a2d5c4
#: ../../java/routing.rst:80
msgid ""
"In general, any message sent to a router will be sent onwards to its "
"routees, but there are a few exceptions. These are documented in the :ref"
":`router-special-messages-java` section below."
msgstr ""

# 702ac2c5083640868bd5f442b6c62f9a
#: ../../java/routing.rst:84
msgid "Pool"
msgstr ""

# cf30ba379d3c495d950abce15103a722
#: ../../java/routing.rst:86
msgid ""
"The following code and configuration snippets show how to create a :ref"
":`round-robin <round-robin-router-java>` router that forwards messages to "
"five ``Worker`` routees. The routees will be created as the router's "
"children."
msgstr ""

# 662520582ad14493a30168282d5e4ce2
# 5dc7b9083c8747bba73b25f105b20af7
#: ../../java/routing.rst:94 ../../java/routing.rst:179
msgid ""
"Here is the same example, but with the router configuration provided "
"programmatically instead of from configuration."
msgstr ""

# 43f442fa57194a529539add38eb14da9
#: ../../java/routing.rst:100
msgid "Remote Deployed Routees"
msgstr ""

# b656f1197a454cdfb35e1d12f5694e82
#: ../../java/routing.rst:102
msgid ""
"In addition to being able to create local actors as routees, you can "
"instruct the router to deploy its created children on a set of remote hosts."
" Routees will be deployed in round-robin fashion. In order to deploy routees"
" remotely, wrap the router configuration in a ``RemoteRouterConfig``, "
"attaching the remote addresses of the nodes to deploy to. Remote deployment "
"requires the ``akka-remote`` module to be included in the classpath."
msgstr ""

# 7e7813628a6649388d5f99d5c44ae801
#: ../../java/routing.rst:111
msgid "Senders"
msgstr ""

# 0f8a3ac087524db9b9d5dcf33ef23bad
#: ../../java/routing.rst:114
msgid ""
"When a routee sends a message, it can :ref:`set itself as the sender "
"<actors-tell-sender-java>`."
msgstr ""

# aa21a5826b234967b142759594ecc9d5
#: ../../java/routing.rst:119
msgid ""
"However, it is often useful for routees to set the *router* as a sender. For"
" example, you might want to set the router as the sender if you want to hide"
" the details of the routees behind the router. The following code snippet "
"shows how to set the parent router as sender."
msgstr ""

# 895e6704b5e543e1bedf3f04b9dfed80
#: ../../java/routing.rst:129
msgid ""
"Routees that are created by a pool router will be created as the router's "
"children. The router is therefore also the children's supervisor."
msgstr ""

# 1b47ca3f2af64e1496ec8391f2c1bacd
#: ../../java/routing.rst:132
msgid ""
"The supervision strategy of the router actor can be configured with the "
"``supervisorStrategy`` property of the Pool. If no configuration is "
"provided, routers default to a strategy of “always escalate”. This means "
"that errors are passed up to the router's supervisor for handling. The "
"router's supervisor will decide what to do about any errors."
msgstr ""

# 9f08b74dfe9a4aa6a61fd24de79aad9b
#: ../../java/routing.rst:137
msgid ""
"Note the router's supervisor will treat the error as an error with the "
"router itself. Therefore a directive to stop or restart will cause the "
"router *itself* to stop or restart. The router, in turn, will cause its "
"children to stop and restart."
msgstr ""

# ad660b3306054ded9f1180d38964939c
#: ../../java/routing.rst:141
msgid ""
"It should be mentioned that the router's restart behavior has been "
"overridden so that a restart, while still re-creating the children, will "
"still preserve the same number of actors in the pool."
msgstr ""

# f3b0428f753240b2adacfbed6b45103d
#: ../../java/routing.rst:144
msgid ""
"This means that if you have not specified :meth:`supervisorStrategy` of the "
"router or its parent a failure in a routee will escalate to the parent of "
"the router, which will by default restart the router, which will restart all"
" routees (it uses Escalate and does not stop routees during restart). The "
"reason is to make the default behave such that adding :meth:`.withRouter` to"
" a child’s definition does not change the supervision strategy applied to "
"the child. This might be an inefficiency that you can avoid by specifying "
"the strategy when defining the router."
msgstr ""

# bc7e381399684fa7b89e7c446b282313
#: ../../java/routing.rst:151
msgid "Setting the strategy is easily done:"
msgstr ""

# c67cd4bbf3b64607af56bc6c0a06f130
#: ../../java/routing.rst:159
msgid ""
"If the child of a pool router terminates, the pool router will not "
"automatically spawn a new child. In the event that all children of a pool "
"router have terminated the router will terminate itself unless it is a "
"dynamic router, e.g. using a resizer."
msgstr ""

# fb2b9e2cdbd34c248f7c285e69da0dc7
#: ../../java/routing.rst:165
msgid "Group"
msgstr ""

# 2122e843b4fe4326944cbc9ed30e7bcd
#: ../../java/routing.rst:167
msgid ""
"Sometimes, rather than having the router actor create its routees, it is "
"desirable to create routees separately and provide them to the router for "
"its use. You can do this by passing an paths of the routees to the router's "
"configuration. Messages will be sent with ``ActorSelection`` to these paths."
msgstr ""

# 6dda766063aa425db4d7e6de67b2b703
#: ../../java/routing.rst:172
msgid ""
"The example below shows how to create a router by providing it with the path"
" strings of three routee actors."
msgstr ""

# adcb1eca7bda470a9ba54eb2276f30a7
#: ../../java/routing.rst:184
msgid "The routee actors are created externally from the router:"
msgstr ""

# a6856000e0744d51ad1bffeb2389d35b
#: ../../java/routing.rst:190
msgid ""
"The paths may contain protocol and address information for actors running on"
" remote hosts. Remoting requires the ``akka-remote`` module to be included "
"in the classpath."
msgstr ""

# 39451438ae5d47979a4ddd4936748a55
#: ../../java/routing.rst:196
msgid "Router usage"
msgstr ""

# 52e7d8401ffc4d00a59066ebe7e17ad3
#: ../../java/routing.rst:198
msgid ""
"In this section we will describe how to create the different types of router"
" actors."
msgstr ""

# fea88687b89f4f8399e36fd8194ceea3
#: ../../java/routing.rst:200
msgid ""
"The router actors in this section are created from within a top level actor "
"named ``parent``. Note that deployment paths in the configuration starts "
"with ``/parent/`` followed by the name of the router actor."
msgstr ""

# fdcefb45ab854bda93b07348badbe66b
#: ../../java/routing.rst:209
msgid "RoundRobinPool and RoundRobinGroup"
msgstr ""

# a995e900e4834085989b1e486c0de2db
#: ../../java/routing.rst:211
msgid ""
"Routes in a `round-robin <http://en.wikipedia.org/wiki/Round-robin>`_ "
"fashion to its routees."
msgstr ""

# 39e509e9a5984ef997141c870b44446e
#: ../../java/routing.rst:213
msgid "RoundRobinPool defined in configuration:"
msgstr ""

# e9a0e7be2966406481f627577112c92b
#: ../../java/routing.rst:219
msgid "RoundRobinPool defined in code:"
msgstr ""

# 45078a6f6ec24508830fbb59b4298326
#: ../../java/routing.rst:223
msgid "RoundRobinGroup defined in configuration:"
msgstr ""

# 50d4352ef54a4f499fd80e325e07130f
#: ../../java/routing.rst:229
msgid "RoundRobinGroup defined in code:"
msgstr ""

# 6ecf23664fad4e82811620d5b4989f63
#: ../../java/routing.rst:235
msgid "RandomPool and RandomGroup"
msgstr ""

# 93ac3c5520e84004b6c17716ea537d45
#: ../../java/routing.rst:237
msgid "This router type selects one of its routees randomly for each message."
msgstr ""

# 28beebb412bc492e879d45f2a6c7a0c6
#: ../../java/routing.rst:239
msgid "RandomPool defined in configuration:"
msgstr ""

# 0b6d6b1940454c44a553e5de983ac0e1
#: ../../java/routing.rst:245
msgid "RandomPool defined in code:"
msgstr ""

# f91865fdb92246f3b4e527a2eb9ddcda
#: ../../java/routing.rst:249
msgid "RandomGroup defined in configuration:"
msgstr ""

# 3e142950dc6d45519ffc574e02e3c75d
#: ../../java/routing.rst:255
msgid "RandomGroup defined in code:"
msgstr ""

# d2d045f3d1b2493a94d3b9d9002adb57
#: ../../java/routing.rst:263
msgid "BalancingPool"
msgstr ""

# dd470cd2b8d74a2abb5e88065017b7e7
#: ../../java/routing.rst:265
msgid ""
"A Router that will try to redistribute work from busy routees to idle "
"routees. All routees share the same mailbox."
msgstr ""

# 2e23f00d69d64b308eb3bdab720bcc14
#: ../../java/routing.rst:270
msgid ""
"The BalancingPool has the property that its routees do not have truly "
"distinct identity: they have different names, but talking to them will not "
"end up at the right actor in most cases. Therefore you cannot use it for "
"workflows that require state to be kept within the routee, you would in this"
" case have to include the whole state in the messages."
msgstr ""

# 9391531187574e73b6fc23493c389a87
#: ../../java/routing.rst:276
msgid ""
"With a `SmallestMailboxPool`_ you can have a vertically scaling service that"
" can interact in a stateful fashion with other services in the back-end "
"before replying to the original client. The other advantage is that it does "
"not place a restriction on the message queue implementation as BalancingPool"
" does."
msgstr ""

# 019d47751e474341a93607d358afc4b4
#: ../../java/routing.rst:282
msgid ""
"Do not use :ref:`broadcast-messages-java` when you use :ref:`balancing-pool-"
"java` for routers, as described in :ref:`router-special-messages-java`."
msgstr ""

# 4bf752e2acbd4cc0a2ef76d63eeab6bf
#: ../../java/routing.rst:285
msgid "BalancingPool defined in configuration:"
msgstr ""

# c95a411cd06042b39c9fb372b2075c5e
#: ../../java/routing.rst:291
msgid "BalancingPool defined in code:"
msgstr ""

# 70f938f02b9b4f319c815f2c484a89af
#: ../../java/routing.rst:295
msgid ""
"Addition configuration for the balancing dispatcher, which is used by the "
"pool, can be configured in the ``pool-dispatcher`` section of the router "
"deployment configuration."
msgstr ""

# 63184ac764524f7daee522c80981e3bd
#: ../../java/routing.rst:301
msgid ""
"The ``BalancingPool`` automatically uses a special ``BalancingDispatcher`` "
"for its routees - disregarding any dispatcher that is set on the routee "
"Props object. This is needed in order to implement the balancing semantics "
"via sharing the same mailbox by all the routees."
msgstr ""

# 85749be4e5d2441e870d93601b6d78f4
#: ../../java/routing.rst:306
msgid ""
"While it is not possible to change the dispatcher used by the routees, it is"
" possible to fine tune the used *executor*. By default the ``fork-join-"
"dispatcher`` is used and can be configured as explained in :ref"
":`dispatchers-java`. In situations where the routees are expected to perform"
" blocking operations it may be useful to replace it with a ``thread-pool-"
"executor`` hinting the number of allocated threads explicitly:"
msgstr ""

# 5278544ece8d448fbe371514172a55d0
#: ../../java/routing.rst:314
msgid ""
"It is also possible to change the ``mailbox`` used by the balancing "
"dispatcher for scenarios where the default unbounded mailbox is not well "
"suited. An example of such a scenario could arise whether there exists the "
"need to manage priority for each message. You can then implement a priority "
"mailbox and configure your dispatcher:"
msgstr ""

# b4ca5beb4b924a8a93892b66a4d3aa7b
#: ../../java/routing.rst:323
msgid ""
"Bear in mind that ``BalancingDispatcher`` requires a message queue that must"
" be thread-safe for multiple concurrent consumers. So it is mandatory for "
"the message queue backing a custom mailbox for this kind of dispatcher to "
"implement akka.dispatch.MultipleConsumerSemantics. See details on how to "
"implement your custom mailbox in :ref:`mailboxes-java`."
msgstr ""

# c1883aa1516745c3904bd606eecbd926
#: ../../java/routing.rst:328
msgid "There is no Group variant of the BalancingPool."
msgstr ""

# 75228902ecd54a06819e05ecbf6b8fa5
#: ../../java/routing.rst:331
msgid "SmallestMailboxPool"
msgstr ""

# de05f90c5c4044cfbe0415cefb6425c5
#: ../../java/routing.rst:333
msgid ""
"A Router that tries to send to the non-suspended child routee with fewest "
"messages in mailbox. The selection is done in this order:"
msgstr ""

# 877f712f27794fee896ddef5c8fb6e07
#: ../../java/routing.rst:336
msgid "pick any idle routee (not processing message) with empty mailbox"
msgstr ""

# b8ca75f12e204fc08f46752d4570708d
#: ../../java/routing.rst:337
msgid "pick any routee with empty mailbox"
msgstr ""

# f7d02aa538564d8bbe0731edb7da4367
#: ../../java/routing.rst:338
msgid "pick routee with fewest pending messages in mailbox"
msgstr ""

# 8cb5f67c395a49a9b97f2f177e7d2699
#: ../../java/routing.rst:339
msgid ""
"pick any remote routee, remote actors are consider lowest priority, since "
"their mailbox size is unknown"
msgstr ""

# f0169188f2b94007b0f5fe05b42825c1
#: ../../java/routing.rst:342
msgid "SmallestMailboxPool defined in configuration:"
msgstr ""

# 8dc53f9ce6cf4553968666bef2ebebea
#: ../../java/routing.rst:348
msgid "SmallestMailboxPool defined in code:"
msgstr ""

# 2ef1d496ae6544e09db20556c7203ac4
#: ../../java/routing.rst:352
msgid ""
"There is no Group variant of the SmallestMailboxPool because the size of the"
" mailbox and the internal dispatching state of the actor is not practically "
"available from the paths of the routees."
msgstr ""

# 7566cec7e3f346318155ed6c426847f4
#: ../../java/routing.rst:357
msgid "BroadcastPool and BroadcastGroup"
msgstr ""

# f216256eb2714f0aab84da31836ae8f0
#: ../../java/routing.rst:359
msgid ""
"A broadcast router forwards the message it receives to *all* its routees."
msgstr ""

# 67b5863436c848f0b7d48502a4d46278
#: ../../java/routing.rst:361
msgid "BroadcastPool defined in configuration:"
msgstr ""

# 2f1deb3b91e4443eb4a33765ea175551
#: ../../java/routing.rst:367
msgid "BroadcastPool defined in code:"
msgstr ""

# ac009a8d8cd24277905f7b81e9a72cc0
#: ../../java/routing.rst:371
msgid "BroadcastGroup defined in configuration:"
msgstr ""

# 341a43de2c2546f7912cb3d333dffa1e
#: ../../java/routing.rst:377
msgid "BroadcastGroup defined in code:"
msgstr ""

# 39c7813016fa4d858d008a4df323b4c5
#: ../../java/routing.rst:384
msgid ""
"Broadcast routers always broadcast *every* message to their routees. If you "
"do not want to broadcast every message, then you can use a non-broadcasting "
"router and use :ref:`broadcast-messages-java` as needed."
msgstr ""

# 3aced36b060f4aa4aa877c6ade9dfd1a
#: ../../java/routing.rst:390
msgid "ScatterGatherFirstCompletedPool and ScatterGatherFirstCompletedGroup"
msgstr ""

# d835f1d9338345c29892ab0209d9212a
#: ../../java/routing.rst:392
msgid ""
"The ScatterGatherFirstCompletedRouter will send the message on to all its "
"routees. It then waits for first reply it gets back. This result will be "
"sent back to original sender. Other replies are discarded."
msgstr ""

# f061e95329ba4ac29c5b12fa69417a59
#: ../../java/routing.rst:396
msgid ""
"It is expecting at least one reply within a configured duration, otherwise "
"it will reply with ``akka.pattern.AskTimeoutException`` in a "
"``akka.actor.Status.Failure``."
msgstr ""

# 23cc3280e8a14ff4ae8fa725ae2cee80
#: ../../java/routing.rst:399
msgid "ScatterGatherFirstCompletedPool defined in configuration:"
msgstr ""

# 043cfecb2ce94b07ae563380fe4f962e
#: ../../java/routing.rst:405
msgid "ScatterGatherFirstCompletedPool defined in code:"
msgstr ""

# cd14f6dd0af2429796b9288d0acd1778
#: ../../java/routing.rst:409
msgid "ScatterGatherFirstCompletedGroup defined in configuration:"
msgstr ""

# f5c36f665d1d4f20b737e4c3ff124da7
#: ../../java/routing.rst:415
msgid "ScatterGatherFirstCompletedGroup defined in code:"
msgstr ""

# 04971b2f3454463b9531698dca2a5e08
#: ../../java/routing.rst:421
msgid "TailChoppingPool and TailChoppingGroup"
msgstr ""

# 98b9193ea8f54cb3afa048cae2719d30
#: ../../java/routing.rst:423
msgid ""
"The TailChoppingRouter will first send the message to one, randomly picked, "
"routee and then after a small delay to a second routee (picked randomly from"
" the remaining routees) and so on. It waits for first reply it gets back and"
" forwards it back to original sender. Other replies are discarded."
msgstr ""

# 06298e3d98d7407e98f8d77cde25cc72
#: ../../java/routing.rst:427
msgid ""
"The goal of this router is to decrease latency by performing redundant "
"queries to multiple routees, assuming that one of the other actors may still"
" be faster to respond than the initial one."
msgstr ""

# 5bd898ea51224171ba7e756e9e2c80f0
#: ../../java/routing.rst:430
msgid ""
"This optimisation was described nicely in a blog post by Peter Bailis: "
"`Doing redundant work to speed up distributed queries "
"<http://www.bailis.org/blog/doing-redundant-work-to-speed-up-distributed-"
"queries/>`_."
msgstr ""

# 13c8a016a71c4edcbbefffd59f8a65f8
#: ../../java/routing.rst:433
msgid "TailChoppingPool defined in configuration:"
msgstr ""

# 1c16a9292397485d8a51ff31bf7540a2
#: ../../java/routing.rst:439
msgid "TailChoppingPool defined in code:"
msgstr ""

# c1c760780b6c444ea383ec7aceb18a96
#: ../../java/routing.rst:443
msgid "TailChoppingGroup defined in configuration:"
msgstr ""

# 98690d97fa9f464ba88c79bbb1ec3cec
#: ../../java/routing.rst:449
msgid "TailChoppingGroup defined in code:"
msgstr ""

# c049037b4ed248f1ae13c0c32b17fc5f
#: ../../java/routing.rst:455
msgid "ConsistentHashingPool and ConsistentHashingGroup"
msgstr ""

# 2e8dff9014e948afa01a1049154129cc
#: ../../java/routing.rst:457
msgid ""
"The ConsistentHashingPool uses `consistent hashing "
"<http://en.wikipedia.org/wiki/Consistent_hashing>`_ to select a routee based"
" on the sent message. This `article "
"<http://weblogs.java.net/blog/tomwhite/archive/2007/11/consistent_hash.html>`_"
" gives good insight into how consistent hashing is implemented."
msgstr ""

# 7150c759cf8c4f3ead8e479bab07f342
#: ../../java/routing.rst:462
msgid ""
"There is 3 ways to define what data to use for the consistent hash key."
msgstr ""

# 5701a14cb7a84f8db4b830250b5b32cd
#: ../../java/routing.rst:464
msgid ""
"You can define ``withHashMapper`` of the router to map incoming messages to "
"their consistent hash key. This makes the decision transparent for the "
"sender."
msgstr ""

# 0faba222a347461595ef668e3121d3fe
#: ../../java/routing.rst:468
msgid ""
"The messages may implement "
"``akka.routing.ConsistentHashingRouter.ConsistentHashable``. The key is part"
" of the message and it's convenient to define it together with the message "
"definition."
msgstr ""

# 42ce7141af87421b8601c2131fc86acc
#: ../../java/routing.rst:472
msgid ""
"The messages can be wrapped in a "
"``akka.routing.ConsistentHashingRouter.ConsistentHashableEnvelope`` to "
"define what data to use for the consistent hash key. The sender knows the "
"key to use."
msgstr ""

# bbeee3fee4ae4608bde68354fdc3b692
#: ../../java/routing.rst:476
msgid ""
"These ways to define the consistent hash key can be use together and at the "
"same time for one router. The ``withHashMapper`` is tried first."
msgstr ""

# 8c2c495c4e2f4d42961e0aba7f74b1b0
#: ../../java/routing.rst:480
msgid "Code example:"
msgstr ""

# 8048a96afb1f42aeaaf16cf3a3b83e06
#: ../../java/routing.rst:486
msgid ""
"In the above example you see that the ``Get`` message implements "
"``ConsistentHashable`` itself, while the ``Entry`` message is wrapped in a "
"``ConsistentHashableEnvelope``. The ``Evict`` message is handled by the "
"``hashMapping`` partial function."
msgstr ""

# 4315657d7344463b97cfdc4c8ec11829
#: ../../java/routing.rst:490
msgid "ConsistentHashingPool defined in configuration:"
msgstr ""

# dd9e163fda4c4776a0582d58813713ff
#: ../../java/routing.rst:496
msgid "ConsistentHashingPool defined in code:"
msgstr ""

# d3dfea2b3b0b49838235fbef02f62191
#: ../../java/routing.rst:500
msgid "ConsistentHashingGroup defined in configuration:"
msgstr ""

# 10fc4e32240f4ea0a8289798276596af
#: ../../java/routing.rst:506
msgid "ConsistentHashingGroup defined in code:"
msgstr ""

# 49e226ae7f834c68a7a802df32f8a306
#: ../../java/routing.rst:512
msgid ""
"``virtual-nodes-factor`` is the number of virtual nodes per routee that is "
"used in the consistent hash node ring to make the distribution more uniform."
msgstr ""

# b8b6135c43724e4f9954e7381b4d516d
#: ../../java/routing.rst:518
msgid "Specially Handled Messages"
msgstr ""

# ee86e31059cf4d048dc76d7d674aba97
#: ../../java/routing.rst:520
msgid ""
"Most messages sent to router actors will be forwarded according to the "
"routers' routing logic. However there are a few types of messages that have "
"special behavior."
msgstr ""

# c43c14ae9b5043c59b71e463ed0b4418
#: ../../java/routing.rst:523
msgid ""
"Note that these special messages, except for the ``Broadcast`` message, are "
"only handled by self contained router actors and not by the "
"``akka.routing.Router`` component described in :ref:`simple-router-java`."
msgstr ""

# 77ac4e32e49c461e857a0be392d55d64
#: ../../java/routing.rst:530
msgid "Broadcast Messages"
msgstr ""

# 4337289c1e87430d8499a8110e1f8c16
#: ../../java/routing.rst:532
msgid ""
"A ``Broadcast`` message can be used to send a message to *all* of a router's"
" routees. When a router receives a ``Broadcast`` message, it will broadcast "
"that message's *payload* to all routees, no matter how that router would "
"normally route its messages."
msgstr ""

# 838c728eacd24d4896012b4cf0353ecc
#: ../../java/routing.rst:536
msgid ""
"The example below shows how you would use a ``Broadcast`` message to send a "
"very important message to every routee of a router."
msgstr ""

# 28312aaabd3e483ab80e1995dd36ab64
#: ../../java/routing.rst:541
msgid ""
"In this example the router receives the ``Broadcast`` message, extracts its "
"payload (``\"Watch out for Davy Jones' locker\"``), and then sends the "
"payload on to all of the router's routees. It is up to each routee actor to "
"handle the received payload message."
msgstr ""

# b5f733f17aa644b09b970d895a074918
#: ../../java/routing.rst:546
msgid ""
"Do not use :ref:`broadcast-messages-java` when you use :ref:`balancing-pool-"
"java` for routers. Routees on :ref:`balancing-pool-java` shares the same "
"mailbox instance, thus some routees can possibly get the broadcast message "
"multiple times, while other routees get no broadcast message."
msgstr ""

# 1209bba8d2364a3b828392c0c979af1f
#: ../../java/routing.rst:551
msgid "PoisonPill Messages"
msgstr ""

# 87b60b03b5784411b990f0c7d63b0f2a
#: ../../java/routing.rst:553
msgid ""
"A ``PoisonPill`` message has special handling for all actors, including for "
"routers. When any actor receives a ``PoisonPill`` message, that actor will "
"be stopped. See the :ref:`poison-pill-java` documentation for details."
msgstr ""

# b8d43b84d0844ffc9a194579226bdf12
#: ../../java/routing.rst:559
msgid ""
"For a router, which normally passes on messages to routees, it is important "
"to realise that ``PoisonPill`` messages are processed by the router only. "
"``PoisonPill`` messages sent to a router will *not* be sent on to routees."
msgstr ""

# 3b5639cf1d884c9ab505a6cf2448b944
#: ../../java/routing.rst:563
msgid ""
"However, a ``PoisonPill`` message sent to a router may still affect its "
"routees, because it will stop the router and when the router stops it also "
"stops its children. Stopping children is normal actor behavior. The router "
"will stop routees that it has created as children. Each child will process "
"its current message and then stop. This may lead to some messages being "
"unprocessed. See the documentation on :ref:`stopping-actors-java` for more "
"information."
msgstr ""

# 2023c6caab9440f6811264f2ebfbfb40
#: ../../java/routing.rst:569
msgid ""
"If you wish to stop a router and its routees, but you would like the routees"
" to first process all the messages currently in their mailboxes, then you "
"should not send a ``PoisonPill`` message to the router. Instead you should "
"wrap a ``PoisonPill`` message inside a ``Broadcast`` message so that each "
"routee will receive the ``PoisonPill`` message. Note that this will stop all"
" routees, even if the routees aren't children of the router, i.e. even "
"routees programmatically provided to the router."
msgstr ""

# 4bda41fd36484cd9a53c802e6cd74a4f
#: ../../java/routing.rst:577
msgid ""
"With the code shown above, each routee will receive a ``PoisonPill`` "
"message. Each routee will continue to process its messages as normal, "
"eventually processing the ``PoisonPill``. This will cause the routee to "
"stop. After all routees have stopped the router will itself be :ref:`stopped"
" automatically <note-router-terminated-children-java>` unless it is a "
"dynamic router, e.g. using a resizer."
msgstr ""

# c5dd3e718bbb40f992fc45f8def99bdd
#: ../../java/routing.rst:585
msgid ""
"Brendan W McAdams' excellent blog post `Distributing Akka Workloads - And "
"Shutting Down Afterwards "
"<http://bytes.codes/2013/01/17/Distributing_Akka_Workloads_And_Shutting_Down_After/>`_"
" discusses in more detail how ``PoisonPill`` messages can be used to shut "
"down routers and routees."
msgstr ""

# 9649e9ddcba74551a425edf99b2015b9
#: ../../java/routing.rst:590
msgid "Kill Messages"
msgstr ""

# 9011cbcde1d9446588c7f3aa2cba6837
#: ../../java/routing.rst:592
msgid ""
"``Kill`` messages are another type of message that has special handling. See"
" :ref:`killing-actors-java` for general information about how actors handle "
"``Kill`` messages."
msgstr ""

# 347c29440fbf492e93a52636fc020aad
#: ../../java/routing.rst:595
msgid ""
"When a ``Kill`` message is sent to a router the router processes the message"
" internally, and does *not* send it on to its routees. The router will throw"
" an ``ActorKilledException`` and fail. It will then be either resumed, "
"restarted or terminated, depending how it is supervised."
msgstr ""

# ceed6fc91c684f1e87e3e760aca34451
#: ../../java/routing.rst:599
msgid ""
"Routees that are children of the router will also be suspended, and will be "
"affected by the supervision directive that is applied to the router. Routees"
" that are not the routers children, i.e. those that were created externally "
"to the router, will not be affected."
msgstr ""

# a583a2ed06b04ffcbf135495a2ad9afa
#: ../../java/routing.rst:605
msgid ""
"As with the ``PoisonPill`` message, there is a distinction between killing a"
" router, which indirectly kills its children (who happen to be routees), and"
" killing routees directly (some of whom may not be children.) To kill "
"routees directly the router should be sent a ``Kill`` message wrapped in a "
"``Broadcast`` message."
msgstr ""

# 5477fb4aeef8493cba29978de9d25966
#: ../../java/routing.rst:613
msgid "Management Messages"
msgstr ""

# cd70849ad4574ccf8a207b7071f5dfb8
#: ../../java/routing.rst:615
msgid ""
"Sending ``akka.routing.GetRoutees`` to a router actor will make it send back"
" its currently used routees in a ``akka.routing.Routees`` message."
msgstr ""

# ff4e2cae71b3444ba8e403ef1b85129d
#: ../../java/routing.rst:617
msgid ""
"Sending ``akka.routing.AddRoutee`` to a router actor will add that routee to"
" its collection of routees."
msgstr ""

# bbdf4739c0aa47fda9f32ccae7b2edcb
#: ../../java/routing.rst:618
msgid ""
"Sending ``akka.routing.RemoveRoutee`` to a router actor will remove that "
"routee to its collection of routees."
msgstr ""

# f53d943e32bc4622aa14e3f0ca3016db
#: ../../java/routing.rst:619
msgid ""
"Sending ``akka.routing.AdjustPoolSize`` to a pool router actor will add or "
"remove that number of routees to its collection of routees."
msgstr ""

# a61993f2dfbd4f84939f447a918bab09
#: ../../java/routing.rst:622
msgid ""
"These management messages may be handled after other messages, so if you "
"send ``AddRoutee`` immediately followed by an ordinary message you are not "
"guaranteed that the routees have been changed when the ordinary message is "
"routed. If you need to know when the change has been applied you can send "
"``AddRoutee`` followed by ``GetRoutees`` and when you receive the "
"``Routees`` reply you know that the preceding change has been applied."
msgstr ""

# 3aea882a7e754ed19531e42c8695dea3
#: ../../java/routing.rst:630
msgid "Dynamically Resizable Pool"
msgstr ""

# fa27445d7d2741c083f1d358e0b40d1b
#: ../../java/routing.rst:632
msgid ""
"All pools can be used with a fixed number of routees or with a resize "
"strategy to adjust the number of routees dynamically."
msgstr ""

# d6c8aab67e764e379f1840052ce4f77b
#: ../../java/routing.rst:635
msgid ""
"There are two types of resizers: the default ``Resizer`` and the "
"``OptimalSizeExploringResizer``."
msgstr ""

# 98b560c99c4e4a53942c50df748dbef2
#: ../../java/routing.rst:638
msgid "Default Resizer"
msgstr ""

# 4d1daca13f584352b1fb1f73c6b0c2cb
#: ../../java/routing.rst:640
msgid ""
"The default resizer ramps up and down pool size based on pressure, measured "
"by the percentage of busy routees in the pool. It ramps up pool size if the "
"pressure is higher than a certain threshold and backs off if the pressure is"
" lower than certain threshold. Both thresholds are configurable."
msgstr ""

# 0b1cb2e773604325a135aeb5b1c702b9
#: ../../java/routing.rst:644
msgid "Pool with default resizer defined in configuration:"
msgstr ""

# fc2d6e53aae34f61a8b217e32e812a09
#: ../../java/routing.rst:650
msgid ""
"Several more configuration options are available and described in "
"``akka.actor.deployment.default.resizer`` section of the reference "
":ref:`configuration`."
msgstr ""

# 3a8bcac08ca44334a1a321411c1ea177
#: ../../java/routing.rst:653
msgid "Pool with resizer defined in code:"
msgstr ""

# 17357004df21460e9333f36005fb22fa
#: ../../java/routing.rst:657
msgid ""
"*It is also worth pointing out that if you define the ``router`` in the "
"configuration file then this value will be used instead of any "
"programmatically sent parameters.*"
msgstr ""

# 1f7005c257044ffa81befb2864c8f0a9
#: ../../java/routing.rst:661
msgid "Optimal Size Exploring Resizer"
msgstr ""

# 5d2d018ad5e441bc935e059b20d84407
#: ../../java/routing.rst:663
msgid ""
"The ``OptimalSizeExploringResizer`` resizes the pool to an optimal size that"
" provides the most message throughput."
msgstr ""

# 4e0edcf8575844aa80f28c6490897d03
#: ../../java/routing.rst:665
msgid ""
"It achieves this by keeping track of message throughput at each pool size "
"and performing one of the following three resizing operations periodically:"
msgstr ""

# 9950982551374b92ac451773e9e67f69
#: ../../java/routing.rst:668
msgid ""
"Downsize if it hasn't seen all routees ever fully utilized for a period of "
"time."
msgstr ""

# 4661908fee084f31b62580bc24ce2128
#: ../../java/routing.rst:669
msgid ""
"Explore to a random nearby pool size to try and collect throughput metrics."
msgstr ""

# b78a0b68ddc74acfaf142737dd5c3afb
#: ../../java/routing.rst:670
msgid ""
"Optimize to a nearby pool size with a better (than any other nearby sizes) "
"throughput metrics."
msgstr ""

# 7d0d5f207e6b471c9e8f4a72085000aa
#: ../../java/routing.rst:672
msgid ""
"When the pool is fully-utilized (i.e. all routees are busy), it randomly "
"choose between exploring and optimizing. When the pool has not been fully-"
"utilized for a period of time, it will downsize the pool to the last seen "
"max utilization multiplied by a configurable ratio."
msgstr ""

# acc68decf35843c5b46524b286096fb1
#: ../../java/routing.rst:676
msgid ""
"By constantly exploring and optimizing, the resizer will eventually walk to "
"the optimal size and remain nearby. When the optimal size changes it will "
"start walking towards the new one. This resizer works best when you expect "
"the pool size to performance function to be a convex function. For example, "
"when you have a CPU bound tasks, the optimal size is bound to the number of "
"CPU cores. When your task is IO bound, the optimal size is bound to optimal "
"number of concurrent connections to that IO service - e.g. a 4 node elastic "
"search cluster may handle 4-8 concurrent requests at optimal speed."
msgstr ""

# e549babbabc1454ca2ba1d64b62b96a2
#: ../../java/routing.rst:683
msgid ""
"It keeps a performance log so it's stateful as well as having a larger "
"memory footprint than the default ``Resizer``. The memory usage is O(n) "
"where n is the number of sizes you allow, i.e. upperBound - lowerBound."
msgstr ""

# 63dd1ed9cbcb44e1b22d46cc8571d3ed
#: ../../java/routing.rst:686
msgid "Pool with ``OptimalSizeExploringResizer`` defined in configuration:"
msgstr ""

# a0e45ec220464df0a9fa6baf6c53c149
#: ../../java/routing.rst:692
msgid ""
"Several more configuration options are available and described in "
"``akka.actor.deployment.default.optimal-size-exploring-resizer`` section of "
"the reference :ref:`configuration`."
msgstr ""

# 5b4d40a8306849e4aa67dcc322285368
#: ../../java/routing.rst:697
msgid ""
"Resizing is triggered by sending messages to the actor pool, but it is not "
"completed synchronously; instead a message is sent to the “head” "
"``RouterActor`` to perform the size change. Thus you cannot rely on resizing"
" to instantaneously create new workers when all others are busy, because the"
" message just sent will be queued to the mailbox of a busy actor. To remedy "
"this, configure the pool to use a balancing dispatcher, see `Configuring "
"Dispatchers`_ for more information."
msgstr ""

# c006ff4e53d542adb124b2e2aefb62d0
#: ../../java/routing.rst:708
msgid "How Routing is Designed within Akka"
msgstr ""

# 45e55e81703f40f184d48fc7e0ce6695
#: ../../java/routing.rst:710
msgid ""
"On the surface routers look like normal actors, but they are actually "
"implemented differently. Routers are designed to be extremely efficient at "
"receiving messages and passing them quickly on to routees."
msgstr ""

# 84587e92b47f4a64817dfde5ba300a77
#: ../../java/routing.rst:714
msgid ""
"A normal actor can be used for routing messages, but an actor's single-"
"threaded processing can become a bottleneck. Routers can achieve much higher"
" throughput with an optimization to the usual message-processing pipeline "
"that allows concurrent routing. This is achieved by embedding routers' "
"routing logic directly in their ``ActorRef`` rather than in the router "
"actor. Messages sent to a router's ``ActorRef`` can be immediately routed to"
" the routee, bypassing the single-threaded router actor entirely."
msgstr ""

# 41a305e74365430bb539c852918ea3a3
#: ../../java/routing.rst:721
msgid ""
"The cost to this is, of course, that the internals of routing code are more "
"complicated than if routers were implemented with normal actors. Fortunately"
" all of this complexity is invisible to consumers of the routing API. "
"However, it is something to be aware of when implementing your own routers."
msgstr ""

# 150cb52fcc5146e39c5bd0b84af8ff3d
#: ../../java/routing.rst:729
msgid "Custom Router"
msgstr ""

# a6edeb22e7a344189d4532f816f9e4e9
#: ../../java/routing.rst:731
msgid ""
"You can create your own router should you not find any of the ones provided "
"by Akka sufficient for your needs. In order to roll your own router you have"
" to fulfill certain criteria which are explained in this section."
msgstr ""

# c3185c6dda22459b991fa17b80ed117b
#: ../../java/routing.rst:734
msgid ""
"Before creating your own router you should consider whether a normal actor "
"with router-like behavior might do the job just as well as a full-blown "
"router. As explained :ref:`above <router-design-java>`, the primary benefit "
"of routers over normal actors is their higher performance. But they are "
"somewhat more complicated to write than normal actors. Therefore if lower "
"maximum throughput is acceptable in your application you may wish to stick "
"with traditional actors. This section, however, assumes that you wish to get"
" maximum performance and so demonstrates how you can create your own router."
msgstr ""

# 38665e49076245c5b39c2596af6f7a38
#: ../../java/routing.rst:742
msgid ""
"The router created in this example is replicating each message to a few "
"destinations."
msgstr ""

# b2660de16c894d7696e44d03a7552334
#: ../../java/routing.rst:744
msgid "Start with the routing logic:"
msgstr ""

# 76731f99d9244a6da3b7b60dfc610a0d
#: ../../java/routing.rst:748
msgid ""
"``select`` will be called for each message and in this example pick a few "
"destinations by round-robin, by reusing the existing "
"``RoundRobinRoutingLogic`` and wrap the result in a ``SeveralRoutees`` "
"instance.  ``SeveralRoutees`` will send the message to all of the supplied "
"routes."
msgstr ""

# 9cf55de313294272acbfc5efee443509
#: ../../java/routing.rst:752
msgid ""
"The implementation of the routing logic must be thread safe, since it might "
"be used outside of actors."
msgstr ""

# 30b1f337999c49b7a49d29bf915251e7
#: ../../java/routing.rst:754
msgid "A unit test of the routing logic:"
msgstr ""

# 49c33a3a8e2144329614e605d712c410
#: ../../java/routing.rst:758
msgid ""
"You could stop here and use the ``RedundancyRoutingLogic`` with a "
"``akka.routing.Router`` as described in :ref:`simple-router-java`."
msgstr ""

# d72b923a01af4eec9e1a38f9ddb2363f
#: ../../java/routing.rst:761
msgid ""
"Let us continue and make this into a self contained, configurable, router "
"actor."
msgstr ""

# f89e19b13b2f4d899815d8fd9c3fc765
#: ../../java/routing.rst:763
msgid ""
"Create a class that extends ``PoolBase``, ``GroupBase`` or "
"``CustomRouterConfig``. That class is a factory for the routing logic and "
"holds the configuration for the router. Here we make it a ``Group``."
msgstr ""

# c43e8613f38c4dbb96500574a1c9faa9
#: ../../java/routing.rst:768
msgid "This can be used exactly as the router actors provided by Akka."
msgstr ""

# 3047fa7e4b0a4e1da37483150a20b971
#: ../../java/routing.rst:772
msgid ""
"Note that we added a constructor in ``RedundancyGroup`` that takes a "
"``Config`` parameter. That makes it possible to define it in configuration."
msgstr ""

# f9ae33bf886e4d8396613670dea20a43
#: ../../java/routing.rst:777
msgid ""
"Note the fully qualified class name in the ``router`` property. The router "
"class must extend ``akka.routing.RouterConfig`` (``Pool``, ``Group`` or "
"``CustomRouterConfig``) and have constructor with one "
"``com.typesafe.config.Config`` parameter. The deployment section of the "
"configuration is passed to the constructor."
msgstr ""

# cb3f0905fea643ffb2c0b8051e3c2976
#: ../../java/routing.rst:785
msgid "Configuring Dispatchers"
msgstr ""

# 6c9f3dfa260f47ccbad171f7bab6e3d2
#: ../../java/routing.rst:787
msgid ""
"The dispatcher for created children of the pool will be taken from ``Props``"
" as described in :ref:`dispatchers-scala`."
msgstr ""

# c94db8f6270e46b98aafe08557868b47
#: ../../java/routing.rst:790
msgid ""
"To make it easy to define the dispatcher of the routees of the pool you can "
"define the dispatcher inline in the deployment section of the config."
msgstr ""

# a84aba71398a4f778e6eba4a67adc5f6
#: ../../java/routing.rst:795
msgid ""
"That is the only thing you need to do enable a dedicated dispatcher for a "
"pool."
msgstr ""

# 156de08be7be45719c833c19ea6616c7
#: ../../java/routing.rst:800
msgid ""
"If you use a group of actors and route to their paths, then they will still "
"use the same dispatcher that was configured for them in their ``Props``, it "
"is not possible to change an actors dispatcher after it has been created."
msgstr ""

# e57383022dc8439ca03759d3e13d9f64
#: ../../java/routing.rst:804
msgid ""
"The “head” router cannot always run on the same dispatcher, because it does "
"not process the same type of messages, hence this special actor does not use"
" the dispatcher configured in ``Props``, but takes the ``routerDispatcher`` "
"from the :class:`RouterConfig` instead, which defaults to the actor system’s"
" default dispatcher. All standard routers allow setting this property in "
"their constructor or factory method, custom routers have to implement the "
"method in a suitable way."
msgstr ""

# c71937b905c040cfbb3a5432b9ed47ff
#: ../../java/routing.rst:816
msgid ""
"It is not allowed to configure the ``routerDispatcher`` to be a "
":class:`akka.dispatch.BalancingDispatcherConfigurator` since the messages "
"meant for the special router actor cannot be processed by any other actor."
msgstr ""

# 25ceabd922c64e06bc912137d9a5c74e
#: ../../java/scheduler.rst:6
msgid "Scheduler"
msgstr ""

# 610c432a08e84a2482d6af444cef37c4
#: ../../java/scheduler.rst:8
msgid ""
"Sometimes the need for making things happen in the future arises, and where "
"do you go look then?  Look no further than ``ActorSystem``! There you find "
"the :meth:`scheduler` method that returns an instance of "
":class:`akka.actor.Scheduler`, this instance is unique per ActorSystem and "
"is used internally for scheduling things to happen at specific points in "
"time."
msgstr ""

# 9636939a8d354860bf6e610c1fbb4077
#: ../../java/scheduler.rst:14
msgid ""
"You can schedule sending of messages to actors and execution of tasks "
"(functions or Runnable).  You will get a ``Cancellable`` back that you can "
"call :meth:`cancel` on to cancel the execution of the scheduled operation."
msgstr ""

# 0fe1f7babc754199b962fbef9c84c823
#: ../../java/scheduler.rst:20
msgid ""
"The default implementation of ``Scheduler`` used by Akka is based on job "
"buckets which are emptied according to a fixed schedule.  It does not "
"execute tasks at the exact time, but on every tick, it will run everything "
"that is (over)due.  The accuracy of the default Scheduler can be modified by"
" the ``akka.scheduler.tick-duration`` configuration property."
msgstr ""

# c06c69ff8c75428fb8927549b27255c2
#: ../../java/scheduler.rst:27
msgid "Some examples"
msgstr ""

# b9e7b73822b44c39a7b5f4f2c9f0a204
#: ../../java/scheduler.rst:29
msgid "Schedule to send the \"foo\"-message to the testActor after 50ms:"
msgstr ""

# c7fabc2d75b84582aa8b5229981f19e6
#: ../../java/scheduler.rst:37
msgid ""
"Schedule a Runnable, that sends the current time to the testActor, to be "
"executed after 50ms:"
msgstr ""

# 570eb00b17904171ac2fd3a5e20346a9
#: ../../java/scheduler.rst:44
msgid ""
"If you schedule Runnable instances you should be extra careful to not pass "
"or close over unstable references. In practice this means that you should "
"not call methods on the enclosing Actor from within the Runnable. If you "
"need to schedule an invocation it is better to use the ``schedule()`` "
"variant accepting a message and an ``ActorRef`` to schedule a message to "
"self (containing the necessary parameters) and then call the method when the"
" message is received."
msgstr ""

# dd78e652b716424280d080fe38e2a20f
#: ../../java/scheduler.rst:51
msgid ""
"Schedule to send the \"Tick\"-message to the ``tickActor`` after 0ms "
"repeating every 50ms:"
msgstr ""

# adc34b933b54414097d679c589888d94
#: ../../java/scheduler.rst:60
msgid "From ``akka.actor.ActorSystem``"
msgstr ""

# 2bd0e9e2aa9d4dc085778dc488c5288c
#: ../../java/scheduler.rst:67
msgid ""
"All scheduled task will be executed when the ``ActorSystem`` is terminated, "
"i.e. the task may execute before its timeout."
msgstr ""

# 6313697bad014a4192fbfd4edebbc085
#: ../../java/scheduler.rst:71
msgid "The Scheduler Interface for Implementors"
msgstr ""

# a7e20b303960491991c3dec236dbff9b
#: ../../java/scheduler.rst:73
msgid ""
"The actual scheduler implementation is loaded reflectively upon "
":class:`ActorSystem` start-up, which means that it is possible to provide a "
"different one using the ``akka.scheduler.implementation`` configuration "
"property. The referenced class must implement the following interface:"
msgstr ""

# 56fe3b9635804fcb88cff51f2642128a
#: ../../java/scheduler.rst:82
msgid "The Cancellable interface"
msgstr ""

# 0739faa11d8641dcafb0ce45ecff5acf
#: ../../java/scheduler.rst:84
msgid ""
"Scheduling a task will result in a :class:`Cancellable` (or throw an "
":class:`IllegalStateException` if attempted after the scheduler’s shutdown)."
" This allows you to cancel something that has been scheduled for execution."
msgstr ""

# e1483e7133124ac69b753fdb81ef2d71
#: ../../java/scheduler.rst:90
msgid ""
"This does not abort the execution of the task, if it had already been "
"started.  Check the return value of ``cancel`` to detect whether the "
"scheduled task was canceled or will (eventually) have run."
msgstr ""

# eb9d845d83c14a35a2bca234a5c5a432
#: ../../java/serialization.rst:8
msgid ""
"Akka has a built-in Extension for serialization, and it is both possible to "
"use the built-in serializers and to write your own."
msgstr ""

# 19728ee75f074b4793e01106a83cc57d
#: ../../java/serialization.rst:11
msgid ""
"The serialization mechanism is both used by Akka internally to serialize "
"messages, and available for ad-hoc serialization of whatever you might need "
"it for."
msgstr ""

# 0e5767523c66492b8581b2d47d82419a
#: ../../java/serialization.rst:15
msgid "Usage"
msgstr ""

# 64dd58999c7a4a6a8810dbbb3d67764e
#: ../../java/serialization.rst:20
msgid ""
"For Akka to know which ``Serializer`` to use for what, you need edit your "
":ref:`configuration`, in the \"akka.actor.serializers\"-section you bind "
"names to implementations of the ``akka.serialization.Serializer`` you wish "
"to use, like this:"
msgstr ""

# f645d960389241918b8fc23d242af17a
#: ../../java/serialization.rst:26
msgid ""
"After you've bound names to different implementations of ``Serializer`` you "
"need to wire which classes should be serialized using which ``Serializer``, "
"this is done in the \"akka.actor.serialization-bindings\"-section:"
msgstr ""

# 66bd9c3c0c6341998c07d6759d9a37d8
#: ../../java/serialization.rst:31
msgid ""
"You only need to specify the name of an interface or abstract base class of "
"the messages. In case of ambiguity, i.e. the message implements several of "
"the configured classes, the most specific configured class will be used, "
"i.e. the one of which all other candidates are superclasses. If this "
"condition cannot be met, because e.g. ``java.io.Serializable`` and "
"``MyOwnSerializable`` both apply and neither is a subtype of the other, a "
"warning will be issued."
msgstr ""

# 4b4cb86df0ef4f378a1e8bee4a6c5a7f
#: ../../java/serialization.rst:38
msgid ""
"Akka provides serializers for :class:`java.io.Serializable` and `protobuf "
"<http://code.google.com/p/protobuf/>`_ "
":class:`com.google.protobuf.GeneratedMessage` by default (the latter only if"
" depending on the akka-remote module), so normally you don't need to add "
"configuration for that; since :class:`com.google.protobuf.GeneratedMessage` "
"implements :class:`java.io.Serializable`, protobuf messages will always be "
"serialized using the protobuf protocol unless specifically overridden. In "
"order to disable a default serializer, map its marker type to “none”::"
msgstr ""

# 1ce88f44740f44d3bfa99c013c84953c
#: ../../java/serialization.rst:52
msgid "Verification"
msgstr ""

# 93687c8efe234c6081660228f0074ca1
#: ../../java/serialization.rst:54
msgid ""
"If you want to verify that your messages are serializable you can enable the"
" following config option:"
msgstr ""

# f417e11dbf2645af84a9951e2842c8e5
# 806346ade4cf473b96954d97487e1708
#: ../../java/serialization.rst:60 ../../java/serialization.rst:69
msgid ""
"We only recommend using the config option turned on when you're running "
"tests. It is completely pointless to have it turned on in other scenarios."
msgstr ""

# 51f41508c32e4be092a314a78bbfc172
#: ../../java/serialization.rst:63
msgid ""
"If you want to verify that your ``Props`` are serializable you can enable "
"the following config option:"
msgstr ""

# 80a8e6ca708c4cb1967e2899dc56ce1f
#: ../../java/serialization.rst:73
msgid "Programmatic"
msgstr ""

# 9d2437f33b7b48da90e7d10a226caec9
#: ../../java/serialization.rst:75
msgid ""
"If you want to programmatically serialize/deserialize using Akka "
"Serialization, here's some examples:"
msgstr ""

# 5b1cd8de5ee74703a53296476ef51444
#: ../../java/serialization.rst:84
msgid ""
"For more information, have a look at the ``ScalaDoc`` for "
"``akka.serialization._``"
msgstr ""

# caead94a83864e9ea4242f70b371ef2a
#: ../../java/serialization.rst:88
msgid "Customization"
msgstr ""

# fcb9c05d45af4a4dbc36b84f27df463d
#: ../../java/serialization.rst:90
msgid ""
"So, lets say that you want to create your own ``Serializer``, you saw the "
"``docs.serialization.MyOwnSerializer`` in the config example above?"
msgstr ""

# 5613ff9932d5468783e08bf3fb28f697
#: ../../java/serialization.rst:94
msgid "Creating new Serializers"
msgstr ""

# 6f8e9fa727c146a39996f1f987b30c62
#: ../../java/serialization.rst:96
msgid ""
"First you need to create a class definition of your ``Serializer``, which is"
" done by extending ``akka.serialization.JSerializer``, like this:"
msgstr ""

# b2bbc9292a1d428bae51f0de5b690f72
#: ../../java/serialization.rst:106
msgid ""
"The manifest is a type hint so that the same serializer can be used for "
"different classes. The manifest parameter in ``fromBinaryJava`` is the class"
" of the object that was serialized. In ``fromBinary`` you can match on the "
"class and deserialize the bytes to different objects."
msgstr ""

# 7505250bd0594254a93cb6d1d4fbca3b
#: ../../java/serialization.rst:111
msgid ""
"Then you only need to fill in the blanks, bind it to a name in your "
":ref:`configuration` and then list which classes that should be serialized "
"using it."
msgstr ""

# fa279d30b00442d2a4843bc256d4a11f
#: ../../java/serialization.rst:117
msgid "Serializer with String Manifest"
msgstr ""

# 10eef55a13734fd790ce5ce2e6fc28c8
#: ../../java/serialization.rst:119
msgid ""
"The ``Serializer`` illustrated above supports a class based manifest (type "
"hint). For serialization of data that need to evolve over time the "
"``SerializerWithStringManifest`` is recommended instead of ``Serializer`` "
"because the manifest (type hint) is a ``String`` instead of a ``Class``. "
"That means that the class can be moved/removed and the serializer can still "
"deserialize old data by matching  on the ``String``. This is especially "
"useful for :ref:`persistence-java`."
msgstr ""

# 0393420b251a48d4b4f3a6fa4db7ecd5
#: ../../java/serialization.rst:126
msgid ""
"The manifest string can also encode a version number that can be used in "
"``fromBinary`` to deserialize in different ways to migrate old data to new "
"domain objects."
msgstr ""

# 9f86db90cfe7418eaba1280519ad51dc
#: ../../java/serialization.rst:129
msgid ""
"If the data was originally serialized with ``Serializer`` and in a later "
"version of the system you change to ``SerializerWithStringManifest`` the "
"manifest string will be the full class name if you used "
"``includeManifest=true``, otherwise it will be the empty string."
msgstr ""

# 0df2f5cfaa394039925ef8b4ff42708d
#: ../../java/serialization.rst:133
msgid "This is how a ``SerializerWithStringManifest`` looks like:"
msgstr ""

# 11cd0116c5fa4b40a9cb1d08e7d2ffc4
#: ../../java/serialization.rst:137
msgid ""
"You must also bind it to a name in your :ref:`configuration` and then list "
"which classes that should be serialized using it."
msgstr ""

# 8ce6b0d493d54b058f8884b31459736c
#: ../../java/serialization.rst:141
msgid "Serializing ActorRefs"
msgstr ""

# 9a8f33a63ae64c61ba0009d71f3524ca
#: ../../java/serialization.rst:143
msgid ""
"All ActorRefs are serializable using JavaSerializer, but in case you are "
"writing your own serializer, you might want to know how to serialize and "
"deserialize them properly. In the general case, the local address to be used"
" depends on the type of remote address which shall be the recipient of the "
"serialized information. Use "
":meth:`Serialization.serializedActorPath(actorRef)` like this:"
msgstr ""

# 9f44e83af4894dcaadce74dcdfb59b0f
#: ../../java/serialization.rst:155
msgid ""
"This assumes that serialization happens in the context of sending a message "
"through the remote transport. There are other uses of serialization, though,"
" e.g. storing actor references outside of an actor application (database, "
"etc.). In this case, it is important to keep in mind that the address part "
"of an actor’s path determines how that actor is communicated with. Storing a"
" local actor path might be the right choice if the retrieval happens in the "
"same logical context, but it is not enough when deserializing it on a "
"different network host: for that it would need to include the system’s "
"remote transport address. An actor system is not limited to having just one "
"remote transport per se, which makes this question a bit more interesting. "
"To find out the appropriate address to use when sending to ``remoteAddr`` "
"you can use :meth:`ActorRefProvider.getExternalAddressFor(remoteAddr)` like "
"this:"
msgstr ""

# 96fb324a63304019804595d98d149007
#: ../../java/serialization.rst:173
msgid ""
"``ActorPath.toSerializationFormatWithAddress`` differs from ``toString`` if "
"the address does not already have ``host`` and ``port`` components, i.e. it "
"only inserts address information for local addresses."
msgstr ""

# 4229ae51f5894d0a907e9d7e9eea32d8
#: ../../java/serialization.rst:177
msgid ""
"``toSerializationFormatWithAddress`` also adds the unique id of the actor, "
"which will change when the actor is stopped and then created again with the "
"same name. Sending messages to a reference pointing the old actor will not "
"be delivered to the new actor. If you do not want this behavior, e.g. in "
"case of long term storage of the reference, you can use "
"``toStringWithAddress``, which does not include the unique id."
msgstr ""

# 199f50b1c4654210ab72d435413a16ba
#: ../../java/serialization.rst:185
msgid ""
"This requires that you know at least which type of address will be supported"
" by the system which will deserialize the resulting actor reference; if you "
"have no concrete address handy you can create a dummy one for the right "
"protocol using ``new Address(protocol, \"\", \"\", 0)`` (assuming that the "
"actual transport used is as lenient as Akka’s RemoteActorRefProvider)."
msgstr ""

# 5bb7877e549f41b4a977efb1e8953b4b
#: ../../java/serialization.rst:191
msgid ""
"There is also a default remote address which is the one used by cluster "
"support (and typical systems have just this one); you can get it like this:"
msgstr ""

# ae861d4f68144845887ddb5f693c0a5b
#: ../../java/serialization.rst:198
msgid "Deep serialization of Actors"
msgstr ""

# f7f1224880ca44c0b3fc806aa92fb8de
#: ../../java/serialization.rst:200
msgid ""
"The recommended approach to do deep serialization of internal actor state is"
" to use Akka :ref:`persistence-java`."
msgstr ""

# 21af65fd65a1480babe30f4137b7c1c5
#: ../../java/serialization.rst:203
msgid "A Word About Java Serialization"
msgstr ""

# b0dc317c583544d09e6cb7f03d901242
#: ../../java/serialization.rst:205
msgid ""
"When using Java serialization without employing the :class:`JavaSerializer` "
"for the task, you must make sure to supply a valid "
":class:`ExtendedActorSystem` in the dynamic variable "
"``JavaSerializer.currentSystem``. This is used when reading in the "
"representation of an :class:`ActorRef` for turning the string representation"
" into a real reference. :class:`DynamicVariable` is a thread-local variable,"
" so be sure to have it set while deserializing anything which might contain "
"actor references."
msgstr ""

# 21d517157ff8437eb4aac8404b48b325
#: ../../java/serialization.rst:214
msgid "External Akka Serializers"
msgstr ""

# a61a25ef853a4cf291e1243f9090af89
#: ../../java/serialization.rst:216
msgid ""
"`Akka-protostuff by Roman Levenstein <https://github.com/romix/akka-"
"protostuff-serialization>`_"
msgstr ""

# 8a86520ced5f4148a7544005e4ca6d4b
#: ../../java/serialization.rst:219
msgid ""
"`Akka-quickser by Roman Levenstein <https://github.com/romix/akka-quickser-"
"serialization>`_"
msgstr ""

# 25dc0ea4bd424aa88ec13b39ff53e48e
#: ../../java/serialization.rst:222
msgid ""
"`Akka-kryo by Roman Levenstein <https://github.com/romix/akka-kryo-"
"serialization>`_"
msgstr ""

# b15a9f731beb42ecbb817af1372c82f1
#: ../../java/serialization.rst:225
msgid ""
"`Twitter Chill Scala extensions for Kryo (based on Akka Version 2.3.x but "
"due to backwards compatibility of the Serializer Interface this extension "
"also works with 2.4.x) <https://github.com/twitter/chill>`_"
msgstr ""

# 75fa8d4cfa114d68a80b8c2699af1370
#: ../../java/stream/index.rst:4
msgid "Streams"
msgstr "ストリーム"

# 61467268029c432f9241bea134bbaebe
#: ../../java/stream/migration-guide-1.0-2.x-java.rst:5
msgid "Migration Guide 1.0 to 2.x"
msgstr ""

# 1fffa984ae8640fea56ecd52f1a75716
#: ../../java/stream/migration-guide-1.0-2.x-java.rst:7
msgid ""
"For this migration guide see `the documentation for Akka Streams 2.0`_."
msgstr ""

# 289c7515dae0442fbba19774c2a694f4
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:5
msgid "Migration Guide 2.0.x to 2.4.x"
msgstr ""

# b7bd71e181c840a1b4d8d7dcc4e4454c
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:8
msgid "General notes"
msgstr ""

# 27d3db06f5424ef2ab6995948077b749
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:11
msgid "Java DSL now uses Java 8 types: CompletionStage and Optional"
msgstr ""

# 5789f4ed5c744c3b8e9655e69330709b
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:13
msgid ""
"In order to provide a top-notch Java API we switched from Scala’s Future and"
" Akka’s ``akka.japi.Option`` interim solutions to the JDK’s own types for "
"deferred computation and optional results. This has been done throughout "
"Streams & HTTP, most notably changing most materialized types, but also the "
"signature of the ``mapAsync`` combinator and the asynchronous route result "
"combinators in the HTTP DSL."
msgstr ""

# dd13758d04fd4b5a8f54827d4931a41a
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:19
msgid ""
"The ``akka.pattern`` package has been updated with a new set of "
"implementations within the ``PatternCS`` class that provide the ability to "
"interact between Actors and Futures (or streams) for ``CompletionStage``."
msgstr ""

# c11034b0fa144691b362b5c8cf37dd73
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:23
msgid ""
"Should you have the need to use Scala Futures with these new Java APIs "
"please use the ``scala-java8-compat`` library that comes as a dependency of "
"Akka. For more information see `the documentation`__."
msgstr ""

# e84c50aeb97f4e16830931c63b4f8179
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:30
msgid "akka.Done and akka.NotUsed replacing Unit and BoxedUnit"
msgstr ""

# 3e5e541129294dad86ff16120d924f11
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:32
msgid ""
"To provide more clear signatures and have a unified API for both Java and "
"Scala two new types have been introduced:"
msgstr ""

# 96f90b726dde4c0ea6282ff9cc5d1011
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:35
msgid ""
"``akka.NotUsed`` is meant to be used instead of ``Unit`` in Scala and "
"``BoxedUnit`` in Java to signify that the type parameter is required but not"
" actually used. This is commonly the case with ``Source``, ``Flow`` and "
"``Sink`` that do not materialize into any value."
msgstr ""

# 9a8be8df79bb492a92400594b3efe136
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:40
msgid ""
"``akka.Done`` is added for the use case where it is boxed inside another "
"object to signify completion but there is no actual value attached to the "
"completion. It is used to replace occurrences of ``Future<BoxedUnit>`` with "
"``Future<Done>`` in Java and ``Future[Unit]`` with ``Future[Done]`` in "
"Scala."
msgstr ""

# 1136b7e5aed94a0d99723f91adfde364
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:45
msgid ""
"All previous usage of ``Unit`` and ``BoxedUnit`` for these two cases in the "
"Akka Streams APIs has been updated."
msgstr ""

# a6de869efdf144808696d8cd6271d965
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:48
msgid "This means that Java code like this::"
msgstr ""

# 6b3245f83a9f48bbb8ab364602183640
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:53
msgid "needs to be changed into::"
msgstr ""

# b79dcc8e8290466b8b7aca13c59e64ed
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:58
msgid ""
"These changes apply to all the places where streams are used, which means "
"that signatures in the persistent query APIs also are affected."
msgstr ""

# ef701b1116f44cfeb8b5d80fa7dab8a4
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:62
msgid "Changed Operators"
msgstr ""

# e339c5336a98492bb41b11b9b59bdd1d
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:65
msgid "``expand()`` is now based on an Iterator"
msgstr ""

# f25782f997834570af87f4cff5db06ea
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:67
msgid ""
"Previously the ``expand`` combinator required two functions as input: the "
"first one lifted incoming values into an extrapolation state and the second "
"one extracted values from that, possibly evolving that state. This has been "
"simplified into a single function that turns the incoming element into an "
"Iterator."
msgstr ""

# 0f71e69c3ddf41f5b6f29f10a9a24171
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:73
msgid ""
"The most prominent use-case previously was to just repeat the previously "
"received value::"
msgstr ""

# 7a31491f8a694d0684c11a23c4994a48
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:78
msgid "In Akka 2.4.x this is simplified to:"
msgstr ""

# 80238864208640e5a3a26fb0d511b3fb
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:82
msgid ""
"If state needs to be be kept during the expansion process then this state "
"will need to be managed by the Iterator. The example of counting the number "
"of expansions might previously have looked like::"
msgstr ""

# 34448d3a0e674d08a19d51648c0badfe
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:91
msgid "In Akka 2.4.x this is formulated like so:"
msgstr ""

# 840361afacf044e4b31d21e69b74a0a8
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:96
msgid "``conflate`` has been renamed to ``conflateWithSeed()``"
msgstr ""

# e3d3925299ec41b8b0933ddb3bee17d3
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:98
msgid ""
"The new ``conflate`` operator is a special case of the original behavior "
"(renamed to ``conflateWithSeed``) that does not change the type of the "
"stream. The usage of the new operator is as simple as::"
msgstr ""

# 4908f3a22b2441bd825fdf44a050f2e1
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:103
msgid ""
"Which is the same as using ``conflateWithSeed`` with an identity function::"
msgstr ""

# 0969a95aeb944b4695ed2ac8df9a4a2c
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:109
msgid "``viaAsync`` and ``viaAsyncMat`` has been replaced with ``async()``"
msgstr ""

# 9a56174b0fe347a69eb1631142f4ac43
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:110
msgid ""
"``async()`` is available from ``Sink``, ``Source``, ``Flow`` and the sub "
"flows. It provides a shortcut for setting the attribute "
"``Attributes.asyncBoundary`` on a flow. The existing methods "
"``Flow.viaAsync`` and ``Flow.viaAsyncMat`` has been removed to make marking "
"out asynchronous boundaries more consistent::"
msgstr ""

# 1f4c77def8e3480a914f9b26238506a6
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:117
msgid "In Akka 2.4.x this will instead look lile this:"
msgstr ""

# 73ec391554d6411190f2387ace2bc99c
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:123
msgid "Changed Sources / Sinks"
msgstr ""

# e08ea431c70941239c035cea5b87f2f2
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:126
msgid "Sink.asPublisher is now configured using an enum"
msgstr ""

# 45a132ec390a4bceb81684cf55af811f
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:128
msgid ""
"In order to not use a meaningless boolean parameter we have changed the "
"signature to:"
msgstr ""

# 63ebc72216e34ec3ac0c11cf28b026e3
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:135
msgid "IO Sources / Sinks materialize IOResult"
msgstr ""

# a56304bdd5c345c9b95ff0e1793fc1cd
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:137
msgid "Materialized values of the following sources and sinks:"
msgstr ""

# 94222fe598754b1ebaad3becd14ed1fb
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:139
msgid "``FileIO.fromPath``"
msgstr ""

# 6ae90cbdeb3f4c1fab650b0f698d8def
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:140
msgid "``FileIO.toPath``"
msgstr ""

# 20c92a231bbe4d4684ecb086a5ad3d44
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:141
msgid "``StreamConverters.fromInputStream``"
msgstr ""

# 6245eb0a2c994b3db5beb28494b01b47
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:142
msgid "``StreamConverters.fromOutputStream``"
msgstr ""

# 3b092a368c56433a873206ea481fe5e5
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:144
msgid ""
"have been changed from ``Long`` to ``akka.stream.io.IOResult``. This allows "
"to signal more complicated completion scenarios. For example, on failure it "
"is now possible to return the exception and the number of bytes written "
"until that exception occured."
msgstr ""

# 0c9326181a294d88be3b85d0d5383535
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:149
msgid ""
"PushStage, PushPullStage and DetachedStage have been deprecated in favor of "
"GraphStage"
msgstr ""

# 18e5e758623d4c77933ff86e87586248
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:151
msgid ""
"The :class:`PushStage` :class:`PushPullStage` and :class:`DetachedStage` "
"classes have been deprecated and should be replaced by :class:`GraphStage` "
"(:ref:`graphstage-java`) which is now a single powerful API for custom "
"stream processing."
msgstr ""

# 83bf5f46eb214fa0abebd8f1ed9ee3e9
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:156
msgid "Update procedure"
msgstr ""

# 1132121ed59d44d988b73aa3c82e65d8
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:158
msgid ""
"Please consult the :class:`GraphStage` documentation (:ref:`graphstage-"
"java`) and the `previous migration guide`_ on migrating from "
":class:`AsyncStage` to :class:`GraphStage`."
msgstr ""

# 862fb499db734170a1ded86dfef9cdeb
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:165
msgid "Changes in Akka HTTP"
msgstr ""

# 0ab99c5c3b894399b7c4a820b4871afd
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:168
msgid "Routing settings parameter name"
msgstr ""

# 2c99f51e633e4612add0379e57558335
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:170
msgid ""
"``RoutingSettings`` were previously the only setting available on "
"``RequestContext``, and were accessible via ``settings``. We now made it "
"possible to configure the parsers settings as well, so ``RoutingSettings`` "
"is now ``routingSettings`` and ``ParserSettings`` is now accessible via "
"``parserSettings``."
msgstr ""

# c31f7f4d6c2949739059d3c094074827
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:176
msgid "Client / server behaviour on cancelled entity"
msgstr ""

# e2723abb2cdd43dcbc22de6df820f17f
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:178
msgid ""
"Previously if request or response were cancelled or consumed only partially "
"(e.g. by using ``take`` combinator) the remaining data was silently drained "
"to prevent stalling the connection, since there could still be more requests"
" / responses incoming. Now the default behaviour is to close the connection "
"in order to prevent using excessive resource usage in case of huge entities."
msgstr ""

# f66911fd6e7a44c2ba579b59cd8c55bb
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:184
msgid "The old behaviour can be achieved by explicitly draining the entity:"
msgstr ""

# 853d68d97437488c8dbd5266aaec2ba4
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:186
msgid "response.entity().getDataBytes().runWith(Sink.ignore())"
msgstr ""

# f5189a5b23354a09a94a8bb5602215e3
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:189
msgid "SslTls has been renamed to TLS and moved"
msgstr ""

# ac3b7723e23e4325b530969ccba02259
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:191
msgid ""
"The DSL to access a TLS (or SSL) :class:`BidiFlow` have now split between "
"the ``javadsl`` and ``scaladsl`` packages and have been renamed to "
":class:`TLS`. Common option types (closing modes, authentication modes, "
"etc.) have been moved to the top level ``stream`` package, and the common "
"message types are accessible in the class :class:`akka.stream.TLSProtocol`"
msgstr ""

# f6267544f2c14389898e6f76a1dc490d
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:196
msgid "Websocket now consistently named WebSocket"
msgstr ""

# 2acfacfb623842e9a8e2e363f51a1421
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:198
msgid ""
"Previously we had a mix of methods and classes called ``websocket`` or "
"``Websocket``, which was in contradiction with how the word is spelled in "
"the spec and some other places of Akka HTTP."
msgstr ""

# 664004f7d81f41b1bedb003f00f4ed70
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:201
msgid ""
"Methods and classes using the word WebSocket now consistently use it as "
"``WebSocket``, so updating is as simple as find-and-replacing the lower-case"
" ``s`` to an upper-case ``S`` wherever the word WebSocket appeared."
msgstr ""

# f4ce717de1134a8bbc366d1939e3e6ee
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:205
msgid "Java DSL for Http binding and connections changed"
msgstr ""

# e69e8b87061d44f08a0dc46cc8d21e7a
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:207
msgid ""
"In order to minimise the number of needed overloads for each method defined "
"on the ``Http`` extension a new mini-DSL has been introduced for connecting "
"to hosts given a hostname, port and optional ``ConnectionContext``."
msgstr ""

# 10c1d850a185476ca3bb61c2d67e00f0
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:210
msgid ""
"The availability of the connection context (if it's set to "
"``HttpsConnectionContext``) makes the server be bound as an HTTPS server, "
"and for outgoing connections those settings are used instead of the default "
"ones if provided."
msgstr ""

# 7912e9d3a2da4e9692f4bd0cd3512887
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:213
msgid "Was::"
msgstr ""

# fc1e060893d54995966d58f556ac0f57
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:218
msgid "Replace with::"
msgstr ""

# 0f05be9f96a245a8a3070852d3bb016d
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:225
msgid "Framing moved to akka.stream.[javadsl/scaladsl]"
msgstr ""

# 1be1d1a6660d42c4a25f00df2dc999ad
#: ../../java/stream/migration-guide-2.0-2.4-java.rst:227
msgid ""
"The ``Framing`` object which can be used to chunk up ``ByteString`` streams "
"into framing dependent chunks (such as lines) has moved to "
"``akka.stream.scaladsl.Framing``, and has gotten a Java DSL equivalent type "
"in ``akka.stream.javadsl.Framing``."
msgstr ""

# 6d5cd10c32fa4bf0a6de067eb0da0573
#: ../../java/stream/stages-overview.rst:4
msgid "Overview of built-in stages and their semantics"
msgstr ""

# c12477c845c949d199282645882aa965
#: ../../java/stream/stages-overview.rst:8
msgid "Source stages"
msgstr ""

# 54e6790a17314928b4c4e5c88c92c097
#: ../../java/stream/stages-overview.rst:9
msgid ""
"These built-in sources are available from ``akka.stream.javadsl.Source``:"
msgstr ""

# 89fee8f566a74840bea91bc3e8ecab19
#: ../../java/stream/stages-overview.rst:14
msgid "fromIterator"
msgstr ""

# 6a4e370b490a46cdafbc76e193607a34
#: ../../java/stream/stages-overview.rst:15
msgid ""
"Stream the values from an ``Iterator``, requesting the next value when there"
" is demand. The iterator will be created anew on each materialization of the"
" source which is the reason the factory takes a ``Creator`` rather than an "
"``Iterator`` directly."
msgstr ""

# f66c9a31cd734e71a12a222d07ec94b6
#: ../../java/stream/stages-overview.rst:18
msgid ""
"If the iterator perform blocking operations, make sure to run it on a "
"separate dispatcher."
msgstr ""

# 051f729286f54d07b25b7aebf665d405
#: ../../java/stream/stages-overview.rst:20
msgid "**emits** the next value returned from the iterator"
msgstr ""

# ff6ec70f0131427d9089f480f9c50f2b
#: ../../java/stream/stages-overview.rst:22
msgid "**completes** when the iterator reaches its end"
msgstr ""

# d97bd4ed66c44036b931a94d02b495e2
#: ../../java/stream/stages-overview.rst:25
msgid "from"
msgstr ""

# b3b23ec4b7d04814808a6724ce93516b
#: ../../java/stream/stages-overview.rst:26
msgid ""
"Stream the values of an ``Iterable``. Make sure the ``Iterable`` is "
"immutable or at least not modified after being used as a source."
msgstr ""

# ce67947b0d5249ae8009340d0e5c1e59
#: ../../java/stream/stages-overview.rst:29
msgid "**emits** the next value of the iterable"
msgstr ""

# b1750a9e81a740ab9a2b8d69dc3c1752
#: ../../java/stream/stages-overview.rst:31
msgid "**completes** after the last element of the iterable has been emitted"
msgstr ""

# 74aa5358f85643b89e5d486a053ef2b5
#: ../../java/stream/stages-overview.rst:35
msgid "single"
msgstr ""

# 0b12c354d803463e85201577dbdd1a5c
#: ../../java/stream/stages-overview.rst:36
msgid "Stream a single object"
msgstr ""

# 6751f9dad8864e5bb28c94387c11d5bc
#: ../../java/stream/stages-overview.rst:38
msgid "**emits** the value once"
msgstr ""

# 7f49d275a46e4f01ac733eb09da7b80b
#: ../../java/stream/stages-overview.rst:40
msgid "**completes** when the single value has been emitted"
msgstr ""

# cff881f33cb24b4c9c66fdfd14cb870b
#: ../../java/stream/stages-overview.rst:43
msgid "repeat"
msgstr ""

# dbed78d3431e4f92841d85dfdc7e5503
#: ../../java/stream/stages-overview.rst:44
msgid "Stream a single object repeatedly"
msgstr ""

# 783144c0fb5842cab1783ef8f7819f19
#: ../../java/stream/stages-overview.rst:46
msgid "**emits** the same value repeatedly when there is demand"
msgstr ""

# e376552a538f468d8a35a60590711ada
# 5af56f1ebc504f81ad311c61e17084d9
# 015b86c9ffc04b578e11347eaab83383
#: ../../java/stream/stages-overview.rst:48
#: ../../java/stream/stages-overview.rst:59
#: ../../java/stream/stages-overview.rst:68
msgid "**completes** never"
msgstr ""

# 7af38dd4a88449a7851fb990d423e784
#: ../../java/stream/stages-overview.rst:51
msgid "cycle"
msgstr ""

# f183037bc3a04cb1aaa60320be517143
#: ../../java/stream/stages-overview.rst:52
msgid ""
"Stream iterator in cycled manner. Internally new iterator is being created "
"to cycle the one provided via argument meaning when original iterator runs "
"out of elements process will start all over again from the beginning of the "
"iterator provided by the evaluation of provided parameter. If method "
"argument provides empty iterator stream will be terminated with exception."
msgstr ""

# 3335765cca5e45868e4e86a94acc3d35
#: ../../java/stream/stages-overview.rst:57
msgid "**emits** the next value returned from cycled iterator"
msgstr ""

# 12cc4bdfe0cc4e56832f6b1c82251cec
#: ../../java/stream/stages-overview.rst:62
msgid "tick"
msgstr ""

# 0131ae8ad89d49238c029c9b54826120
#: ../../java/stream/stages-overview.rst:63
msgid ""
"A periodical repetition of an arbitrary object. Delay of first tick is "
"specified separately from interval of the following ticks."
msgstr ""

# 14f342fc0f4448a48cf7ea7ca932ec5d
#: ../../java/stream/stages-overview.rst:66
msgid ""
"**emits** periodically, if there is downstream backpressure ticks are "
"skipped"
msgstr ""

# 6ee69cbe25b5499aa47ef20b14e48dc6
#: ../../java/stream/stages-overview.rst:71
msgid "fromCompletionStage"
msgstr ""

# e6c9a92e32404633bed6453d4beaa806
#: ../../java/stream/stages-overview.rst:72
msgid ""
"Send the single value of the ``CompletionStage`` when it completes and there"
" is demand. If the ``CompletionStage`` fails the stream is failed with that "
"exception."
msgstr ""

# 4a447ebde7b6454a90d20002646a7668
#: ../../java/stream/stages-overview.rst:75
msgid "**emits** when the ``CompletionStage`` completes"
msgstr ""

# 13ac865f175b4c56b467abcbe3c2a90e
#: ../../java/stream/stages-overview.rst:77
msgid ""
"**completes** after the ``CompletionStage`` has completed or when it fails"
msgstr ""

# e4332652ff134f3dba48424a2f45dad4
#: ../../java/stream/stages-overview.rst:81
msgid "fromFuture"
msgstr ""

# a78560a864d34c2db607c9ff81cbc976
#: ../../java/stream/stages-overview.rst:82
msgid ""
"Send the single value of the Scala ``Future`` when it completes and there is"
" demand. If the future fails the stream is failed with that exception."
msgstr ""

# 5807415f647a4936b1d1eb9a9a0a9fe5
#: ../../java/stream/stages-overview.rst:85
msgid "**emits** the future completes"
msgstr ""

# 03f25dfd288443f19bcc3468e1cd064b
#: ../../java/stream/stages-overview.rst:87
msgid "**completes** after the future has completed"
msgstr ""

# 9b64af5c6bc3463a9d2bd49ceb5419b9
#: ../../java/stream/stages-overview.rst:90
msgid "unfold"
msgstr ""

# 2b313a2587484223984e5ab147c91115
#: ../../java/stream/stages-overview.rst:91
msgid ""
"Stream the result of a function as long as it returns a ``Optional``, the "
"value inside the optional consists of a pair where the first value is a "
"state passed back into the next call to the function allowing to pass a "
"state. The first invocation of the provided fold function will receive the "
"``zero`` state."
msgstr ""

# cdf35f0bcac14daf9b92a3748324ee11
# 6599fb4d721a4a82bad6a3672c441ddc
#: ../../java/stream/stages-overview.rst:95
#: ../../java/stream/stages-overview.rst:106
msgid ""
"Can be used to implement many stateful sources without having to touch the "
"more low level ``GraphStage`` API."
msgstr ""

# b141fca0f1774ee09fdcdf7e2d8ebf7e
#: ../../java/stream/stages-overview.rst:97
msgid ""
"**emits** when there is demand and the unfold function over the previous "
"state returns non empty value"
msgstr ""

# 93417217470f4a2a84e96208f0df23ce
#: ../../java/stream/stages-overview.rst:99
msgid "**completes** when the unfold function returns an empty value"
msgstr ""

# c2c66ad5b05d4588b9e3de20e637078c
#: ../../java/stream/stages-overview.rst:102
msgid "unfoldAsync"
msgstr ""

# 96e1deb4bf8a4042887a74ac5d5ee045
#: ../../java/stream/stages-overview.rst:103
msgid ""
"Just like ``unfold`` but the fold function returns a ``CompletionStage`` "
"which will cause the source to complete or emit when it completes."
msgstr ""

# 95a8e6c31eeb4a828a0ec405eb5d2f04
#: ../../java/stream/stages-overview.rst:108
msgid ""
"**emits** when there is demand and unfold state returned CompletionStage "
"completes with some value"
msgstr ""

# 64047f85e60c4aedaee4f27d36f056b9
#: ../../java/stream/stages-overview.rst:110
msgid ""
"**completes** when the CompletionStage returned by the unfold function "
"completes with an empty value"
msgstr ""

# 5afbfb54c7b8424a97d61180d4bc7216
#: ../../java/stream/stages-overview.rst:113
msgid "empty"
msgstr ""

# 39b2e9da56144dd7837a30c7cf4e7475
#: ../../java/stream/stages-overview.rst:114
msgid ""
"Complete right away without ever emitting any elements. Useful when you have"
" to provide a source to an API but there are no elements to emit."
msgstr ""

# 96cabfb25b2e49c8b8957f348f0c9859
# 46496cd4fe5646039c5a1d2af377ba24
#: ../../java/stream/stages-overview.rst:117
#: ../../java/stream/stages-overview.rst:135
msgid "**emits** never"
msgstr ""

# 78bb2c17df6946e293dbcabfec8e8262
#: ../../java/stream/stages-overview.rst:119
msgid "**completes** directly"
msgstr ""

# d8c9e28aec9d4b57b37a1f5f7254ac12
#: ../../java/stream/stages-overview.rst:122
msgid "maybe"
msgstr ""

# aee66de501b34892ac79b3655652f569
#: ../../java/stream/stages-overview.rst:123
msgid ""
"Materialize a ``CompletionStage`` that can be completed with an "
"``Optional``. If it is completed with a value it will be eimitted from the "
"source if it is an empty ``Optional`` it will complete directly."
msgstr ""

# 439d048711a3403da923735151fff036
#: ../../java/stream/stages-overview.rst:127
msgid "**emits** when the returned promise is completed with some value"
msgstr ""

# a0cefdf4953046ae98562164fbe89625
#: ../../java/stream/stages-overview.rst:129
msgid ""
"**completes** after emitting some value, or directly if the promise is "
"completed with no value"
msgstr ""

# a37bfd59ce6e42b5a9750a3c325f56c9
#: ../../java/stream/stages-overview.rst:132
msgid "failed"
msgstr ""

# d337aa0c6edc47f3a50a12fdd1fba1e1
#: ../../java/stream/stages-overview.rst:133
msgid "Fail directly with a user specified exception."
msgstr ""

# 825b9a7839104d1480db3c4d7c92d2b6
#: ../../java/stream/stages-overview.rst:137
msgid "**completes** fails the stream directly with the given exception"
msgstr ""

# fcbfbf2788e54350b5ee284c403841aa
#: ../../java/stream/stages-overview.rst:140
msgid "actorPublisher"
msgstr ""

# 4f32223f829c44a4ab37878d6af3d3d9
#: ../../java/stream/stages-overview.rst:141
msgid "Wrap an actor extending ``ActorPublisher`` as a source."
msgstr ""

# 114e09819e0749ee8b348282c9ae2e93
#: ../../java/stream/stages-overview.rst:143
msgid "**emits** depends on the actor implementation"
msgstr ""

# e1e725f5d88f41eea41a3feb0eb0a668
#: ../../java/stream/stages-overview.rst:145
msgid "**completes** when the actor stops"
msgstr ""

# 11027f48eac24a6b9a0497d65d4d25c5
# 756bace11af447908fb98e4217e60062
#: ../../java/stream/stages-overview.rst:148
#: ../../java/stream/stages-overview.rst:363
msgid "actorRef"
msgstr ""

# f527115067c145a4aa5c698f305e1e18
#: ../../java/stream/stages-overview.rst:149
msgid ""
"Materialize an ``ActorRef``, sending messages to it will emit them on the "
"stream. The actor contain a buffer but since communication is one way, there"
" is no back pressure. Handling overflow is done by either dropping elements "
"or failing the stream, the strategy is chosen by the user."
msgstr ""

# b062b2030104489d8fba53cb45d71bba
#: ../../java/stream/stages-overview.rst:153
msgid ""
"**emits** when there is demand and there are messages in the buffer or a "
"message is sent to the actorref"
msgstr ""

# 40ea64b0cfb2436f98985510f48ad0b2
#: ../../java/stream/stages-overview.rst:155
msgid ""
"**completes** when the ``ActorRef`` is sent ``akka.actor.Status.Success`` or"
" ``PoisonPill``"
msgstr ""

# d624339418b54616929a8e22d7930e9e
# 690817931db74aac952755a2751fa01c
#: ../../java/stream/stages-overview.rst:158
#: ../../java/stream/stages-overview.rst:354
msgid "combine"
msgstr ""

# 0d883a2f5bdd400592c0e330c12a6713
#: ../../java/stream/stages-overview.rst:159
msgid ""
"Combine several sources, using a given strategy such as merge or concat, "
"into one source."
msgstr ""

# a229f9e89bde40dc9c225d93572a01ac
#: ../../java/stream/stages-overview.rst:161
msgid "**emits** when there is demand, but depending on the strategy"
msgstr ""

# 3322ed9bd3064193b993bc000652738f
#: ../../java/stream/stages-overview.rst:163
msgid "**completes** when all sources has completed"
msgstr ""

# 887de79c4877496f9f4ebc4776ca9459
#: ../../java/stream/stages-overview.rst:167
msgid "range"
msgstr ""

# ecbc6ec077764c9f8cbc1506914c6799
#: ../../java/stream/stages-overview.rst:168
msgid ""
"Emit each integer in a range, with an option to take bigger steps than 1."
msgstr ""

# e0152275368f4bbfbe7c93c609997db5
#: ../../java/stream/stages-overview.rst:170
msgid "**emits** when there is demand, the next value"
msgstr ""

# fe3767ac35aa4af6aa8cfa486198478a
#: ../../java/stream/stages-overview.rst:172
msgid "**completes** when the end of the range has been reached"
msgstr ""

# a182896e847743c899ca4c7e3a1d283d
#: ../../java/stream/stages-overview.rst:175
msgid "unfoldResource"
msgstr ""

# 8551af5d73f24feb83e5bd1df85dcbb3
#: ../../java/stream/stages-overview.rst:176
msgid ""
"Wrap any resource that can be opened, queried for next element (in a "
"blocking way) and closed using three distinct functions into a source."
msgstr ""

# 900148c9e7a54a909e071145de1a2018
#: ../../java/stream/stages-overview.rst:178
msgid "**emits** when there is demand and read method returns value"
msgstr ""

# 485711cdfbf24617809cdc6b939a852e
#: ../../java/stream/stages-overview.rst:180
msgid "**completes** when read function returns ``None``"
msgstr ""

# c229dee0485e477aa14ea106c2651c53
#: ../../java/stream/stages-overview.rst:183
msgid "unfoldAsyncResource"
msgstr ""

# a034ea06ae2d462b9fa83a209ea66a94
#: ../../java/stream/stages-overview.rst:184
msgid ""
"Wrap any resource that can be opened, queried for next element and closed "
"using three distinct functions into a source. Functions return "
"``CompletionStage`` result to achieve asynchronous processing"
msgstr ""

# 6b9563dbb67d42bebd7d96e5a5c911af
#: ../../java/stream/stages-overview.rst:187
msgid ""
"**emits** when there is demand and ``CompletionStage`` from read function "
"returns value"
msgstr ""

# c7ee5feec5264b3f8d00b25fdcbdf093
#: ../../java/stream/stages-overview.rst:189
msgid ""
"**completes** when ``CompletionStage`` from read function returns ``None``"
msgstr ""

# d8d7c11581824722b0bb644ddb732dd8
#: ../../java/stream/stages-overview.rst:192
msgid "queue"
msgstr ""

# db75500b8f8a4e92bad12263d0ab3636
#: ../../java/stream/stages-overview.rst:193
msgid ""
"Materialize a ``SourceQueue`` onto which elements can be pushed for emitting"
" from the source. The queue contains a buffer, if elements are pushed onto "
"the queue faster than the source is consumed the overflow will be handled "
"with a strategy specified by the user. Functionality for tracking when an "
"element has been emitted is available through ``SourceQueue.offer``."
msgstr ""

# e5c7e7a5855a4fa8961351cbe4159e23
#: ../../java/stream/stages-overview.rst:198
msgid "**emits** when there is demand and the queue contains elements"
msgstr ""

# 960a6983f8a6460db445e7af0c4cdeb9
#: ../../java/stream/stages-overview.rst:200
msgid "**completes** when downstream completes"
msgstr ""

# 664d39ffc79a45408f31eed2c9fb632e
#: ../../java/stream/stages-overview.rst:203
msgid "asSubscriber"
msgstr ""

# cbb79016636c46148915c7438180cdbd
#: ../../java/stream/stages-overview.rst:204
msgid ""
"Integration with Reactive Streams, materializes into a "
"``org.reactivestreams.Subscriber``."
msgstr ""

# 716839971af14d1e9ecc364545e77b2e
#: ../../java/stream/stages-overview.rst:208
msgid "fromPublisher"
msgstr ""

# 1a4547f56b21493a91abcd003986ddbe
#: ../../java/stream/stages-overview.rst:209
msgid ""
"Integration with Reactive Streams, subscribes to a "
"``org.reactivestreams.Publisher``."
msgstr ""

# 666bcac4100d4666bce27304b581aba3
#: ../../java/stream/stages-overview.rst:212
msgid "zipN"
msgstr ""

# 4a81fa1918ba45ea89bc7e0527c73c61
#: ../../java/stream/stages-overview.rst:213
msgid "Combine the elements of multiple streams into a stream of sequences."
msgstr ""

# b3c2ea7275ad43948f2de30b8383c55f
# 277328187e834bcbbcb560990ca2b96e
#: ../../java/stream/stages-overview.rst:215
#: ../../java/stream/stages-overview.rst:223
msgid "**emits** when all of the inputs has an element available"
msgstr ""

# 7cff5fb4bcac4ac49695b5d1a8ebffd8
# cb2ca2d528424b638fed051148728640
# da8c6ff85a304519a4242ff027d4e1c3
# a8d350b592e648e186108e8850163edd
#: ../../java/stream/stages-overview.rst:217
#: ../../java/stream/stages-overview.rst:225
#: ../../java/stream/stages-overview.rst:1128
#: ../../java/stream/stages-overview.rst:1139
msgid "**completes** when any upstream completes"
msgstr ""

# 1cae108461684875857b7ab0653d7e47
#: ../../java/stream/stages-overview.rst:220
msgid "zipWithN"
msgstr ""

# 5fce04a8555a4718bdbabb806e6ee88f
#: ../../java/stream/stages-overview.rst:221
msgid ""
"Combine the elements of multiple streams into a stream of sequences using a "
"combiner function."
msgstr ""

# b793b8e0e71c4733ae07bab01083d4c3
#: ../../java/stream/stages-overview.rst:231
msgid "Sink stages"
msgstr ""

# e5016bc8b229486ca30ccbd71536d628
#: ../../java/stream/stages-overview.rst:232
msgid "These built-in sinks are available from ``akka.stream.javadsl.Sink``:"
msgstr ""

# 2c5ee7f0d88b4a3881e44ad81d9cb1f0
#: ../../java/stream/stages-overview.rst:237
msgid ""
"Materializes into a ``CompletionStage`` which completes with the first value"
" arriving, after this the stream is canceled. If no element is emitted, the "
"CompletionStage is be failed."
msgstr ""

# 57f9f4d5c93042fd97ca02a5d50d2da5
# 13aefb8e07c54446a8b1e1a88f3b6240
#: ../../java/stream/stages-overview.rst:240
#: ../../java/stream/stages-overview.rst:249
msgid "**cancels** after receiving one element"
msgstr ""

# 62eb48dfcd6e4d2195c45527d555241c
# e5851e043b2c496c872de8d815c65db9
# e9b5d6b602cb4773823f64fcf7c76bdc
# abe38d7c634041398164fea8f59f86b9
# 8438b305f9ef463496369bb70d31602a
# c13d8d1c37f7465c950f36e24c1a7e4a
# 9bc4bdfca9e64a5988688e7757ea1e56
#: ../../java/stream/stages-overview.rst:242
#: ../../java/stream/stages-overview.rst:251
#: ../../java/stream/stages-overview.rst:260
#: ../../java/stream/stages-overview.rst:270
#: ../../java/stream/stages-overview.rst:279
#: ../../java/stream/stages-overview.rst:324
#: ../../java/stream/stages-overview.rst:368
msgid "**backpressures** never"
msgstr ""

# 7726afed404842299f01dd2d68d4cc2a
#: ../../java/stream/stages-overview.rst:245
msgid "headOption"
msgstr ""

# 548cd7fbe7bd4d53b29eb671f67bc13e
#: ../../java/stream/stages-overview.rst:246
msgid ""
"Materializes into a ``CompletionStage<Optional<T>>`` which completes with "
"the first value arriving wrapped in optional, or an empty optional if the "
"stream completes without any elements emitted."
msgstr ""

# 9700d94564954acdaf03082d15cfd11b
#: ../../java/stream/stages-overview.rst:254
msgid "last"
msgstr ""

# f0b20d53b9f44327a52ced0a47604a6c
#: ../../java/stream/stages-overview.rst:255
msgid ""
"Materializes into a ``CompletionStage`` which will complete with the last "
"value emitted when the stream completes. If the stream completes with no "
"elements the CompletionStage is failed."
msgstr ""

# 6e7de54a1eb04aabb5eb3889ec76fb3e
# c5bc31e8e10e4d4dabc4d6088ecb4c38
# a7091394f13940bb88d16091700260c9
# 6ba1d909ec594e1b9ccc8031ae695d17
# 4b76080500044b6a962da303702c52c2
# f113631f340a4e2bba339690806a90a1
# e136d2d85a594e5b810e3a2ee0f9715f
# d7abaa2bbacb4d8cb28b56b8e1e814e2
#: ../../java/stream/stages-overview.rst:258
#: ../../java/stream/stages-overview.rst:268
#: ../../java/stream/stages-overview.rst:277
#: ../../java/stream/stages-overview.rst:304
#: ../../java/stream/stages-overview.rst:313
#: ../../java/stream/stages-overview.rst:322
#: ../../java/stream/stages-overview.rst:337
#: ../../java/stream/stages-overview.rst:348
msgid "**cancels** never"
msgstr ""

# 9197482de933486fa82ce50375208241
#: ../../java/stream/stages-overview.rst:263
msgid "lastOption"
msgstr ""

# 166cd9c3f35a4333a1cd66aa871cd912
#: ../../java/stream/stages-overview.rst:264
msgid ""
"Materialize a ``CompletionStage<Optional<T>>`` which completes with the last"
" value emitted wrapped in an optional when the stream completes. if the "
"stream completes with no elements the ``CompletionStage`` is completed with "
"an empty optional."
msgstr ""

# 46de45d2125e4c218df5b56eeaa28e2b
#: ../../java/stream/stages-overview.rst:273
msgid "ignore"
msgstr ""

# a242f76022494e468e57242a221495db
#: ../../java/stream/stages-overview.rst:274
msgid ""
"Consume all elements but discards them. Useful when a stream has to be "
"consumed but there is no use to actually do anything with the elements."
msgstr ""

# e251ebf88db249709a0e4cc155b493fd
#: ../../java/stream/stages-overview.rst:282
msgid "cancelled"
msgstr ""

# 9ee9c4c1eb0c43619f546921c645230c
#: ../../java/stream/stages-overview.rst:283
msgid "Immediately cancel the stream"
msgstr ""

# 8690e2212f194bf3b3a4921ff917fc67
#: ../../java/stream/stages-overview.rst:285
msgid "**cancels** immediately"
msgstr ""

# 8c2f8056aec5490d991f2e6c6438dcde
#: ../../java/stream/stages-overview.rst:288
msgid "seq"
msgstr ""

# b7cdbc8498e44d7494238edb65a9eeef
#: ../../java/stream/stages-overview.rst:289
msgid ""
"Collect values emitted from the stream into a collection, the collection is "
"available through a ``CompletionStage`` or which completes when the stream "
"completes. Note that the collection is bounded to ``Integer.MAX_VALUE``, if "
"more element are emitted the sink will cancel the stream"
msgstr ""

# f41e99e37704425d9d0c158a3ac5c65a
#: ../../java/stream/stages-overview.rst:293
msgid "**cancels** If too many values are collected"
msgstr ""

# 98da6d5d20f64c77905b4f124eaffe38
#: ../../java/stream/stages-overview.rst:296
msgid "foreach"
msgstr ""

# b4f3344f59674d9b9f1767383d484082
#: ../../java/stream/stages-overview.rst:297
msgid ""
"Invoke a given procedure for each element received. Note that it is not safe"
" to mutate shared state from the procedure."
msgstr ""

# f1a58e84b3b04c799294cd3e2e4b7ecf
#: ../../java/stream/stages-overview.rst:299
msgid ""
"The sink materializes into a ``CompletionStage<Optional<Done>>`` which "
"completes when the stream completes, or fails if the stream fails."
msgstr ""

# a7c0bed05a454f709bb7145ef3878fba
#: ../../java/stream/stages-overview.rst:302
msgid "Note that it is not safe to mutate state from the procedure."
msgstr ""

# 1ff758b3d68b4230baa1995712d88a91
#: ../../java/stream/stages-overview.rst:306
msgid ""
"**backpressures** when the previous procedure invocation has not yet "
"completed"
msgstr ""

# 19ba1b6a0c2e47a582ab73d7439a823f
#: ../../java/stream/stages-overview.rst:310
msgid "foreachParallel"
msgstr ""

# d985a6ae666d413f9a3e179906a732c4
#: ../../java/stream/stages-overview.rst:311
msgid ""
"Like ``foreach`` but allows up to ``parallellism`` procedure calls to happen"
" in parallel."
msgstr ""

# 9034811113c840cea7e374f2108c4832
#: ../../java/stream/stages-overview.rst:315
msgid ""
"**backpressures** when the previous parallel procedure invocations has not "
"yet completed"
msgstr ""

# 48f7eb71e4ce4caaa52cde3d7985dba5
#: ../../java/stream/stages-overview.rst:320
msgid "Invoke a callback when the stream has completed or failed."
msgstr ""

# 311375ce5dff4dff9ca093766e15aba4
# 2749d831be22485287c7ce250662a1a2
#: ../../java/stream/stages-overview.rst:328
#: ../../java/stream/stages-overview.rst:623
msgid "fold"
msgstr ""

# 94e319acf2dc4cf1a9f5900088edf6b7
#: ../../java/stream/stages-overview.rst:329
msgid ""
"Fold over emitted element with a function, where each invocation will get "
"the new element and the result from the previous fold invocation. The first "
"invocation will be provided the ``zero`` value."
msgstr ""

# b7cccca7e0114a54ad51db9b4e696b64
#: ../../java/stream/stages-overview.rst:332
msgid ""
"Materializes into a CompletionStage that will complete with the last state "
"when the stream has completed."
msgstr ""

# 7e1394ea84b44b14bfe7f69d788ad7aa
#: ../../java/stream/stages-overview.rst:334
msgid ""
"This stage allows combining values into a result without a global mutable "
"state by instead passing the state along between invocations."
msgstr ""

# 049d698666d84732a69c9348de674a77
#: ../../java/stream/stages-overview.rst:339
msgid ""
"**backpressures** when the previous fold function invocation has not yet "
"completed"
msgstr ""

# 477e85b330834479820a767c5616a5b7
#: ../../java/stream/stages-overview.rst:342
msgid "reduce"
msgstr ""

# cae5fa9d21814f238f22cca6001a0f9f
#: ../../java/stream/stages-overview.rst:343
msgid ""
"Apply a reduction function on the incoming elements and pass the result to "
"the next invocation. The first invocation receives the two first elements of"
" the flow."
msgstr ""

# 1e4262d1529244948920daaecc6cc33a
#: ../../java/stream/stages-overview.rst:346
msgid ""
"Materializes into a CompletionStage that will be completed by the last "
"result of the reduction function."
msgstr ""

# 6815787fd7974943abcf26ed0c7c9afb
#: ../../java/stream/stages-overview.rst:350
msgid ""
"**backpressures** when the previous reduction function invocation has not "
"yet completed"
msgstr ""

# d1d4461209814b6080e535c4c6f9e9bb
#: ../../java/stream/stages-overview.rst:355
msgid "Combine several sinks into one using a user specified strategy"
msgstr ""

# dd054c1d9bee48d1892f73dc35cdb366
#: ../../java/stream/stages-overview.rst:357
msgid "**cancels** depends on the strategy"
msgstr ""

# b3f3f7eff2fa43e8a82f72c8fadd98a1
#: ../../java/stream/stages-overview.rst:359
msgid "**backpressures** depends on the strategy"
msgstr ""

# 036ad61f529f431189846ae4f778a4da
#: ../../java/stream/stages-overview.rst:364
msgid ""
"Send the elements from the stream to an ``ActorRef``. No backpressure so "
"care must be taken to not overflow the inbox."
msgstr ""

# 4936c1436d274decb07d0610c6233d92
# 4b5468c30e614558b56853119f1c6247
# d60932275e1347b3a18868da469a94b3
#: ../../java/stream/stages-overview.rst:366
#: ../../java/stream/stages-overview.rst:376
#: ../../java/stream/stages-overview.rst:388
msgid "**cancels** when the actor terminates"
msgstr ""

# 16421a63a6d14826862fce3cabf8fc6b
#: ../../java/stream/stages-overview.rst:372
msgid "actorRefWithAck"
msgstr ""

# b3326079fd294819a4e165154a7e18b1
#: ../../java/stream/stages-overview.rst:373
msgid ""
"Send the elements from the stream to an ``ActorRef`` which must then "
"acknowledge reception after completing a message, to provide back pressure "
"onto the sink."
msgstr ""

# 285587b92a2549f6b3e02ab1155f35df
#: ../../java/stream/stages-overview.rst:378
msgid "**backpressures** when the actor acknowledgement has not arrived"
msgstr ""

# d24fc0103c734e96b885328f795cd4ee
#: ../../java/stream/stages-overview.rst:382
msgid "actorSubscriber"
msgstr ""

# 1f9dc580371d455b83833f047bfa438b
#: ../../java/stream/stages-overview.rst:383
msgid ""
"Create an actor from a ``Props`` upon materialization, where the actor "
"implements ``ActorSubscriber``, which will receive the elements from the "
"stream."
msgstr ""

# 33017ac58bd64fc29f33ec66ec9fdf1a
#: ../../java/stream/stages-overview.rst:386
msgid "Materializes into an ``ActorRef`` to the created actor."
msgstr ""

# 1acc19046ba04d8991c3ef55f11177c4
#: ../../java/stream/stages-overview.rst:390
msgid "**backpressures** depends on the actor implementation"
msgstr ""

# 002dc4b96bf447b795bdb56f55718281
#: ../../java/stream/stages-overview.rst:394
msgid "asPublisher"
msgstr ""

# b81662ebd34c43c6b97db91679baf104
#: ../../java/stream/stages-overview.rst:395
msgid ""
"Integration with Reactive Streams, materializes into a "
"``org.reactivestreams.Publisher``."
msgstr ""

# 63b2ef2317ad42daac2e015cd58706f2
#: ../../java/stream/stages-overview.rst:399
msgid "fromSubscriber"
msgstr ""

# 2bf12aa67cd8486692d814ae6a052518
#: ../../java/stream/stages-overview.rst:400
msgid ""
"Integration with Reactive Streams, wraps a "
"``org.reactivestreams.Subscriber`` as a sink"
msgstr ""

# 1d907f13081d49b3a3e889b4f8f9f753
#: ../../java/stream/stages-overview.rst:406
msgid "Additional Sink and Source converters"
msgstr ""

# a18ec7af02cb4aecb460f0d817c1089a
#: ../../java/stream/stages-overview.rst:407
msgid ""
"Sources and sinks for integrating with ``java.io.InputStream`` and "
"``java.io.OutputStream`` can be found on ``StreamConverters``. As they are "
"blocking APIs the implementations of these stages are run on a separate "
"dispatcher configured through the ``akka.stream.blocking-io-dispatcher``."
msgstr ""

# 4f493b585b0e4312b9096629860bada3
#: ../../java/stream/stages-overview.rst:412
msgid "fromOutputStream"
msgstr ""

# e5f2e1e8ac1c4521a572191e10ded039
#: ../../java/stream/stages-overview.rst:413
msgid ""
"Create a sink that wraps an ``OutputStream``. Takes a function that produces"
" an ``OutputStream``, when the sink is materialized the function will be "
"called and bytes sent to the sink will be written to the returned "
"``OutputStream``."
msgstr ""

# 450ef97aca784667a9ac148c707b4198
# baf9c3cdadaf4932bc7d3eded0cc7cf2
#: ../../java/stream/stages-overview.rst:416
#: ../../java/stream/stages-overview.rst:438
msgid ""
"Materializes into a ``CompletionStage`` which will complete with a "
"``IOResult`` when the stream completes."
msgstr ""

# 2770c85c2ee64684ab263b35356a9212
#: ../../java/stream/stages-overview.rst:419
msgid ""
"Note that a flow can be materialized multiple times, so the function "
"producing the ``OutputStream`` must be able to handle multiple invocations."
msgstr ""

# 88b172b49e63423abe544cf654f9ea09
#: ../../java/stream/stages-overview.rst:422
msgid ""
"The ``OutputStream`` will be closed when the stream that flows into the "
"``Sink`` is completed, and the ``Sink`` will cancel its inflow when the "
"``OutputStream`` is no longer writable."
msgstr ""

# 3f5d44dec8e34c0ba59cdc450a80b66f
#: ../../java/stream/stages-overview.rst:426
msgid "asInputStream"
msgstr ""

# 383f9a66bbcb4f3b9febf8a67c7c2133
#: ../../java/stream/stages-overview.rst:427
msgid ""
"Create a sink which materializes into an ``InputStream`` that can be read to"
" trigger demand through the sink. Bytes emitted through the stream will be "
"available for reading through the ``InputStream``"
msgstr ""

# f64f117a94a44679bd4de5ab2a66844c
#: ../../java/stream/stages-overview.rst:430
msgid ""
"The ``InputStream`` will be ended when the stream flowing into this ``Sink``"
" completes, and the closing the ``InputStream`` will cancel the inflow of "
"this ``Sink``."
msgstr ""

# 4b8fb615e75a46d5abd446808a332b3b
#: ../../java/stream/stages-overview.rst:434
msgid "fromInputStream"
msgstr ""

# 8ecd3dd7ed86454f9c0022579baac750
#: ../../java/stream/stages-overview.rst:435
msgid ""
"Create a source that wraps an ``InputStream``. Takes a function that "
"produces an ``InputStream``, when the source is materialized the function "
"will be called and bytes from the ``InputStream`` will be emitted into the "
"stream."
msgstr ""

# 86767f0df2cb4907ba3c25fca5178f37
#: ../../java/stream/stages-overview.rst:441
msgid ""
"Note that a flow can be materialized multiple times, so the function "
"producing the ``InputStream`` must be able to handle multiple invocations."
msgstr ""

# a4e5e39e7d864a279bf39a9e8545d174
#: ../../java/stream/stages-overview.rst:444
msgid ""
"The ``InputStream`` will be closed when the ``Source`` is canceled from its "
"downstream, and reaching the end of the ``InputStream`` will complete the "
"``Source``."
msgstr ""

# b3511a7ba0dd495a9f8a46c32d883d8b
#: ../../java/stream/stages-overview.rst:448
msgid "asOutputStream"
msgstr ""

# 52aa84002e8649bf9160e354fa12819f
#: ../../java/stream/stages-overview.rst:449
msgid ""
"Create a source that materializes into an ``OutputStream``. When bytes are "
"written to the ``OutputStream`` they are emitted from the source."
msgstr ""

# a4de904871d044fbb567351f485c6472
#: ../../java/stream/stages-overview.rst:452
msgid ""
"The ``OutputStream`` will no longer be writable when the ``Source`` has been"
" canceled from its downstream, and closing the ``OutputStream`` will "
"complete the ``Source``."
msgstr ""

# 9e2ec5b6df1b4e099aeb6d77a0d1f860
#: ../../java/stream/stages-overview.rst:456
msgid "asJavaStream"
msgstr ""

# 98235b7b541e40be9f32e26e688bb8f5
#: ../../java/stream/stages-overview.rst:457
msgid ""
"Create a sink which materializes into Java 8 ``Stream`` that can be run to "
"trigger demand through the sink. Elements emitted through the stream will be"
" available for reading through the Java 8 ``Stream``."
msgstr ""

# 11a71e4277834f84b9b7290ed3c2fbad
#: ../../java/stream/stages-overview.rst:460
msgid ""
"The Java 8 a ``Stream`` will be ended when the stream flowing into this "
"``Sink`` completes, and closing the Java ``Stream`` will cancel the inflow "
"of this ``Sink``. Java ``Stream`` throws exception in case reactive stream "
"failed."
msgstr ""

# d46867d0dfbd4f32bb37d0b733ab385a
#: ../../java/stream/stages-overview.rst:463
msgid ""
"Be aware that Java 8 ``Stream`` blocks current thread while waiting on next "
"element from downstream."
msgstr ""

# 89425fe46e1a4f57b7237fc5848f10cd
#: ../../java/stream/stages-overview.rst:466
msgid "fromJavaStream"
msgstr ""

# 1509fc19cd2542e3be031742a50a6f33
#: ../../java/stream/stages-overview.rst:467
msgid ""
"Create a source that wraps Java 8 ``Stream``. ``Source`` uses a stream "
"iterator to get all its elements and send them downstream on demand."
msgstr ""

# 6002848c6631439293e810710206e0cd
#: ../../java/stream/stages-overview.rst:471
msgid "javaCollector"
msgstr ""

# 47e3a5dd645c40ecbc1ae6772bc168c3
#: ../../java/stream/stages-overview.rst:472
msgid ""
"Create a sink which materializes into a ``CompletionStage`` which will be "
"completed with a result of the Java 8 ``Collector`` transformation and "
"reduction operations. This allows usage of Java 8 streams transformations "
"for reactive streams. The ``Collector`` will trigger demand downstream. "
"Elements emitted through the stream will be accumulated into a mutable "
"result container, optionally transformed into a final representation after "
"all input elements have been processed. The ``Collector`` can also do "
"reduction at the end. Reduction processing is performed sequentially"
msgstr ""

# d586d12a68d04b629d7f16ea1a266bfa
# 09e05a93b91740cebe8259e19a0d243d
#: ../../java/stream/stages-overview.rst:478
#: ../../java/stream/stages-overview.rst:489
msgid ""
"Note that a flow can be materialized multiple times, so the function "
"producing the ``Collector`` must be able to handle multiple invocations."
msgstr ""

# 9acbc6cf93ee4179bd3fd28203696ee2
#: ../../java/stream/stages-overview.rst:482
msgid "javaCollectorParallelUnordered"
msgstr ""

# 8677fb8c646c4ce4a74290b6f10b2aa0
#: ../../java/stream/stages-overview.rst:483
msgid ""
"Create a sink which materializes into a ``CompletionStage`` which will be "
"completed with a result of the Java 8 Collector transformation and reduction"
" operations. This allows usage of Java 8 streams transformations for "
"reactive streams. The ``Collector`` will trigger demand downstream.. "
"Elements emitted through the stream will be accumulated into a mutable "
"result container, optionally transformed into a final representation after "
"all input elements have been processed. The ``Collector`` can also do "
"reduction at the end. Reduction processing is performed in parallel based on"
" graph ``Balance``."
msgstr ""

# da4a81bb17524d67ba02e04544809e0f
#: ../../java/stream/stages-overview.rst:493
msgid "File IO Sinks and Sources"
msgstr ""

# 127dd975fb364692a7b614e11e90a81c
#: ../../java/stream/stages-overview.rst:494
msgid ""
"Sources and sinks for reading and writing files can be found on ``FileIO``."
msgstr ""

# fdb0108392a94ab2a554786fc83866b6
#: ../../java/stream/stages-overview.rst:497
msgid "fromFile"
msgstr ""

# fee56c261b8c40c1ac848cc1b2a904d0
#: ../../java/stream/stages-overview.rst:498
msgid ""
"Emit the contents of a file, as ``ByteString`` s, materializes into a "
"``CompletionStage`` which will be completed with a ``IOResult`` upon "
"reaching the end of the file or if there is a failure."
msgstr ""

# 6c09a1143e0b47c3ab8d0cc54505a27b
#: ../../java/stream/stages-overview.rst:502
msgid "toFile"
msgstr ""

# 0f8473c67deb439d9f6c1ab09941dc66
#: ../../java/stream/stages-overview.rst:503
msgid ""
"Create a sink which will write incoming ``ByteString`` s to a given file."
msgstr ""

# 77d04eb363ba4f30a16cc9245f5579e0
#: ../../java/stream/stages-overview.rst:508
msgid "Flow stages"
msgstr ""

# f901ea74de534484834d546f93fb839e
#: ../../java/stream/stages-overview.rst:510
msgid ""
"All flows by default backpressure if the computation they encapsulate is not"
" fast enough to keep up with the rate of incoming elements from the "
"preceding stage. There are differences though how the different stages "
"handle when some of their downstream stages backpressure them."
msgstr ""

# 80de2071fd764d609e7712d7013d4798
#: ../../java/stream/stages-overview.rst:514
msgid ""
"Most stages stop and propagate the failure downstream as soon as any of "
"their upstreams emit a failure. This happens to ensure reliable teardown of "
"streams and cleanup when failures happen. Failures are meant to be to model "
"unrecoverable conditions, therefore they are always eagerly propagated. For "
"in-band error handling of normal errors (dropping elements if a map fails "
"for example) you should use the supervision support, or explicitly wrap your"
" element types in a proper container that can express error or success "
"states."
msgstr ""

# 6b82033466da4227b1bfbecfe4fda305
#: ../../java/stream/stages-overview.rst:523
msgid "Simple processing stages"
msgstr ""

# 6083fa33d9ef4271b3def26b006112c5
#: ../../java/stream/stages-overview.rst:525
msgid ""
"These stages can transform the rate of incoming elements since there are "
"stages that emit multiple elements for a single input (e.g. `mapConcat') or "
"consume multiple elements before emitting one output (e.g. ``filter``). "
"However, these rate transformations are data-driven, i.e. it is the incoming"
" elements that define how the rate is affected. This is in contrast with "
":ref:`detached-stages-overview_java` which can change their processing "
"behavior depending on being backpressured by downstream or not."
msgstr ""

# b3fc4e85ca044ccaa82516f6a5d8ac16
#: ../../java/stream/stages-overview.rst:532
msgid "map"
msgstr ""

# de711a3584ad452da76414107b0ea6a3
#: ../../java/stream/stages-overview.rst:533
msgid ""
"Transform each element in the stream by calling a mapping function with it "
"and passing the returned value downstream."
msgstr ""

# 202a279dd1384474b3f15eae9bbb96cd
#: ../../java/stream/stages-overview.rst:535
msgid "**emits** when the mapping function returns an element"
msgstr ""

# 4d5a10e098b2427ba3c74783206795db
# 74132dbdf7ee4697be9102559247bb85
# 938b5d75d05e4435b7c513440132eab3
# bed4289dd6d94ff0b4363345c00c26bc
# 35caef8059314e98af1399e96f42e752
# ebe58d4f51ec49ffbb5c001ecbc86a4f
# de3b9efef4644989a7de7bdd0a8de73a
# 980193399e8a4f7e9e13fbd531979989
# 1197d3aac8c348019ba74b38a8738761
# 54e57226bfa244caa722cce0a51a13f3
# 22bb27613da9402aa9eb074869abfe87
# cc878ab2c2dc4cc8a1e3bf6ed8ce6b54
# 8b3bbee63b7f4c11824ebb8682a3fc22
# c76496886a2a4e5cb368bd726c86f978
# 6003cd287ede40698bacee5a1a97d285
# 23c66eb613674975b5826d2070cfdd16
# 94e3f8179d824148a2ddd6bea0c5d35c
# 4b02eb5a691a4294b3f3da247516782b
# 53fea57cfde444d6955494e7b928e710
# db375d2c23d24413b498c127c1697375
# 0a546e9b1b29448399875d4dea9c4623
# 6cb399134df9498f97dbde144ad1f71f
# 94a6f0ff55de4b3c97703d4edb8ee5d7
#: ../../java/stream/stages-overview.rst:537
#: ../../java/stream/stages-overview.rst:618
#: ../../java/stream/stages-overview.rst:629
#: ../../java/stream/stages-overview.rst:649
#: ../../java/stream/stages-overview.rst:661
#: ../../java/stream/stages-overview.rst:701
#: ../../java/stream/stages-overview.rst:712
#: ../../java/stream/stages-overview.rst:775
#: ../../java/stream/stages-overview.rst:885
#: ../../java/stream/stages-overview.rst:982
#: ../../java/stream/stages-overview.rst:994
#: ../../java/stream/stages-overview.rst:1011
#: ../../java/stream/stages-overview.rst:1024
#: ../../java/stream/stages-overview.rst:1038
#: ../../java/stream/stages-overview.rst:1052
#: ../../java/stream/stages-overview.rst:1064
#: ../../java/stream/stages-overview.rst:1095
#: ../../java/stream/stages-overview.rst:1106
#: ../../java/stream/stages-overview.rst:1116
#: ../../java/stream/stages-overview.rst:1126
#: ../../java/stream/stages-overview.rst:1137
#: ../../java/stream/stages-overview.rst:1147
#: ../../java/stream/stages-overview.rst:1159
msgid "**backpressures** when downstream backpressures"
msgstr ""

# 86e5eacd2a4d4f6fa508eef7862ddbe5
# 23fe0572c2cb400fa6aa54ebb75abae7
# f76784712b0648088ef3fafad20220eb
# 06da8bd1b2444b498ab3bd9720bc1caf
# 0e362d39dbd1418c898f4949a7eb0435
# 0aef3464810c4c65a943ed59828c364a
# 81c17e6d681c4ebabbdebcd02bc621a2
# 6cbafd0eb8444f47b3dc37817e150715
# 39a4487f51d84a2891d4a54d1fc26ce7
# 3396087129924f279004ea981486a314
# e4e991bcd2684c3da452a4a61b7a3681
# ff07e184837b4a91ac7ce639e88970e3
# 50ddf9f7e33f42139dc1ede7d5d7ebe4
# 96e7c606557e4e158472848055fe902a
# 7122962086ac45bb9c698a5c6ac2f7c8
# e226057d48ee494b94712771544fe377
# a5eca81796e84b6ca06be240ae83a86c
# 032a84773ef2495c8a8dd759a0144c01
# 0749eed91caf488f95d059cb3ff3bbd1
# 1ebcca4e8b4c48a386ade6df6914904d
# a797589124044fdb809db2a3cbd681b0
# f8caca897df742cabcc59642383b1bab
# 9141090da83149f1acb33926d9c44450
# 66304eee4dba4523af8b886751646fff
#: ../../java/stream/stages-overview.rst:539
#: ../../java/stream/stages-overview.rst:571
#: ../../java/stream/stages-overview.rst:582
#: ../../java/stream/stages-overview.rst:593
#: ../../java/stream/stages-overview.rst:605
#: ../../java/stream/stages-overview.rst:620
#: ../../java/stream/stages-overview.rst:631
#: ../../java/stream/stages-overview.rst:641
#: ../../java/stream/stages-overview.rst:673
#: ../../java/stream/stages-overview.rst:703
#: ../../java/stream/stages-overview.rst:714
#: ../../java/stream/stages-overview.rst:788
#: ../../java/stream/stages-overview.rst:798
#: ../../java/stream/stages-overview.rst:829
#: ../../java/stream/stages-overview.rst:841
#: ../../java/stream/stages-overview.rst:887
#: ../../java/stream/stages-overview.rst:1066
#: ../../java/stream/stages-overview.rst:1078
#: ../../java/stream/stages-overview.rst:1188
#: ../../java/stream/stages-overview.rst:1198
#: ../../java/stream/stages-overview.rst:1208
#: ../../java/stream/stages-overview.rst:1218
#: ../../java/stream/stages-overview.rst:1244
#: ../../java/stream/stages-overview.rst:1256
msgid "**completes** when upstream completes"
msgstr ""

# c9ae91232914492f8e2f541e476ff041
#: ../../java/stream/stages-overview.rst:542
msgid "mapConcat"
msgstr ""

# 0db86c51dcd641168b88e443a75d1bd3
#: ../../java/stream/stages-overview.rst:543
msgid ""
"Transform each element into zero or more elements that are individually "
"passed downstream."
msgstr ""

# ceb8a44db16f421bba3d32246124c038
# a0cb9400dca648e1b1445c8cf5694385
#: ../../java/stream/stages-overview.rst:545
#: ../../java/stream/stages-overview.rst:556
msgid ""
"**emits** when the mapping function returns an element or there are still "
"remaining elements from the previously calculated collection"
msgstr ""

# afc79e4c9c2442898730334f81669207
# bd0e3c164bc5495b8a2f2f10ba84c13e
#: ../../java/stream/stages-overview.rst:547
#: ../../java/stream/stages-overview.rst:558
msgid ""
"**backpressures** when downstream backpressures or there are still available"
" elements from the previously calculated collection"
msgstr ""

# c8bb4a0639074f7aa654d4f8fcb7a058
# 46e6268a754d4c8ca1ff2dabe7a7b996
#: ../../java/stream/stages-overview.rst:549
#: ../../java/stream/stages-overview.rst:560
msgid ""
"**completes** when upstream completes and all remaining elements has been "
"emitted"
msgstr ""

# c27f5b7b648a45d697d163b8d3576a9d
#: ../../java/stream/stages-overview.rst:552
msgid "statefulMapConcat"
msgstr ""

# 8c9e44f4c1b74364b0bb4550cd314954
#: ../../java/stream/stages-overview.rst:553
msgid ""
"Transform each element into zero or more elements that are individually "
"passed downstream. The difference to ``mapConcat`` is that the "
"transformation function is created from a factory for every materialization "
"of the flow."
msgstr ""

# c6fbd35349134e9d9e022f2b15ba2c31
#: ../../java/stream/stages-overview.rst:563
msgid "filter"
msgstr ""

# e841802b352f4e1783935163bdb3498c
#: ../../java/stream/stages-overview.rst:564
msgid ""
"Filter the incoming elements using a predicate. If the predicate returns "
"true the element is passed downstream, if it returns false the element is "
"discarded."
msgstr ""

# 7afce078e87f481a94e9d88a3f73c3c1
#: ../../java/stream/stages-overview.rst:567
msgid "**emits** when the given predicate returns true for the element"
msgstr ""

# 1f4a2959e0604b0d99c30a802f62c440
#: ../../java/stream/stages-overview.rst:569
msgid ""
"**backpressures** when the given predicate returns true for the element and "
"downstream backpressures"
msgstr ""

# c9d07768142041c493e2408c44761347
#: ../../java/stream/stages-overview.rst:574
msgid "collect"
msgstr ""

# f9fda00530c444ee81a95a085779a6f0
#: ../../java/stream/stages-overview.rst:575
msgid ""
"Apply a partial function to each incoming element, if the partial function "
"is defined for a value the returned value is passed downstream. Can often "
"replace ``filter`` followed by ``map`` to achieve the same in one single "
"stage."
msgstr ""

# c8bf5c0186474ba288b9ddadf977bdf9
#: ../../java/stream/stages-overview.rst:578
msgid ""
"**emits** when the provided partial function is defined for the element"
msgstr ""

# 24c4fcd7be464e98b77da03201c805cf
#: ../../java/stream/stages-overview.rst:580
msgid ""
"**backpressures** the partial function is defined for the element and "
"downstream backpressures"
msgstr ""

# 9e973647b071477084281dd6573077d1
#: ../../java/stream/stages-overview.rst:585
msgid "grouped"
msgstr ""

# 3f5fa7f7e50649b585d5935eeb2adc6b
#: ../../java/stream/stages-overview.rst:586
msgid ""
"Accumulate incoming events until the specified number of elements have been "
"accumulated and then pass the collection of elements downstream."
msgstr ""

# 01ed8897a9ec47f1b109fd3a66287703
#: ../../java/stream/stages-overview.rst:589
msgid ""
"**emits** when the specified number of elements has been accumulated or "
"upstream completed"
msgstr ""

# 7fb9b425948b4280adfc7d2add17dc4e
# 455342d636bc4da3b8e3fd0f77ddf7f0
#: ../../java/stream/stages-overview.rst:591
#: ../../java/stream/stages-overview.rst:603
msgid ""
"**backpressures** when a group has been assembled and downstream "
"backpressures"
msgstr ""

# e3f9a77df7264975bfe3e7970dfe42dd
#: ../../java/stream/stages-overview.rst:596
msgid "sliding"
msgstr ""

# 6fb00b83d3644f29a1748e2e2d0f1e62
#: ../../java/stream/stages-overview.rst:597
msgid ""
"Provide a sliding window over the incoming stream and pass the windows as "
"groups of elements downstream."
msgstr ""

# 78054172b74b4c2b9d9d74da6ad1be88
#: ../../java/stream/stages-overview.rst:599
msgid ""
"Note: the last window might be smaller than the requested size due to end of"
" stream."
msgstr ""

# f90102b3e36c407288d496626ed1c396
#: ../../java/stream/stages-overview.rst:601
msgid ""
"**emits** the specified number of elements has been accumulated or upstream "
"completed"
msgstr ""

# 4ee6bf2217394e0494727e6ece946330
#: ../../java/stream/stages-overview.rst:609
msgid "scan"
msgstr ""

# 6e531bb77ee44c1185e6404a4765a164
#: ../../java/stream/stages-overview.rst:610
msgid ""
"Emit its current value which starts at ``zero`` and then applies the current"
" and next value to the given function emitting the next current value."
msgstr ""

# d78aee4007c448689e18f31273504d2f
#: ../../java/stream/stages-overview.rst:613
msgid ""
"Note that this means that scan emits one element downstream before and "
"upstream elements will not be requested until the second element is required"
" from downstream."
msgstr ""

# 18dfe3e974a7439a970e8bb369a15ede
#: ../../java/stream/stages-overview.rst:616
msgid "**emits** when the function scanning the element returns a new element"
msgstr ""

# 007d49260b8c49ca8520b8c01ac560de
#: ../../java/stream/stages-overview.rst:624
msgid ""
"Start with current value ``zero`` and then apply the current and next value "
"to the given function, when upstream complete the current value is emitted "
"downstream."
msgstr ""

# 80f5a9de708347b987b75e107ec1e3a9
#: ../../java/stream/stages-overview.rst:627
msgid "**emits** when upstream completes"
msgstr ""

# 074153ed3aa44a45a25f14f6e0fab780
#: ../../java/stream/stages-overview.rst:634
msgid "drop"
msgstr ""

# 07bfc7a02a564bfaa2114015c9730e57
#: ../../java/stream/stages-overview.rst:635
msgid "Drop ``n`` elements and then pass any subsequent element downstream."
msgstr ""

# bb1b3f8ce9f44beca49a0334c00f7180
#: ../../java/stream/stages-overview.rst:637
msgid ""
"**emits** when the specified number of elements has been dropped already"
msgstr ""

# 0d229465f14449588d51ebca16e555d1
#: ../../java/stream/stages-overview.rst:639
msgid ""
"**backpressures** when the specified number of elements has been dropped and"
" downstream backpressures"
msgstr ""

# 5f555e49460e45a78377851b35a7e952
#: ../../java/stream/stages-overview.rst:644
msgid "take"
msgstr ""

# 875dcaca4e814da2a3f7a01af01b63f5
#: ../../java/stream/stages-overview.rst:645
msgid "Pass ``n`` incoming elements downstream and then complete"
msgstr ""

# be50722bbe23481d9e80d2c134409b06
#: ../../java/stream/stages-overview.rst:647
msgid ""
"**emits** while the specified number of elements to take has not yet been "
"reached"
msgstr ""

# a994cb7c6266484dbc7cc09557fc2bba
#: ../../java/stream/stages-overview.rst:651
msgid ""
"**completes** when the defined number of elements has been taken or upstream"
" completes"
msgstr ""

# f3d9b1bfb9f3435ca5e52cb9b53c7e73
#: ../../java/stream/stages-overview.rst:655
msgid "takeWhile"
msgstr ""

# bae3fb3114804cb5a3788561b605b765
#: ../../java/stream/stages-overview.rst:656
msgid ""
"Pass elements downstream as long as a predicate function return true for the"
" element include the element when the predicate first return false and then "
"complete."
msgstr ""

# 0d8169fecda740c6a8ff6c6aa715a46e
#: ../../java/stream/stages-overview.rst:659
msgid "**emits** while the predicate is true and until the first false result"
msgstr ""

# e6600071f77940d091b44654fbf64daf
#: ../../java/stream/stages-overview.rst:663
msgid "**completes** when predicate returned false or upstream completes"
msgstr ""

# 9b0a1f87be024369a9c887e7fdadaf45
#: ../../java/stream/stages-overview.rst:666
msgid "dropWhile"
msgstr ""

# e1dfea0c72ca411cbc34fbf3fbd24acd
#: ../../java/stream/stages-overview.rst:667
msgid ""
"Drop elements as long as a predicate function return true for the element"
msgstr ""

# 260af0a4ba684ba4a61adf89de9ad61b
#: ../../java/stream/stages-overview.rst:669
msgid ""
"**emits** when the predicate returned false and for all following stream "
"elements"
msgstr ""

# f17b92ccb07947e98d4a51c3a9c50d35
#: ../../java/stream/stages-overview.rst:671
msgid ""
"**backpressures** predicate returned false and downstream backpressures"
msgstr ""

# 42d56c028c224e289973e61309dc04a6
#: ../../java/stream/stages-overview.rst:676
msgid "recover"
msgstr ""

# ceb8199febdb44ddbde531ae5b5c49a3
#: ../../java/stream/stages-overview.rst:677
msgid ""
"Allow sending of one last element downstream when a failure has happened "
"upstream."
msgstr ""

# 0a7aa31241684420b7643a71f27f7c79
#: ../../java/stream/stages-overview.rst:679
msgid ""
"**emits** when the element is available from the upstream or upstream is "
"failed and pf returns an element"
msgstr ""

# f7101ae2801d4f719be60ef96c80616d
#: ../../java/stream/stages-overview.rst:681
msgid ""
"**backpressures** when downstream backpressures, not when failure happened"
msgstr ""

# 71884e306c0545dda3f981c411ad21a8
#: ../../java/stream/stages-overview.rst:683
msgid ""
"**completes** when upstream completes or upstream failed with exception pf "
"can handle"
msgstr ""

# a02e0a4d7622407d9e5283f487970542
#: ../../java/stream/stages-overview.rst:686
msgid "recoverWith"
msgstr ""

# e90e6a2cdc064a298dd2c4899fc7d17d
#: ../../java/stream/stages-overview.rst:687
msgid ""
"Allow switching to alternative Source when a failure has happened upstream."
msgstr ""

# 89194ed8d26e45b1bd742ae10578b43e
#: ../../java/stream/stages-overview.rst:689
msgid ""
"**emits** the element is available from the upstream or upstream is failed "
"and pf returns alternative Source"
msgstr ""

# 41f6a6ad167a40f8a9667f213f307a3d
#: ../../java/stream/stages-overview.rst:691
msgid ""
"**backpressures** downstream backpressures, after failure happened it "
"backprssures to alternative Source"
msgstr ""

# 1d7683952ca04a84a6a03a98406b054a
#: ../../java/stream/stages-overview.rst:693
msgid ""
"**completes** upstream completes or upstream failed with exception pf can "
"handle"
msgstr ""

# 154a090f6f054de6b829ce00b3a8e765
#: ../../java/stream/stages-overview.rst:696
msgid "detach"
msgstr ""

# e3b63309dc184543877d85f0b7c31867
#: ../../java/stream/stages-overview.rst:697
msgid ""
"Detach upstream demand from downstream demand without detaching the stream "
"rates."
msgstr ""

# bc0822c4f9a341e4a7aa84a94ed7af9a
#: ../../java/stream/stages-overview.rst:699
msgid "**emits** when the upstream stage has emitted and there is demand"
msgstr ""

# de3952bddd2c482d8dd3f6807368722f
#: ../../java/stream/stages-overview.rst:706
msgid "throttle"
msgstr ""

# 6074e46c0d8b46a5ae304c1d6ade4b69
#: ../../java/stream/stages-overview.rst:707
msgid ""
"Limit the throughput to a specific number of elements per time unit, or a "
"specific total cost per time unit, where a function has to be provided to "
"calculate the individual cost of each element."
msgstr ""

# 9037194f9cf743caa73b1153efb9e7e0
#: ../../java/stream/stages-overview.rst:710
msgid ""
"**emits** when upstream emits an element and configured time per each "
"element elapsed"
msgstr ""

# 80ca317f973b41878b6e97d77dc6b875
#: ../../java/stream/stages-overview.rst:719
msgid "Asynchronous processing stages"
msgstr ""

# aa2831bfec7146788527974c2cecae58
#: ../../java/stream/stages-overview.rst:721
msgid ""
"These stages encapsulate an asynchronous computation, properly handling "
"backpressure while taking care of the asynchronous operation at the same "
"time (usually handling the completion of a CompletionStage)."
msgstr ""

# 1248b1bc2fcf4fecbdabe27171d10981
#: ../../java/stream/stages-overview.rst:726
msgid "mapAsync"
msgstr ""

# 3cc26ad26b404e24bdf000cec7abb11d
#: ../../java/stream/stages-overview.rst:727
msgid ""
"Pass incoming elements to a function that return a ``CompletionStage`` "
"result. When the CompletionStage arrives the result is passed downstream. Up"
" to ``n`` elements can be processed concurrently, but regardless of their "
"completion time the incoming order will be kept when results complete. For "
"use cases where order does not mather ``mapAsyncUnordered`` can be used."
msgstr ""

# dbcc9035448d4e3291a9eed67681bf1f
#: ../../java/stream/stages-overview.rst:731
msgid ""
"If a ``CompletionStage`` fails, the stream also fails (unless a different "
"supervision strategy is applied)"
msgstr ""

# aab04a0425db40518d43a413e456c3e9
#: ../../java/stream/stages-overview.rst:733
msgid ""
"**emits** when the CompletionStage returned by the provided function "
"finishes for the next element in sequence"
msgstr ""

# d239442005e749ad882452832a8eeaaf
# 369ea3c6e4f84f90b6287592e5b50e77
#: ../../java/stream/stages-overview.rst:735
#: ../../java/stream/stages-overview.rst:748
msgid ""
"**backpressures** when the number of ``CompletionStage`` s reaches the "
"configured parallelism and the downstream backpressures"
msgstr ""

# 870c809584114c2ba5e8037b19ab47bd
#: ../../java/stream/stages-overview.rst:737
msgid ""
"**completes** when upstream completes and all ``CompletionStage`` s has been"
" completed and all elements has been emitted"
msgstr ""

# 6e07fcb18f394b1eb0e315d97c874d66
#: ../../java/stream/stages-overview.rst:740
msgid "mapAsyncUnordered"
msgstr ""

# 7825b638d9874b248fb15622947b4ede
#: ../../java/stream/stages-overview.rst:741
msgid ""
"Like ``mapAsync`` but ``CompletionStage`` results are passed downstream as "
"they arrive regardless of the order of the elements that triggered them."
msgstr ""

# 0e7557124040452a8937c6d8519c3869
#: ../../java/stream/stages-overview.rst:744
msgid ""
"If a CompletionStage fails, the stream also fails (unless a different "
"supervision strategy is applied)"
msgstr ""

# 2c23ce6fb06c49f4945e8ee750092c35
#: ../../java/stream/stages-overview.rst:746
msgid ""
"**emits** any of the ``CompletionStage`` s returned by the provided function"
" complete"
msgstr ""

# ad1af24828574d1493d789292a7a40b2
#: ../../java/stream/stages-overview.rst:750
msgid ""
"**completes** upstream completes and all CompletionStages has been completed"
"  and all elements has been emitted"
msgstr ""

# 8336beac6c664eab81a72b0cb9e807d4
#: ../../java/stream/stages-overview.rst:754
msgid "Timer driven stages"
msgstr ""

# 070759c4a24b4984b31862515fe008c0
#: ../../java/stream/stages-overview.rst:756
msgid ""
"These stages process elements using timers, delaying, dropping or grouping "
"elements for certain time durations."
msgstr ""

# 6783d3ec5be04eba9bcbd6d61fe07f54
#: ../../java/stream/stages-overview.rst:759
msgid "takeWithin"
msgstr ""

# e2f1218656804f3aabd728c5ebd4ce1d
#: ../../java/stream/stages-overview.rst:760
msgid "Pass elements downstream within a timeout and then complete."
msgstr ""

# 608eb9f41edd4b79842c57cdaa587818
#: ../../java/stream/stages-overview.rst:762
msgid "**emits** when an upstream element arrives"
msgstr ""

# cb5bc4f373174226936443a697d4c4e2
#: ../../java/stream/stages-overview.rst:764
msgid "**backpressures** downstream backpressures"
msgstr ""

# 81ed4599423e4ba6bdcb4d2840ccb448
#: ../../java/stream/stages-overview.rst:766
msgid "**completes** upstream completes or timer fires"
msgstr ""

# be7c3fce7fb1482d85cf731ffeb245e1
#: ../../java/stream/stages-overview.rst:770
msgid "dropWithin"
msgstr ""

# 7cdb948788204534825775732c0bcca0
#: ../../java/stream/stages-overview.rst:771
msgid "Drop elements until a timeout has fired"
msgstr ""

# e49aea1772b04cf1a076ee3c694f8607
#: ../../java/stream/stages-overview.rst:773
msgid "**emits** after the timer fired and a new upstream element arrives"
msgstr ""

# de4f60dd0a81493ebaece6e3faa9b535
#: ../../java/stream/stages-overview.rst:777
msgid "**completes** upstream completes"
msgstr ""

# 0cd053d01172459db2735d7d73afdf84
#: ../../java/stream/stages-overview.rst:780
msgid "groupedWithin"
msgstr ""

# 0786a6dfbce24cc191f95a3b84e5ba9b
#: ../../java/stream/stages-overview.rst:781
msgid ""
"Chunk up the stream into groups of elements received within a time window, "
"or limited by the given number of elements, whichever happens first."
msgstr ""

# 10332051a3854d189fd231f71cd17734
#: ../../java/stream/stages-overview.rst:784
msgid ""
"**emits** when the configured time elapses since the last group has been "
"emitted"
msgstr ""

# 8e550725dcd542928bbb8367abf3df14
#: ../../java/stream/stages-overview.rst:786
msgid ""
"**backpressures** when the group has been assembled (the duration elapsed) "
"and downstream backpressures"
msgstr ""

# f69e6b9bd3144ed7b0da312e2ca30682
# 045dd5c6762d44c5964e56357c179c1c
#: ../../java/stream/stages-overview.rst:791
#: ../../java/stream/stages-overview.rst:1071
msgid "initialDelay"
msgstr ""

# 560536cc5184492db04ff855acf72386
#: ../../java/stream/stages-overview.rst:792
msgid ""
"Delay the initial element by a user specified duration from stream "
"materialization."
msgstr ""

# 69600fcd0e6a49558fe7d681d9a88cf9
#: ../../java/stream/stages-overview.rst:794
msgid ""
"**emits** upstream emits an element if the initial delay already elapsed"
msgstr ""

# 6e8eec2bd15744aca5954daefe4c9bd4
#: ../../java/stream/stages-overview.rst:796
msgid ""
"**backpressures** downstream backpressures or initial delay not yet elapsed"
msgstr ""

# ebc5741097df403cbef1f466414f70c6
#: ../../java/stream/stages-overview.rst:802
msgid "delay"
msgstr ""

# 8f12a688e12941acb8f338455ea05c71
#: ../../java/stream/stages-overview.rst:803
msgid "Delay every element passed through with a specific duration."
msgstr ""

# bd40ebe70851440ab15aa292b363ec06
#: ../../java/stream/stages-overview.rst:805
msgid ""
"**emits** there is a pending element in the buffer and configured time for "
"this element elapsed"
msgstr ""

# 8c4cea95911c4a7f960da82dd0fe7a72
#: ../../java/stream/stages-overview.rst:807
msgid "**backpressures** differs, depends on ``OverflowStrategy`` set"
msgstr ""

# 3836dea689ce4368b1c89d4fa7a2e212
# 2d00a0b97f2a40d8970f421ec8e2ef75
# 244a27ea8fd44d87bb52238d3fb79e27
#: ../../java/stream/stages-overview.rst:809
#: ../../java/stream/stages-overview.rst:898
#: ../../java/stream/stages-overview.rst:925
msgid ""
"**completes** when upstream completes and buffered elements has been drained"
msgstr ""

# 3d3f185de81b42b082064f536f1f051e
#: ../../java/stream/stages-overview.rst:815
msgid "Backpressure aware stages"
msgstr ""

# b96fc8a9830a4d2cb569b163dd3ec2a1
#: ../../java/stream/stages-overview.rst:817
msgid ""
"These stages are aware of the backpressure provided by their downstreams and"
" able to adapt their behavior to that signal."
msgstr ""

# 5c2fd2125b3d42ad884ce47a11a89246
#: ../../java/stream/stages-overview.rst:820
msgid "conflate"
msgstr ""

# 84277f468dbc4c4c83137423016d4259
#: ../../java/stream/stages-overview.rst:821
msgid ""
"Allow for a slower downstream by passing incoming elements and a summary "
"into an aggregate function as long as there is backpressure. The summary "
"value must be of the same type as the incoming elements, for example the sum"
" or average of incoming numbers, if aggregation should lead to a different "
"type ``conflateWithSeed`` can be used:"
msgstr ""

# f270b459af0d4e87aefecc9ee2d84556
# 904b03904b934570a7c8db0c2d93ffe7
#: ../../java/stream/stages-overview.rst:825
#: ../../java/stream/stages-overview.rst:837
msgid ""
"**emits** when downstream stops backpressuring and there is a conflated "
"element available"
msgstr ""

# d8bf3133e88a4227aaa7ce3728e38358
#: ../../java/stream/stages-overview.rst:827
msgid ""
"**backpressures** when the aggregate function cannot keep up with incoming "
"elements"
msgstr ""

# 48e2dce181564386b6d9507208e7838f
#: ../../java/stream/stages-overview.rst:832
msgid "conflateWithSeed"
msgstr ""

# 9d44234b2704485fb9f6bab06ae21e9d
#: ../../java/stream/stages-overview.rst:833
msgid ""
"Allow for a slower downstream by passing incoming elements and a summary "
"into an aggregate function as long as there is backpressure. When "
"backpressure starts or there is no backpressure element is passed into a "
"``seed`` function to transform it to the summary type."
msgstr ""

# 3d9079329d2b4339af6514155e910593
#: ../../java/stream/stages-overview.rst:839
msgid ""
"**backpressures** when the aggregate or seed functions cannot keep up with "
"incoming elements"
msgstr ""

# 2e195f5429854eb3850bfdde91041dae
#: ../../java/stream/stages-overview.rst:844
msgid "batch"
msgstr ""

# 5f56a0305f834bdbb0b03e68a7bb47e4
#: ../../java/stream/stages-overview.rst:845
msgid ""
"Allow for a slower downstream by passing incoming elements and a summary "
"into an aggregate function as long as there is backpressure and a maximum "
"number of batched elements is not yet reached. When the maximum number is "
"reached and downstream still backpressures batch will also backpressure."
msgstr ""

# 4a5589414d8e44c9a8d5c6408e872164
#: ../../java/stream/stages-overview.rst:849
msgid ""
"When backpressure starts or there is no backpressure element is passed into "
"a ``seed`` function to transform it to the summary type."
msgstr ""

# ad3b7457348c4ef3b68c4ca91b771603
# 41438f77de294ef0b0a834ee7ce51590
#: ../../java/stream/stages-overview.rst:852
#: ../../java/stream/stages-overview.rst:869
msgid ""
"Will eagerly pull elements, this behavior may result in a single pending "
"(i.e. buffered) element which cannot be aggregated to the batched value."
msgstr ""

# 2fd393399cd84807a800a11ef399a604
#: ../../java/stream/stages-overview.rst:855
msgid ""
"**emits** when downstream stops backpressuring and there is a batched "
"element available"
msgstr ""

# dcf1d1050eba4e52bb499b8091745344
#: ../../java/stream/stages-overview.rst:857
msgid ""
"**backpressures** when batched elements reached the max limit of allowed "
"batched elements & downstream backpressures"
msgstr ""

# 602e8db0f5174eb58d3548991f59d0fe
#: ../../java/stream/stages-overview.rst:859
msgid ""
"**completes** when upstream completes and a \"possibly pending\" element was"
" drained"
msgstr ""

# ec74b6e7c19841cbb5d82dc0aabf0646
#: ../../java/stream/stages-overview.rst:863
msgid "batchWeighted"
msgstr ""

# 966f26cc06264fa389e4e11d616e353c
#: ../../java/stream/stages-overview.rst:864
msgid ""
"Allow for a slower downstream by passing incoming elements and a summary "
"into an aggregate function as long as there is backpressure and a maximum "
"weight batched elements is not yet reached. The weight of each element is "
"determined by applying ``costFn``. When the maximum total weight is reached "
"and downstream still backpressures batch will also backpressure."
msgstr ""

# b04563f1fec5454992efc30ca0b566d1
#: ../../java/stream/stages-overview.rst:872
msgid ""
"**emits** downstream stops backpressuring and there is a batched element "
"available"
msgstr ""

# 4de1e0decfea49a994906e70ac9a375c
#: ../../java/stream/stages-overview.rst:874
msgid ""
"**backpressures** batched elements reached the max weight limit of allowed "
"batched elements & downstream backpressures"
msgstr ""

# 367aab5077044a069724c1c644de79ff
#: ../../java/stream/stages-overview.rst:876
msgid ""
"**completes** upstream completes and a \"possibly pending\" element was "
"drained"
msgstr ""

# 0323eff327c6451b9bebf737de099333
#: ../../java/stream/stages-overview.rst:879
msgid "expand"
msgstr ""

# 6fcf9916ac2d4b6c84bd4f542760c836
#: ../../java/stream/stages-overview.rst:880
msgid ""
"Allow for a faster downstream by expanding the last incoming element to an "
"``Iterator``. For example ``Iterator.continually(element)`` to keep repating"
" the last incoming element."
msgstr ""

# be773e777bca46f0a621374a949d34b8
#: ../../java/stream/stages-overview.rst:883
msgid "**emits** when downstream stops backpressuring"
msgstr ""

# 0915f567f62440b0bd92eae963c4e21b
#: ../../java/stream/stages-overview.rst:890
msgid "buffer (Backpressure)"
msgstr ""

# 6f38bb51c5db4da9bdb26ae63dd216f6
#: ../../java/stream/stages-overview.rst:891
msgid ""
"Allow for a temporarily faster upstream events by buffering ``size`` "
"elements. When the buffer is full backpressure is applied."
msgstr ""

# 7165baac34604f239079862fa73447db
# d56eab5805484d98a5110f60afc9677b
# 95556d7a84314fa9a53412104cebf9f7
#: ../../java/stream/stages-overview.rst:894
#: ../../java/stream/stages-overview.rst:910
#: ../../java/stream/stages-overview.rst:921
msgid ""
"**emits** when downstream stops backpressuring and there is a pending "
"element in the buffer"
msgstr ""

# fbccce9fe31d44fa96403979fd025cf2
#: ../../java/stream/stages-overview.rst:896
msgid "**backpressures** when buffer is full"
msgstr ""

# 2de22c8bbe084a9086243219e8eec6d5
#: ../../java/stream/stages-overview.rst:901
msgid "buffer (Drop)"
msgstr ""

# 3184ed24b8034e4fa1344a84dfce8560
#: ../../java/stream/stages-overview.rst:902
msgid ""
"Allow for a temporarily faster upstream events by buffering ``size`` "
"elements. When the buffer is full elements are dropped according to the "
"specified ``OverflowStrategy``:"
msgstr ""

# 536bfbb1809f45bb932c6ef06c01638e
#: ../../java/stream/stages-overview.rst:905
msgid ""
"``dropHead()`` drops the oldest element in the buffer to make space for the "
"new element"
msgstr ""

# 15744634772746ac97366f63b1ae3099
#: ../../java/stream/stages-overview.rst:906
msgid ""
"``dropTail()`` drops the youngest element in the buffer to make space for "
"the new element"
msgstr ""

# a8a22d734fff46dbbc73be8f6ddeb06d
#: ../../java/stream/stages-overview.rst:907
msgid "``dropBuffer()`` drops the entire buffer and buffers the new element"
msgstr ""

# 97cb67b8d31748139f40945226d9b6b3
#: ../../java/stream/stages-overview.rst:908
msgid "``dropNew()`` drops the new element"
msgstr ""

# 4a1328651a1342949213987627573d51
#: ../../java/stream/stages-overview.rst:912
msgid ""
"**backpressures** never (when dropping cannot keep up with incoming "
"elements)"
msgstr ""

# 6700455e9f774319af500266bddccb3c
#: ../../java/stream/stages-overview.rst:914
msgid ""
"**completes** upstream completes and buffered elements has been drained"
msgstr ""

# a87eb3475b5145719062f5e4cdd743ce
#: ../../java/stream/stages-overview.rst:917
msgid "buffer (Fail)"
msgstr ""

# d4e6186e23834224b12ebeb5c35f13ce
#: ../../java/stream/stages-overview.rst:918
msgid ""
"Allow for a temporarily faster upstream events by buffering ``size`` "
"elements. When the buffer is full the stage fails the flow with a "
"``BufferOverflowException``."
msgstr ""

# f79009793eca4dd18b496e1b62dd5fa3
#: ../../java/stream/stages-overview.rst:923
msgid ""
"**backpressures** never, fails the stream instead of backpressuring when "
"buffer is full"
msgstr ""

# 64e2605a75c1441189443060f20f7223
#: ../../java/stream/stages-overview.rst:929
msgid "Nesting and flattening stages"
msgstr ""

# 3cfd7e1c0a2644e69ed4f8e96e07cab0
#: ../../java/stream/stages-overview.rst:931
msgid ""
"These stages either take a stream and turn it into a stream of streams "
"(nesting) or they take a stream that contains nested streams and turn them "
"into a stream of elements instead (flattening)."
msgstr ""

# 1f9ffa015ba7461a8e39773257d36133
#: ../../java/stream/stages-overview.rst:935
msgid "prefixAndTail"
msgstr ""

# 384816fa1df14420a97bf86f6e957a7d
#: ../../java/stream/stages-overview.rst:936
msgid ""
"Take up to `n` elements from the stream (less than `n` only if the upstream "
"completes before emitting `n` elements) and returns a pair containing a "
"strict sequence of the taken element and a stream representing the remaining"
" elements."
msgstr ""

# a7fecf43be5c417593a1cf4336093daf
#: ../../java/stream/stages-overview.rst:939
msgid ""
"**emits** when the configured number of prefix elements are available. Emits"
" this prefix, and the rest as a substream"
msgstr ""

# 0a8e0a6ba0d54a01b40fedbc727fd123
#: ../../java/stream/stages-overview.rst:941
msgid ""
"**backpressures** when downstream backpressures or substream backpressures"
msgstr ""

# ef2cd8b3007a432d9659fe57079cf703
#: ../../java/stream/stages-overview.rst:943
msgid ""
"**completes** when prefix elements has been consumed and substream has been "
"consumed"
msgstr ""

# 0ea8f97f16444e3488e3838a49e17e4e
#: ../../java/stream/stages-overview.rst:947
msgid "groupBy"
msgstr ""

# 6ff645c67b5e46639eed007b1084e584
#: ../../java/stream/stages-overview.rst:948
msgid "Demultiplex the incoming stream into separate output streams."
msgstr ""

# 946fafe7728c4410aaa81142c3985631
#: ../../java/stream/stages-overview.rst:950
msgid ""
"**emits** an element for which the grouping function returns a group that "
"has not yet been created. Emits the new group there is an element pending "
"for a group whose substream backpressures"
msgstr ""

# 85cf0b810cf44862b6c9a769422bde82
# e64689634da143e09cf903dccae0ac59
# d8b72e7eeb0f4d5faf8e3182a0176354
#: ../../java/stream/stages-overview.rst:953
#: ../../java/stream/stages-overview.rst:963
#: ../../java/stream/stages-overview.rst:973
msgid ""
"**completes** when upstream completes (Until the end of stream it is not "
"possible to know whether new substreams will be needed or not)"
msgstr ""

# 2b083554ea7b42a5b75d19f04185e275
#: ../../java/stream/stages-overview.rst:956
msgid "splitWhen"
msgstr ""

# c60b8669bdb04a199a425bc52b445b79
#: ../../java/stream/stages-overview.rst:957
msgid ""
"Split off elements into a new substream whenever a predicate function return"
" ``true``."
msgstr ""

# 8c45ebdb77bd40f2a7e86efc335a10ef
#: ../../java/stream/stages-overview.rst:959
msgid ""
"**emits** an element for which the provided predicate is true, opening and "
"emitting a new substream for subsequent elements"
msgstr ""

# b3a995970df04987ad5defed5d983526
# fe096ce6edb0450e93a61deab65ecc89
#: ../../java/stream/stages-overview.rst:961
#: ../../java/stream/stages-overview.rst:971
msgid ""
"**backpressures** when there is an element pending for the next substream, "
"but the previous is not fully consumed yet, or the substream backpressures"
msgstr ""

# 3b408fb72e154cdb92eb4546cfe64b18
#: ../../java/stream/stages-overview.rst:966
msgid "splitAfter"
msgstr ""

# b9adf210fea6450d9c6ca21b9fabfc21
#: ../../java/stream/stages-overview.rst:967
msgid ""
"End the current substream whenever a predicate returns ``true``, starting a "
"new substream for the next element."
msgstr ""

# 67d208c13c1748068e7806dbcbb55734
#: ../../java/stream/stages-overview.rst:969
msgid ""
"**emits** when an element passes through. When the provided predicate is "
"true it emits the element * and opens a new substream for subsequent element"
msgstr ""

# dd4eb484a3d34b1fa3882a7842f3ffec
#: ../../java/stream/stages-overview.rst:976
msgid "flatMapConcat"
msgstr ""

# c5057b45192a48f58d39e84e5346f7f6
#: ../../java/stream/stages-overview.rst:977
msgid ""
"Transform each input element into a ``Source`` whose elements are then "
"flattened into the output stream through concatenation. This means each "
"source is fully consumed before consumption of the next source starts."
msgstr ""

# fb3e711c611e4ef1a76a6bf41fdd054f
#: ../../java/stream/stages-overview.rst:980
msgid "**emits** when the current consumed substream has an element available"
msgstr ""

# 2da3359cb66a4de4a753f6704bc6fb88
# af4a15999acc4c42a6b1e2eff42bb7b6
#: ../../java/stream/stages-overview.rst:984
#: ../../java/stream/stages-overview.rst:996
msgid ""
"**completes** when upstream completes and all consumed substreams complete"
msgstr ""

# e54eccea8d864f7cbe06e15325e8e69a
#: ../../java/stream/stages-overview.rst:988
msgid "flatMapMerge"
msgstr ""

# 9759056bd8644246913ac1438dfcf63c
#: ../../java/stream/stages-overview.rst:989
msgid ""
"Transform each input element into a ``Source`` whose elements are then "
"flattened into the output stream through merging. The maximum number of "
"merged sources has to be specified."
msgstr ""

# 5899b783480a4788bc1c4d78ad7aea63
#: ../../java/stream/stages-overview.rst:992
msgid ""
"**emits** when one of the currently consumed substreams has an element "
"available"
msgstr ""

# 08866b37eb79400ab00dd7646b7d5efc
#: ../../java/stream/stages-overview.rst:1000
msgid "Time aware stages"
msgstr ""

# 6e2c2bc1210345f2a7a1ea2134637e51
#: ../../java/stream/stages-overview.rst:1002
msgid "Those stages operate taking time into consideration."
msgstr ""

# 0ccb0c9e9d884fe6acc7e590812e2c4a
#: ../../java/stream/stages-overview.rst:1005
msgid "initialTimeout"
msgstr ""

# 21374d62e1bb446f87022948576b41a4
#: ../../java/stream/stages-overview.rst:1006
msgid ""
"If the first element has not passed through this stage before the provided "
"timeout, the stream is failed with a ``TimeoutException``."
msgstr ""

# a1519136dfb54b339a89f7e9365d7c28
# 874e54863b544843b524621b038d06fa
# ce22cf131c104c4799dd41e4af281e11
# fcc4ab6240bd429c8bba76f2f354180b
# 299498c473e745c5ad89cb309332c6b0
#: ../../java/stream/stages-overview.rst:1009
#: ../../java/stream/stages-overview.rst:1022
#: ../../java/stream/stages-overview.rst:1036
#: ../../java/stream/stages-overview.rst:1050
#: ../../java/stream/stages-overview.rst:1252
msgid "**emits** when upstream emits an element"
msgstr ""

# bdd7c0d1e42f426aa20c039e93ce1703
#: ../../java/stream/stages-overview.rst:1013
msgid ""
"**completes** when upstream completes or fails if timeout elapses before "
"first element arrives"
msgstr ""

# 0733651e45b64d088f39efdf022ef001
# 323a7fdfe78e4503ae29b276dd2ab179
# 6d7ea5b293394213ab116339a9ddc3c3
# b46fa6a34af244a4ac73a917f66df9da
# 4b0a2d6e74ce4302b741d6c220e4c015
# 3b85fa005967414aaddcca4319a7f910
#: ../../java/stream/stages-overview.rst:1015
#: ../../java/stream/stages-overview.rst:1028
#: ../../java/stream/stages-overview.rst:1042
#: ../../java/stream/stages-overview.rst:1056
#: ../../java/stream/stages-overview.rst:1068
#: ../../java/stream/stages-overview.rst:1080
msgid "**cancels** when downstream cancels"
msgstr ""

# 4108ddf487b245e4b00183c438ce33c4
#: ../../java/stream/stages-overview.rst:1018
msgid "completionTimeout"
msgstr ""

# cbae1facdb86456ca099466e4b84d419
#: ../../java/stream/stages-overview.rst:1019
msgid ""
"If the completion of the stream does not happen until the provided timeout, "
"the stream is failed with a ``TimeoutException``."
msgstr ""

# 4fecc86f2d46426989310d869551b38c
#: ../../java/stream/stages-overview.rst:1026
msgid ""
"**completes** when upstream completes or fails if timeout elapses before "
"upstream completes"
msgstr ""

# ea7eb8c02b164be8a2067bd3261ab632
#: ../../java/stream/stages-overview.rst:1031
msgid "idleTimeout"
msgstr ""

# 8b729a88e6e44ebbbd850aa45e7eb329
#: ../../java/stream/stages-overview.rst:1032
msgid ""
"If the time between two processed elements exceeds the provided timeout, the"
" stream is failed with a ``TimeoutException``. The timeout is checked "
"periodically, so the resolution of the check is one period (equals to "
"timeout value)."
msgstr ""

# ef90c5c9db8e424396af32de192f11ca
#: ../../java/stream/stages-overview.rst:1040
msgid ""
"**completes** when upstream completes or fails if timeout elapses between "
"two emitted elements"
msgstr ""

# 3609b275f38340f6b3b4232e15a1c16f
#: ../../java/stream/stages-overview.rst:1045
msgid "backpressureTimeout"
msgstr ""

# 236480aeac2f407293bc526708c6e4fc
#: ../../java/stream/stages-overview.rst:1046
msgid ""
"If the time between the emission of an element and the following downstream "
"demand exceeds the provided timeout, the stream is failed with a "
"``TimeoutException``. The timeout is checked periodically, so the resolution"
" of the check is one period (equals to timeout value)."
msgstr ""

# 387cd80d8b5241f69c9904a3b992ecf4
#: ../../java/stream/stages-overview.rst:1054
msgid ""
"**completes** when upstream completes or fails if timeout elapses between "
"element emission and downstream demand."
msgstr ""

# 44115a4d57644b2c87ba4d4ed5d47c8a
#: ../../java/stream/stages-overview.rst:1059
msgid "keepAlive"
msgstr ""

# 54f1df3599764679883caa53718ec048
#: ../../java/stream/stages-overview.rst:1060
msgid ""
"Injects additional (configured) elements if upstream does not emit for a "
"configured amount of time."
msgstr ""

# 6ba77bbbb65a4f9ba3c920029df83621
#: ../../java/stream/stages-overview.rst:1062
msgid ""
"**emits** when upstream emits an element or if the upstream was idle for the"
" configured period"
msgstr ""

# 54f2628703134462a19bf615cadfeabb
#: ../../java/stream/stages-overview.rst:1072
msgid "Delays the initial element by the specified duration."
msgstr ""

# 29e099982da449e69259e208e9f4171e
#: ../../java/stream/stages-overview.rst:1074
msgid ""
"**emits** when upstream emits an element if the initial delay is already "
"elapsed"
msgstr ""

# 908cbf55f4ac4bd7aff15929fefef8e3
#: ../../java/stream/stages-overview.rst:1076
msgid ""
"**backpressures** when downstream backpressures or initial delay is not yet "
"elapsed"
msgstr ""

# 4871ecf702f642b984b6813a0af0718b
#: ../../java/stream/stages-overview.rst:1084
msgid "Fan-in stages"
msgstr ""

# 55c973c29f18438db347a2ffb2a7915e
#: ../../java/stream/stages-overview.rst:1086
msgid ""
"These stages take multiple streams as their input and provide a single "
"output combining the elements from all of the inputs in different ways."
msgstr ""

# 68b6202e345b4e1e94df50c764ad6054
#: ../../java/stream/stages-overview.rst:1090
msgid "merge"
msgstr ""

# f1ec484e933c4a20be049305c2399aaf
#: ../../java/stream/stages-overview.rst:1091
msgid ""
"Merge multiple sources. Picks elements randomly if all sources has elements "
"ready."
msgstr ""

# 3266a9f99d0046de8eeab4969addc345
#: ../../java/stream/stages-overview.rst:1093
msgid "**emits** when one of the inputs has an element available"
msgstr ""

# bbd64a1e5803417db5916b79f660fce7
# a769f0d7fa7043e08cd26d82aa9b7de9
#: ../../java/stream/stages-overview.rst:1097
#: ../../java/stream/stages-overview.rst:1118
msgid ""
"**completes** when all upstreams complete (This behavior is changeable to "
"completing when any upstream completes by setting ``eagerComplete=true``.)"
msgstr ""

# a946cecd276a4df1baf7dbfe9b71fc92
#: ../../java/stream/stages-overview.rst:1100
msgid "mergeSorted"
msgstr ""

# d6ee988b926f451fbe1a938f9319a597
#: ../../java/stream/stages-overview.rst:1101
msgid ""
"Merge multiple sources. Waits for one element to be ready from each input "
"stream and emits the smallest element."
msgstr ""

# 226fbbfa78fc4d66a489dafcf1005c0f
# dc9c0d2b4a1642029fe9b6429ff121a5
# b440dbb6859f4ea1b7c7e8842d1dcb4f
#: ../../java/stream/stages-overview.rst:1104
#: ../../java/stream/stages-overview.rst:1124
#: ../../java/stream/stages-overview.rst:1135
msgid "**emits** when all of the inputs have an element available"
msgstr ""

# 5d64d6cd1c134f6ca3891868489f3b7d
# 13e1fb521b4f48f1a676dedb27d8dd9c
# 08da72e7b0d94ae7ba847c8a6dd0c0a5
#: ../../java/stream/stages-overview.rst:1108
#: ../../java/stream/stages-overview.rst:1149
#: ../../java/stream/stages-overview.rst:1161
msgid "**completes** when all upstreams complete"
msgstr ""

# 2f1eb45040c0445995bb786bc2d842d4
#: ../../java/stream/stages-overview.rst:1111
msgid "mergePreferred"
msgstr ""

# fbe55e9ac32340a69f1d0dea806fef42
#: ../../java/stream/stages-overview.rst:1112
msgid ""
"Merge multiple sources. Prefer one source if all sources has elements ready."
msgstr ""

# be25ea2598554c32a65391e4465f3db3
#: ../../java/stream/stages-overview.rst:1114
msgid ""
"**emits** when one of the inputs has an element available, preferring a "
"defined input if multiple have elements available"
msgstr ""

# c224b0edfa574214b6e8e2f6afe168e9
#: ../../java/stream/stages-overview.rst:1121
msgid "zip"
msgstr ""

# be75bf22f9dc427c948430be48892375
#: ../../java/stream/stages-overview.rst:1122
msgid ""
"Combines elements from each of multiple sources into `Pair` s and passes the"
" pairs downstream."
msgstr ""

# 6bee3bb69d6d4dcfabfe6a4514665a5e
#: ../../java/stream/stages-overview.rst:1131
msgid "zipWith"
msgstr ""

# d13cc88c34f546428b3d1aa278f120f0
#: ../../java/stream/stages-overview.rst:1132
msgid ""
"Combines elements from multiple sources through a ``combine`` function and "
"passes the returned value downstream."
msgstr ""

# d369b6d6787c42038ce5c62dec28b7ac
#: ../../java/stream/stages-overview.rst:1142
msgid "concat"
msgstr ""

# a4c913a9209b47f1b94525e05c9a9fd3
#: ../../java/stream/stages-overview.rst:1143
msgid ""
"After completion of the original upstream the elements of the given source "
"will be emitted."
msgstr ""

# 18cea5752928490a93f86c06c3c154d4
#: ../../java/stream/stages-overview.rst:1145
msgid ""
"**emits** when the current stream has an element available; if the current "
"input completes, it tries the next one"
msgstr ""

# 2f6b48021426432ba8b49c7863000056
#: ../../java/stream/stages-overview.rst:1152
msgid "prepend"
msgstr ""

# eb85152c5028415db6972f7073dcad8a
#: ../../java/stream/stages-overview.rst:1153
msgid ""
"Prepends the given source to the flow, consuming it until completion before "
"the original source is consumed."
msgstr ""

# 9a63ff193e124683a3287e85630a0198
#: ../../java/stream/stages-overview.rst:1155
msgid ""
"If materialized values needs to be collected ``prependMat`` is available."
msgstr ""

# c51c939e7aa8447c89657cc192d44eb4
#: ../../java/stream/stages-overview.rst:1157
msgid ""
"**emits** when the given stream has an element available; if the given input"
" completes, it tries the current one"
msgstr ""

# f2885045e6e24ee4a352bbba8e0ff20b
#: ../../java/stream/stages-overview.rst:1164
msgid "interleave"
msgstr ""

# d9d92c02989f40aab4c25ccde4b84fd4
#: ../../java/stream/stages-overview.rst:1165
msgid ""
"Emits a specifiable number of elements from the original source, then from "
"the provided source and repeats. If one source completes the rest of the "
"other stream will be emitted."
msgstr ""

# 465f12613ad741a6937539c66725ee36
#: ../../java/stream/stages-overview.rst:1168
msgid ""
"**emits** when element is available from the currently consumed upstream"
msgstr ""

# 8a712e263023444e9a031689ce5aa124
#: ../../java/stream/stages-overview.rst:1170
msgid "**backpressures** when upstream backpressures"
msgstr ""

# a5c51f42dc0b4ef9b71c59ac06956381
#: ../../java/stream/stages-overview.rst:1172
msgid "**completes** when both upstreams have completed"
msgstr ""

# 2f9d697d6f8a4b23b26f2b5cd320e7fe
#: ../../java/stream/stages-overview.rst:1175
msgid "Fan-out stages"
msgstr ""

# f9491325fab34cb193918d1914954e23
#: ../../java/stream/stages-overview.rst:1177
msgid ""
"These have one input and multiple outputs. They might route the elements "
"between different outputs, or emit elements on multiple outputs at the same "
"time."
msgstr ""

# 33d5fea1920e4598a8da97b55094504f
#: ../../java/stream/stages-overview.rst:1181
msgid "unzip"
msgstr ""

# b9a8414258b84d2c9f10817cc60d8b57
#: ../../java/stream/stages-overview.rst:1182
msgid ""
"Takes a stream of two element tuples and unzips the two elements ino two "
"different downstreams."
msgstr ""

# b35196989eb04c93a45f7c5ab043382e
# b5bebf607e884800894cea60cc38c05b
# 7cdfe68c1bc542b3a9837a7037c1f221
#: ../../java/stream/stages-overview.rst:1184
#: ../../java/stream/stages-overview.rst:1194
#: ../../java/stream/stages-overview.rst:1204
msgid ""
"**emits** when all of the outputs stops backpressuring and there is an input"
" element available"
msgstr ""

# 26382b432fa1440db0e274e3dd3e90a6
# e4625d3c97e045e196641b0058b6faa0
# 615bc1efe39f44439206561453abb7c2
#: ../../java/stream/stages-overview.rst:1186
#: ../../java/stream/stages-overview.rst:1196
#: ../../java/stream/stages-overview.rst:1206
msgid "**backpressures** when any of the outputs backpressures"
msgstr ""

# 18d103239cd54f9d81dce3f3324b8c08
#: ../../java/stream/stages-overview.rst:1191
msgid "unzipWith"
msgstr ""

# c72251eae7c74b39bc66efefec085591
#: ../../java/stream/stages-overview.rst:1192
msgid ""
"Splits each element of input into multiple downstreams using a function"
msgstr ""

# c4ac57fe853242f7bcb31292e35ec463
#: ../../java/stream/stages-overview.rst:1201
msgid "broadcast"
msgstr ""

# f477f75d20494ac19fc8f508ebb829a3
#: ../../java/stream/stages-overview.rst:1202
msgid "Emit each incoming element each of ``n`` outputs."
msgstr ""

# 26a04c705e1b4f6993447ceb4aef5463
#: ../../java/stream/stages-overview.rst:1211
msgid "balance"
msgstr ""

# 0140f1873a9e409b9f4062228ad1915f
#: ../../java/stream/stages-overview.rst:1212
msgid ""
"Fan-out the stream to several streams. Each upstream element is emitted to "
"the first available downstream consumer."
msgstr ""

# 53b864615509419ab1e1ecdc81b00921
#: ../../java/stream/stages-overview.rst:1214
msgid ""
"**emits** when any of the outputs stops backpressuring; emits the element to"
" the first available output"
msgstr ""

# 3dca85506a374835abade479742cb70c
#: ../../java/stream/stages-overview.rst:1216
msgid "**backpressures** when all of the outputs backpressure"
msgstr ""

# 0a81247eca7e4b02912d69642bdfc048
#: ../../java/stream/stages-overview.rst:1221
msgid "partition"
msgstr ""

# b84d854ff8ce4a1190b97122cbee9cd7
#: ../../java/stream/stages-overview.rst:1222
msgid ""
"Fan-out the stream to several streams. Each upstream element is emitted to "
"one downstream consumer according to the partitioner function applied to the"
" element."
msgstr ""

# 878496d0f70c44768ae41dff4b7fed6a
#: ../../java/stream/stages-overview.rst:1225
msgid ""
"**emits** when the chosen output stops backpressuring and there is an input "
"element available"
msgstr ""

# 53b2d34770b04ce7a4a0e95e80f9e82e
#: ../../java/stream/stages-overview.rst:1227
msgid "**backpressures** when the chosen output backpressures"
msgstr ""

# bf2a563da47a4a1180aed6e8f9ed1aa7
#: ../../java/stream/stages-overview.rst:1229
msgid "**completes** when upstream completes and no output is pending"
msgstr ""

# 57dc6b03b0cd423fbd21a837e6695ee3
#: ../../java/stream/stages-overview.rst:1233
msgid "Watching status stages"
msgstr ""

# c05be1029cfa404895741473ceef31e0
#: ../../java/stream/stages-overview.rst:1236
msgid "watchTermination"
msgstr ""

# f87e1b91e38d480ba80fa9a3027aad7e
#: ../../java/stream/stages-overview.rst:1237
msgid ""
"Materializes to a ``CompletionStage`` that will be completed with Done or "
"failed depending whether the upstream of the stage has been completed or "
"failed. The stage otherwise passes through elements unchanged."
msgstr ""

# 923bf14a0af84cde95a65e6723b4982f
#: ../../java/stream/stages-overview.rst:1240
msgid "**emits** when input has an element available"
msgstr ""

# 3e7015a5b31a4e36b96ab100ecefcb3b
#: ../../java/stream/stages-overview.rst:1242
msgid "**backpressures** when output backpressures"
msgstr ""

# 4518fb885d204eaf9f0976ba417992a8
#: ../../java/stream/stages-overview.rst:1247
msgid "monitor"
msgstr ""

# e1ecfa663f82479ba33141e3f6907261
#: ../../java/stream/stages-overview.rst:1248
msgid ""
"Materializes to a ``FlowMonitor`` that monitors messages flowing through or "
"completion of the stage. The stage otherwise passes through elements "
"unchanged. Note that the ``FlowMonitor`` inserts a memory barrier every time"
" it processes an event, and may therefore affect performance."
msgstr ""

# e5c7324a7e2e41bf92901fec96f456ac
#: ../../java/stream/stages-overview.rst:1254
msgid "**backpressures** when downstream **backpressures**"
msgstr ""

# 06f19ee5588a4fe4a40891c24385481e
#: ../../java/stream/stream-composition.rst:4
msgid "Modularity, Composition and Hierarchy"
msgstr ""

# 6bfb39393ab647f290a37592f3ea0029
#: ../../java/stream/stream-composition.rst:6
msgid ""
"Akka Streams provide a uniform model of stream processing graphs, which "
"allows flexible composition of reusable components. In this chapter we show "
"how these look like from the conceptual and API perspective, demonstrating "
"the modularity aspects of the library."
msgstr ""

# 44532d18a85b495482765426b6018e95
#: ../../java/stream/stream-composition.rst:11
msgid "Basics of composition and modularity"
msgstr ""

# 2af036846c6946c1a720d56531d38cef
#: ../../java/stream/stream-composition.rst:13
msgid ""
"Every processing stage used in Akka Streams can be imagined as a \"box\" "
"with input and output ports where elements to be processed arrive and leave "
"the stage. In this view, a :class:`Source` is nothing else than a \"box\" "
"with a single output port, or, a :class:`BidiFlow` is a \"box\" with exactly"
" two input and two output ports. In the figure below we illustrate the most "
"common used stages viewed as \"boxes\"."
msgstr ""

# 6a8a5c8199ff454fb89fbd8409c1bd2f
#: ../../java/stream/stream-composition.rst:25
msgid ""
"The *linear* stages are :class:`Source`, :class:`Sink` and :class:`Flow`, as"
" these can be used to compose strict chains of processing stages. Fan-in and"
" Fan-out stages have usually multiple input or multiple output ports, "
"therefore they allow to build more complex graph layouts, not just chains. "
":class:`BidiFlow` stages are usually useful in IO related tasks, where there"
" are input and output channels to be handled. Due to the specific shape of "
":class:`BidiFlow` it is easy to stack them on top of each other to build a "
"layered protocol for example. The ``TLS`` support in Akka is for example "
"implemented as a :class:`BidiFlow`."
msgstr ""

# ccf8100727954b3980c89992b87b9d0f
#: ../../java/stream/stream-composition.rst:33
msgid ""
"These reusable components already allow the creation of complex processing "
"networks. What we have seen so far does not implement modularity though. It "
"is desirable for example to package up a larger graph entity into a reusable"
" component which hides its internals only exposing the ports that are meant "
"to the users of the module to interact with. One good example is the "
"``Http`` server component, which is encoded internally as a "
":class:`BidiFlow` which interfaces with the client TCP connection using an "
"input-output port pair accepting and sending :class:`ByteString` s, while "
"its upper ports emit and receive :class:`HttpRequest` and "
":class:`HttpResponse` instances."
msgstr ""

# 31dd0e2533fb44dcb83ecb887cacaadc
#: ../../java/stream/stream-composition.rst:40
msgid ""
"The following figure demonstrates various composite stages, that contain "
"various other type of stages internally, but hiding them behind a *shape* "
"that looks like a :class:`Source`, :class:`Flow`, etc."
msgstr ""

# 8196ad313bb24925bd1cd76c5e2c963a
#: ../../java/stream/stream-composition.rst:50
msgid ""
"One interesting example above is a :class:`Flow` which is composed of a "
"disconnected :class:`Sink` and :class:`Source`. This can be achieved by "
"using the ``fromSinkAndSource()`` constructor method on :class:`Flow` which "
"takes the two parts as parameters."
msgstr ""

# 13b4f7858b594d7985fe496af951cd1e
#: ../../java/stream/stream-composition.rst:54
msgid ""
"The example :class:`BidiFlow` demonstrates that internally a module can be "
"of arbitrary complexity, and the exposed ports can be wired in flexible "
"ways. The only constraint is that all the ports of enclosed modules must be "
"either connected to each other, or exposed as interface ports, and the "
"number of such ports needs to match the requirement of the shape, for "
"example a :class:`Source` allows only one exposed output port, the rest of "
"the internal ports must be properly connected."
msgstr ""

# 3da9dc3f9e234c6dad776ee1e629fba0
#: ../../java/stream/stream-composition.rst:60
msgid ""
"These mechanics allow arbitrary nesting of modules. For example the "
"following figure demonstrates a :class:`RunnableGraph` that is built from a "
"composite :class:`Source` and a composite :class:`Sink` (which in turn "
"contains a composite :class:`Flow`)."
msgstr ""

# ab9b99b897054fd79b147656d428bd65
#: ../../java/stream/stream-composition.rst:71
msgid ""
"The above diagram contains one more shape that we have not seen yet, which "
"is called :class:`RunnableGraph`. It turns out, that if we wire all exposed "
"ports together, so that no more open ports remain, we get a module that is "
"*closed*. This is what the :class:`RunnableGraph` class represents. This is "
"the shape that a :class:`Materializer` can take and turn into a network of "
"running entities that perform the task described. In fact, a "
":class:`RunnableGraph` is a module itself, and (maybe somewhat surprisingly)"
" it can be used as part of larger graphs. It is rarely useful to embed a "
"closed graph shape in a larger graph (since it becomes an isolated island as"
" there are no open port for communication with the rest of the graph), but "
"this demonstrates the uniform underlying model."
msgstr ""

# ce892b99c7c0496ba56fe39204ba1582
#: ../../java/stream/stream-composition.rst:79
msgid ""
"If we try to build a code snippet that corresponds to the above diagram, our"
" first try might look like this:"
msgstr ""

# cc0c540062634aaca1704cb224916aab
#: ../../java/stream/stream-composition.rst:83
msgid ""
"It is clear however that there is no nesting present in our first attempt, "
"since the library cannot figure out where we intended to put composite "
"module boundaries, it is our responsibility to do that. If we are using the "
"DSL provided by the :class:`Flow`, :class:`Source`, :class:`Sink` classes "
"then nesting can be achieved by calling one of the methods "
"``withAttributes()`` or ``named()`` (where the latter is just a shorthand "
"for adding a name attribute)."
msgstr ""

# 9d40ae471c8646d782b70ae369710fc5
#: ../../java/stream/stream-composition.rst:88
msgid "The following code demonstrates how to achieve the desired nesting:"
msgstr ""

# bdd614e7e29e4957b2f58412cc3ed395
#: ../../java/stream/stream-composition.rst:92
msgid ""
"Once we have hidden the internals of our components, they act like any other"
" built-in component of similar shape. If we hide some of the internals of "
"our composites, the result looks just like if any other predefine component "
"has been used:"
msgstr ""

# e1cb812c56db4b618e66f72b75cdb409
#: ../../java/stream/stream-composition.rst:103
msgid ""
"If we look at usage of built-in components, and our custom components, there"
" is no difference in usage as the code snippet below demonstrates."
msgstr ""

# d0ecafa94cc44eacb691e8ae6e2cc857
#: ../../java/stream/stream-composition.rst:109
msgid "Composing complex systems"
msgstr ""

# 46237ceab610443b90aba6bf8af83682
#: ../../java/stream/stream-composition.rst:111
msgid ""
"In the previous section we explored the possibility of composition, and "
"hierarchy, but we stayed away from non-linear, generalized graph components."
" There is nothing in Akka Streams though that enforces that stream "
"processing layouts can only be linear. The DSL for :class:`Source` and "
"friends is optimized for creating such linear chains, as they are the most "
"common in practice. There is a more advanced DSL for building complex "
"graphs, that can be used if more flexibility is needed. We will see that the"
" difference between the two DSLs is only on the surface: the concepts they "
"operate on are uniform across all DSLs and fit together nicely."
msgstr ""

# 625960b8020147beb348cc491ff7dfcd
#: ../../java/stream/stream-composition.rst:118
msgid "As a first example, let's look at a more complex layout:"
msgstr ""

# 3dbf9ef6ca1549fba5ec2ccf2fc24672
#: ../../java/stream/stream-composition.rst:127
msgid ""
"The diagram shows a :class:`RunnableGraph` (remember, if there are no "
"unwired ports, the graph is closed, and therefore can be materialized) that "
"encapsulates a non-trivial stream processing network. It contains fan-in, "
"fan-out stages, directed and non-directed cycles. The ``runnable()`` method "
"of the :class:`GraphDSL` factory object allows the creation of a general, "
"closed, and runnable graph. For example the network on the diagram can be "
"realized like this:"
msgstr ""

# d64cf18976f54805ad408c5345248dad
#: ../../java/stream/stream-composition.rst:134
msgid ""
"In the code above we used the implicit port numbering feature to make the "
"graph more readable and similar to the diagram. It is possible to refer to "
"the ports, so another version might look like this:"
msgstr ""

# 6661d895cca8486d8a1743ebd8cfbb0d
#: ../../java/stream/stream-composition.rst:141
msgid ""
"Similar to the case in the first section, so far we have not considered "
"modularity. We created a complex graph, but the layout is flat, not "
"modularized. We will modify our example, and create a reusable component "
"with the graph DSL. The way to do it is to use the ``create()`` method on "
":class:`GraphDSL` factory. If we remove the sources and sinks from the "
"previous example, what remains is a partial graph:"
msgstr ""

# b0fe8ac67c59437aa3dc012a3f8b1c7c
#: ../../java/stream/stream-composition.rst:153
msgid ""
"We can recreate a similar graph in code, using the DSL in a similar way than"
" before:"
msgstr ""

# 10857dc2f28f4da088babfaf55c4b2d5
#: ../../java/stream/stream-composition.rst:157
msgid ""
"The only new addition is the return value of the builder block, which is a "
":class:`Shape`. All graphs (including :class:`Source`, :class:`BidiFlow`, "
"etc) have a shape, which encodes the *typed* ports of the module. In our "
"example there is exactly one input and output port left, so we can declare "
"it to have a :class:`FlowShape` by returning an instance of it. While it is "
"possible to create new :class:`Shape` types, it is usually recommended to "
"use one of the matching built-in ones."
msgstr ""

# af5631a1d6814a74a02ee2b4d5138658
#: ../../java/stream/stream-composition.rst:163
msgid ""
"The resulting graph is already a properly wrapped module, so there is no "
"need to call `named()` to encapsulate the graph, but it is a good practice "
"to give names to modules to help debugging."
msgstr ""

# 2561f3fc43b54205adba3da7efa920ef
#: ../../java/stream/stream-composition.rst:173
msgid ""
"Since our partial graph has the right shape, it can be already used in the "
"simpler, linear DSL:"
msgstr ""

# 5a0082071b224b1e96d1269bee1f46ed
#: ../../java/stream/stream-composition.rst:177
msgid ""
"It is not possible to use it as a :class:`Flow` yet, though (i.e. we cannot "
"call ``.filter()`` on it), but :class:`Flow` has a ``fromGraph()`` method "
"that just adds the DSL to a :class:`FlowShape`. There are similar methods on"
" :class:`Source`, :class:`Sink` and :class:`BidiShape`, so it is easy to get"
" back to the simpler DSL if a graph has the right shape. For convenience, it"
" is also possible to skip the partial graph creation, and use one of the "
"convenience creator methods. To demonstrate this, we will create the "
"following graph:"
msgstr ""

# 2cd2c28b56774ae0b25cdafd748f7276
#: ../../java/stream/stream-composition.rst:190
msgid "The code version of the above closed graph might look like this:"
msgstr ""

# 0d44204f25b048a7b165f7f9918d9456
#: ../../java/stream/stream-composition.rst:195
msgid ""
"All graph builder sections check if the resulting graph has all ports "
"connected except the exposed ones and will throw an exception if this is "
"violated."
msgstr ""

# c516c22aca8b48ddacfa3ea91395aab8
#: ../../java/stream/stream-composition.rst:198
msgid ""
"We are still in debt of demonstrating that :class:`RunnableGraph` is a "
"component just like any other, which can be embedded in graphs. In the "
"following snippet we embed one closed graph in another:"
msgstr ""

# 7467e98107ce439982478c05a9490387
#: ../../java/stream/stream-composition.rst:203
msgid ""
"The type of the imported module indicates that the imported module has a "
":class:`ClosedShape`, and so we are not able to wire it to anything else "
"inside the enclosing closed graph. Nevertheless, this \"island\" is embedded"
" properly, and will be materialized just like any other module that is part "
"of the graph."
msgstr ""

# 17b2301b2da74646a6ca7d35d1f3f1d2
#: ../../java/stream/stream-composition.rst:207
msgid ""
"As we have demonstrated, the two DSLs are fully interoperable, as they "
"encode a similar nested structure of \"boxes with ports\", it is only the "
"DSLs that differ to be as much powerful as possible on the given abstraction"
" level. It is possible to embed complex graphs in the fluid DSL, and it is "
"just as easy to import and embed a :class:`Flow`, etc, in a larger, complex "
"structure."
msgstr ""

# 9b99e9619e4040d2af7490eb702ddd3e
#: ../../java/stream/stream-composition.rst:212
msgid ""
"We have also seen, that every module has a :class:`Shape` (for example a "
":class:`Sink` has a :class:`SinkShape`) independently which DSL was used to "
"create it. This uniform representation enables the rich composability of "
"various stream processing entities in a convenient way."
msgstr ""

# f4e3af74df3244f2a5e62e696a08d406
# 41313efbe3ac470587263c6255ba94d0
#: ../../java/stream/stream-composition.rst:217
#: ../../java/stream/stream-quickstart.rst:290
msgid "Materialized values"
msgstr ""

# c705047797d7434a9cd21e9e8cfe6103
#: ../../java/stream/stream-composition.rst:219
msgid ""
"After realizing that :class:`RunnableGraph` is nothing more than a module "
"with no unused ports (it is an island), it becomes clear that after "
"materialization the only way to communicate with the running stream "
"processing logic is via some side-channel. This side channel is represented "
"as a *materialized value*. The situation is similar to :class:`Actor` s, "
"where the :class:`Props` instance describes the actor logic, but it is the "
"call to ``actorOf()`` that creates an actually running actor, and returns an"
" :class:`ActorRef` that can be used to communicate with the running actor "
"itself. Since the :class:`Props` can be reused, each call will return a "
"different reference."
msgstr ""

# abe11ecdfb314799898b95ed5ab137e2
#: ../../java/stream/stream-composition.rst:226
msgid ""
"When it comes to streams, each materialization creates a new running network"
" corresponding to the blueprint that was encoded in the provided "
":class:`RunnableGraph`. To be able to interact with the running network, "
"each materialization needs to return a different object that provides the "
"necessary interaction capabilities. In other words, the "
":class:`RunnableGraph` can be seen as a factory, which creates:"
msgstr ""

# f09e26ae23d84ddab793cb4b7e17b2fa
#: ../../java/stream/stream-composition.rst:231
msgid ""
"a network of running processing entities, inaccessible from the outside"
msgstr ""

# 0fd4c00f8589489c950da06722392f34
#: ../../java/stream/stream-composition.rst:232
msgid ""
"a materialized value, optionally providing a controlled interaction "
"capability with the network"
msgstr ""

# bda04bf811b944669b862618ae521634
#: ../../java/stream/stream-composition.rst:234
msgid ""
"Unlike actors though, each of the processing stages might provide a "
"materialized value, so when we compose multiple stages or modules, we need "
"to combine the materialized value as well (there are default rules which "
"make this easier, for example `to()` and `via()` takes care of the most "
"common case of taking the materialized value to the left. See :ref:`flow-"
"combine-mat-scala` for details). We demonstrate how this works by a code "
"example and a diagram which graphically demonstrates what is happening."
msgstr ""

# db25fcf660af4f82a56291cb0a3e01fb
#: ../../java/stream/stream-composition.rst:240
msgid ""
"The propagation of the individual materialized values from the enclosed "
"modules towards the top will look like this:"
msgstr ""

# 94b1bed63758459088cbd32f6bd72e7a
#: ../../java/stream/stream-composition.rst:249
msgid ""
"To implement the above, first, we create a composite :class:`Source`, where "
"the enclosed :class:`Source` have a materialized type of "
":class:`Promise<BoxedUnit>`. By using the combiner function ``Keep.left()``,"
" the resulting materialized type is of the nested module (indicated by the "
"color *red* on the diagram):"
msgstr ""

# 104b06a1a053405585a6b88efc2809e6
#: ../../java/stream/stream-composition.rst:255
msgid ""
"Next, we create a composite :class:`Flow` from two smaller components. Here,"
" the second enclosed :class:`Flow` has a materialized type of "
":class:`CompletionStage<OutgoingConnection>`, and we propagate this to the "
"parent by using ``Keep.right()`` as the combiner function (indicated by the "
"color *yellow* on the diagram):"
msgstr ""

# a53a0d9594b94660a95db1837bf24185
#: ../../java/stream/stream-composition.rst:261
msgid ""
"As a third step, we create a composite :class:`Sink`, using our "
"``nestedFlow`` as a building block. In this snippet, both the enclosed "
":class:`Flow` and the folding :class:`Sink` has a materialized value that is"
" interesting for us, so we use ``Keep.both()`` to get a :class:`Pair` of "
"them as the materialized type of ``nestedSink`` (indicated by the color "
"*blue* on the diagram)"
msgstr ""

# 21857781668842eebd7d21e433a59691
#: ../../java/stream/stream-composition.rst:268
msgid ""
"As the last example, we wire together ``nestedSource`` and ``nestedSink`` "
"and we use a custom combiner function to create a yet another materialized "
"type of the resulting :class:`RunnableGraph`. This combiner function just "
"ignores the :class:`CompletionStage<Sink>` part, and wraps the other two "
"values in a custom case class :class:`MyClass` (indicated by color *purple* "
"on the diagram):"
msgstr ""

# f52f8ecbe20949b99cdb57fd94bcd005
#: ../../java/stream/stream-composition.rst:278
msgid ""
"The nested structure in the above example is not necessary for combining the"
" materialized values, it just demonstrates how the two features work "
"together. See :ref:`flow-combine-mat-java` for further examples of combining"
" materialized values without nesting and hierarchy involved."
msgstr ""

# 8a07bb1494ed41e484a6db8af0ab12cb
#: ../../java/stream/stream-composition.rst:283
msgid "Attributes"
msgstr ""

# 3cbccdf1673046a48788abfb04cf302c
#: ../../java/stream/stream-composition.rst:285
msgid ""
"We have seen that we can use ``named()`` to introduce a nesting level in the"
" fluid DSL (and also explicit nesting by using ``create()`` from "
":class:`GraphDSL`). Apart from having the effect of adding a nesting level, "
"``named()`` is actually a shorthand for calling "
"``withAttributes(Attributes.name(\"someName\"))``. Attributes provide a way "
"to fine-tune certain aspects of the materialized running entity. For example"
" buffer sizes for asynchronous stagescan be controlled via attributes (see "
":ref:`async-stream-buffers-java`). When it comes to hierarchic composition, "
"attributes are inherited by nested modules, unless they override them with a"
" custom value."
msgstr ""

# d1ba7353cce94c36bb191b8eef0caff3
#: ../../java/stream/stream-composition.rst:292
msgid ""
"The code below, a modification of an earlier example sets the "
"``inputBuffer`` attribute on certain modules, but not on others:"
msgstr ""

# 48c71afb15d04daa8038c9b98e68b8a9
#: ../../java/stream/stream-composition.rst:297
msgid ""
"The effect is, that each module inherits the ``inputBuffer`` attribute from "
"its enclosing parent, unless it has the same attribute explicitly set. "
"``nestedSource`` gets the default attributes from the materializer itself. "
"``nestedSink`` on the other hand has this attribute set, so it will be used "
"by all nested modules. ``nestedFlow`` will inherit from ``nestedSink`` "
"except the ``map`` stage which has again an explicitly provided attribute "
"overriding the inherited one."
msgstr ""

# 9c29c8aaba4642c9987cd6081e9c9f89
#: ../../java/stream/stream-composition.rst:309
msgid ""
"This diagram illustrates the inheritance process for the example code "
"(representing the materializer default attributes as the color *red*, the "
"attributes set on ``nestedSink`` as *blue* and the attributes set on "
"``nestedFlow`` as *green*)."
msgstr ""

# 6932c7349ce54475a2b0802c0e416831
#: ../../java/stream/stream-cookbook.rst:5
msgid "Streams Cookbook"
msgstr ""

# 73b3df16d28f4902ad989a2f9467e3ba
#: ../../java/stream/stream-cookbook.rst:10
msgid ""
"This is a collection of patterns to demonstrate various usage of the Akka "
"Streams API by solving small targeted problems in the format of \"recipes\"."
" The purpose of this page is to give inspiration and ideas how to approach "
"various small tasks involving streams. The recipes in this page can be used "
"directly as-is, but they are most powerful as starting points: customization"
" of the code snippets is warmly encouraged."
msgstr ""

# 43a6d0ae60724b1aa0c942e87796cb33
#: ../../java/stream/stream-cookbook.rst:15
msgid ""
"This part also serves as supplementary material for the main body of "
"documentation. It is a good idea to have this page open while reading the "
"manual and look for examples demonstrating various streaming concepts as "
"they appear in the main body of documentation."
msgstr ""

# 7d5a02726d724fe188d84e495e598002
#: ../../java/stream/stream-cookbook.rst:19
msgid ""
"If you need a quick reference of the available processing stages used in the"
" recipes see :ref:`stages-overview_java`."
msgstr ""

# d334c7679f814417910eab80d8f8ee29
#: ../../java/stream/stream-cookbook.rst:22
msgid "Working with Flows"
msgstr ""

# 3d547aab551145388ccd481b4d68f4bf
#: ../../java/stream/stream-cookbook.rst:24
msgid ""
"In this collection we show simple recipes that involve linear flows. The "
"recipes in this section are rather general, more targeted recipes are "
"available as separate sections (:ref:`stream-rate-java`, :ref:`stream-io-"
"java`)."
msgstr ""

# afdefc73967e4ccfb895f06f72e120e3
#: ../../java/stream/stream-cookbook.rst:28
msgid "Logging elements of a stream"
msgstr ""

# c78cbe376dc84f338f1e1fe9d94a45fa
#: ../../java/stream/stream-cookbook.rst:30
msgid ""
"**Situation:** During development it is sometimes helpful to see what "
"happens in a particular section of a stream."
msgstr ""

# 1479d085ad1a4cde89b6c46fc2baa12c
#: ../../java/stream/stream-cookbook.rst:32
msgid ""
"The simplest solution is to simply use a ``map`` operation and use "
"``println`` to print the elements received to the console. While this recipe"
" is rather simplistic, it is often suitable for a quick debug session."
msgstr ""

# a281f5a28967455c962abe3f394fdf69
#: ../../java/stream/stream-cookbook.rst:37
msgid ""
"Another approach to logging is to use ``log()`` operation which allows "
"configuring logging for elements flowing through the stream as well as "
"completion and erroring."
msgstr ""

# 221f2f64dae4462da79c0958ea1cb28d
#: ../../java/stream/stream-cookbook.rst:43
msgid "Flattening a stream of sequences"
msgstr ""

# 06210a69c96b40e18bf6caf0f819e2cc
#: ../../java/stream/stream-cookbook.rst:45
msgid ""
"**Situation:** A stream is given as a stream of sequence of elements, but a "
"stream of elements needed instead, streaming all the nested elements inside "
"the sequences separately."
msgstr ""

# 951434637d9243c998bfcb29f154eb23
#: ../../java/stream/stream-cookbook.rst:48
msgid ""
"The ``mapConcat`` operation can be used to implement a one-to-many "
"transformation of elements using a mapper function in the form of ``In -> "
"List<Out>``. In this case we want to map a ``List`` of elements to the "
"elements in the collection itself, so we can just call ``mapConcat(l -> "
"l)``."
msgstr ""

# 6c6fade4479645b3af9e011c30f86386
#: ../../java/stream/stream-cookbook.rst:55
msgid "Draining a stream to a strict collection"
msgstr ""

# e2457ec7e64f4304baac92f9fa2cac7f
#: ../../java/stream/stream-cookbook.rst:57
msgid ""
"**Situation:** A possibly unbounded sequence of elements is given as a "
"stream, which needs to be collected into a Scala collection while ensuring "
"boundedness"
msgstr ""

# 2902c437b0eb45d28dab0031e6bf5400
#: ../../java/stream/stream-cookbook.rst:59
msgid ""
"A common situation when working with streams is one where we need to collect"
" incoming elements into a Scala collection. This operation is supported via "
"``Sink.seq`` which materializes into a ``CompletionStage<List<T>>``."
msgstr ""

# b2728f5484794d16af68b0ac4c9588cb
#: ../../java/stream/stream-cookbook.rst:62
msgid ""
"The function ``limit`` or ``take`` should always be used in conjunction in "
"order to guarantee stream boundedness, thus preventing the program from "
"running out of memory."
msgstr ""

# b8d8ecd4fe1c4ca1874c9c36927fbc22
#: ../../java/stream/stream-cookbook.rst:64
msgid "For example, this is best avoided:"
msgstr ""

# 95b6454396f24465b66436b581ad0e00
#: ../../java/stream/stream-cookbook.rst:68
msgid ""
"Rather, use ``limit`` or ``take`` to ensure that the resulting ``List`` will"
" contain only up to ``MAX_ALLOWED_SIZE`` elements:"
msgstr ""

# 0e7554500ad64689a44919319596a825
#: ../../java/stream/stream-cookbook.rst:73
msgid "Calculating the digest of a ByteString stream"
msgstr ""

# 35e51a222d0745cb86ae1acb9fd25449
#: ../../java/stream/stream-cookbook.rst:75
msgid ""
"**Situation:** A stream of bytes is given as a stream of ``ByteStrings`` and"
" we want to calculate the cryptographic digest of the stream."
msgstr ""

# e1243bda5c9c48308e33e790c5991e62
#: ../../java/stream/stream-cookbook.rst:78
msgid ""
"This recipe uses a :class:`GraphStage` to host a mutable "
":class:`MessageDigest` class (part of the Java Cryptography API) and update "
"it with the bytes arriving from the stream. When the stream starts, the "
"``onPull`` handler of the stage is called, which just bubbles up the "
"``pull`` event to its upstream. As a response to this pull, a ByteString "
"chunk will arrive (``onPush``) which we use to update the digest, then it "
"will pull for the next chunk."
msgstr ""

# bff70e50423c43ef98c18cd655c6d913
#: ../../java/stream/stream-cookbook.rst:83
msgid ""
"Eventually the stream of ``ByteStrings`` depletes and we get a notification "
"about this event via ``onUpstreamFinish``. At this point we want to emit the"
" digest value, but we cannot do it with ``push`` in this handler directly "
"since there may be no downstream demand. Instead we call ``emit`` which will"
" temporarily replace the handlers, emit the provided value when demand comes"
" in and then reset the stage state. It will then complete the stage."
msgstr ""

# 480d5aad6acf4d11bb3d9f24d195cf13
#: ../../java/stream/stream-cookbook.rst:95
msgid "Parsing lines from a stream of ByteStrings"
msgstr ""

# 3d8fdbc5488246e682d0168d2c2cc2a7
#: ../../java/stream/stream-cookbook.rst:97
msgid ""
"**Situation:** A stream of bytes is given as a stream of ``ByteStrings`` "
"containing lines terminated by line ending characters (or, alternatively, "
"containing binary frames delimited by a special delimiter byte sequence) "
"which needs to be parsed."
msgstr ""

# baea8fb87eb04acca08c76ba7eb11f16
#: ../../java/stream/stream-cookbook.rst:101
msgid ""
"The :class:`Framing` helper class contains a convenience method to parse "
"messages from a stream of ``ByteStrings``:"
msgstr ""

# 6069359f380046b488a66cf5237becfd
#: ../../java/stream/stream-cookbook.rst:106
msgid "Implementing reduce-by-key"
msgstr ""

# a07c9c6db71e4826a9fe7c460e4f7e8b
#: ../../java/stream/stream-cookbook.rst:108
msgid ""
"**Situation:** Given a stream of elements, we want to calculate some "
"aggregated value on different subgroups of the elements."
msgstr ""

# c393ee6af90145b78e3daa4e623402c5
#: ../../java/stream/stream-cookbook.rst:111
msgid ""
"The \"hello world\" of reduce-by-key style operations is *wordcount* which "
"we demonstrate below. Given a stream of words we first create a new stream "
"that groups the words according to the ``i -> i`` function, i.e. now we have"
" a stream of streams, where every substream will serve identical words."
msgstr ""

# 7be416cf93144762a38606e26e4ce455
#: ../../java/stream/stream-cookbook.rst:115
msgid ""
"To count the words, we need to process the stream of streams (the actual "
"groups containing identical words). ``groupBy`` returns a "
":class:`SubSource`, which means that we transform the resulting substreams "
"directly. In this case we use the ``reduce`` combinator to aggregate the "
"word itself and the number of its occurrences within a :class:`Pair<String, "
"Integer>`. Each substream will then emit one final value—precisely such a "
"pair—when the overall input completes. As a last step we merge back these "
"values from the substreams into one single output stream."
msgstr ""

# ad71d60030404adaa3f66b9ead4d0431
#: ../../java/stream/stream-cookbook.rst:124
msgid ""
"One noteworthy detail pertains to the ``MAXIMUM_DISTINCT_WORDS`` parameter: "
"this defines the breadth of the merge operation. Akka Streams is focused on "
"bounded resource consumption and the number of concurrently open inputs to "
"the merge operator describes the amount of resources needed by the merge "
"itself. Therefore only a finite number of substreams can be active at any "
"given time. If the ``groupBy`` operator encounters more keys than this "
"number then the stream cannot continue without violating its resource bound,"
" in this case ``groupBy`` will terminate with a failure."
msgstr ""

# a01755db511c45bc9d42d8eabd7792e7
#: ../../java/stream/stream-cookbook.rst:135
msgid "By extracting the parts specific to *wordcount* into"
msgstr ""

# 4547ba1734aa4cafb47704bca72b5a46
#: ../../java/stream/stream-cookbook.rst:137
msgid "a ``groupKey`` function that defines the groups"
msgstr ""

# dee215ac53384bfdab5171d9e71e47d5
#: ../../java/stream/stream-cookbook.rst:138
msgid ""
"a ``map`` map each element to value that is used by the reduce on the "
"substream"
msgstr ""

# 44fd728a90a94ab5ae0c25f346485dab
#: ../../java/stream/stream-cookbook.rst:139
msgid "a ``reduce`` function that does the actual reduction"
msgstr ""

# daa016ba2d4d40e6b1648ed71d8d9bb6
#: ../../java/stream/stream-cookbook.rst:141
msgid "we get a generalized version below:"
msgstr ""

# 408f0ef38f8d42d0a57845115598a16e
#: ../../java/stream/stream-cookbook.rst:148
msgid ""
"Please note that the reduce-by-key version we discussed above is sequential "
"in reading the overall input stream, in other words it is **NOT** a "
"parallelization pattern like MapReduce and similar frameworks."
msgstr ""

# 328d5649858a46f19099dbd39b6d5f6b
#: ../../java/stream/stream-cookbook.rst:153
msgid "Sorting elements to multiple groups with groupBy"
msgstr ""

# 946309aa53dc405db81906d29cb8fb81
#: ../../java/stream/stream-cookbook.rst:155
msgid ""
"**Situation:** The ``groupBy`` operation strictly partitions incoming "
"elements, each element belongs to exactly one group. Sometimes we want to "
"map elements into multiple groups simultaneously."
msgstr ""

# 97bc028a5327451c8faeccb4b9bdc38a
#: ../../java/stream/stream-cookbook.rst:158
msgid "To achieve the desired result, we attack the problem in two steps:"
msgstr ""

# 2c82628ffd93490ea0fd100ee3871564
#: ../../java/stream/stream-cookbook.rst:160
msgid ""
"first, using a function ``topicMapper`` that gives a list of topics (groups)"
" a message belongs to, we transform our stream of ``Message`` to a stream of"
" :class:`Pair<Message, Topic>`` where for each topic the message belongs to "
"a separate pair will be emitted. This is achieved by using ``mapConcat``"
msgstr ""

# 6fd60dea9e3449fbb701a0f81355041e
#: ../../java/stream/stream-cookbook.rst:163
msgid ""
"Then we take this new stream of message topic pairs (containing a separate "
"pair for each topic a given message belongs to) and feed it into groupBy, "
"using the topic as the group key."
msgstr ""

# 08b6fbc0e68a402a9ba07309fc84bf09
# e78eba8b8dc94436bcc2b57e1cdd0bfb
#: ../../java/stream/stream-cookbook.rst:169
#: ../../java/stream/stream-graphs.rst:5
msgid "Working with Graphs"
msgstr ""

# 543bb434fb104b8693da7597640d0928
#: ../../java/stream/stream-cookbook.rst:171
msgid ""
"In this collection we show recipes that use stream graph elements to achieve"
" various goals."
msgstr ""

# 1d8a13b7cf334992a81816cde62a477e
#: ../../java/stream/stream-cookbook.rst:174
msgid "Triggering the flow of elements programmatically"
msgstr ""

# b213fb9b5d2545d9a52308f9fcbb0745
#: ../../java/stream/stream-cookbook.rst:176
msgid ""
"**Situation:** Given a stream of elements we want to control the emission of"
" those elements according to a trigger signal. In other words, even if the "
"stream would be able to flow (not being backpressured) we want to hold back "
"elements until a trigger signal arrives."
msgstr ""

# e7f2ea4d91cf43668aef547feb10dc54
#: ../../java/stream/stream-cookbook.rst:180
msgid ""
"This recipe solves the problem by simply zipping the stream of ``Message`` "
"elements with the stream of ``Trigger`` signals. Since ``Zip`` produces "
"pairs, we simply map the output stream selecting the first element of the "
"pair."
msgstr ""

# 25b53265cfbf45edbb285ff06b0468f2
#: ../../java/stream/stream-cookbook.rst:185
msgid ""
"Alternatively, instead of using a ``Zip``, and then using ``map`` to get the"
" first element of the pairs, we can avoid creating the pairs in the first "
"place by using ``ZipWith`` which takes a two argument function to produce "
"the output element. If this function would return a pair of the two argument"
" it would be exactly the behavior of ``Zip`` so ``ZipWith`` is a "
"generalization of zipping."
msgstr ""

# f1d47c3fa10745009c88a0b572068ecd
#: ../../java/stream/stream-cookbook.rst:194
msgid "Balancing jobs to a fixed pool of workers"
msgstr ""

# 8a4c0d80600944ea877ef7d63c331f77
#: ../../java/stream/stream-cookbook.rst:196
msgid ""
"**Situation:** Given a stream of jobs and a worker process expressed as a "
":class:`Flow` create a pool of workers that automatically balances incoming "
"jobs to available workers, then merges the results."
msgstr ""

# da4c3b02e3ba45479e9f43941379f196
#: ../../java/stream/stream-cookbook.rst:199
msgid ""
"We will express our solution as a function that takes a worker flow and the "
"number of workers to be allocated and gives a flow that internally contains "
"a pool of these workers. To achieve the desired result we will create a "
":class:`Flow` from a graph."
msgstr ""

# 226a2e8eb7ad47d5805271f0f713405d
#: ../../java/stream/stream-cookbook.rst:203
msgid ""
"The graph consists of a ``Balance`` node which is a special fan-out "
"operation that tries to route elements to available downstream consumers. In"
" a ``for`` loop we wire all of our desired workers as outputs of this "
"balancer element, then we wire the outputs of these workers to a ``Merge`` "
"element that will collect the results from the workers."
msgstr ""

# f4cc5773ef804773ba5c66dbfc75f428
#: ../../java/stream/stream-cookbook.rst:207
msgid ""
"To make the worker stages run in parallel we mark them as asynchronous with "
"`async()`."
msgstr ""

# b2217683480d4c43b4fcd4a04549e0d5
#: ../../java/stream/stream-cookbook.rst:214
msgid "Working with rate"
msgstr ""

# 6f4b0e50c8794a3eb36c2238c1135606
#: ../../java/stream/stream-cookbook.rst:216
msgid ""
"This collection of recipes demonstrate various patterns where rate "
"differences between upstream and downstream needs to be handled by other "
"strategies than simple backpressure."
msgstr ""

# cbb9b3fbb9b14323abacfd10e676738e
#: ../../java/stream/stream-cookbook.rst:220
msgid "Dropping elements"
msgstr ""

# ca3b0c1883824a4eb7ed0cd9626283e7
#: ../../java/stream/stream-cookbook.rst:222
msgid ""
"**Situation:** Given a fast producer and a slow consumer, we want to drop "
"elements if necessary to not slow down the producer too much."
msgstr ""

# ae154a704786421ab3adfd8ac78622b8
#: ../../java/stream/stream-cookbook.rst:225
msgid ""
"This can be solved by using a versatile rate-transforming operation, "
"``conflate``. Conflate can be thought as a special ``reduce`` operation that"
" collapses multiple upstream elements into one aggregate element if needed "
"to keep the speed of the upstream unaffected by the downstream."
msgstr ""

# 443d8fe229924881bb5225651b5d5459
#: ../../java/stream/stream-cookbook.rst:229
msgid ""
"When the upstream is faster, the reducing process of the ``conflate`` "
"starts. Our reducer function simply takes the freshest element. This in a "
"simple dropping operation."
msgstr ""

# b9af74943a4748c4bf3f7ecd79fc0854
#: ../../java/stream/stream-cookbook.rst:234
msgid ""
"There is a version of ``conflate`` named ``conflateWithSeed`` that allows to"
" express more complex aggregations, more similar to a ``fold``."
msgstr ""

# 9ff308ac892b48b8864d4b8d1038967a
#: ../../java/stream/stream-cookbook.rst:238
msgid "Dropping broadcast"
msgstr ""

# c7ce26e37e4641f6a7c94d4b705925b5
#: ../../java/stream/stream-cookbook.rst:240
msgid ""
"**Situation:** The default ``Broadcast`` graph element is properly "
"backpressured, but that means that a slow downstream consumer can hold back "
"the other downstream consumers resulting in lowered throughput. In other "
"words the rate of ``Broadcast`` is the rate of its slowest downstream "
"consumer. In certain cases it is desirable to allow faster consumers to "
"progress independently of their slower siblings by dropping elements if "
"necessary."
msgstr ""

# 4c0cdeef6ff54c30b3d686bb5d3be4b4
#: ../../java/stream/stream-cookbook.rst:245
msgid ""
"One solution to this problem is to append a ``buffer`` element in front of "
"all of the downstream consumers defining a dropping strategy instead of the "
"default ``Backpressure``. This allows small temporary rate differences "
"between the different consumers (the buffer smooths out small rate "
"variances), but also allows faster consumers to progress by dropping from "
"the buffer of the slow consumers if necessary."
msgstr ""

# 33606821113147aea370020e08d6bdcd
#: ../../java/stream/stream-cookbook.rst:255
msgid "Collecting missed ticks"
msgstr ""

# 86f2bde47ac541f2afd8398ce26bc35c
#: ../../java/stream/stream-cookbook.rst:257
msgid ""
"**Situation:** Given a regular (stream) source of ticks, instead of trying "
"to backpressure the producer of the ticks we want to keep a counter of the "
"missed ticks instead and pass it down when possible."
msgstr ""

# bb796191200f46b189cb8cb06211d4ba
#: ../../java/stream/stream-cookbook.rst:260
msgid ""
"We will use ``conflateWithSeed`` to solve the problem. Conflate takes two "
"functions:"
msgstr ""

# 73e8d9cfa99b486b8ed3b6b03f9b84b6
#: ../../java/stream/stream-cookbook.rst:262
msgid ""
"A seed function that produces the zero element for the folding process that "
"happens when the upstream is faster than the downstream. In our case the "
"seed function is a constant function that returns 0 since there were no "
"missed ticks at that point."
msgstr ""

# 689446a933934a6b85a0c6fd393be075
#: ../../java/stream/stream-cookbook.rst:265
msgid ""
"A fold function that is invoked when multiple upstream messages needs to be "
"collapsed to an aggregate value due to the insufficient processing rate of "
"the downstream. Our folding function simply increments the currently stored "
"count of the missed ticks so far."
msgstr ""

# 27e55b888c9441f68f984e69ac970713
#: ../../java/stream/stream-cookbook.rst:269
msgid ""
"As a result, we have a flow of ``Int`` where the number represents the "
"missed ticks. A number 0 means that we were able to consume the tick fast "
"enough (i.e. zero means: 1 non-missed tick + 0 missed ticks)"
msgstr ""

# 0efeeef264f84581990c8738c9eb7ccd
#: ../../java/stream/stream-cookbook.rst:275
msgid "Create a stream processor that repeats the last element seen"
msgstr ""

# cb4a845542bc4c478f180aeb7e3c8cd3
#: ../../java/stream/stream-cookbook.rst:277
msgid ""
"**Situation:** Given a producer and consumer, where the rate of neither is "
"known in advance, we want to ensure that none of them is slowing down the "
"other by dropping earlier unconsumed elements from the upstream if "
"necessary, and repeating the last value for the downstream if necessary."
msgstr ""

# 2c2a7aa7c0ac4de38077ca80bcd28cb4
#: ../../java/stream/stream-cookbook.rst:281
msgid ""
"We have two options to implement this feature. In both cases we will use "
":class:`GraphStage` to build our custom element. In the first version we "
"will use a provided initial value ``initial`` that will be used to feed the "
"downstream if no upstream element is ready yet. In the ``onPush()`` handler "
"we just overwrite the ``currentValue`` variable and immediately relieve the "
"upstream by calling ``pull()``. The downstream ``onPull`` handler is very "
"similar, we immediately relieve the downstream by emitting ``currentValue``."
msgstr ""

# aab9adcaea96455698e3dfabed40cfdb
#: ../../java/stream/stream-cookbook.rst:289
msgid ""
"While it is relatively simple, the drawback of the first version is that it "
"needs an arbitrary initial element which is not always possible to provide. "
"Hence, we create a second version where the downstream might need to wait in"
" one single case: if the very first element is not yet available."
msgstr ""

# d5f871da51d44c50b69df5abef1bf540
#: ../../java/stream/stream-cookbook.rst:293
msgid ""
"We introduce a boolean variable ``waitingFirstValue`` to denote whether the "
"first element has been provided or not (alternatively an :class:`Optional` "
"can be used for ``currentValue`` or if the element type is a subclass of "
"Object a null can be used with the same purpose). In the downstream "
"``onPull()`` handler the difference from the previous version is that we "
"check if we have received the first value and only emit if we have. This "
"leads to that when the first element comes in we must check if there "
"possibly already was demand from downstream so that we in that case can push"
" the element directly."
msgstr ""

# 583741b1e3cd42ceba581fb103f9d145
#: ../../java/stream/stream-cookbook.rst:303
msgid "Globally limiting the rate of a set of streams"
msgstr ""

# e6b667ba56e34b428ac3f3b13dee1e63
#: ../../java/stream/stream-cookbook.rst:305
msgid ""
"**Situation:** Given a set of independent streams that we cannot merge, we "
"want to globally limit the aggregate throughput of the set of streams."
msgstr ""

# 5185d7ca76b14662b3881008e2af7326
#: ../../java/stream/stream-cookbook.rst:308
msgid ""
"One possible solution uses a shared actor as the global limiter combined "
"with mapAsync to create a reusable :class:`Flow` that can be plugged into a "
"stream to limit its rate."
msgstr ""

# 21f9835951eb48ab9e33de8b52c1d839
#: ../../java/stream/stream-cookbook.rst:311
msgid ""
"As the first step we define an actor that will do the accounting for the "
"global rate limit. The actor maintains a timer, a counter for pending permit"
" tokens and a queue for possibly waiting participants. The actor has an "
"``open`` and ``closed`` state. The actor is in the ``open`` state while it "
"has still pending permits. Whenever a request for permit arrives as a "
"``WantToPass`` message to the actor the number of available permits is "
"decremented and we notify the sender that it can pass by answering with a "
"``MayPass`` message. If the amount of permits reaches zero, the actor "
"transitions to the ``closed`` state. In this state requests are not "
"immediately answered, instead the reference of the sender is added to a "
"queue. Once the timer for replenishing the pending permits fires by sending "
"a ``ReplenishTokens`` message, we increment the pending permits counter and "
"send a reply to each of the waiting senders. If there are more waiting "
"senders than permits available we will stay in the ``closed`` state."
msgstr ""

# 446ee3dffb38493abb8c4335e1a5bb38
#: ../../java/stream/stream-cookbook.rst:323
msgid ""
"To create a Flow that uses this global limiter actor we use the ``mapAsync``"
" function with the combination of the ``ask`` pattern. We also define a "
"timeout, so if a reply is not received during the configured maximum wait "
"period the returned future from ``ask`` will fail, which will fail the "
"corresponding stream as well."
msgstr ""

# 2861be6f5b79432e9994b5b5499bd2c5
#: ../../java/stream/stream-cookbook.rst:330
msgid ""
"The global actor used for limiting introduces a global bottleneck. You might"
" want to assign a dedicated dispatcher for this actor."
msgstr ""

# badb62b064934e0886a24d698d319b0a
#: ../../java/stream/stream-cookbook.rst:334
msgid "Working with IO"
msgstr ""

# 6a711e8532ed41dea033ddcedaff9257
#: ../../java/stream/stream-cookbook.rst:337
msgid "Chunking up a stream of ByteStrings into limited size ByteStrings"
msgstr ""

# 79d0f4ca6eef4633aa43075e6cf5a166
#: ../../java/stream/stream-cookbook.rst:339
msgid ""
"**Situation:** Given a stream of ByteStrings we want to produce a stream of "
"ByteStrings containing the same bytes in the same sequence, but capping the "
"size of ByteStrings. In other words we want to slice up ByteStrings into "
"smaller chunks if they exceed a size threshold."
msgstr ""

# e177c93251cd4e9dbfd81e3fa2ccf934
#: ../../java/stream/stream-cookbook.rst:343
msgid ""
"This can be achieved with a single :class:`GraphStage`. The main logic of "
"our stage is in ``emitChunk()`` which implements the following logic:"
msgstr ""

# bc53417322f541f491657e9777a8c4a9
#: ../../java/stream/stream-cookbook.rst:346
msgid ""
"if the buffer is empty, and upstream is not closed we pull for more bytes, "
"if it is closed we complete"
msgstr ""

# 37e86d3e06a2441aa5733974b3aa97e2
#: ../../java/stream/stream-cookbook.rst:347
msgid ""
"if the buffer is nonEmpty, we split it according to the ``chunkSize``. This "
"will give a next chunk that we will emit, and an empty or nonempty remaining"
" buffer."
msgstr ""

# 3d0e3786df3e48a2a83e7aa67117ebcd
#: ../../java/stream/stream-cookbook.rst:350
msgid ""
"Both ``onPush()`` and ``onPull()`` calls ``emitChunk()`` the only difference"
" is that the push handler also stores the incoming chunk by appending to the"
" end of the buffer."
msgstr ""

# baf50a87cf834d94a6042c1be0e17fc7
#: ../../java/stream/stream-cookbook.rst:358
msgid "Limit the number of bytes passing through a stream of ByteStrings"
msgstr ""

# bc7d2c83a52e4e988736a2ed868101f4
#: ../../java/stream/stream-cookbook.rst:360
msgid ""
"**Situation:** Given a stream of ByteStrings we want to fail the stream if "
"more than a given maximum of bytes has been consumed."
msgstr ""

# 0a3ee346e56d4b758ec99df5ac0c662d
#: ../../java/stream/stream-cookbook.rst:363
msgid ""
"This recipe uses a :class:`GraphStage` to implement the desired feature. In "
"the only handler we override, ``onPush()`` we just update a counter and see "
"if it gets larger than ``maximumBytes``. If a violation happens we signal "
"failure, otherwise we forward the chunk we have received."
msgstr ""

# e6e399e92a3b4034b11cc669158b5fb8
#: ../../java/stream/stream-cookbook.rst:372
msgid "Compact ByteStrings in a stream of ByteStrings"
msgstr ""

# 865d8aedce3c4843b59ef0a7cf57d788
#: ../../java/stream/stream-cookbook.rst:374
msgid ""
"**Situation:** After a long stream of transformations, due to their "
"immutable, structural sharing nature ByteStrings may refer to multiple "
"original ByteString instances unnecessarily retaining memory. As the final "
"step of a transformation chain we want to have clean copies that are no "
"longer referencing the original ByteStrings."
msgstr ""

# a94001a8a73b4337a27cd967fdbd56ad
#: ../../java/stream/stream-cookbook.rst:378
msgid ""
"The recipe is a simple use of map, calling the ``compact()`` method of the "
":class:`ByteString` elements. This does copying of the underlying arrays, so"
" this should be the last element of a long chain if used."
msgstr ""

# be6cbb1b56a94cd2ab92590e73920a7b
#: ../../java/stream/stream-cookbook.rst:384
msgid "Injecting keep-alive messages into a stream of ByteStrings"
msgstr ""

# 68c8c121267345499a14cfed189ec7b6
#: ../../java/stream/stream-cookbook.rst:386
msgid ""
"**Situation:** Given a communication channel expressed as a stream of "
"ByteStrings we want to inject keep-alive messages but only if this does not "
"interfere with normal traffic."
msgstr ""

# ac6df0bccdb14bc1861acd0bb7e7c883
#: ../../java/stream/stream-cookbook.rst:389
msgid "There is a built-in operation that allows to do this directly:"
msgstr ""

# 18e2dbccaee64e7b9087a227843acbb1
#: ../../java/stream/stream-customize.rst:5
msgid "Custom stream processing"
msgstr ""

# bca37313a78a40bf91bae0ac256b3cb7
#: ../../java/stream/stream-customize.rst:7
msgid ""
"While the processing vocabulary of Akka Streams is quite rich (see the :ref"
":`stream-cookbook-java` for examples) it is sometimes necessary to define "
"new transformation stages either because some functionality is missing from "
"the stock operations, or for performance reasons. In this part we show how "
"to build custom processing stages and graph junctions of various kinds."
msgstr ""

# dc713dbae6264d6bbeea385c773334a1
#: ../../java/stream/stream-customize.rst:13
msgid ""
"A custom graph stage should not be the first tool you reach for, defining "
"graphs using flows and the graph DSL is in general easier and does to a "
"larger extent protect you from mistakes that might be easy to make with a "
"custom :class:`GraphStage`"
msgstr ""

# 622adc401c09459e8a51a3882709ef3a
#: ../../java/stream/stream-customize.rst:21
msgid "Custom processing with GraphStage"
msgstr ""

# 6106a39a4eaf4661a170c9c2090dc43b
#: ../../java/stream/stream-customize.rst:23
msgid ""
"The :class:`GraphStage` abstraction can be used to create arbitrary graph "
"processing stages with any number of input or output ports. It is a "
"counterpart of the ``GraphDSL.create()`` method which creates new stream "
"processing stages by composing  others. Where :class:`GraphStage` differs is"
" that it creates a stage that is itself not divisible into smaller ones, and"
" allows state to be maintained inside it in a safe way."
msgstr ""

# 4b7e4e1ee65a47899e7c85d36e953798
#: ../../java/stream/stream-customize.rst:28
msgid ""
"As a first motivating example, we will build a new :class:`Source` that will"
" simply emit numbers from 1 until it is cancelled. To start, we need to "
"define the \"interface\" of our stage, which is called *shape* in Akka "
"Streams terminology (this is explained in more detail in the section :ref"
":`composition-java`)."
msgstr ""

# 914dbd1bd65f456889fb30aaa4ce4a18
#: ../../java/stream/stream-customize.rst:34
msgid ""
"As you see, in itself the :class:`GraphStage` only defines the ports of this"
" stage and a shape that contains the ports. It also has a user implemented "
"method called ``createLogic``. If you recall, stages are reusable in "
"multiple materializations, each resulting in a different executing entity. "
"In the case of :class:`GraphStage` the actual running logic is modeled as an"
" instance of a :class:`GraphStageLogic` which will be created by the "
"materializer by calling the ``createLogic`` method. In other words, all we "
"need to do is to create a suitable logic that will emit the numbers we want."
msgstr ""

# 9ed36e7f45994fc2a2cf9fd2f5f40e5e
#: ../../java/stream/stream-customize.rst:43
msgid ""
"It is very important to keep the GraphStage object itself immutable and "
"reusable. All mutable state needs to be confined to the GraphStageLogic that"
" is created for every materialization."
msgstr ""

# 39066458d7d9434d85cb4c121cd405b8
#: ../../java/stream/stream-customize.rst:46
msgid ""
"In order to emit from a :class:`Source` in a backpressured stream one needs "
"first to have demand from downstream. To receive the necessary events one "
"needs to register a subclass of :class:`AbstractOutHandler` with the output "
"port (:class:`Outlet`). This handler will receive events related to the "
"lifecycle of the port. In our case we need to override ``onPull()`` which "
"indicates that we are free to emit a single element. There is another "
"callback, ``onDownstreamFinish()`` which is called if the downstream "
"cancelled. Since the default behavior of that callback is to stop the stage,"
" we don't need to override it. In the ``onPull`` callback we simply emit the"
" next number."
msgstr ""

# 8df0dc3514634b9e8689ca641ff5ef71
#: ../../java/stream/stream-customize.rst:53
msgid ""
"Instances of the above :class:`GraphStage` are subclasses of "
"``Graph<SourceShape<Int>,Unit>`` which means that they are already usable in"
" many situations, but do not provide the DSL methods we usually have for "
"other :class:`Source` s. In order to convert this :class:`Graph` to a proper"
" :class:`Source` we need to wrap it using ``Source.fromGraph`` (see :ref"
":`composition-java` for more details about graphs and DSLs). Now we can use "
"the source as any other built-in one:"
msgstr ""

# e6f6836fe2584ecab64c11104f6effff
#: ../../java/stream/stream-customize.rst:61
msgid ""
"Similarly, to create a custom :class:`Sink` one can register a subclass "
":class:`InHandler` with the stage :class:`Inlet`. The ``onPush()`` callback "
"is used to signal the handler a new element has been pushed to the stage, "
"and can hence be grabbed and used. ``onPush()`` can be overridden to provide"
" custom behaviour. Please note, most Sinks would need to request upstream "
"elements as soon as they are created: this can be done by calling "
"``pull(inlet)`` in the ``preStart()`` callback."
msgstr ""

# b14e8336f79c468a9f1aea21829b856c
#: ../../java/stream/stream-customize.rst:70
msgid "Port states, AbstractInHandler and AbstractOutHandler"
msgstr ""

# 84382ed751de48e58dd4019dd993c9dd
#: ../../java/stream/stream-customize.rst:72
msgid ""
"In order to interact with a port (:class:`Inlet` or :class:`Outlet`) of the "
"stage we need to be able to receive events and generate new events belonging"
" to the port. From the :class:`GraphStageLogic` the following operations are"
" available on an output port:"
msgstr ""

# b5f8e8f9dedd43bfaf1992ccda02ed3e
#: ../../java/stream/stream-customize.rst:76
msgid ""
"``push(out,elem)`` pushes an element to the output port. Only possible after"
" the port has been pulled by downstream."
msgstr ""

# fee4567c2bdb4ddd93cb89b77aad7bab
#: ../../java/stream/stream-customize.rst:77
msgid "``complete(out)`` closes the output port normally."
msgstr ""

# a6fc2e51f6f94f77b83f00d7669a99a0
#: ../../java/stream/stream-customize.rst:78
msgid "``fail(out,exception)`` closes the port with a failure signal."
msgstr ""

# 10f21da9f75441829a91c5b11c838dcd
#: ../../java/stream/stream-customize.rst:81
msgid ""
"The events corresponding to an *output* port can be received in an "
":class:`AbstractOutHandler` instance registered to the output port using "
"``setHandler(out,handler)``. This handler has two callbacks:"
msgstr ""

# f991d70bc92e4ad58ae5240b58f732b4
#: ../../java/stream/stream-customize.rst:84
msgid ""
"``onPull()`` is called when the output port is ready to emit the next "
"element, ``push(out, elem)`` is now allowed to be called on this port."
msgstr ""

# d05427240d854c2b94b536e95a87c59d
#: ../../java/stream/stream-customize.rst:86
msgid ""
"``onDownstreamFinish()`` is called once the downstream has cancelled and no "
"longer allows messages to be pushed to it. No more ``onPull()`` will arrive "
"after this event. If not overridden this will default to stopping the stage."
msgstr ""

# 1d632c6cc258494fb43acddc2b55aaff
#: ../../java/stream/stream-customize.rst:89
msgid "Also, there are two query methods available for output ports:"
msgstr ""

# de3a864ac435468bb6dddc6b798aaa1a
#: ../../java/stream/stream-customize.rst:91
msgid "``isAvailable(out)`` returns true if the port can be pushed."
msgstr ""

# 34088ce630e740d3ab16114f928e7bc6
#: ../../java/stream/stream-customize.rst:92
msgid ""
"``isClosed(out)`` returns true if the port is closed. At this point the port"
" can not be pushed and will not be pulled anymore."
msgstr ""

# 187265ca13f54618afee38a43e9cb062
# fafdf15838d546deb3a79e1e4f179795
#: ../../java/stream/stream-customize.rst:94
#: ../../java/stream/stream-customize.rst:130
msgid ""
"The relationship of the above operations, events and queries are summarized "
"in the state machine below. Green shows the initial state while orange "
"indicates the end state. If an operation is not listed for a state, then it "
"is invalid to call it while the port is in that state. If an event is not "
"listed for a state, then that event cannot happen in that state."
msgstr ""

# eb54cfe6229547f28d85c059a325706d
#: ../../java/stream/stream-customize.rst:106
msgid "The following operations are available for *input* ports:"
msgstr ""

# 6bb9f04148744371bbb137d3afd68b33
#: ../../java/stream/stream-customize.rst:108
msgid ""
"``pull(in)`` requests a new element from an input port. This is only "
"possible after the port has been pushed by upstream."
msgstr ""

# a008073e2df943ae8ca3f7d155891635
#: ../../java/stream/stream-customize.rst:109
msgid ""
"``grab(in)`` acquires the element that has been received during an "
"``onPush()``. It cannot be called again until the port is pushed again by "
"the upstream."
msgstr ""

# b6bc6f1156f7404fa152f0e023b88815
#: ../../java/stream/stream-customize.rst:111
msgid "``cancel(in)`` closes the input port."
msgstr ""

# 01ada8004df5432b8510ca5e2b1a7218
#: ../../java/stream/stream-customize.rst:113
msgid ""
"The events corresponding to an *input* port can be received in an "
":class:`AbstractInHandler` instance registered to the input port using "
"``setHandler(in, handler)``. This handler has three callbacks:"
msgstr ""

# 0d4065062c894ad1b9ba9fda4a828fbd
#: ../../java/stream/stream-customize.rst:116
msgid ""
"``onPush()`` is called when the input port has now a new element. Now it is "
"possible to acquire this element using ``grab(in)`` and/or call ``pull(in)``"
" on the port to request the next element. It is not mandatory to grab the "
"element, but if it is pulled while the element has not been grabbed it will "
"drop the buffered element."
msgstr ""

# 5e22e7c46ddc48659306cf0ed0fffd09
#: ../../java/stream/stream-customize.rst:119
msgid ""
"``onUpstreamFinish()`` is called once the upstream has completed and no "
"longer can be pulled for new elements. No more ``onPush()`` will arrive "
"after this event. If not overridden this will default to stopping the stage."
msgstr ""

# 1f78766148414c78ab01aafd3d5fcfa0
#: ../../java/stream/stream-customize.rst:121
msgid ""
"``onUpstreamFailure()`` is called if the upstream failed with an exception "
"and no longer can be pulled for new elements. No more ``onPush()`` will "
"arrive after this event. If not overridden this will default to failing the "
"stage."
msgstr ""

# b6743efc99f54261817fa099a3f4eaee
#: ../../java/stream/stream-customize.rst:124
msgid "Also, there are three query methods available for input ports:"
msgstr ""

# c1252e14683e4b59bbe3f87651d4bd18
#: ../../java/stream/stream-customize.rst:126
msgid ""
"``isAvailable(in)`` returns true if a data element can be grabbed from the "
"port"
msgstr ""

# 51c4bff27afc4b54a2ad4c77ee288c88
#: ../../java/stream/stream-customize.rst:127
msgid ""
"``hasBeenPulled(in)`` returns true if the port has been already pulled. "
"Calling ``pull(in)`` in this state is illegal."
msgstr ""

# e5627743417345e7b4f984513ac51bbb
#: ../../java/stream/stream-customize.rst:128
msgid ""
"``isClosed(in)`` returns true if the port is closed. At this point the port "
"can not be pulled and will not be pushed anymore."
msgstr ""

# aefc3a8d18e5426787e31ae183ef80a5
#: ../../java/stream/stream-customize.rst:142
msgid ""
"Finally, there are two methods available for convenience to complete the "
"stage and all of its ports:"
msgstr ""

# c2b1cc6bf766490ba2c8530ed3c8aec8
#: ../../java/stream/stream-customize.rst:144
msgid ""
"``completeStage()`` is equivalent to closing all output ports and cancelling"
" all input ports."
msgstr ""

# f821e3cba5ce4f6898037094a26caed1
#: ../../java/stream/stream-customize.rst:145
msgid ""
"``failStage(exception)`` is equivalent to failing all output ports and "
"cancelling all input ports."
msgstr ""

# b93c7c03310e41aa9496f37969788eaf
#: ../../java/stream/stream-customize.rst:148
msgid ""
"In some cases it is inconvenient and error prone to react on the regular "
"state machine events with the signal based API described above. For those "
"cases there is an API which allows for a more declarative sequencing of "
"actions which will greatly simplify some use cases at the cost of some extra"
" allocations. The difference between the two APIs could be described as that"
" the first one is signal driven from the outside, while this API is more "
"active and drives its surroundings."
msgstr ""

# 5c6d965c93e44b528e733ab999bb6df0
#: ../../java/stream/stream-customize.rst:154
msgid "The operations of this part of the :class:``GraphStage`` API are:"
msgstr ""

# 6493594cab01412e8d40bd01641ecc95
#: ../../java/stream/stream-customize.rst:156
msgid ""
"``emit(out, elem)`` and ``emitMultiple(out, Iterable(elem1, elem2))`` "
"replaces the ``OutHandler`` with a handler that emits one or more elements "
"when there is demand, and then reinstalls the current handlers"
msgstr ""

# 673ba763a1d54a52bdb037f414187117
#: ../../java/stream/stream-customize.rst:158
msgid ""
"``read(in)(andThen)`` and ``readN(in, n)(andThen)`` replaces the "
"``InHandler`` with a handler that reads one or more elements as they are "
"pushed and allows the handler to react once the requested number of elements"
" has been read."
msgstr ""

# 2bf9fcaa43f948ac987966d3b1b3b3fc
#: ../../java/stream/stream-customize.rst:160
msgid ""
"``abortEmitting()`` and ``abortReading()`` which will cancel an ongoing emit"
" or read"
msgstr ""

# 111ccc6b9b1940c8805dc5c0832ff30b
#: ../../java/stream/stream-customize.rst:162
msgid ""
"Note that since the above methods are implemented by temporarily replacing "
"the handlers of the stage you should never call ``setHandler`` while they "
"are running ``emit`` or ``read`` as that interferes with how they are "
"implemented. The following methods are safe to call after invoking ``emit`` "
"and ``read`` (and will lead to actually running the operation when those are"
" done): ``complete(out)``, ``completeStage()``, ``emit``, ``emitMultiple``, "
"``abortEmitting()`` and ``abortReading()``"
msgstr ""

# ea9d1c28c6df4b56ab9b1a9d41244ca7
#: ../../java/stream/stream-customize.rst:168
msgid ""
"An example of how this API simplifies a stage can be found below in the "
"second version of the :class:``Duplicator``."
msgstr ""

# f80373502b0442ff9f58a1cb9cac3b0d
#: ../../java/stream/stream-customize.rst:171
msgid "Custom linear processing stages using GraphStage"
msgstr ""

# af5e9c4b3aa941a0b767aa73e2fef8a3
#: ../../java/stream/stream-customize.rst:173
msgid ""
"Graph stages allows for custom linear processing stages through letting them"
" have one input and one output and using :class:`FlowShape` as their shape."
msgstr ""

# c48ebdb1368f43a1848ca34f5378f25a
#: ../../java/stream/stream-customize.rst:176
msgid ""
"Such a stage can be illustrated as a box with two flows as it is seen in the"
" illustration below. Demand flowing upstream leading to elements flowing "
"downstream."
msgstr ""

# ba336e8485924d22b061231c90c63947
#: ../../java/stream/stream-customize.rst:189
msgid ""
"To illustrate these concepts we create a small :class:`GraphStage` that "
"implements the ``map`` transformation."
msgstr ""

# 307a75485ab54be189aee606d8d8217b
#: ../../java/stream/stream-customize.rst:199
msgid ""
"Map calls ``push(out)`` from the ``onPush()`` handler and it also calls "
"``pull()`` from the ``onPull`` handler resulting in the conceptual wiring "
"above, and fully expressed in code below:"
msgstr ""

# 41e455d971514eaeb4f4c460c5ff44f3
#: ../../java/stream/stream-customize.rst:204
msgid ""
"Map is a typical example of a one-to-one transformation of a stream where "
"demand is passed along upstream elements passed on downstream."
msgstr ""

# 93fae4eea0434b81a3a372850ac16dc7
#: ../../java/stream/stream-customize.rst:207
msgid ""
"To demonstrate a many-to-one stage we will implement filter. The conceptual "
"wiring of ``Filter`` looks like this:"
msgstr ""

# 1d8ef7a0671d484e851e652190f87d3c
#: ../../java/stream/stream-customize.rst:219
msgid ""
"As we see above, if the given predicate matches the current element we are "
"propagating it downwards, otherwise we return the “ball” to our upstream so "
"that we get the new element. This is achieved by modifying the map example "
"by adding a conditional in the ``onPush`` handler and decide between a "
"``pull(in)`` or ``push(out)`` call (and of course not having a mapping ``f``"
" function)."
msgstr ""

# 931d2fabbf2247dd89d65fa8346ea39d
#: ../../java/stream/stream-customize.rst:226
msgid ""
"To complete the picture we define a one-to-many transformation as the next "
"step. We chose a straightforward example stage that emits every upstream "
"element twice downstream. The conceptual wiring of this stage looks like "
"this:"
msgstr ""

# 6d0f1a80235c492e995e790379c21767
#: ../../java/stream/stream-customize.rst:237
msgid ""
"This is a stage that has state: an option with the last element it has seen "
"indicating if it has duplicated this last element already or not. We must "
"also make sure to emit the extra element if the upstream completes."
msgstr ""

# 73deace1a17e4d30873cebe6464d4f03
#: ../../java/stream/stream-customize.rst:243
msgid ""
"In this case a pull from downstream might be consumed by the stage itself "
"rather than passed along upstream as the stage might contain an element it "
"wants to push. Note that we also need to handle the case where the upstream "
"closes while the stage still has elements it wants to push downstream. This "
"is done by overriding `onUpstreamFinish` in the `AbstractInHandler` and "
"provide custom logic that should happen when the upstream has been finished."
msgstr ""

# 8e5ea003d7404619969688510f564d25
#: ../../java/stream/stream-customize.rst:250
msgid ""
"This example can be simplified by replacing the usage of a mutable state "
"with calls to ``emitMultiple`` which will replace the handlers, emit each of"
" multiple elements and then reinstate the original handlers:"
msgstr ""

# d61c4bf5ec3841c39c34278c13db1e30
#: ../../java/stream/stream-customize.rst:256
msgid ""
"Finally, to demonstrate all of the stages above, we put them together into a"
" processing chain, which conceptually would correspond to the following "
"structure:"
msgstr ""

# e8938821ebc24de386769d708d3fa3c1
#: ../../java/stream/stream-customize.rst:268
msgid ""
"In code this is only a few lines, using the ``via`` use our custom stages in"
" a stream:"
msgstr ""

# d1c1892124b64a11815ffc00eda43785
#: ../../java/stream/stream-customize.rst:272
msgid ""
"If we attempt to draw the sequence of events, it shows that there is one "
"\"event token\" in circulation in a potential chain of stages, just like our"
" conceptual \"railroad tracks\" representation predicts."
msgstr ""

# bde1a6f9f98b41c799c53e04234a8ae5
#: ../../java/stream/stream-customize.rst:286
msgid "Completion"
msgstr ""

# ab20c8c4ff894d48bb94ee5778ffe334
#: ../../java/stream/stream-customize.rst:288
msgid ""
"Completion handling usually (but not exclusively) comes into the picture "
"when processing stages need to emit a few more elements after their upstream"
" source has been completed. We have seen an example of this in our first "
":class:`Duplicator` implementation where the last element needs to be "
"doubled even after the upstream neighbor stage has been completed. This can "
"be done by overriding the ``onUpstreamFinish`` method in "
"``AbstractInHandler``."
msgstr ""

# 703d669d089a456cb1e590159b1f4155
#: ../../java/stream/stream-customize.rst:293
msgid ""
"Stages by default automatically stop once all of their ports (input and "
"output) have been closed externally or internally. It is possible to opt out"
" from this behavior by invoking ``setKeepGoing(true)`` (which is not "
"supported from the stage’s constructor and usually done in ``preStart``). In"
" this case the stage **must** be explicitly closed by calling "
"``completeStage()`` or ``failStage(exception)``. This feature carries the "
"risk of leaking streams and actors, therefore it should be used with care."
msgstr ""

# 6c2ece3536b348c398c5e4de4459ebcd
#: ../../java/stream/stream-customize.rst:300
msgid "Using timers"
msgstr ""

# d0e38e657f6a49499c0914d70e01b9aa
#: ../../java/stream/stream-customize.rst:302
msgid ""
"It is possible to use timers in :class:`GraphStages` by using "
":class:`TimerGraphStageLogic` as the base class for the returned logic. "
"Timers can be scheduled by calling one of ``scheduleOnce(key,delay)``, "
"``schedulePeriodically(key,period)`` or "
"``schedulePeriodicallyWithInitialDelay(key,delay,period)`` and passing an "
"object as a key for that timer (can be any object, for example a "
":class:`String`). The ``onTimer(key)`` method needs to be overridden and it "
"will be called once the timer of ``key`` fires. It is possible to cancel a "
"timer using ``cancelTimer(key)`` and check the status of a timer with "
"``isTimerActive(key)``. Timers will be automatically cleaned up when the "
"stage completes."
msgstr ""

# a529bfeb3d77414cbf47cd44e950b209
#: ../../java/stream/stream-customize.rst:309
msgid ""
"Timers can not be scheduled from the constructor of the logic, but it is "
"possible to schedule them from the ``preStart()`` lifecycle hook."
msgstr ""

# e5c44a1e381c4842b048898bf8c1fa08
#: ../../java/stream/stream-customize.rst:312
msgid ""
"In this sample the stage toggles between open and closed, where open means "
"no elements are passed through. The stage starts out as closed but as soon "
"as an element is pushed downstream the gate becomes open for a duration of "
"time during which it will consume and drop upstream messages:"
msgstr ""

# aeb4f5d4aa454576b502da827c1c6eca
#: ../../java/stream/stream-customize.rst:319
msgid "Using asynchronous side-channels"
msgstr ""

# 354779d87daa401d84ca66cc02030e73
#: ../../java/stream/stream-customize.rst:320
msgid ""
"In order to receive asynchronous events that are not arriving as stream "
"elements (for example a completion of a future or a callback from a 3rd "
"party API) one must acquire a :class:`AsyncCallback` by calling "
"``getAsyncCallback()`` from the stage logic. The method ``getAsyncCallback``"
" takes as a parameter a callback that will be called once the asynchronous "
"event fires. It is important to **not call the callback directly**, instead,"
" the external API must call the ``invoke(event)`` method on the returned "
":class:`AsyncCallback`. The execution engine will take care of calling the "
"provided callback in a thread-safe way. The callback can safely access the "
"state of the :class:`GraphStageLogic` implementation."
msgstr ""

# 2e076072b816439ba6fdac7f1f1b6891
#: ../../java/stream/stream-customize.rst:328
msgid ""
"Sharing the AsyncCallback from the constructor risks race conditions, "
"therefore it is recommended to use the ``preStart()`` lifecycle hook "
"instead."
msgstr ""

# cee445db6ab14ef88c9ee5fb917a674e
#: ../../java/stream/stream-customize.rst:332
msgid ""
"This example shows an asynchronous side channel graph stage that starts "
"dropping elements when a future completes:"
msgstr ""

# 1ca48c41ba3649e69286a4f01b4026ce
#: ../../java/stream/stream-customize.rst:339
msgid "Integration with actors"
msgstr ""

# 776c6fff3c624ce0972e0697c14cc5ed
#: ../../java/stream/stream-customize.rst:341
msgid ""
"**This section is a stub and will be extended in the next release** **This "
"is an experimental feature***"
msgstr ""

# ec6db23ab99944409a24e570b8aff006
#: ../../java/stream/stream-customize.rst:344
msgid ""
"It is possible to acquire an ActorRef that can be addressed from the outside"
" of the stage, similarly how :class:`AsyncCallback` allows injecting "
"asynchronous events into a stage logic. This reference can be obtained by "
"calling ``getStageActorRef(receive)`` passing in a function that takes a "
":class:`Pair` of the sender :class:`ActorRef` and the received message. This"
" reference can be used to watch other actors by calling its ``watch(ref)`` "
"or ``unwatch(ref)`` methods. The reference can be also watched by external "
"actors. The current limitations of this :class:`ActorRef` are:"
msgstr ""

# fc3f372b10cc4c2995723db8f23815a5
#: ../../java/stream/stream-customize.rst:351
msgid ""
"they are not location transparent, they cannot be accessed via remoting."
msgstr ""

# 86c19602ab0b4a78bc6aa24026577c4f
#: ../../java/stream/stream-customize.rst:352
msgid "they cannot be returned as materialized values."
msgstr ""

# 68357c2e7ff4425caabb569cb04eee07
#: ../../java/stream/stream-customize.rst:353
msgid ""
"they cannot be accessed from the constructor of the "
":class:`GraphStageLogic`, but they can be accessed from the ``preStart()`` "
"method."
msgstr ""

# e1a4a752fa234a4693eb338ecaa43172
#: ../../java/stream/stream-customize.rst:357
msgid "Custom materialized values"
msgstr ""

# e667c27fe87c4bc8bdccbad1d2a68dd4
#: ../../java/stream/stream-customize.rst:359
msgid ""
"Custom stages can return materialized values instead of ``Unit`` by "
"inheriting from :class:`GraphStageWithMaterializedValue` instead of the "
"simpler :class:`GraphStage`. The difference is that in this case the method "
"``createLogicAndMaterializedValue(inheritedAttributes)`` needs to be "
"overridden, and in addition to the stage logic the materialized value must "
"be provided"
msgstr ""

# 9cbd17750710489f80a9821432b5683c
#: ../../java/stream/stream-customize.rst:365
msgid ""
"There is no built-in synchronization of accessing this value from both of "
"the thread where the logic runs and the thread that got hold of the "
"materialized value. It is the responsibility of the programmer to add the "
"necessary (non-blocking) synchronization and visibility guarantees to this "
"shared object."
msgstr ""

# 5020bbd0a13b46758a446573c2f0e333
#: ../../java/stream/stream-customize.rst:369
msgid ""
"In this sample the materialized value is a future containing the first "
"element to go through the stream:"
msgstr ""

# 175f4a89ee8a498c8ccc39b0e03735e2
#: ../../java/stream/stream-customize.rst:374
msgid "Using attributes to affect the behavior of a stage"
msgstr ""

# f6cf6fa27cc2400e8c03f4b6f4e252c9
#: ../../java/stream/stream-customize.rst:376
msgid "**This section is a stub and will be extended in the next release**"
msgstr ""

# 6225fa339013431a93b4ac5d52382fb6
#: ../../java/stream/stream-customize.rst:378
msgid ""
"Stages can access the :class:`Attributes` object created by the "
"materializer. This contains all the applied (inherited) attributes applying "
"to the stage, ordered from least specific (outermost) towards the most "
"specific (innermost) attribute. It is the responsibility of the stage to "
"decide how to reconcile this inheritance chain to a final effective "
"decision."
msgstr ""

# d640f650d6f9478f8234720e9e3dd7e8
#: ../../java/stream/stream-customize.rst:383
msgid "See :ref:`composition-java` for an explanation on how attributes work."
msgstr ""

# 530c02d9b66a494cb2056b54036f39b0
#: ../../java/stream/stream-customize.rst:387
msgid "Rate decoupled graph stages"
msgstr ""

# 862f70d4d8be4a7dbe1017ed261745b0
#: ../../java/stream/stream-customize.rst:389
msgid ""
"Sometimes it is desirable to *decouple* the rate of the upstream and "
"downstream of a stage, synchronizing only when needed."
msgstr ""

# 6722f72e077d479bb7f28691771315af
#: ../../java/stream/stream-customize.rst:392
msgid ""
"This is achieved in the model by representing a :class:`GraphStage` as a "
"*boundary* between two regions where the demand sent upstream is decoupled "
"from the demand that arrives from downstream. One immediate consequence of "
"this difference is that an ``onPush`` call does not always lead to calling "
"``push`` and an ``onPull``  call does not always lead to calling ``pull``."
msgstr ""

# f3327fe0d6e84190b4a05fbd3c3af9cf
#: ../../java/stream/stream-customize.rst:397
msgid ""
"One of the important use-case for this is to build buffer-like entities, "
"that allow independent progress of upstream and downstream stages when the "
"buffer is not full or empty, and slowing down the appropriate side if the "
"buffer becomes empty or full."
msgstr ""

# 7a13397330924f52afc214bd82437169
#: ../../java/stream/stream-customize.rst:401
msgid ""
"The next diagram illustrates the event sequence for a buffer with capacity "
"of two elements in a setting where the downstream demand is slow to start "
"and the buffer will fill up with upstream elements before any demand is seen"
" from downstream."
msgstr ""

# 4064ef0bf7ed4ffba8246e426ddf3092
#: ../../java/stream/stream-customize.rst:413
msgid ""
"Another scenario would be where the demand from downstream starts coming in "
"before any element is pushed into the buffer stage."
msgstr ""

# d8bafe5685d544828b037b2febc652c0
#: ../../java/stream/stream-customize.rst:426
msgid ""
"The first difference we can notice is that our ``Buffer`` stage is "
"automatically pulling its upstream on initialization. The buffer has demand "
"for up to two elements without any downstream demand."
msgstr ""

# f425bd1478bb49249ca281d7161f17a5
#: ../../java/stream/stream-customize.rst:429
msgid ""
"The following code example demonstrates a buffer class corresponding to the "
"message sequence chart above."
msgstr ""

# 46299420e88b497ea5bc144fce3f0e93
#: ../../java/stream/stream-customize.rst:434
msgid "Thread safety of custom processing stages"
msgstr ""

# a324442684704ccea63a684e1f9792c9
#: ../../java/stream/stream-customize.rst:437
msgid ""
"The callbacks exposed by all of these classes are never called concurrently."
msgstr ""

# 5ffd347aaef245499ace463f656baedf
#: ../../java/stream/stream-customize.rst:438
msgid ""
"The state encapsulated by these classes can be safely modified from the "
"provided callbacks, without any further synchronization."
msgstr ""

# 53f34c3312a5494c8dd580a5a5481b07
#: ../../java/stream/stream-customize.rst:441
msgid ""
"In essence, the above guarantees are similar to what :class:`Actor` s "
"provide, if one thinks of the state of a custom stage as state of an actor, "
"and the callbacks as the ``receive`` block of the actor."
msgstr ""

# 5018029f0557464a8fc684d3a0a272c6
#: ../../java/stream/stream-customize.rst:445
msgid ""
"It is **not safe** to access the state of any custom stage outside of the "
"callbacks that it provides, just like it is unsafe to access the state of an"
" actor from the outside. This means that Future callbacks should **not close"
" over** internal state of custom stages because such access can be "
"concurrent with the provided callbacks, leading to undefined behavior."
msgstr ""

# dc148ae57b9545c28944ed92616dedf6
#: ../../java/stream/stream-dynamic.rst:5
msgid "Dynamic stream handling"
msgstr ""

# ba7a1031cd8e4b3ea8b4826ef15e31d6
#: ../../java/stream/stream-dynamic.rst:10
msgid "Controlling graph completion with KillSwitch"
msgstr ""

# 13a8589329224aadb6fdd684414cfb69
#: ../../java/stream/stream-dynamic.rst:12
msgid ""
"A ``KillSwitch`` allows the completion of graphs of ``FlowShape`` from the "
"outside. It consists of a flow element that can be linked to a graph of "
"``FlowShape`` needing completion control. The ``KillSwitch`` interface "
"allows to:"
msgstr ""

# 6f07dddeb82445d5af1aa43c681e5c97
#: ../../java/stream/stream-dynamic.rst:16
msgid "complete the graph(s) via ``shutdown()``"
msgstr ""

# 920dcd5f2fe04cb0ba32ce0dd55211dc
#: ../../java/stream/stream-dynamic.rst:17
msgid "fail the graph(s) via ``abort(Throwable error)``"
msgstr ""

# 67a1b131f2e7493eb69c9eeb19350f69
#: ../../java/stream/stream-dynamic.rst:19
msgid ""
"After the first call to either ``shutdown`` or ``abort``, all subsequent "
"calls to any of these methods will be ignored. Graph completion is performed"
" by both"
msgstr ""

# 3a840b9a632245619b9081fa72b687c3
#: ../../java/stream/stream-dynamic.rst:22
msgid "completing its downstream"
msgstr ""

# 2e10a72d0d884a1e846349c3f142aab9
#: ../../java/stream/stream-dynamic.rst:23
msgid ""
"cancelling (in case of ``shutdown``) or failing (in case of ``abort``) its "
"upstream."
msgstr ""

# 2b1a183804ae41d0a5148db96600f8a0
#: ../../java/stream/stream-dynamic.rst:25
msgid ""
"A ``KillSwitch`` can control the completion of one or multiple streams, and "
"therefore comes in two different flavours."
msgstr ""

# 5591ce7945f842f99b7164f17ccab4c4
#: ../../java/stream/stream-dynamic.rst:30
msgid "UniqueKillSwitch"
msgstr ""

# 591639fbe207452fb2e361c570270fa2
#: ../../java/stream/stream-dynamic.rst:32
msgid ""
"``UniqueKillSwitch`` allows to control the completion of **one** "
"materialized ``Graph`` of ``FlowShape``. Refer to the below for usage "
"examples."
msgstr ""

# dbe649a37df343ac8dddd95b3754601d
# cafccc29d0824d0491b339ee9900c665
#: ../../java/stream/stream-dynamic.rst:35
#: ../../java/stream/stream-dynamic.rst:52
msgid "**Shutdown**"
msgstr ""

# bd95b690d5a442e5854fc42bb13491ac
# b750c7a0fe874d08af7832a4374ff43a
#: ../../java/stream/stream-dynamic.rst:39
#: ../../java/stream/stream-dynamic.rst:56
msgid "**Abort**"
msgstr ""

# d8e3b7c13532435eab648153f09572a4
#: ../../java/stream/stream-dynamic.rst:46
msgid "SharedKillSwitch"
msgstr ""

# cd2f9aef55e84e3db038a6eac87b0181
#: ../../java/stream/stream-dynamic.rst:48
msgid ""
"A ``SharedKillSwitch`` allows to control the completion of an arbitrary "
"number graphs of ``FlowShape``. It can be materialized multiple times via "
"its ``flow`` method, and all materialized graphs linked to it are controlled"
" by the switch. Refer to the below for usage examples."
msgstr ""

# c7fd1fe100254d838678f47519935e8c
#: ../../java/stream/stream-dynamic.rst:61
msgid ""
"A ``UniqueKillSwitch`` is always a result of a materialization, whilst "
"``SharedKillSwitch`` needs to be constructed before any materialization "
"takes place."
msgstr ""

# 9df3636eb49144bca0f8746a31c23435
#: ../../java/stream/stream-error.rst:5
msgid "Error Handling"
msgstr ""

# eec3453b64154378acae2e81e5dc252c
#: ../../java/stream/stream-error.rst:7
msgid ""
"Strategies for how to handle exceptions from processing stream elements can "
"be defined when materializing the stream. The error handling strategies are "
"inspired by actor supervision strategies, but the semantics have been "
"adapted to the domain of stream processing."
msgstr ""

# 849de31d370d4d1bbebc6ac7afa32b42
#: ../../java/stream/stream-error.rst:13
msgid ""
"*ZipWith*, *GraphStage* junction, *ActorPublisher* source and "
"*ActorSubscriber* sink components do not honour the supervision strategy "
"attribute yet."
msgstr ""

# 2f73e76e29954cd6b2564775e3690a82
#: ../../java/stream/stream-error.rst:17
msgid "Supervision Strategies"
msgstr ""

# 94ad3252b2cd40d4a528bb49b0d9af85
#: ../../java/stream/stream-error.rst:19
msgid "There are three ways to handle exceptions from application code:"
msgstr ""

# d81cec23a13a4e15972f3d30d36942b0
#: ../../java/stream/stream-error.rst:21
msgid "``Stop`` - The stream is completed with failure."
msgstr ""

# 11c7c94339b040b8b63732946c0a601d
#: ../../java/stream/stream-error.rst:22
msgid "``Resume`` - The element is dropped and the stream continues."
msgstr ""

# 3e2691991ef641b489df9e022261f0ac
#: ../../java/stream/stream-error.rst:23
msgid ""
"``Restart`` - The element is dropped and the stream continues after "
"restarting the stage. Restarting a stage means that any accumulated state is"
" cleared. This is typically performed by creating a new instance of the "
"stage."
msgstr ""

# 3d3d2cff3584412b9d6a97fa35b305e5
#: ../../java/stream/stream-error.rst:28
msgid ""
"By default the stopping strategy is used for all exceptions, i.e. the stream"
" will be completed with failure when an exception is thrown."
msgstr ""

# 570766734c7c4f128483248fad3818e4
#: ../../java/stream/stream-error.rst:33
msgid ""
"The default supervision strategy for a stream can be defined on the settings"
" of the materializer."
msgstr ""

# cbc92e34c876474abe1fa0ecf5a5b5d9
#: ../../java/stream/stream-error.rst:37
msgid ""
"Here you can see that all ``ArithmeticException`` will resume the "
"processing, i.e. the elements that cause the division by zero are "
"effectively dropped."
msgstr ""

# 501732e496714ac8bb052d6594782bf7
#: ../../java/stream/stream-error.rst:42
msgid ""
"Be aware that dropping elements may result in deadlocks in graphs with "
"cycles, as explained in :ref:`graph-cycles-java`."
msgstr ""

# 8631aa3af4cb4825bdc54461ef474abe
#: ../../java/stream/stream-error.rst:45
msgid ""
"The supervision strategy can also be defined for all operators of a flow."
msgstr ""

# 86409243dfdd4536a667369c10a09b67
#: ../../java/stream/stream-error.rst:49
msgid ""
"``Restart`` works in a similar way as ``Resume`` with the addition that "
"accumulated state, if any, of the failing processing stage will be reset."
msgstr ""

# 56a9742e3b7148a48cb51085c0b99c84
#: ../../java/stream/stream-error.rst:55
msgid "Errors from mapAsync"
msgstr ""

# f29b30d52b4840f39d79e69ed1e302c9
#: ../../java/stream/stream-error.rst:57
msgid "Stream supervision can also be applied to the futures of ``mapAsync``."
msgstr ""

# 46b0c5311a4d46a18029f82fac4aa5cd
#: ../../java/stream/stream-error.rst:59
msgid ""
"Let's say that we use an external service to lookup email addresses and we "
"would like to discard those that cannot be found."
msgstr ""

# a0f39d2fa08240f5b7e44f4b443465ec
# 116ed9992b6440e4812ebdc438eb4628
#: ../../java/stream/stream-error.rst:62
#: ../../java/stream/stream-integrations.rst:154
msgid "We start with the tweet stream of authors:"
msgstr ""

# f79620d018ad47e89c2c7f1eaea4c87f
# fcaa935f62e5468d850f45737fc4cfe0
#: ../../java/stream/stream-error.rst:66
#: ../../java/stream/stream-integrations.rst:158
msgid "Assume that we can lookup their email address using:"
msgstr ""

# c03f3ef7d9ef4a2a87b92a7b2ccdbe7e
#: ../../java/stream/stream-error.rst:70
msgid ""
"The ``CompletionStage`` is completed normally if the email is not found."
msgstr ""

# c12bc54c5dd34413941226ba7abd52d9
#: ../../java/stream/stream-error.rst:72
msgid ""
"Transforming the stream of authors to a stream of email addresses by using "
"the ``lookupEmail`` service can be done with ``mapAsync`` and we use "
"``Supervision.getResumingDecider`` to drop unknown email addresses:"
msgstr ""

# f613b1aafcc347d58710c8b1aac4afb0
#: ../../java/stream/stream-error.rst:78
msgid ""
"If we would not use ``Resume`` the default stopping strategy would complete "
"the stream with failure on the first ``CompletionStage`` that was completed "
"exceptionally."
msgstr ""

# 80e1f771a7484ee4a18f0a2854347929
#: ../../java/stream/stream-flows-and-basics.rst:5
msgid "Basics and working with Flows"
msgstr ""

# a5ab9948e9cc4db2800178e2cb715ead
#: ../../java/stream/stream-flows-and-basics.rst:10
msgid "Core concepts"
msgstr ""

# 1fb24e39af40491cbb874c92d6bf5fac
#: ../../java/stream/stream-flows-and-basics.rst:12
msgid ""
"Akka Streams is a library to process and transfer a sequence of elements "
"using bounded buffer space. This latter property is what we refer to as "
"*boundedness* and it is the defining feature of Akka Streams. Translated to "
"everyday terms it is possible to express a chain (or as we see later, "
"graphs) of processing entities, each executing independently (and possibly "
"concurrently) from the others while only buffering a limited number of "
"elements at any given time. This property of bounded buffers is one of the "
"differences from the actor model, where each actor usually has an unbounded,"
" or a bounded, but dropping mailbox. Akka Stream processing entities have "
"bounded \"mailboxes\" that do not drop."
msgstr ""

# b94cab82ed1244839afd2c11b772e0be
#: ../../java/stream/stream-flows-and-basics.rst:20
msgid ""
"Before we move on, let's define some basic terminology which will be used "
"throughout the entire documentation:"
msgstr ""

# 18a3a3f289ef43d4897bb1583f411631
#: ../../java/stream/stream-flows-and-basics.rst:23
msgid "An active process that involves moving and transforming data."
msgstr ""

# 9509ea8dd7c440eb90b9eb94c5f9c2ee
#: ../../java/stream/stream-flows-and-basics.rst:25
msgid ""
"An element is the processing unit of streams. All operations transform and "
"transfer elements from upstream to downstream. Buffer sizes are always "
"expressed as number of elements independently form the actual size of the "
"elements."
msgstr ""

# 6742412d65234e5e9747af528d9354e7
#: ../../java/stream/stream-flows-and-basics.rst:28
msgid ""
"A means of flow-control, a way for consumers of data to notify a producer "
"about their current availability, effectively slowing down the upstream "
"producer to match their consumption speeds. In the context of Akka Streams "
"back-pressure is always understood as *non-blocking* and *asynchronous*."
msgstr ""

# 671e1a6cb1244b7086b5ffc731758f9b
#: ../../java/stream/stream-flows-and-basics.rst:32
msgid ""
"Means that a certain operation does not hinder the progress of the calling "
"thread, even if it takes long time to finish the requested operation."
msgstr ""

# 96b4ab851cca41b4a767fe75d3e7e1c3
#: ../../java/stream/stream-flows-and-basics.rst:35
msgid ""
"A description of a stream processing topology, defining the pathways through"
" which elements shall flow when the stream is running."
msgstr ""

# 12752a3d3c7943c3a9ed03c34104eaf0
#: ../../java/stream/stream-flows-and-basics.rst:38
msgid ""
"The common name for all building blocks that build up a Graph. Examples of a"
" processing stage would be  operations like ``map()``, ``filter()``, custom "
"``GraphStage`` s and graph junctions like ``Merge`` or ``Broadcast``. For "
"the full list of built-in processing stages see :ref:`stages-overview_java`"
msgstr ""

# 83fcabb6ab8941198911889c9acd0122
#: ../../java/stream/stream-flows-and-basics.rst:42
msgid ""
"When we talk about *asynchronous, non-blocking backpressure* we mean that "
"the processing stages available in Akka Streams will not use blocking calls "
"but asynchronous message passing to exchange messages between each other, "
"and they will use asynchronous means to slow down a fast producer, without "
"blocking its thread. This is a thread-pool friendly design, since entities "
"that need to wait (a fast producer waiting on a slow consumer) will not "
"block the thread but can hand it back for further use to an underlying "
"thread-pool."
msgstr ""

# 02fd0240a97b41648b0ce4bf73baed48
#: ../../java/stream/stream-flows-and-basics.rst:51
msgid "Defining and running streams"
msgstr ""

# 57fec55844164bb49b4953c096ed5e32
#: ../../java/stream/stream-flows-and-basics.rst:53
msgid ""
"Linear processing pipelines can be expressed in Akka Streams using the "
"following core abstractions:"
msgstr ""

# 355f2ad4ceb9469384b93b9e8a63d826
#: ../../java/stream/stream-flows-and-basics.rst:56
msgid ""
"A processing stage with *exactly one output*, emitting data elements "
"whenever downstream processing stages are ready to receive them."
msgstr ""

# a6be28995a92447993ffd4fabdb5470f
#: ../../java/stream/stream-flows-and-basics.rst:59
msgid ""
"A processing stage with *exactly one input*, requesting and accepting data "
"elements possibly slowing down the upstream producer of elements"
msgstr ""

# c9fd2d73d48d438ba3479ac883ff6082
#: ../../java/stream/stream-flows-and-basics.rst:62
msgid ""
"A processing stage which has *exactly one input and output*, which connects "
"its up- and downstreams by transforming the data elements flowing through "
"it."
msgstr ""

# d513c340608847858a638135ce770505
#: ../../java/stream/stream-flows-and-basics.rst:65
msgid ""
"A Flow that has both ends \"attached\" to a Source and Sink respectively, "
"and is ready to be ``run()``."
msgstr ""

# bfe9e1744733464c9c34330dafa749c5
#: ../../java/stream/stream-flows-and-basics.rst:67
msgid ""
"It is possible to attach a ``Flow`` to a ``Source`` resulting in a composite"
" source, and it is also possible to prepend a ``Flow`` to a ``Sink`` to get "
"a new sink. After a stream is properly terminated by having both a source "
"and a sink, it will be represented by the ``RunnableGraph`` type, indicating"
" that it is ready to be executed."
msgstr ""

# 9e949460a06b435fa5b62c27d920216c
#: ../../java/stream/stream-flows-and-basics.rst:71
msgid ""
"It is important to remember that even after constructing the "
"``RunnableGraph`` by connecting all the source, sink and different "
"processing stages, no data will flow through it until it is materialized. "
"Materialization is the process of allocating all resources needed to run the"
" computation described by a Graph (in Akka Streams this will often involve "
"starting up Actors). Thanks to Flows being simply a description of the "
"processing pipeline they are *immutable, thread-safe, and freely shareable*,"
" which means that it is for example safe to share and send them between "
"actors, to have one actor prepare the work, and then have it be materialized"
" at some completely different place in the code."
msgstr ""

# 7b8351936c674c2fb3e76c75d174ec3d
#: ../../java/stream/stream-flows-and-basics.rst:80
msgid ""
"After running (materializing) the ``RunnableGraph`` we get a special "
"container object, the ``MaterializedMap``. Both sources and sinks are able "
"to put specific objects into this map. Whether they put something in or not "
"is implementation dependent. For example a ``FoldSink`` will make a "
"``CompletionStage`` available in this map which will represent the result of"
" the folding process over the stream.  In general, a stream can expose "
"multiple materialized values, but it is quite common to be interested in "
"only the value of the Source or the Sink in the stream. For this reason "
"there is a convenience method called ``runWith()`` available for ``Sink``, "
"``Source`` or ``Flow`` requiring, respectively, a supplied ``Source`` (in "
"order to run a ``Sink``), a ``Sink`` (in order to run a ``Source``) or both "
"a ``Source`` and a ``Sink`` (in order to run a ``Flow``, since it has "
"neither attached yet)."
msgstr ""

# 0fd15f753c404b8789bacaadc8273fb9
#: ../../java/stream/stream-flows-and-basics.rst:91
msgid ""
"It is worth pointing out that since processing stages are *immutable*, "
"connecting them returns a new processing stage, instead of modifying the "
"existing instance, so while constructing long flows, remember to assign the "
"new value to a variable or run it:"
msgstr ""

# acd0155ebda246df8ab320c8b10d9cae
#: ../../java/stream/stream-flows-and-basics.rst:97
msgid ""
"By default Akka Streams elements support **exactly one** downstream "
"processing stage. Making fan-out (supporting multiple downstream processing "
"stages) an explicit opt-in feature allows default stream elements to be less"
" complex and more efficient. Also it allows for greater flexibility on *how "
"exactly* to handle the multicast scenarios, by providing named fan-out "
"elements such as broadcast (signals all down-stream elements) or balance "
"(signals one of available down-stream elements)."
msgstr ""

# d4c47d49eb424df39e1cca30abb57c1f
#: ../../java/stream/stream-flows-and-basics.rst:102
msgid ""
"In the above example we used the ``runWith`` method, which both materializes"
" the stream and returns the materialized value of the given sink or source."
msgstr ""

# 8f089011c73f4ddc867ae3c91c94f4ee
#: ../../java/stream/stream-flows-and-basics.rst:105
msgid ""
"Since a stream can be materialized multiple times, the ``MaterializedMap`` "
"returned is different for each materialization. In the example below we "
"create two running materialized instance of the stream that we described in "
"the ``runnable`` variable, and both materializations give us a different "
"``CompletionStage`` from the map even though we used the same ``sink`` to "
"refer to the future:"
msgstr ""

# 8e34100100484640a5914608afa49054
#: ../../java/stream/stream-flows-and-basics.rst:113
msgid "Defining sources, sinks and flows"
msgstr ""

# b2416a60baa7465e84fd460931d8233a
#: ../../java/stream/stream-flows-and-basics.rst:115
msgid ""
"The objects :class:`Source` and :class:`Sink` define various ways to create "
"sources and sinks of elements. The following examples show some of the most "
"useful constructs (refer to the API documentation for more details):"
msgstr ""

# b9981868da0446b48d499293913a0625
#: ../../java/stream/stream-flows-and-basics.rst:120
msgid ""
"There are various ways to wire up different parts of a stream, the following"
" examples show some of the available options:"
msgstr ""

# a41c05a276e548519f38f0ed0ba7035d
#: ../../java/stream/stream-flows-and-basics.rst:125
msgid "Illegal stream elements"
msgstr ""

# 1929bb40a14844cca0d15f92674b27ba
#: ../../java/stream/stream-flows-and-basics.rst:127
msgid ""
"In accordance to the Reactive Streams specification (`Rule 2.13 "
"<https://github.com/reactive-streams/reactive-streams-jvm#2.13>`_) Akka "
"Streams do not allow ``null`` to be passed through the stream as an element."
" In case you want to model the concept of absence of a value we recommend "
"using ``java.util.Optional`` which is available since Java 8."
msgstr ""

# d7a512d174294335939a22e008581da6
#: ../../java/stream/stream-flows-and-basics.rst:134
msgid "Back-pressure explained"
msgstr ""

# 6f44fa59a203430ba7304516e2d7caf5
#: ../../java/stream/stream-flows-and-basics.rst:136
msgid ""
"Akka Streams implement an asynchronous non-blocking back-pressure protocol "
"standardised by the `Reactive Streams`_ specification, which Akka is a "
"founding member of."
msgstr ""

# a00bcfc15aeb40d7a15f2f042e39e70b
#: ../../java/stream/stream-flows-and-basics.rst:141
msgid ""
"The user of the library does not have to write any explicit back-pressure "
"handling code — it is built in and dealt with automatically by all of the "
"provided Akka Streams processing stages. It is possible however to add "
"explicit buffer stages with overflow strategies that can influence the "
"behaviour of the stream. This is especially important in complex processing "
"graphs which may even contain loops (which *must* be treated with very "
"special care, as explained in :ref:`graph-cycles-java`)."
msgstr ""

# 07340926721f40b3aa29ed2435295cca
#: ../../java/stream/stream-flows-and-basics.rst:147
msgid ""
"The back pressure protocol is defined in terms of the number of elements a "
"downstream ``Subscriber`` is able to receive and buffer, referred to as "
"``demand``. The source of data, referred to as ``Publisher`` in Reactive "
"Streams terminology and implemented as ``Source`` in Akka Streams, "
"guarantees that it will never emit more elements than the received total "
"demand for any given ``Subscriber``."
msgstr ""

# 4a729ca39fed415ca3b29c661d450223
#: ../../java/stream/stream-flows-and-basics.rst:154
msgid ""
"The Reactive Streams specification defines its protocol in terms of "
"``Publisher`` and ``Subscriber``. These types are **not** meant to be user "
"facing API, instead they serve as the low level building blocks for "
"different Reactive Streams implementations."
msgstr ""

# 35ba198be8d841e6a992595e3147451d
#: ../../java/stream/stream-flows-and-basics.rst:158
msgid ""
"Akka Streams implements these concepts as ``Source``, ``Flow`` (referred to "
"as ``Processor`` in Reactive Streams) and ``Sink`` without exposing the "
"Reactive Streams interfaces directly. If you need to integrate with other "
"Reactive Stream libraries read :ref:`reactive-streams-integration-java`."
msgstr ""

# 43f430378f4540da8b8fabe4c8c96a28
#: ../../java/stream/stream-flows-and-basics.rst:162
msgid ""
"The mode in which Reactive Streams back-pressure works can be colloquially "
"described as \"dynamic push / pull mode\", since it will switch between push"
" and pull based back-pressure models depending on the downstream being able "
"to cope with the upstream production rate or not."
msgstr ""

# 20c5ebbacb4f46ffa889e04ed39e3a1a
#: ../../java/stream/stream-flows-and-basics.rst:166
msgid ""
"To illustrate this further let us consider both problem situations and how "
"the back-pressure protocol handles them:"
msgstr ""

# f73ba3d267ca4518bcd1bf3b27aa2ff5
#: ../../java/stream/stream-flows-and-basics.rst:169
msgid "Slow Publisher, fast Subscriber"
msgstr ""

# fc3559ae47ac4195821b81b7188d58b2
#: ../../java/stream/stream-flows-and-basics.rst:171
msgid ""
"This is the happy case of course – we do not need to slow down the Publisher"
" in this case. However signalling rates are rarely constant and could change"
" at any point in time, suddenly ending up in a situation where the "
"Subscriber is now slower than the Publisher. In order to safeguard from "
"these situations, the back-pressure protocol must still be enabled during "
"such situations, however we do not want to pay a high penalty for this "
"safety net being enabled."
msgstr ""

# 55b026b3ba874173a8dd9b98a8b160aa
#: ../../java/stream/stream-flows-and-basics.rst:176
msgid ""
"The Reactive Streams protocol solves this by asynchronously signalling from "
"the Subscriber to the Publisher ``Request(int n)`` signals. The protocol "
"guarantees that the Publisher will never signal *more* elements than the "
"signalled demand. Since the Subscriber however is currently faster, it will "
"be signalling these Request messages at a higher rate (and possibly also "
"batching together the demand - requesting multiple elements in one Request "
"signal). This means that the Publisher should not ever have to wait (be "
"back-pressured) with publishing its incoming elements."
msgstr ""

# 6a501576197c4b5698a234d3afbc3b41
#: ../../java/stream/stream-flows-and-basics.rst:182
msgid ""
"As we can see, in this scenario we effectively operate in so called push-"
"mode since the Publisher can continue producing elements as fast as it can, "
"since the pending demand will be recovered just-in-time while it is emitting"
" elements."
msgstr ""

# 9d34d9a01de0487ca597bc4f457c6c18
#: ../../java/stream/stream-flows-and-basics.rst:186
msgid "Fast Publisher, slow Subscriber"
msgstr ""

# df17442b2341435bad5f2d8acd7f1b21
#: ../../java/stream/stream-flows-and-basics.rst:188
msgid ""
"This is the case when back-pressuring the ``Publisher`` is required, because"
" the ``Subscriber`` is not able to cope with the rate at which its upstream "
"would like to emit data elements."
msgstr ""

# 23a6cccfb9b84879bbfdaec6c9077c97
#: ../../java/stream/stream-flows-and-basics.rst:191
msgid ""
"Since the ``Publisher`` is not allowed to signal more elements than the "
"pending demand signalled by the ``Subscriber``, it will have to abide to "
"this back-pressure by applying one of the below strategies:"
msgstr ""

# 2c93b502a11c40acba50810533ff8169
#: ../../java/stream/stream-flows-and-basics.rst:194
msgid "not generate elements, if it is able to control their production rate,"
msgstr ""

# 37d3fe09ada04899b37ad690ca569914
#: ../../java/stream/stream-flows-and-basics.rst:195
msgid ""
"try buffering the elements in a *bounded* manner until more demand is "
"signalled,"
msgstr ""

# a8f1f20147104003963678d60d45c8aa
#: ../../java/stream/stream-flows-and-basics.rst:196
msgid "drop elements until more demand is signalled,"
msgstr ""

# 8b9d5a7588b24911aea8a17547af2f7d
#: ../../java/stream/stream-flows-and-basics.rst:197
msgid "tear down the stream if unable to apply any of the above strategies."
msgstr ""

# be3440381acf47dead3d1204eada2e5b
#: ../../java/stream/stream-flows-and-basics.rst:199
msgid ""
"As we can see, this scenario effectively means that the ``Subscriber`` will "
"*pull* the elements from the Publisher – this mode of operation is referred "
"to as pull-based back-pressure."
msgstr ""

# 901a9159e63247c2a73579589533592b
#: ../../java/stream/stream-flows-and-basics.rst:205
msgid "Stream Materialization"
msgstr ""

# 64184aae58574159b15e3b8c7580ba64
#: ../../java/stream/stream-flows-and-basics.rst:207
msgid ""
"When constructing flows and graphs in Akka Streams think of them as "
"preparing a blueprint, an execution plan. Stream materialization is the "
"process of taking a stream description (the graph) and allocating all the "
"necessary resources it needs in order to run. In the case of Akka Streams "
"this often means starting up Actors which power the processing, but is not "
"restricted to that—it could also mean opening files or socket connections "
"etc.—depending on what the stream needs."
msgstr ""

# 8fd908f01da64f20a42f440d4d556b59
#: ../../java/stream/stream-flows-and-basics.rst:212
msgid ""
"Materialization is triggered at so called \"terminal operations\". Most "
"notably this includes the various forms of the ``run()`` and ``runWith()`` "
"methods defined on :class:`Source` or :class:`Flow` elements as well as a "
"small number of special syntactic sugars for running with well-known sinks, "
"such as ``runForeach(el -> ...)`` (being an alias to "
"``runWith(Sink.foreach(el -> ...))``."
msgstr ""

# 2e47d4df5d364baab60fe39de950f1c0
#: ../../java/stream/stream-flows-and-basics.rst:216
msgid ""
"Materialization is currently performed synchronously on the materializing "
"thread. The actual stream processing is handled by actors started up during "
"the streams materialization, which will be running on the thread pools they "
"have been configured to run on - which defaults to the dispatcher set in "
":class:`MaterializationSettings` while constructing the "
":class:`ActorMaterializer`."
msgstr ""

# ecd84fb943ef4b8d8532b3bae0a05e9c
#: ../../java/stream/stream-flows-and-basics.rst:222
msgid ""
"Reusing *instances* of linear computation stages (Source, Sink, Flow) inside"
" composite Graphs is legal, yet will materialize that stage multiple times."
msgstr ""

# ed913df9aad842b7b3d7c9ce7b27b3bf
#: ../../java/stream/stream-flows-and-basics.rst:228
msgid "Operator Fusion"
msgstr ""

# 069b6732e4cc446a8a75fdea92329f10
#: ../../java/stream/stream-flows-and-basics.rst:230
msgid ""
"Akka Streams 2.0 contains an initial version of stream operator fusion "
"support. This means that the processing steps of a flow or stream graph can "
"be executed within the same Actor and has three consequences:"
msgstr ""

# be96e25afc9e42cdb174cce5c9e88935
#: ../../java/stream/stream-flows-and-basics.rst:234
msgid ""
"starting up a stream may take longer than before due to executing the fusion"
" algorithm"
msgstr ""

# f2d808ecb2be4af283894d291b9b0655
#: ../../java/stream/stream-flows-and-basics.rst:235
msgid ""
"passing elements from one processing stage to the next is a lot faster "
"between fused stages due to avoiding the asynchronous messaging overhead"
msgstr ""

# f313873ed96147afb9c9eda7895347bf
#: ../../java/stream/stream-flows-and-basics.rst:237
msgid ""
"fused stream processing stages do no longer run in parallel to each other, "
"meaning that only up to one CPU core is used for each fused part"
msgstr ""

# 30aaf426487f484abf44144baafca22e
#: ../../java/stream/stream-flows-and-basics.rst:240
msgid ""
"The first point can be countered by pre-fusing and then reusing a stream "
"blueprint as sketched below:"
msgstr ""

# 8d3d6aebf46d487b8b9776aadc882bc1
#: ../../java/stream/stream-flows-and-basics.rst:244
msgid ""
"In order to balance the effects of the second and third bullet points you "
"will have to insert asynchronous boundaries manually into your flows and "
"graphs by way of adding ``Attributes.asyncBoundary`` using the method "
"``async`` on ``Source``, ``Sink`` and ``Flow`` to pieces that shall "
"communicate with the rest of the graph in an asynchronous fashion."
msgstr ""

# 494ed8fc8694494e882a33de8dcf1f0e
#: ../../java/stream/stream-flows-and-basics.rst:251
msgid ""
"In this example we create two regions within the flow which will be executed"
" in one Actor each—assuming that adding and multiplying integers is an "
"extremely costly operation this will lead to a performance gain since two "
"CPUs can work on the tasks in parallel. It is important to note that "
"asynchronous boundaries are not singular places within a flow where elements"
" are passed asynchronously (as in other streaming libraries), but instead "
"attributes always work by adding information to the flow graph that has been"
" constructed up to this point:"
msgstr ""

# 2c1319676a274be1af35de9612b4975e
#: ../../java/stream/stream-flows-and-basics.rst:265
msgid ""
"This means that everything that is inside the red bubble will be executed by"
" one actor and everything outside of it by another. This scheme can be "
"applied successively, always having one such boundary enclose the previous "
"ones plus all processing stages that have been added since them."
msgstr ""

# 8d50d0a70e9249a3bc815aa2d9c6968e
#: ../../java/stream/stream-flows-and-basics.rst:271
msgid ""
"Without fusing (i.e. up to version 2.0-M2) each stream processing stage had "
"an implicit input buffer that holds a few elements for efficiency reasons. "
"If your flow graphs contain cycles then these buffers may have been crucial "
"in order to avoid deadlocks. With fusing these implicit buffers are no "
"longer there, data elements are passed without buffering between fused "
"stages. In those cases where buffering is needed in order to allow the "
"stream to run at all, you will have to insert explicit buffers with the "
"``.buffer()`` combinator—typically a buffer of size 2 is enough to allow a "
"feedback loop to function."
msgstr ""

# 10a927684992408d9ff7a49a9027095c
#: ../../java/stream/stream-flows-and-basics.rst:278
msgid ""
"The new fusing behavior can be disabled by setting the configuration "
"parameter ``akka.stream.materializer.auto-fusing=off``. In that case you can"
" still manually fuse those graphs which shall run on less Actors. With the "
"exception of the :class:`SslTlsStage` and the ``groupBy`` operator all "
"built-in processing stages can be fused."
msgstr ""

# e5f0059609e643ee973f5d55cbd6f58f
#: ../../java/stream/stream-flows-and-basics.rst:283
msgid "Combining materialized values"
msgstr ""

# d335b0779ab34910bf0929b076f3843e
#: ../../java/stream/stream-flows-and-basics.rst:285
msgid ""
"Since every processing stage in Akka Streams can provide a materialized "
"value after being materialized, it is necessary to somehow express how these"
" values should be composed to a final value when we plug these stages "
"together. For this, many combinator methods have variants that take an "
"additional argument, a function, that will be used to combine the resulting "
"values. Some examples of using these combiners are illustrated in the "
"example below."
msgstr ""

# b25a77ee2dbe48feafbaca0e71a3f8a4
#: ../../java/stream/stream-flows-and-basics.rst:294
msgid ""
"In Graphs it is possible to access the materialized value from inside the "
"stream processing graph. For details see :ref:`graph-matvalue-java`."
msgstr ""

# e47426b7d979409193123bf7dcfcdf63
#: ../../java/stream/stream-flows-and-basics.rst:297
msgid "Stream ordering"
msgstr ""

# 889e56364d5d4e7199f595c7b0335b96
#: ../../java/stream/stream-flows-and-basics.rst:298
msgid ""
"In Akka Streams almost all computation stages *preserve input order* of "
"elements. This means that if inputs ``{IA1,IA2,...,IAn}`` \"cause\" outputs "
"``{OA1,OA2,...,OAk}`` and inputs ``{IB1,IB2,...,IBm}`` \"cause\" outputs "
"``{OB1,OB2,...,OBl}`` and all of ``IAi`` happened before all ``IBi`` then "
"``OAi`` happens before ``OBi``."
msgstr ""

# f1390a3087a04d88ae1062679ee12b96
#: ../../java/stream/stream-flows-and-basics.rst:302
msgid ""
"This property is even uphold by async operations such as ``mapAsync``, "
"however an unordered version exists called ``mapAsyncUnordered`` which does "
"not preserve this ordering."
msgstr ""

# 4f42ff236016467e936faef03e2656c7
#: ../../java/stream/stream-flows-and-basics.rst:305
msgid ""
"However, in the case of Junctions which handle multiple input streams (e.g. "
":class:`Merge`) the output order is, in general, *not defined* for elements "
"arriving on different input ports. That is a merge-like operation may emit "
"``Ai`` before emitting ``Bi``, and it is up to its internal logic to decide "
"the order of emitted elements. Specialized elements such as ``Zip`` however "
"*do guarantee* their outputs order, as each output element depends on all "
"upstream elements having been signalled already – thus the ordering in the "
"case of zipping is defined by this property."
msgstr ""

# 6c47598dd17e4f17aed37ffb0b8304e0
#: ../../java/stream/stream-flows-and-basics.rst:311
msgid ""
"If you find yourself in need of fine grained control over order of emitted "
"elements in fan-in scenarios consider using :class:`MergePreferred` or "
":class:`GraphStage` – which gives you full control over how the merge is "
"performed."
msgstr ""

# d62a9fb1f6764abfa9953f476de1d62c
#: ../../java/stream/stream-graphs.rst:7
msgid ""
"In Akka Streams computation graphs are not expressed using a fluent DSL like"
" linear computations are, instead they are written in a more graph-"
"resembling DSL which aims to make translating graph drawings (e.g. from "
"notes taken from design discussions, or illustrations in protocol "
"specifications) to and from code simpler. In this section we'll dive into "
"the multiple ways of constructing and re-using graphs, as well as explain "
"common pitfalls and how to avoid them."
msgstr ""

# b3ee849dc07b444295110d5bfb86daf1
#: ../../java/stream/stream-graphs.rst:12
msgid ""
"Graphs are needed whenever you want to perform any kind of fan-in "
"(\"multiple inputs\") or fan-out (\"multiple outputs\") operations. "
"Considering linear Flows to be like roads, we can picture graph operations "
"as junctions: multiple flows being connected at a single point. Some graph "
"operations which are common enough and fit the linear style of Flows, such "
"as ``concat`` (which concatenates two streams, such that the second one is "
"consumed after the first one has completed), may have shorthand methods "
"defined on :class:`Flow` or :class:`Source` themselves, however you should "
"keep in mind that those are also implemented as graph junctions."
msgstr ""

# 5df399fee73d4620ae0010cb69f9df33
#: ../../java/stream/stream-graphs.rst:21
msgid "Constructing Graphs"
msgstr ""

# 897c5965493f42e49cc2176c0df943e0
#: ../../java/stream/stream-graphs.rst:23
msgid ""
"Graphs are built from simple Flows which serve as the linear connections "
"within the graphs as well as junctions which serve as fan-in and fan-out "
"points for Flows. Thanks to the junctions having meaningful types based on "
"their behaviour and making them explicit elements these elements should be "
"rather straightforward to use."
msgstr ""

# a8a537fe603d4aa89c857748e776517d
#: ../../java/stream/stream-graphs.rst:27
msgid ""
"Akka Streams currently provide these junctions (for a detailed list see :ref"
":`stages-overview_java`):"
msgstr ""

# 5a26bb5ca9eb44048866bdee9daf3b0a
#: ../../java/stream/stream-graphs.rst:29
msgid "**Fan-out**"
msgstr ""

# 1aa0af0dd49f4f9f971280f9d5371b67
#: ../../java/stream/stream-graphs.rst:31
msgid ""
"``Broadcast<T>`` – *(1 input, N outputs)* given an input element emits to "
"each output"
msgstr ""

# 239cb25164b1477e9ee61e11112df8c6
#: ../../java/stream/stream-graphs.rst:32
msgid ""
"``Balance<T>`` – *(1 input, N outputs)* given an input element emits to one "
"of its output ports"
msgstr ""

# 2253bf0b7db04bfd95e4f9d7f5da8547
#: ../../java/stream/stream-graphs.rst:33
msgid ""
"``UnzipWith<In,A,B,...>`` – *(1 input, N outputs)* takes a function of 1 "
"input that given a value for each input emits N output elements (where N <= "
"20)"
msgstr ""

# 330d0776f0704aa4891ede6341fbfb49
#: ../../java/stream/stream-graphs.rst:34
msgid ""
"``UnZip<A,B>`` – *(1 input, 2 outputs)* splits a stream of ``Pair<A,B>`` "
"tuples into two streams, one of type ``A`` and one of type ``B``"
msgstr ""

# cf9489d074b44ab891e13fd8f8fdec4e
#: ../../java/stream/stream-graphs.rst:36
msgid "**Fan-in**"
msgstr ""

# 6ab59869d1a545baa438080243bbe36c
#: ../../java/stream/stream-graphs.rst:38
msgid ""
"``Merge<In>`` – *(N inputs , 1 output)* picks randomly from inputs pushing "
"them one by one to its output"
msgstr ""

# e752930d5b71491cb9b37eae99be3bce
#: ../../java/stream/stream-graphs.rst:39
msgid ""
"``MergePreferred<In>`` – like :class:`Merge` but if elements are available "
"on ``preferred`` port, it picks from it, otherwise randomly from ``others``"
msgstr ""

# f48ee223c71140a393ee19fd1d1cd750
#: ../../java/stream/stream-graphs.rst:40
msgid ""
"``ZipWith<A,B,...,Out>`` – *(N inputs, 1 output)* which takes a function of "
"N inputs that given a value for each input emits 1 output element"
msgstr ""

# a2ffbf86b2eb41edae891e4ee8d21338
#: ../../java/stream/stream-graphs.rst:41
msgid ""
"``Zip<A,B>`` – *(2 inputs, 1 output)* is a :class:`ZipWith` specialised to "
"zipping input streams of ``A`` and ``B`` into a ``Pair(A,B)`` tuple stream"
msgstr ""

# 9c393a3653d74bd8b5dfc0d692b7e814
#: ../../java/stream/stream-graphs.rst:42
msgid ""
"``Concat<A>`` – *(2 inputs, 1 output)* concatenates two streams (first "
"consume one, then the second one)"
msgstr ""

# dc1976bcfdea42e8b6233ce7ec926ef0
#: ../../java/stream/stream-graphs.rst:44
msgid ""
"One of the goals of the GraphDSL DSL is to look similar to how one would "
"draw a graph on a whiteboard, so that it is simple to translate a design "
"from whiteboard to code and be able to relate those two. Let's illustrate "
"this by translating the below hand drawn graph into Akka Streams:"
msgstr ""

# b50f17893a3f4a218c2fe58575c9b838
#: ../../java/stream/stream-graphs.rst:50
msgid ""
"Such graph is simple to translate to the Graph DSL since each linear element"
" corresponds to a :class:`Flow`, and each circle corresponds to either a "
":class:`Junction` or a :class:`Source` or :class:`Sink` if it is beginning "
"or ending a :class:`Flow`."
msgstr ""

# 3fc5cebe7f794bf9b3987692ed976b8a
#: ../../java/stream/stream-graphs.rst:57
msgid ""
"Junction *reference equality* defines *graph node equality* (i.e. the same "
"merge *instance* used in a GraphDSL refers to the same location in the "
"resulting graph)."
msgstr ""

# d1a4d6fe58f840d686a67fa4bf5c1f6a
#: ../../java/stream/stream-graphs.rst:60
msgid ""
"By looking at the snippets above, it should be apparent that the ``builder``"
" object is *mutable*. The reason for this design choice is to enable simpler"
" creation of complex graphs, which may even contain cycles. Once the "
"GraphDSL has been constructed though, the :class:`RunnableGraph` instance "
"*is immutable, thread-safe, and freely shareable*. The same is true of all "
"graph pieces—sources, sinks, and flows—once they are constructed. This means"
" that you can safely re-use one given Flow or junction in multiple places in"
" a processing graph."
msgstr ""

# 3e3d6a8c252c4361998ebd716b19ea1c
#: ../../java/stream/stream-graphs.rst:66
msgid ""
"We have seen examples of such re-use already above: the merge and broadcast "
"junctions were imported into the graph using ``builder.add(...)``, an "
"operation that will make a copy of the blueprint that is passed to it and "
"return the inlets and outlets of the resulting copy so that they can be "
"wired up. Another alternative is to pass existing graphs—of any shape—into "
"the factory method that produces a new graph. The difference between these "
"approaches is that importing using ``builder.add(...)`` ignores the "
"materialized value of the imported graph while importing via the factory "
"method allows its inclusion; for more details see :ref:`stream-"
"materialization-scala`."
msgstr ""

# 31b05c6dbed847ffa8f7db4ab5332674
#: ../../java/stream/stream-graphs.rst:74
msgid ""
"In the example below we prepare a graph that consists of two parallel "
"streams, in which we re-use the same instance of :class:`Flow`, yet it will "
"properly be materialized as two connections between the corresponding "
"Sources and Sinks:"
msgstr ""

# acd1afb199304d6f801c8f58f3f17f62
#: ../../java/stream/stream-graphs.rst:83
msgid "Constructing and combining Partial Graphs"
msgstr ""

# 60111ea4e39b4bd18b24407a6b322383
#: ../../java/stream/stream-graphs.rst:85
msgid ""
"Sometimes it is not possible (or needed) to construct the entire computation"
" graph in one place, but instead construct all of its different phases in "
"different places and in the end connect them all into a complete graph and "
"run it."
msgstr ""

# 4a143979cbc343278d00a6bc60538037
#: ../../java/stream/stream-graphs.rst:88
msgid ""
"This can be achieved by using the returned :class:`Graph` from "
"``GraphDSL.create()`` rather than passing it to "
"``RunnableGraph.fromGraph()`` to wrap it in a :class:`RunnableGraph`.The "
"reason of representing it as a different type is that a "
":class:`RunnableGraph` requires all ports to be connected, and if they are "
"not it will throw an exception at construction time, which helps to avoid "
"simple wiring errors while working with graphs. A partial graph however "
"allows you to return the set of yet to be connected ports from the code "
"block that performs the internal wiring."
msgstr ""

# 9a1fdaa7ba7144b9b6bae7a46ee85012
#: ../../java/stream/stream-graphs.rst:96
msgid ""
"Let's imagine we want to provide users with a specialized element that given"
" 3 inputs will pick the greatest int value of each zipped triple. We'll want"
" to expose 3 input ports (unconnected sources) and one output port "
"(unconnected sink)."
msgstr ""

# 9f0ecb866fbb4ed087efe8705419c9cf
#: ../../java/stream/stream-graphs.rst:102
msgid ""
"As you can see, first we construct the partial graph that describes how to "
"compute the maximum of two input streams, then we reuse that twice while "
"constructing the partial graph that extends this to three input streams, "
"then we import it (all of its nodes and connections) explicitly into the "
"last graph in which all the undefined elements are rewired to real sources "
"and sinks. The graph can then be run and yields the expected result."
msgstr ""

# 4cc46c01ed444f6d8198a72c8d577d99
#: ../../java/stream/stream-graphs.rst:108
msgid ""
"Please note that :class:`GraphDSL` is not able to provide compile time type-"
"safety about whether or not all elements have been properly connected—this "
"validation is performed as a runtime check during the graph's instantiation."
msgstr ""

# a5d303f9eecf45e5847b7014268f0a4c
#: ../../java/stream/stream-graphs.rst:111
msgid ""
"A partial graph also verifies that all ports are either connected or part of"
" the returned :class:`Shape`."
msgstr ""

# 3c2dc6a888f349b08547cd6aa8f9e9a2
#: ../../java/stream/stream-graphs.rst:116
msgid "Constructing Sources, Sinks and Flows from Partial Graphs"
msgstr ""

# 2d5486d9fbf94c7893c2a5a846b19703
#: ../../java/stream/stream-graphs.rst:118
msgid ""
"Instead of treating a ``Graph`` as simply a collection of flows and "
"junctions which may not yet all be connected it is sometimes useful to "
"expose such a complex graph as a simpler structure, such as a "
":class:`Source`, :class:`Sink` or :class:`Flow`."
msgstr ""

# 1bc3531bac5a4311975cab063de78d79
#: ../../java/stream/stream-graphs.rst:122
msgid ""
"In fact, these concepts can be easily expressed as special cases of a "
"partially connected graph:"
msgstr ""

# 0e1f6fd59f0f4b4da81a5420160ed1bb
#: ../../java/stream/stream-graphs.rst:124
msgid ""
":class:`Source` is a partial graph with *exactly one* output, that is it "
"returns a :class:`SourceShape`."
msgstr ""

# 8e94a833bbce43a4bf35d146bc9628fc
#: ../../java/stream/stream-graphs.rst:125
msgid ""
":class:`Sink` is a partial graph with *exactly one* input, that is it "
"returns a :class:`SinkShape`."
msgstr ""

# 17fdcb029e8e4fc0b2ae0bece62cf136
#: ../../java/stream/stream-graphs.rst:126
msgid ""
":class:`Flow` is a partial graph with *exactly one* input and *exactly one* "
"output, that is it returns a :class:`FlowShape`."
msgstr ""

# 46bcd56696a54b5b8c21edf7c8909210
#: ../../java/stream/stream-graphs.rst:128
msgid ""
"Being able to hide complex graphs inside of simple elements such as Sink / "
"Source / Flow enables you to easily create one complex element and from "
"there on treat it as simple compound stage for linear computations."
msgstr ""

# ccd238fed9804f019b5ff36336e3198f
#: ../../java/stream/stream-graphs.rst:131
msgid ""
"In order to create a Source from a graph the method ``Source.fromGraph`` is "
"used, to use it we must have a ``Graph`` with a ``SourceShape``. This is "
"constructed using ``GraphDSL.create`` and providing building a "
"``SourceShape`` graph. The single outlet must be provided to the "
"``SourceShape.of`` method and will become “the sink that must be attached "
"before this Source can run”."
msgstr ""

# 84590b2bb93642cdbd66143f6906fbba
#: ../../java/stream/stream-graphs.rst:136
msgid ""
"Refer to the example below, in which we create a Source that zips together "
"two numbers, to see this graph construction in action:"
msgstr ""

# d9dc9559ee3a4a6fb5964797a6d65228
#: ../../java/stream/stream-graphs.rst:141
msgid ""
"Similarly the same can be done for a ``Sink<T>`` using ``SinkShape.of`` in "
"which case the provided value must be an ``Inlet<T>``. For defining a "
"``Flow<T>`` we need to expose both an undefined source and sink:"
msgstr ""

# b82d6669f0ee44a29fb617ab946db91f
#: ../../java/stream/stream-graphs.rst:147
msgid "Combining Sources and Sinks with simplified API"
msgstr ""

# 1ccd0f597e50487aad76cce5832a164d
#: ../../java/stream/stream-graphs.rst:149
msgid ""
"There is simplified API you can use to combine sources and sinks with "
"junctions like: ``Broadcast<T>``, ``Balance<T>``, ``Merge<In>`` and "
"``Concat<A>`` without the need for using the Graph DSL. The combine method "
"takes care of constructing the necessary graph underneath. In following "
"example we combine two sources into one (fan-in):"
msgstr ""

# 017333af7471490f8ab126321180d029
#: ../../java/stream/stream-graphs.rst:155
msgid ""
"The same can be done for a ``Sink`` but in this case it will be fan-out:"
msgstr ""

# 0bae8b2eedc04074845571879328afd7
#: ../../java/stream/stream-graphs.rst:162
msgid "Bidirectional Flows"
msgstr ""

# 2bb1375ae67e4a46bc70968a092d1466
#: ../../java/stream/stream-graphs.rst:164
msgid ""
"A graph topology that is often useful is that of two flows going in opposite"
" directions. Take for example a codec stage that serializes outgoing "
"messages and deserializes incoming octet streams. Another such stage could "
"add a framing protocol that attaches a length header to outgoing data and "
"parses incoming frames back into the original octet stream chunks. These two"
" stages are meant to be composed, applying one atop the other as part of a "
"protocol stack. For this purpose exists the special type :class:`BidiFlow` "
"which is a graph that has exactly two open inlets and two open outlets. The "
"corresponding shape is called :class:`BidiShape` and is defined like this:"
msgstr ""

# c916d358cfcd4c62b13b095a9202569a
#: ../../java/stream/stream-graphs.rst:178
msgid ""
"A bidirectional flow is defined just like a unidirectional :class:`Flow` as "
"demonstrated for the codec mentioned above:"
msgstr ""

# 5aa10e776e1b43a3b3ad2788e4bbd7f5
#: ../../java/stream/stream-graphs.rst:185
msgid ""
"The first version resembles the partial graph constructor, while for the "
"simple case of a functional 1:1 transformation there is a concise "
"convenience method as shown on the last line. The implementation of the two "
"functions is not difficult either:"
msgstr ""

# 92b7352068e647e1bcf32f4063be98a2
#: ../../java/stream/stream-graphs.rst:192
msgid ""
"In this way you could easily integrate any other serialization library that "
"turns an object into a sequence of bytes."
msgstr ""

# c07b14140d08438d999365e66353aadb
#: ../../java/stream/stream-graphs.rst:195
msgid ""
"The other stage that we talked about is a little more involved since "
"reversing a framing protocol means that any received chunk of bytes may "
"correspond to zero or more messages. This is best implemented using a "
":class:`GraphStage` (see also :ref:`graphstage-java`)."
msgstr ""

# 531e4c681cb84503ba1ef4f338805a08
#: ../../java/stream/stream-graphs.rst:202
msgid "With these implementations we can build a protocol stack and test it:"
msgstr ""

# acc22d88932b48e98ac5560f6a05665a
#: ../../java/stream/stream-graphs.rst:206
msgid ""
"This example demonstrates how :class:`BidiFlow` subgraphs can be hooked "
"together and also turned around with the ``.reversed()`` method. The test "
"simulates both parties of a network communication protocol without actually "
"having to open a network connection—the flows can just be connected "
"directly."
msgstr ""

# 06b11e6921634659ae4b2f7e529d1714
#: ../../java/stream/stream-graphs.rst:214
msgid "Accessing the materialized value inside the Graph"
msgstr ""

# 2f428199a4ec4f13953aa01e74d32116
#: ../../java/stream/stream-graphs.rst:216
msgid ""
"In certain cases it might be necessary to feed back the materialized value "
"of a Graph (partial, closed or backing a Source, Sink, Flow or BidiFlow). "
"This is possible by using ``builder.materializedValue`` which gives an "
"``Outlet`` that can be used in the graph as an ordinary source or outlet, "
"and which will eventually emit the materialized value. If the materialized "
"value is needed at more than one place, it is possible to call "
"``materializedValue`` any number of times to acquire the necessary number of"
" outlets."
msgstr ""

# 2b5a07a57f9744458ea77a0907ae930b
#: ../../java/stream/stream-graphs.rst:224
msgid ""
"Be careful not to introduce a cycle where the materialized value actually "
"contributes to the materialized value. The following example demonstrates a "
"case where the materialized ``CompletionStage`` of a fold is fed back to the"
" fold itself."
msgstr ""

# 50bf589db195413d98c8c60e762d6b0b
#: ../../java/stream/stream-graphs.rst:232
msgid "Graph cycles, liveness and deadlocks"
msgstr ""

# 4ab14fc2c39348418dd4b15c176500b0
#: ../../java/stream/stream-graphs.rst:234
msgid ""
"Cycles in bounded stream topologies need special considerations to avoid "
"potential deadlocks and other liveness issues. This section shows several "
"examples of problems that can arise from the presence of feedback arcs in "
"stream processing graphs."
msgstr ""

# 1a05f754f6664f4e892b2663d03b4cec
#: ../../java/stream/stream-graphs.rst:238
msgid ""
"In the following examples runnable graphs are created but do not run because"
" each have some issue and will deadlock after start. ``Source`` variable is "
"not defined as the nature and number of element does not matter for "
"described problems."
msgstr ""

# 0d49171d2f3048d19074b2de93d0ff64
#: ../../java/stream/stream-graphs.rst:241
msgid ""
"The first example demonstrates a graph that contains a naive cycle. The "
"graph takes elements from the source, prints them, then broadcasts those "
"elements to a consumer (we just used ``Sink.ignore`` for now) and to a "
"feedback arc that is merged back into the main via a ``Merge`` junction."
msgstr ""

# e330c0b6a91a4d8abceb55cd742af6eb
#: ../../java/stream/stream-graphs.rst:248
msgid ""
"Running this we observe that after a few numbers have been printed, no more "
"elements are logged to the console - all processing stops after some time. "
"After some investigation we observe that:"
msgstr ""

# 1291eed632c04acb9ad65f26ff1d1582
#: ../../java/stream/stream-graphs.rst:251
msgid ""
"through merging from ``source`` we increase the number of elements flowing "
"in the cycle"
msgstr ""

# 6149dc2b17864056bfb7e84aedda4660
#: ../../java/stream/stream-graphs.rst:252
msgid ""
"by broadcasting back to the cycle we do not decrease the number of elements "
"in the cycle"
msgstr ""

# 19bcca3e5bb64bc4997c11680a5de330
#: ../../java/stream/stream-graphs.rst:254
msgid ""
"Since Akka Streams (and Reactive Streams in general) guarantee bounded "
"processing (see the \"Buffering\" section for more details) it means that "
"only a bounded number of elements are buffered over any time span. Since our"
" cycle gains more and more elements, eventually all of its internal buffers "
"become full, backpressuring ``source`` forever. To be able to process more "
"elements from ``source`` elements would need to leave the cycle somehow."
msgstr ""

# 8c44f7311844491e9137f39fdc3ac8af
#: ../../java/stream/stream-graphs.rst:259
msgid ""
"If we modify our feedback loop by replacing the ``Merge`` junction with a "
"``MergePreferred`` we can avoid the deadlock. ``MergePreferred`` is unfair "
"as it always tries to consume from a preferred input port if there are "
"elements available before trying the other lower priority input ports. Since"
" we feed back through the preferred port it is always guaranteed that the "
"elements in the cycles can flow."
msgstr ""

# 8569e2543b244890aa432ffbcdf38dec
#: ../../java/stream/stream-graphs.rst:266
msgid ""
"If we run the example we see that the same sequence of numbers are printed "
"over and over again, but the processing does not stop. Hence, we avoided the"
" deadlock, but ``source`` is still back-pressured forever, because buffer "
"space is never recovered: the only action we see is the circulation of a "
"couple of initial elements from ``source``."
msgstr ""

# bbe37b4132fa41a8b4da96e4e86fd637
#: ../../java/stream/stream-graphs.rst:272
msgid ""
"What we see here is that in certain cases we need to choose between "
"boundedness and liveness. Our first example would not deadlock if there "
"would be an infinite buffer in the loop, or vice versa, if the elements in "
"the cycle would be balanced (as many elements are removed as many are "
"injected) then there would be no deadlock."
msgstr ""

# f4cd237c082541f284a05f8448ef72bb
#: ../../java/stream/stream-graphs.rst:276
msgid ""
"To make our cycle both live (not deadlocking) and fair we can introduce a "
"dropping element on the feedback arc. In this case we chose the ``buffer()``"
" operation giving it a dropping strategy ``OverflowStrategy.dropHead``."
msgstr ""

# a097bdbc0fc94a6b95ed2f55b9c6d3b8
#: ../../java/stream/stream-graphs.rst:281
msgid "If we run this example we see that"
msgstr ""

# 0e0f46fc29714a95893038f38f04edf3
#: ../../java/stream/stream-graphs.rst:283
msgid "The flow of elements does not stop, there are always elements printed"
msgstr ""

# 34b2d6629566439bae163f00dfe42407
#: ../../java/stream/stream-graphs.rst:284
msgid ""
"We see that some of the numbers are printed several times over time (due to "
"the feedback loop) but on average the numbers are increasing in the long "
"term"
msgstr ""

# d5c24bfa48254244b941dad333c03346
#: ../../java/stream/stream-graphs.rst:287
msgid ""
"This example highlights that one solution to avoid deadlocks in the presence"
" of potentially unbalanced cycles (cycles where the number of circulating "
"elements are unbounded) is to drop elements. An alternative would be to "
"define a larger buffer with ``OverflowStrategy.fail`` which would fail the "
"stream instead of deadlocking it after all buffer space has been consumed."
msgstr ""

# a07ec82359e442f69a6a6c276926db9a
#: ../../java/stream/stream-graphs.rst:292
msgid ""
"As we discovered in the previous examples, the core problem was the "
"unbalanced nature of the feedback loop. We circumvented this issue by adding"
" a dropping element, but now we want to build a cycle that is balanced from "
"the beginning instead. To achieve this we modify our first graph by "
"replacing the ``Merge`` junction with a ``ZipWith``. Since ``ZipWith`` takes"
" one element from ``source`` *and* from the feedback arc to inject one "
"element into the cycle, we maintain the balance of elements."
msgstr ""

# d8b9e158720446828c036c1637a33c54
#: ../../java/stream/stream-graphs.rst:300
msgid ""
"Still, when we try to run the example it turns out that no element is "
"printed at all! After some investigation we realize that:"
msgstr ""

# 905b0104b60646b79aa0aea6e0ebe310
#: ../../java/stream/stream-graphs.rst:303
msgid ""
"In order to get the first element from ``source`` into the cycle we need an "
"already existing element in the cycle"
msgstr ""

# ac5e7e9b4fad4acdbc8ad4c02c50c184
#: ../../java/stream/stream-graphs.rst:304
msgid ""
"In order to get an initial element in the cycle we need an element from "
"``source``"
msgstr ""

# 4ce725fbbac7487d95bf1c242d4bec2b
#: ../../java/stream/stream-graphs.rst:306
msgid ""
"These two conditions are a typical \"chicken-and-egg\" problem. The solution"
" is to inject an initial element into the cycle that is independent from "
"``source``. We do this by using a ``Concat`` junction on the backwards arc "
"that injects a single element using ``Source.single``."
msgstr ""

# a70cfdc37ed84dedb62170e636bedaa3
#: ../../java/stream/stream-graphs.rst:312
msgid ""
"When we run the above example we see that processing starts and never stops."
" The important takeaway from this example is that balanced cycles often need"
" an initial \"kick-off\" element to be injected into the cycle."
msgstr ""

# e1920f9e9e62438a963b168f17885da0
#: ../../java/stream/stream-integrations.rst:5
msgid "Integration"
msgstr ""

# 426d32ce1764420d8a6f712c528eec0e
#: ../../java/stream/stream-integrations.rst:8
msgid "Integrating with Actors"
msgstr ""

# b3d0143959e14ea58abf3a3b3550019b
#: ../../java/stream/stream-integrations.rst:10
msgid ""
"For piping the elements of a stream as messages to an ordinary actor you can"
" use the ``Sink.actorRef``. Messages can be sent to a stream via the "
":class:`ActorRef` that is materialized by ``Source.actorRef``."
msgstr ""

# d7f3eee04d904a42a588f53262801bb9
#: ../../java/stream/stream-integrations.rst:14
msgid ""
"For more advanced use cases the :class:`ActorPublisher` and "
":class:`ActorSubscriber` traits are provided to support implementing "
"Reactive Streams :class:`Publisher` and :class:`Subscriber` with an "
":class:`Actor`."
msgstr ""

# c549c86636ea453c9bd4f12c8c1c3fcb
#: ../../java/stream/stream-integrations.rst:18
msgid ""
"These can be consumed by other Reactive Stream libraries or used as an Akka "
"Streams :class:`Source` or :class:`Sink`."
msgstr ""

# eff6af8d84c34b83a44daed624c5b0ab
#: ../../java/stream/stream-integrations.rst:23
msgid ""
":class:`AbstractActorPublisher` and :class:`AbstractActorSubscriber` cannot "
"be used with remote actors, because if signals of the Reactive Streams "
"protocol (e.g. ``request``) are lost the the stream may deadlock."
msgstr ""

# 0591cf56c37948a0b7be23a58df6a1e4
#: ../../java/stream/stream-integrations.rst:28
msgid ""
"These Actors are designed to be implemented using Java 8 lambda expressions."
" In case you need to stay on a JVM prior to 8, Akka provides "
":class:`UntypedActorPublisher` and :class:`UntypedActorSubscriber` which can"
" be used easily from any language level."
msgstr ""

# 0bd18fcb09b545ecb0c830f9f3b4c960
#: ../../java/stream/stream-integrations.rst:33
msgid "Source.actorRef"
msgstr ""

# cd61dcc2aa714a6fa8ec8f78ea627539
#: ../../java/stream/stream-integrations.rst:35
msgid ""
"Messages sent to the actor that is materialized by ``Source.actorRef`` will "
"be emitted to the stream if there is demand from downstream, otherwise they "
"will be buffered until request for demand is received."
msgstr ""

# 9a53cb313d6d4e4cac9af48e366cd38c
#: ../../java/stream/stream-integrations.rst:39
msgid ""
"Depending on the defined :class:`OverflowStrategy` it might drop elements if"
" there is no space available in the buffer. The strategy "
"``OverflowStrategy.backpressure()`` is not supported for this Source type, "
"you should consider using ``ActorPublisher`` if you want a backpressured "
"actor interface."
msgstr ""

# 8baa54b57b654ea18b160eb7a2d7876f
#: ../../java/stream/stream-integrations.rst:44
msgid ""
"The stream can be completed successfully by sending "
"``akka.actor.PoisonPill`` or ``akka.actor.Status.Success`` to the actor "
"reference."
msgstr ""

# 9de3f8aa723245bb94b36890eec338ec
#: ../../java/stream/stream-integrations.rst:47
msgid ""
"The stream can be completed with failure by sending "
"``akka.actor.Status.Failure`` to the actor reference."
msgstr ""

# 417769fba1fa4497b8e5ab4d791d33a6
#: ../../java/stream/stream-integrations.rst:50
msgid ""
"The actor will be stopped when the stream is completed, failed or cancelled "
"from downstream, i.e. you can watch it to get notified when that happens."
msgstr ""

# a04b9dc69535453183cc04eb6e4859c6
#: ../../java/stream/stream-integrations.rst:54
msgid "Sink.actorRef"
msgstr ""

# 08d4127986da4094a6e8b9d3e4f25801
#: ../../java/stream/stream-integrations.rst:56
msgid ""
"The sink sends the elements of the stream to the given `ActorRef`. If the "
"target actor terminates the stream will be cancelled. When the stream is "
"completed successfully the given ``onCompleteMessage`` will be sent to the "
"destination actor. When the stream is completed with failure a "
"``akka.actor.Status.Failure`` message will be sent to the destination actor."
msgstr ""

# 0f049870c58045ef9f3c548230411863
#: ../../java/stream/stream-integrations.rst:63
msgid ""
"There is no back-pressure signal from the destination actor, i.e. if the "
"actor is not consuming the messages fast enough the mailbox of the actor "
"will grow. For potentially slow consumer actors it is recommended to use a "
"bounded mailbox with zero `mailbox-push-timeout-time` or use a rate limiting"
" stage in front of this stage."
msgstr ""

# f1d65f7a4c4840dd91c3bb3058c21261
#: ../../java/stream/stream-integrations.rst:69
msgid "ActorPublisher"
msgstr ""

# 88082428a72e4523bebc221f6ec53310
#: ../../java/stream/stream-integrations.rst:71
msgid ""
"Extend :class:`akka.stream.actor.AbstractActorPublisher` to implement a "
"stream publisher that keeps track of the subscription life cycle and "
"requested elements."
msgstr ""

# 7bcac94d518c4d1299b084de29cdffdd
#: ../../java/stream/stream-integrations.rst:74
msgid ""
"Here is an example of such an actor. It dispatches incoming jobs to the "
"attached subscriber:"
msgstr ""

# ec11b04d55634cf8abbe82d377b20d61
#: ../../java/stream/stream-integrations.rst:78
msgid ""
"You send elements to the stream by calling ``onNext``. You are allowed to "
"send as many elements as have been requested by the stream subscriber. This "
"amount can be inquired with ``totalDemand``. It is only allowed to use "
"``onNext`` when ``isActive`` and ``totalDemand>0``, otherwise ``onNext`` "
"will throw ``IllegalStateException``."
msgstr ""

# 1fa8219989ca40fd9431f8f7e7b99fab
#: ../../java/stream/stream-integrations.rst:83
msgid ""
"When the stream subscriber requests more elements the "
"``ActorPublisherMessage.Request`` message is delivered to this actor, and "
"you can act on that event. The ``totalDemand`` is updated automatically."
msgstr ""

# e370acc25e83495e9909ab6fc9119cef
#: ../../java/stream/stream-integrations.rst:87
msgid ""
"When the stream subscriber cancels the subscription the "
"``ActorPublisherMessage.Cancel`` message is delivered to this actor. After "
"that subsequent calls to ``onNext`` will be ignored."
msgstr ""

# 1d54f3fa32154a60aa782082e5a0f7a1
#: ../../java/stream/stream-integrations.rst:90
msgid ""
"You can complete the stream by calling ``onComplete``. After that you are "
"not allowed to call ``onNext``, ``onError`` and ``onComplete``."
msgstr ""

# 8876397052594985b20a148ea656a791
#: ../../java/stream/stream-integrations.rst:93
msgid ""
"You can terminate the stream with failure by calling ``onError``. After that"
" you are not allowed to call ``onNext``, ``onError`` and ``onComplete``."
msgstr ""

# efba9018725a463d9e6a77c011f07cc2
#: ../../java/stream/stream-integrations.rst:96
msgid ""
"If you suspect that this ``AbstractActorPublisher`` may never get subscribed"
" to, you can override the ``subscriptionTimeout`` method to provide a "
"timeout after which this Publisher should be considered canceled. The actor "
"will be notified when the timeout triggers via an "
"``ActorPublisherMessage.SubscriptionTimeoutExceeded`` message and MUST then "
"perform cleanup and stop itself."
msgstr ""

# e3ef7b1fa57d400fa78b8aaba8bf2dc8
#: ../../java/stream/stream-integrations.rst:101
msgid ""
"If the actor is stopped the stream will be completed, unless it was not "
"already terminated with failure, completed or canceled."
msgstr ""

# 63ed6f618a4941bdab3d822fc546cc88
# f30525a7c18d48e5992c438a1b57e4f7
#: ../../java/stream/stream-integrations.rst:104
#: ../../java/stream/stream-integrations.rst:137
msgid "More detailed information can be found in the API documentation."
msgstr ""

# b2cc2f20e61841efa9bf3eafc23fef4a
#: ../../java/stream/stream-integrations.rst:106
msgid ""
"This is how it can be used as input :class:`Source` to a :class:`Flow`:"
msgstr ""

# dcf2ee86023e4e13bd79a916ccfff7da
#: ../../java/stream/stream-integrations.rst:110
msgid ""
"You can only attach one subscriber to this publisher. Use a "
"``Broadcast``-element or attach a "
"``Sink.asPublisher(AsPublisher.WITH_FANOUT)`` to enable multiple "
"subscribers."
msgstr ""

# d38bb976dc944f2f8a1c6adfa1b5089e
#: ../../java/stream/stream-integrations.rst:114
msgid "ActorSubscriber"
msgstr ""

# 670a97f155eb405795ef80250bab3511
#: ../../java/stream/stream-integrations.rst:116
msgid ""
"Extend :class:`akka.stream.actor.AbstractActorSubscriber` to make your class"
" a stream subscriber with full control of stream back pressure. It will "
"receive ``ActorSubscriberMessage.OnNext``, "
"``ActorSubscriberMessage.OnComplete`` and ``ActorSubscriberMessage.OnError``"
" messages from the stream. It can also receive other, non-stream messages, "
"in the same way as any actor."
msgstr ""

# 283319f954d74067a1dda3da353585f6
#: ../../java/stream/stream-integrations.rst:121
msgid ""
"Here is an example of such an actor. It dispatches incoming jobs to child "
"worker actors:"
msgstr ""

# 5b232d5e251a45a6ab09308ae1623e49
#: ../../java/stream/stream-integrations.rst:125
msgid ""
"Subclass must define the ``RequestStrategy`` to control stream back "
"pressure. After each incoming message the ``AbstractActorSubscriber`` will "
"automatically invoke the ``RequestStrategy.requestDemand`` and propagate the"
" returned demand to the stream."
msgstr ""

# 94945967de414849a3a76523c1cff1cb
#: ../../java/stream/stream-integrations.rst:129
msgid ""
"The provided ``WatermarkRequestStrategy`` is a good strategy if the actor "
"performs work itself."
msgstr ""

# 9ceee02727614295a31dd0b8b3de4251
#: ../../java/stream/stream-integrations.rst:130
msgid ""
"The provided ``MaxInFlightRequestStrategy`` is useful if messages are queued"
" internally or delegated to other actors."
msgstr ""

# c65298492360473e9fd48c2a847895d7
#: ../../java/stream/stream-integrations.rst:132
msgid ""
"You can also implement a custom ``RequestStrategy`` or call ``request`` "
"manually together with ``ZeroRequestStrategy`` or some other strategy. In "
"that case you must also call ``request`` when the actor is started or when "
"it is ready, otherwise it will not receive any elements."
msgstr ""

# d8e0233f45c645429886b7b192191ff3
#: ../../java/stream/stream-integrations.rst:139
msgid "This is how it can be used as output :class:`Sink` to a :class:`Flow`:"
msgstr ""

# a8ea12ad1fd543ad80547fd8a1cd7afe
#: ../../java/stream/stream-integrations.rst:144
msgid "Integrating with External Services"
msgstr ""

# 385f62f9f7d8486c98d5d7d015a636ad
#: ../../java/stream/stream-integrations.rst:146
msgid ""
"Stream transformations and side effects involving external non-stream based "
"services can be performed with ``mapAsync`` or ``mapAsyncUnordered``."
msgstr ""

# b8d8eb804f9e47d48e5c3f388e63be13
#: ../../java/stream/stream-integrations.rst:149
msgid ""
"For example, sending emails to the authors of selected tweets using an "
"external email service:"
msgstr ""

# 8721d6596c6f46d4b6e63d7ec4bba2c0
#: ../../java/stream/stream-integrations.rst:162
msgid ""
"Transforming the stream of authors to a stream of email addresses by using "
"the ``lookupEmail`` service can be done with ``mapAsync``:"
msgstr ""

# f1e567621085461e9a2be29e93009d58
#: ../../java/stream/stream-integrations.rst:167
msgid "Finally, sending the emails:"
msgstr ""

# 5a924bd3aedd49a2bf443c0a76e50a06
#: ../../java/stream/stream-integrations.rst:171
msgid ""
"``mapAsync`` is applying the given function that is calling out to the "
"external service to each of the elements as they pass through this "
"processing step. The function returns a :class:`CompletionStage` and the "
"value of that future will be emitted downstreams. The number of Futures that"
" shall run in parallel is given as the first argument to ``mapAsync``. These"
" Futures may complete in any order, but the elements that are emitted "
"downstream are in the same order as received from upstream."
msgstr ""

# 3ad4b90c28634b0caa70a3f5e710c1b6
#: ../../java/stream/stream-integrations.rst:178
msgid ""
"That means that back-pressure works as expected. For example if the "
"``emailServer.send`` is the bottleneck it will limit the rate at which "
"incoming tweets are retrieved and email addresses looked up."
msgstr ""

# 2e0fdb87b76f4eb79f8bf7c5e6081505
#: ../../java/stream/stream-integrations.rst:182
msgid ""
"The final piece of this pipeline is to generate the demand that pulls the "
"tweet authors information through the emailing pipeline: we attach a "
"``Sink.ignore`` which makes it all run. If our email process would return "
"some interesting data for further transformation then we would of course not"
" ignore it but send that result stream onwards for further processing or "
"storage."
msgstr ""

# 282c2a10b3c148b7b492281ae44cf9d9
#: ../../java/stream/stream-integrations.rst:188
msgid ""
"Note that ``mapAsync`` preserves the order of the stream elements. In this "
"example the order is not important and then we can use the more efficient "
"``mapAsyncUnordered``:"
msgstr ""

# e8b77887753a48ad9c9b682764773eda
#: ../../java/stream/stream-integrations.rst:193
msgid ""
"In the above example the services conveniently returned a "
":class:`CompletionStage` of the result. If that is not the case you need to "
"wrap the call in a :class:`CompletionStage`. If the service call involves "
"blocking you must also make sure that you run it on a dedicated execution "
"context, to avoid starvation and disturbance of other tasks in the system."
msgstr ""

# d1f31891678242c7aa93f5da9a65c9ee
#: ../../java/stream/stream-integrations.rst:200
msgid ""
"The configuration of the ``\"blocking-dispatcher\"`` may look something "
"like:"
msgstr ""

# 5a210010b33348f8b9213f864713225c
#: ../../java/stream/stream-integrations.rst:204
msgid ""
"An alternative for blocking calls is to perform them in a ``map`` operation,"
" still using a dedicated dispatcher for that operation."
msgstr ""

# b6c8c2a475ab422985fe295f86fe63a6
#: ../../java/stream/stream-integrations.rst:209
msgid ""
"However, that is not exactly the same as ``mapAsync``, since the "
"``mapAsync`` may run several calls concurrently, but ``map`` performs them "
"one at a time."
msgstr ""

# b027016a13894bcca63d6806628a2d9d
#: ../../java/stream/stream-integrations.rst:212
msgid ""
"For a service that is exposed as an actor, or if an actor is used as a "
"gateway in front of an external service, you can use ``ask``:"
msgstr ""

# 40ff63d9666343bcb7c1ef0a840a53ec
#: ../../java/stream/stream-integrations.rst:217
msgid ""
"Note that if the ``ask`` is not completed within the given timeout the "
"stream is completed with failure. If that is not desired outcome you can use"
" ``recover`` on the ``ask`` :class:`CompletionStage`."
msgstr ""

# 6d02877e7d7a41c6af0e241dcffaba20
#: ../../java/stream/stream-integrations.rst:221
msgid "Illustrating ordering and parallelism"
msgstr ""

# 41178dbe88534e6597dcc348ba3ee052
#: ../../java/stream/stream-integrations.rst:223
msgid ""
"Let us look at another example to get a better understanding of the ordering"
" and parallelism characteristics of ``mapAsync`` and ``mapAsyncUnordered``."
msgstr ""

# 386247c6f483457eaed8c524868c2339
#: ../../java/stream/stream-integrations.rst:226
msgid ""
"Several ``mapAsync`` and ``mapAsyncUnordered`` futures may run concurrently."
" The number of concurrent futures are limited by the downstream demand. For "
"example, if 5 elements have been requested by downstream there will be at "
"most 5 futures in progress."
msgstr ""

# fbf38f745c1342e2bdbdc96a71d400b2
#: ../../java/stream/stream-integrations.rst:231
msgid ""
"``mapAsync`` emits the future results in the same order as the input "
"elements were received. That means that completed results are only emitted "
"downstream when earlier results have been completed and emitted. One slow "
"call will thereby delay the results of all successive calls, even though "
"they are completed before the slow call."
msgstr ""

# 7117620a3da04cef869724aedd18233f
#: ../../java/stream/stream-integrations.rst:237
msgid ""
"``mapAsyncUnordered`` emits the future results as soon as they are "
"completed, i.e. it is possible that the elements are not emitted downstream "
"in the same order as received from upstream. One slow call will thereby not "
"delay the results of faster successive calls as long as there is downstream "
"demand of several elements."
msgstr ""

# bee414340fde4cdf80646557b06a989b
#: ../../java/stream/stream-integrations.rst:242
msgid "Here is a fictive service that we can use to illustrate these aspects."
msgstr ""

# 723cd8693cd74dbdbc1ad1f18c9b7222
#: ../../java/stream/stream-integrations.rst:246
msgid ""
"Elements starting with a lower case character are simulated to take longer "
"time to process."
msgstr ""

# 0d1d66e874ee4eb5bb1c3199cd33b37f
#: ../../java/stream/stream-integrations.rst:249
msgid "Here is how we can use it with ``mapAsync``:"
msgstr ""

# 15a988478d454d32b914a0a2daf947da
# 887abdb13d724454aa2f2ccc2907db36
#: ../../java/stream/stream-integrations.rst:253
#: ../../java/stream/stream-integrations.rst:310
msgid "The output may look like this:"
msgstr ""

# 0f33349843aa457e8d9ad557091cc7c1
#: ../../java/stream/stream-integrations.rst:298
msgid ""
"Note that ``after`` lines are in the same order as the ``before`` lines even"
" though elements are ``completed`` in a different order. For example ``H`` "
"is ``completed`` before ``g``, but still emitted afterwards."
msgstr ""

# c9a58a61b6b84121a459c5afaa940975
# 35f93acd1c50491196998f451beb6ad7
#: ../../java/stream/stream-integrations.rst:302
#: ../../java/stream/stream-integrations.rst:358
msgid ""
"The numbers in parenthesis illustrates how many calls that are in progress "
"at the same time. Here the downstream demand and thereby the number of "
"concurrent calls are limited by the buffer size (4) of the "
":class:`ActorMaterializerSettings`."
msgstr ""

# 4c377b114cad414bbf4663e6df148ff1
#: ../../java/stream/stream-integrations.rst:306
msgid "Here is how we can use the same service with ``mapAsyncUnordered``:"
msgstr ""

# d7c1cec2773b4395835f192dc6980f58
#: ../../java/stream/stream-integrations.rst:355
msgid ""
"Note that ``after`` lines are not in the same order as the ``before`` lines."
" For example ``H`` overtakes the slow ``G``."
msgstr ""

# a2073ee1ffa54e4f98d2541648b43834
#: ../../java/stream/stream-integrations.rst:365
msgid "Integrating with Reactive Streams"
msgstr ""

# 3539b991e6b24105b2075af4b86b6bc6
#: ../../java/stream/stream-integrations.rst:367
msgid ""
"`Reactive Streams`_ defines a standard for asynchronous stream processing "
"with non-blocking back pressure. It makes it possible to plug together "
"stream libraries that adhere to the standard. Akka Streams is one such "
"library."
msgstr ""

# 2b75ab686a0345d0a85c71330faa6463
#: ../../java/stream/stream-integrations.rst:371
msgid "An incomplete list of other implementations:"
msgstr ""

# 44f2c728199748d0b0d944d2f0da0439
#: ../../java/stream/stream-integrations.rst:373
msgid "`Reactor (1.1+)`_"
msgstr ""

# 2a87e976800d41909f96e64f46871f9c
#: ../../java/stream/stream-integrations.rst:374
msgid "`RxJava`_"
msgstr ""

# e9463292b6bd47a4ab1a4f34b0704a05
#: ../../java/stream/stream-integrations.rst:375
msgid "`Ratpack`_"
msgstr ""

# da4792915a0947c38d70f64b4000f3af
#: ../../java/stream/stream-integrations.rst:376
msgid "`Slick`_"
msgstr ""

# 18c730acf46e4ec7ac038f325b4dc0d6
#: ../../java/stream/stream-integrations.rst:384
msgid ""
"The two most important interfaces in Reactive Streams are the "
":class:`Publisher` and :class:`Subscriber`."
msgstr ""

# a7cfdfd062cd494486234769b0a886b0
#: ../../java/stream/stream-integrations.rst:388
msgid "Let us assume that a library provides a publisher of tweets:"
msgstr ""

# cce95a081a6940d9abb763acb30a02d1
#: ../../java/stream/stream-integrations.rst:392
msgid "and another library knows how to store author handles in a database:"
msgstr ""

# 06b9db8cd36840b3a8968e656e331168
#: ../../java/stream/stream-integrations.rst:396
msgid ""
"Using an Akka Streams :class:`Flow` we can transform the stream and connect "
"those:"
msgstr ""

# 9c8bdb394c9747ca8472059923b6ead6
#: ../../java/stream/stream-integrations.rst:401
msgid ""
"The :class:`Publisher` is used as an input :class:`Source` to the flow and "
"the :class:`Subscriber` is used as an output :class:`Sink`."
msgstr ""

# 198bd92dcedf44f5beb0e924262c07ab
#: ../../java/stream/stream-integrations.rst:404
msgid ""
"A :class:`Flow` can also be also converted to a "
":class:`RunnableGraph[Processor[In, Out]]` which materializes to a "
":class:`Processor` when ``run()`` is called. ``run()`` itself can be called "
"multiple times, resulting in a new :class:`Processor` instance each time."
msgstr ""

# 682251508f72448cb9df881a4a698c6e
#: ../../java/stream/stream-integrations.rst:410
msgid ""
"A publisher can be connected to a subscriber with the ``subscribe`` method."
msgstr ""

# 8c845186e43e41d089c0a4c162b2a4bc
#: ../../java/stream/stream-integrations.rst:412
msgid ""
"It is also possible to expose a :class:`Source` as a :class:`Publisher` by "
"using the Publisher-:class:`Sink`:"
msgstr ""

# c25dcce9c1b64c09886474c6bdaba7b4
#: ../../java/stream/stream-integrations.rst:417
msgid ""
"A publisher that is created with "
"``Sink.asPublisher(AsPublisher.WITHOUT_FANOUT)`` supports only a single "
"subscription. Additional subscription attempts will be rejected with an "
":class:`IllegalStateException`."
msgstr ""

# 0af186c43a4f49e193fc149baf33efaf
#: ../../java/stream/stream-integrations.rst:420
msgid ""
"A publisher that supports multiple subscribers using fan-out/broadcasting is"
" created as follows:"
msgstr ""

# 62e8b7623e3d435cab4edca3586aa764
#: ../../java/stream/stream-integrations.rst:427
msgid ""
"The input buffer size of the stage controls how far apart the slowest "
"subscriber can be from the fastest subscriber before slowing down the "
"stream."
msgstr ""

# b2a07818f8334677948c9df2af798496
#: ../../java/stream/stream-integrations.rst:430
msgid ""
"To make the picture complete, it is also possible to expose a :class:`Sink` "
"as a :class:`Subscriber` by using the Subscriber-:class:`Source`:"
msgstr ""

# 8dc76a39e9284a4680a611e47378ca21
#: ../../java/stream/stream-integrations.rst:435
msgid ""
"It is also possible to use re-wrap :class:`Processor` instances as a "
":class:`Flow` by passing a factory function that will create the "
":class:`Processor` instances:"
msgstr ""

# c7023b769c2a441d98e342ef8e92a1e7
#: ../../java/stream/stream-integrations.rst:440
msgid ""
"Please note that a factory is necessary to achieve reusability of the "
"resulting :class:`Flow`."
msgstr ""

# 4ba4b4c79d4d4104936ff69ec3e81795
#: ../../java/stream/stream-introduction.rst:8
msgid "Motivation"
msgstr "モチベーション"

# 7cf3570e96f5449b90182e1d0b28edbe
#: ../../java/stream/stream-introduction.rst:10
msgid ""
"The way we consume services from the Internet today includes many instances "
"of streaming data, both downloading from a service as well as uploading to "
"it or peer-to-peer data transfers. Regarding data as a stream of elements "
"instead of in its entirety is very useful because it matches the way "
"computers send and receive them (for example via TCP), but it is often also "
"a necessity because data sets frequently become too large to be handled as a"
" whole. We spread computations or analyses over large clusters and call it "
"“big data”, where the whole principle of processing them is by feeding those"
" data sequentially—as a stream—through some CPUs."
msgstr ""
"今日わたしたちがインターネット上のサービスを利用する際、連続的なデータのダウンロードやアップロード、そしてピアツーピアのデータ通信を扱うことが増えてきています。データを全体としてではなく、連続した要素(ストリーム)として捉えることは非常に有用です。これはコンピュータが"
" TCP "
"などを経由してデータの送受信を行うやり方と一致しています。さらにデータセットがあまりにも巨大になり、それをひとかたまりのものとして処理できない場合、ストリームという考え方は欠かせなくなります。我々は計算処理や分析を巨大なクラスタ上に展開しそれを「ビッグデータ」と呼んでいます。ここでは複数の"
" CPU を通して、データをシーケンシャルに、ストリームとして流しこむことがデータ処理の基本原則となっています。"

# ff0f7a483ab24b4ca77d19bedfaa9cc0
#: ../../java/stream/stream-introduction.rst:20
msgid ""
"Actors can be seen as dealing with streams as well: they send and receive "
"series of messages in order to transfer knowledge (or data) from one place "
"to another. We have found it tedious and error-prone to implement all the "
"proper measures in order to achieve stable streaming between actors, since "
"in addition to sending and receiving we also need to take care to not "
"overflow any buffers or mailboxes in the process. Another pitfall is that "
"Actor messages can be lost and must be retransmitted in that case lest the "
"stream have holes on the receiving side. When dealing with streams of "
"elements of a fixed given type, Actors also do not currently offer good "
"static guarantees that no wiring errors are made: type-safety could be "
"improved in this case."
msgstr ""
"アクターも同様にストリームを扱うものとして捉えることができます。何故ならアクターは知識(あるいはデータ)をある場所から別の場所へ移すために、一連のメッセージを送受信しているからです。しかしアクター間のストリーミングの安定化を実現するには、メッセージの送受信に加えて処理中のバッファやメールボックスがオーバーフローを起こさないよう対処しなければいけません。その実装は厄介で、エラーを引き起こしがちなものとなってしまいます。それに加えて、アクターのメッセージは消失することがあるため、受信側に穴あきのストリームが発生しないような再送信の仕組みが必要です。さらに、決められた型をもつ要素のストリームを扱う場合、アクターは現在のところ、正しい型でメッセージの送受信が行われているかを静的に保証する術を持っていないのです。ここではより厳密な型安全が求められます。"

# 270e2936e0a34a509f4900aecdfb6760
#: ../../java/stream/stream-introduction.rst:31
msgid ""
"For these reasons we decided to bundle up a solution to these problems as an"
" Akka Streams API. The purpose is to offer an intuitive and safe way to "
"formulate stream processing setups such that we can then execute them "
"efficiently and with bounded resource usage—no more OutOfMemoryErrors. In "
"order to achieve this our streams need to be able to limit the buffering "
"that they employ, they need to be able to slow down producers if the "
"consumers cannot keep up. This feature is called back-pressure and is at the"
" core of the `Reactive Streams`_ initiative of which Akka is a founding "
"member. For you this means that the hard problem of propagating and reacting"
" to back-pressure has been incorporated in the design of Akka Streams "
"already, so you have one less thing to worry about; it also means that Akka "
"Streams interoperate seamlessly with all other Reactive Streams "
"implementations (where Reactive Streams interfaces define the "
"interoperability SPI while implementations like Akka Streams offer a nice "
"user API)."
msgstr ""
"そういったわけで、我々はこれらの問題に対するソリューションを Akka Stream API として統合することにしました。Akka Stream "
"API "
"は、ストリーム処理に必要な機構を、直感的かつ安全なやり方で構築する仕組みを提供します。この仕組みのもとで、ストリーム処理を効率的に、そして限られたリソースのもとで実行することができるのです。もはや"
" OutOfMemoryErrors "
"の心配をする必要はありません。これを実現するために、ストリームはそのバッファリングを制御する必要があります。つまり消費者側が処理しきれないような場合に生産者側がスピードを落とすことができないといけないのです。この仕組みはバックプレッシャーと呼ばれ、Akka"
" が設立メンバーである `Reactive Streams` "
"イニシアチブの核ともなっています。そういった意味では、バックプレッシャーをどう伝播しそれに応答するかという困難な問題は、Akka Stream "
"の設計の中にすでに組み込まれているため、課題は一つクリアされたとも言えるでしょう。また、Reactive Stream "
"のインターフェースがインターオペラビリティをもった SPI である一方で、その実装の一つとして Akka Stream が使い勝手の良いユーザー API"
" を提供しています。つまり Akka Stream は他の全ての Reactive Stream 実装とシームレスに相互運用が可能なのです。"

# 2a85830a034d4a1e88d2fb6ec3610415
#: ../../java/stream/stream-introduction.rst:49
msgid "Relationship with Reactive Streams"
msgstr "Reactive Stream との関連について"

# a6a983a63b21404488100b6eb462daec
#: ../../java/stream/stream-introduction.rst:51
msgid ""
"The Akka Streams API is completely decoupled from the Reactive Streams "
"interfaces. While Akka Streams focus on the formulation of transformations "
"on data streams the scope of Reactive Streams is just to define a common "
"mechanism of how to move data across an asynchronous boundary without "
"losses, buffering or resource exhaustion."
msgstr ""
"Akka Stream API は Reactive Stream のインターフェースとは完全に切り離されています。Akka Stream "
"がデータストリームにおける変換処理の定式化を重視する一方で、Reactive Stream "
"のスコープは、データの消失、バッファリング、リソース枯渇を引き起こさずに、非同期境界をまたがってデータを移動させるための共通のメカニズムを定義しているにとどまっています。"

# 1f3d3148d42e4d68b25e9a70f3f198bf
#: ../../java/stream/stream-introduction.rst:57
msgid ""
"The relationship between these two is that the Akka Streams API is geared "
"towards end-users while the Akka Streams implementation uses the Reactive "
"Streams interfaces internally to pass data between the different processing "
"stages. For this reason you will not find any resemblance between the "
"Reactive Streams interfaces and the Akka Streams API. This is in line with "
"the expectations of the Reactive Streams project, whose primary purpose is "
"to define interfaces such that different streaming implementation can "
"interoperate; it is not the purpose of Reactive Streams to describe an end-"
"user API."
msgstr ""
"この二者は、Akka Stream API がエンドユーザーを対象としているのに対して、 Akka Stream "
"実装が異なるプロセシングステージへデータを渡すために内部的に Reactive Stream "
"のインターフェースを利用しているという関係になっています。そのため、Reactive Stream のインターフェースと Akka Stream API"
" の間には、何の類似性も見いだせないことでしょう。しかしこれは Reactive Stream "
"プロジェクトの意図に反するものではありません。Reactive Stream "
"の第一の目的は異なるストリーミング実装でも相互運用できるようなインターフェースを定義することであり、エンドユーザー API "
"を記述することではないのです。"

# a5c69503e72a4af98978b5acc859b197
#: ../../java/stream/stream-introduction.rst:68
msgid "How to read these docs"
msgstr "ドキュメンテーションの読み方"

# c1e26b86568247e6919b8ccf5cdc9648
#: ../../java/stream/stream-introduction.rst:70
msgid ""
"Stream processing is a different paradigm to the Actor Model or to Future "
"composition, therefore it may take some careful study of this subject until "
"you feel familiar with the tools and techniques. The documentation is here "
"to help and for best results we recommend the following approach:"
msgstr ""
"ストリーミング処理はアクターモデルや Future "
"合成とは異なったパラダイムであり、その道具立てや技術に慣れるまでは、ある程度の学習を要することになると思われます。そのための手助けとしてドキュメンテーションを用意していますが、こを十二分に役立てるためには、以下の指針を参考にされると良いでしょう。"

# 5a29a23e76834e36a7f3b6824089309e
#: ../../java/stream/stream-introduction.rst:75
msgid ""
"Read the :ref:`stream-quickstart-java` to get a feel for how streams look "
"like and what they can do."
msgstr ""

# d6871c6b5cd44a9c9c08800f34689110
#: ../../java/stream/stream-introduction.rst:77
msgid ""
"The top-down learners may want to peruse the :ref:`stream-design` at this "
"point."
msgstr "順番に物事を理解してゆきたい方には、:ref:`stream-design` を精読することをお勧めします。"

# dc9f680b530f456caf476ef9d6c6313e
#: ../../java/stream/stream-introduction.rst:79
msgid ""
"The bottom-up learners may feel more at home rummaging through the :ref"
":`stream-cookbook-java`."
msgstr ""

# 038655899b9f440c8af13a361f32449d
#: ../../java/stream/stream-introduction.rst:81
msgid ""
"For a complete overview of the built-in processing stages you can look at "
"the table in :ref:`stages-overview_java`"
msgstr ""

# 15a2e7a0c17941cea29b21f6a5db189a
#: ../../java/stream/stream-introduction.rst:83
msgid ""
"The other sections can be read sequentially or as needed during the previous"
" steps, each digging deeper into specific topics."
msgstr ""
"その他のセクションは順番に読んでも、必要に応じて読んでいってもどちらでも構いません。各セクションでは特定のトピックについて掘り下げてゆきます。"

# 2ab3be68b5ee4387a5530739493468ff
#: ../../java/stream/stream-io.rst:5
msgid "Working with streaming IO"
msgstr ""

# b8f1882085d042abb8ac8fe473574c8d
#: ../../java/stream/stream-io.rst:7
msgid ""
"Akka Streams provides a way of handling File IO and TCP connections with "
"Streams. While the general approach is very similar to the `Actor based TCP "
"handling`_ using Akka IO, by using Akka Streams you are freed of having to "
"manually react to back-pressure signals, as the library does it "
"transparently for you."
msgstr ""

# b1984f4daa74483e81fd8d01670609c6
#: ../../java/stream/stream-io.rst:15
msgid "Streaming TCP"
msgstr ""

# 103c039425ec4be1add4b704fc5ce354
#: ../../java/stream/stream-io.rst:18
msgid "Accepting connections: Echo Server"
msgstr ""

# 5e32a0f155134af88836ed24f461db36
#: ../../java/stream/stream-io.rst:19
msgid ""
"In order to implement a simple EchoServer we ``bind`` to a given address, "
"which returns a ``Source<IncomingConnection, "
"CompletionStage<ServerBinding>>``, which will emit an "
":class:`IncomingConnection` element for each new connection that the Server "
"should handle:"
msgstr ""

# d3bf5587a59141e3aaa36b194407e94c
#: ../../java/stream/stream-io.rst:24
msgid ""
"Next, we simply handle *each* incoming connection using a :class:`Flow` "
"which will be used as the processing stage to handle and emit ByteStrings "
"from and to the TCP Socket. Since one :class:`ByteString` does not have to "
"necessarily correspond to exactly one line of text (the client might be "
"sending the line in chunks) we use the ``delimiter`` helper Flow from "
"``akka.stream.javadsl.Framing`` to chunk the inputs up into actual lines of "
"text. The last boolean argument indicates that we require an explicit line "
"ending even for the last message before the connection is closed. In this "
"example we simply add exclamation marks to each incoming text message and "
"push it through the flow:"
msgstr ""

# a82c7d4329924d289317f0de827a9b10
#: ../../java/stream/stream-io.rst:33
msgid ""
"Notice that while most building blocks in Akka Streams are reusable and "
"freely shareable, this is *not* the case for the incoming connection Flow, "
"since it directly corresponds to an existing, already accepted connection "
"its handling can only ever be materialized *once*."
msgstr ""

# f5ad486dd3e04eeab4bc8003146dc838
#: ../../java/stream/stream-io.rst:37
msgid ""
"Closing connections is possible by cancelling the *incoming connection* "
":class:`Flow` from your server logic (e.g. by connecting its downstream to a"
" :class:`Sink.cancelled()` and its upstream to a :class:`Source.empty()`). "
"It is also possible to shut down the server's socket by cancelling the "
":class:`IncomingConnection` source ``connections``."
msgstr ""

# a9255fb8740d4ac4bdde1fb3f4ad5acd
#: ../../java/stream/stream-io.rst:41
msgid ""
"We can then test the TCP server by sending data to the TCP Socket using "
"``netcat``:"
msgstr ""

# b01dca7a5fde439abd5ed398f5176d04
#: ../../java/stream/stream-io.rst:49
msgid "Connecting: REPL Client"
msgstr ""

# 805b30bf2e994e0d93067234a4b2a68c
#: ../../java/stream/stream-io.rst:50
msgid ""
"In this example we implement a rather naive Read Evaluate Print Loop client "
"over TCP. Let's say we know a server has exposed a simple command line "
"interface over TCP, and would like to interact with it using Akka Streams "
"over TCP. To open an outgoing connection socket we use the "
"``outgoingConnection`` method:"
msgstr ""

# 8d41f6f1cacf49f2ac88b4c5deec1579
#: ../../java/stream/stream-io.rst:57
msgid ""
"The ``repl`` flow we use to handle the server interaction first prints the "
"servers response, then awaits on input from the command line (this blocking "
"call is used here just for the sake of simplicity) and converts it to a "
":class:`ByteString` which is then sent over the wire to the server. Then we "
"simply connect the TCP pipeline to this processing stage–at this point it "
"will be materialized and start processing data once the server responds with"
" an *initial message*."
msgstr ""

# ba19ead68df3427280bb4caf36c43f95
#: ../../java/stream/stream-io.rst:63
msgid ""
"A resilient REPL client would be more sophisticated than this, for example "
"it should split out the input reading into a separate mapAsync step and have"
" a way to let the server write more data than one ByteString chunk at any "
"given time, these improvements however are left as exercise for the reader."
msgstr ""

# 063cbf4d94d3459792aad8ff401e276a
#: ../../java/stream/stream-io.rst:68
msgid "Avoiding deadlocks and liveness issues in back-pressured cycles"
msgstr ""

# 7bc96c51cafc4308ba27dda569ad5be9
#: ../../java/stream/stream-io.rst:69
msgid ""
"When writing such end-to-end back-pressured systems you may sometimes end up"
" in a situation of a loop, in which *either side is waiting for the other "
"one to start the conversation*. One does not need to look far to find "
"examples of such back-pressure loops. In the two examples shown previously, "
"we always assumed that the side we are connecting to would start the "
"conversation, which effectively means both sides are back-pressured and can "
"not get the conversation started. There are multiple ways of dealing with "
"this which are explained in depth in :ref:`graph-cycles-java`, however in "
"client-server scenarios it is often the simplest to make either side simply "
"send an initial message."
msgstr ""

# 0e1c6f72454b4109acde56ead8ecb5ff
#: ../../java/stream/stream-io.rst:77
msgid ""
"In case of back-pressured cycles (which can occur even between different "
"systems) sometimes you have to decide which of the sides has start the "
"conversation in order to kick it off. This can be often done by injecting an"
" initial message from one of the sides–a conversation starter."
msgstr ""

# 738c9e74a6604bfeb05314446dd9b84e
#: ../../java/stream/stream-io.rst:81
msgid ""
"To break this back-pressure cycle we need to inject some initial message, a "
"\"conversation starter\". First, we need to decide which side of the "
"connection should remain passive and which active. Thankfully in most "
"situations finding the right spot to start the conversation is rather "
"simple, as it often is inherent to the protocol we are trying to implement "
"using Streams. In chat-like applications, which our examples resemble, it "
"makes sense to make the Server initiate the conversation by emitting a "
"\"hello\" message:"
msgstr ""

# 25c5d496fba344bf9feb3089db389f8f
#: ../../java/stream/stream-io.rst:89
msgid ""
"To emit the initial message we merge a ``Source`` with a single element, "
"after the command processing but before the framing and transformation to "
"``ByteStrings`` this way we do not have to repeat such logic."
msgstr ""

# 3b74686196b640fb8f63aa091aed2249
#: ../../java/stream/stream-io.rst:92
msgid ""
"In this example both client and server may need to close the stream based on"
" a parsed command - ``BYE`` in the case of the server, and ``q`` in the case"
" of the client. This is implemented by using a custom :class:`GraphStage` "
"which completes the stream once it encounters such command."
msgstr ""

# 607b17ae7cbe4c279f58028dd953e4cf
#: ../../java/stream/stream-io.rst:97
msgid "Streaming File IO"
msgstr ""

# 87130814fa4b48aa8763da2ac7e8475d
#: ../../java/stream/stream-io.rst:99
msgid ""
"Akka Streams provide simple Sources and Sinks that can work with "
":class:`ByteString` instances to perform IO operations on files."
msgstr ""

# 38ca7b61a069421ba668d0e33b4f8612
#: ../../java/stream/stream-io.rst:103
msgid ""
"Streaming data from a file is as easy as creating a `FileIO.fromPath` given "
"a target path, and an optional ``chunkSize`` which determines the buffer "
"size determined as one \"element\" in such stream:"
msgstr ""

# 4ab83f9bf1f04af9ac575b8000845a0b
#: ../../java/stream/stream-io.rst:108
msgid ""
"Please note that these processing stages are backed by Actors and by default"
" are configured to run on a pre-configured threadpool-backed dispatcher "
"dedicated for File IO. This is very important as it isolates the blocking "
"file IO operations from the rest of the ActorSystem allowing each dispatcher"
" to be utilised in the most efficient way. If you want to configure a custom"
" dispatcher for file IO operations globally, you can do so by changing the "
"``akka.stream.blocking-io-dispatcher``, or for a specific stage by "
"specifying a custom Dispatcher in code, like this:"
msgstr ""

# dea3f46d3fc44a41a3913e05bdebc22c
#: ../../java/stream/stream-parallelism.rst:5
msgid "Pipelining and Parallelism"
msgstr ""

# db93079c6a2b468a96927913e565dde8
#: ../../java/stream/stream-parallelism.rst:7
msgid ""
"Akka Streams processing stages (be it simple operators on Flows and Sources "
"or graph junctions) are \"fused\" together and executed sequentially by "
"default. This avoids the overhead of events crossing asynchronous boundaries"
" but limits the flow to execute at most one stage at any given time."
msgstr ""

# 944519116b7f4a499a089d5289905e4f
#: ../../java/stream/stream-parallelism.rst:11
msgid ""
"In many cases it is useful to be able to concurrently execute the stages of "
"a flow, this is done by explicitly marking them as asynchronous using the "
"``async()`` method. Each processing stage marked as asynchronous will run in"
" a dedicated actor internally, while all stages not marked asynchronous will"
" run in one single actor."
msgstr ""

# e7e6e73b905d4cd2bad6be0c451a70ba
#: ../../java/stream/stream-parallelism.rst:15
msgid ""
"We will illustrate through the example of pancake cooking how streams can be"
" used for various processing patterns, exploiting the available parallelism "
"on modern computers. The setting is the following: both Patrik and Roland "
"like to make pancakes, but they need to produce sufficient amount in a "
"cooking session to make all of the children happy. To increase their pancake"
" production throughput they use two frying pans. How they organize their "
"pancake processing is markedly different."
msgstr ""

# 0352932c15cc472497cb8dbf249576cd
#: ../../java/stream/stream-parallelism.rst:22
msgid "Pipelining"
msgstr ""

# 6f4db042a84245eb8c6e28e9d80d552f
#: ../../java/stream/stream-parallelism.rst:24
msgid ""
"Roland uses the two frying pans in an asymmetric fashion. The first pan is "
"only used to fry one side of the pancake then the half-finished pancake is "
"flipped into the second pan for the finishing fry on the other side. Once "
"the first frying pan becomes available it gets a new scoop of batter. As an "
"effect, most of the time there are two pancakes being cooked at the same "
"time, one being cooked on its first side and the second being cooked to "
"completion. This is how this setup would look like implemented as a stream:"
msgstr ""

# a9bc315f93bd4202aa48447e246894e3
#: ../../java/stream/stream-parallelism.rst:33
msgid ""
"The two ``map`` stages in sequence (encapsulated in the \"frying pan\" "
"flows) will be executed in a pipelined way, basically doing the same as "
"Roland with his frying pans:"
msgstr ""

# 546bcffbf8864bd8801c0bbd7fca0afb
#: ../../java/stream/stream-parallelism.rst:36
msgid "A ``ScoopOfBatter`` enters ``fryingPan1``"
msgstr ""

# bb8485f602c043d68ae366ff4caaa07b
#: ../../java/stream/stream-parallelism.rst:37
msgid ""
"``fryingPan1`` emits a HalfCookedPancake once ``fryingPan2`` becomes "
"available"
msgstr ""

# bfcde47a362246b99cbe3bb0e4f16481
#: ../../java/stream/stream-parallelism.rst:38
msgid "``fryingPan2`` takes the HalfCookedPancake"
msgstr ""

# 74564134318d4d15a335680d9f2e1a26
#: ../../java/stream/stream-parallelism.rst:39
msgid ""
"at this point fryingPan1 already takes the next scoop, without waiting for "
"fryingPan2 to finish"
msgstr ""

# e19fb4dffd2b4e429266398c18631e76
#: ../../java/stream/stream-parallelism.rst:41
msgid ""
"The benefit of pipelining is that it can be applied to any sequence of "
"processing steps that are otherwise not parallelisable (for example because "
"the result of a processing step depends on all the information from the "
"previous step). One drawback is that if the processing times of the stages "
"are very different then some of the stages will not be able to operate at "
"full throughput because they will wait on a previous or subsequent stage "
"most of the time. In the pancake example frying the second half of the "
"pancake is usually faster than frying the first half, ``fryingPan2`` will "
"not be able to operate at full capacity [#]_."
msgstr ""

# 196f77175b434e71b17d33a5adbd63f6
#: ../../java/stream/stream-parallelism.rst:49
msgid ""
"Asynchronous stream processing stages have internal buffers to make "
"communication between them more efficient. For more details about the "
"behavior of these and how to add additional buffers refer to :ref:`stream-"
"rate-scala`."
msgstr ""

# b525776b768b419390cc6179a9a5ebf5
#: ../../java/stream/stream-parallelism.rst:53
msgid "Parallel processing"
msgstr ""

# 4f5957f67e524051820d48f64a30a748
#: ../../java/stream/stream-parallelism.rst:55
msgid ""
"Patrik uses the two frying pans symmetrically. He uses both pans to fully "
"fry a pancake on both sides, then puts the results on a shared plate. "
"Whenever a pan becomes empty, he takes the next scoop from the shared bowl "
"of batter. In essence he parallelizes the same process over multiple pans. "
"This is how this setup will look like if implemented using streams:"
msgstr ""

# 0b62092f863840bba805f1411f6b3887
#: ../../java/stream/stream-parallelism.rst:62
msgid ""
"The benefit of parallelizing is that it is easy to scale. In the pancake "
"example it is easy to add a third frying pan with Patrik's method, but "
"Roland cannot add a third frying pan, since that would require a third "
"processing step, which is not practically possible in the case of frying "
"pancakes."
msgstr ""

# c4cd42e4f5744e2ebadf4b9192c3f62c
#: ../../java/stream/stream-parallelism.rst:66
msgid ""
"One drawback of the example code above that it does not preserve the "
"ordering of pancakes. This might be a problem if children like to track "
"their \"own\" pancakes. In those cases the ``Balance`` and ``Merge`` stages "
"should be replaced by strict-round robing balancing and merging stages that "
"put in and take out pancakes in a strict order."
msgstr ""

# c19bb3084fc940f5b2468a1014bc72f7
#: ../../java/stream/stream-parallelism.rst:70
msgid ""
"A more detailed example of creating a worker pool can be found in the "
"cookbook: :ref:`cookbook-balance-scala`"
msgstr ""

# c6cfbd6461284dd0892c73045ddfc318
#: ../../java/stream/stream-parallelism.rst:73
msgid "Combining pipelining and parallel processing"
msgstr ""

# c4895043477d4194a4ff2bafc5709dfa
#: ../../java/stream/stream-parallelism.rst:75
msgid ""
"The two concurrency patterns that we demonstrated as means to increase "
"throughput are not exclusive. In fact, it is rather simple to combine the "
"two approaches and streams provide a nice unifying language to express and "
"compose them."
msgstr ""

# 8419a3fed650443aba4f8c4b70731113
#: ../../java/stream/stream-parallelism.rst:79
msgid ""
"First, let's look at how we can parallelize pipelined processing stages. In "
"the case of pancakes this means that we will employ two chefs, each working "
"using Roland's pipelining method, but we use the two chefs in parallel, just"
" like Patrik used the two frying pans. This is how it looks like if "
"expressed as streams:"
msgstr ""

# 7072db9aee3647dc9fc3fb56ce84eef4
#: ../../java/stream/stream-parallelism.rst:85
msgid ""
"The above pattern works well if there are many independent jobs that do not "
"depend on the results of each other, but the jobs themselves need multiple "
"processing steps where each step builds on the result of the previous one. "
"In our case individual pancakes do not depend on each other, they can be "
"cooked in parallel, on the other hand it is not possible to fry both sides "
"of the same pancake at the same time, so the two sides have to be fried in "
"sequence."
msgstr ""

# 12e0e99f53844682a5495e39a3422efe
#: ../../java/stream/stream-parallelism.rst:91
msgid ""
"It is also possible to organize parallelized stages into pipelines. This "
"would mean employing four chefs:"
msgstr ""

# c597e8c05d0c43fc9fb3fabfb429d912
#: ../../java/stream/stream-parallelism.rst:93
msgid ""
"the first two chefs prepare half-cooked pancakes from batter, in parallel, "
"then putting those on a large enough flat surface."
msgstr ""

# 9af4c952a944458a915a900af73af68f
#: ../../java/stream/stream-parallelism.rst:95
msgid ""
"the second two chefs take these and fry their other side in their own pans, "
"then they put the pancakes on a shared plate."
msgstr ""

# 53e07ad1455346d28548107d571a5f73
#: ../../java/stream/stream-parallelism.rst:98
msgid "This is again straightforward to implement with the streams API:"
msgstr ""

# 3105c2e5d39d47988e2dfe05bc6fe9a4
#: ../../java/stream/stream-parallelism.rst:102
msgid ""
"This usage pattern is less common but might be usable if a certain step in "
"the pipeline might take wildly different times to finish different jobs. The"
" reason is that there are more balance-merge steps in this pattern compared "
"to the parallel pipelines. This pattern rebalances after each step, while "
"the previous pattern only balances at the entry point of the pipeline. This "
"only matters however if the processing time distribution has a large "
"deviation."
msgstr ""

# 61e9555088204df6861ac707dbf7d9cb
#: ../../java/stream/stream-parallelism.rst:108
msgid ""
"Roland's reason for this seemingly suboptimal procedure is that he prefers "
"the temperature of the second pan to be slightly lower than the first in "
"order to achieve a more homogeneous result."
msgstr ""

# ede14cbe867f4e9f94a437a829004282
#: ../../java/stream/stream-quickstart.rst:4
msgid "Quick Start Guide"
msgstr "クイックスタートガイド"

# 0cf4f3bc3e3d493e96504debf1c9454f
#: ../../java/stream/stream-quickstart.rst:6
msgid ""
"A stream usually begins at a source, so this is also how we start an Akka "
"Stream. Before we create one, we import the full complement of streaming "
"tools:"
msgstr ""
"ストリームは基本的にはソースから始まります。Akka Stream "
"を始める場合も然りです。しかしまずは、ストリーミングのために必要な道具をインポートしてみましょう。"

# c2bef433210f4bf491b374f260d7883c
#: ../../java/stream/stream-quickstart.rst:11
msgid ""
"If you want to execute the code samples while you read through the quick "
"start guide, you will also need the following imports:"
msgstr "このクイックスタートガイドを読みつつサンプルコードを実行したい場合、以下のインポートも必要になります。"

# d73979a818dd4c43b29a28261759389e
#: ../../java/stream/stream-quickstart.rst:15
msgid ""
"Now we will start with a rather simple source, emitting the integers 1 to "
"100:"
msgstr "さて、まずは整数値を 1 から 100 まで発行するシンプルなソースから始めてゆきましょう。"

# a6508814df3040a580efc5892dd0a211
#: ../../java/stream/stream-quickstart.rst:19
msgid ""
"The :class:`Source` type is parameterized with two types: the first one is "
"the type of element that this source emits and the second one may signal "
"that running the source produces some auxiliary value (e.g. a network source"
" may provide information about the bound port or the peer’s address). Where "
"no auxiliary information is produced, the type ``akka.NotUsed`` is used—and "
"a simple range of integers surely falls into this category."
msgstr ""
"*TBD* :class:`Source` "
"型は2つの型パラメータを取ります。一つ目がソースが発行する個別要素の型を示し、二つ目が、実行中のソースが生成する補助的な値を示します（##???##）(例えばネットワークソースは、接続先のポートや通信先のアドレスに関する情報を提供します)。"
" 補助的な情報が生成されない場合、ここには ``akka.NotUsed`` "
"という型が使われます。例えば整数の範囲をストリームとして扱う場合、これに相当します。"

# ddaa18ce9a8447f7a34ae9742efefc78
#: ../../java/stream/stream-quickstart.rst:26
msgid ""
"Having created this source means that we have a description of how to emit "
"the first 100 natural numbers, but this source is not yet active. In order "
"to get those numbers out we have to run it:"
msgstr ""
"このソースを作成したということは、1から100までの整数を発行するためのレシピが作成されたということです。しかしソースはまだアクティブにはなっていません。これらの整数を手にするには、次のようなコードを実行する必要があります。"

# 11382ea722604fae8c345974dc6c6071
#: ../../java/stream/stream-quickstart.rst:32
msgid ""
"This line will complement the source with a consumer function—in this "
"example we simply print out the numbers to the console—and pass this little "
"stream setup to an Actor that runs it. This activation is signaled by having"
" “run” be part of the method name; there are other methods that run Akka "
"Streams, and they all follow this pattern."
msgstr ""

# 942354b449c74ff1baffc9aad19be36b
#: ../../java/stream/stream-quickstart.rst:38
msgid ""
"You may wonder where the Actor gets created that runs the stream, and you "
"are probably also asking yourself what this ``materializer`` means. In order"
" to get this value we first need to create an Actor system:"
msgstr ""

# 4f93e7a5be4448a8aab365062b33572f
#: ../../java/stream/stream-quickstart.rst:44
msgid ""
"There are other ways to create a materializer, e.g. from an "
":class:`ActorContext` when using streams from within Actors. The "
":class:`Materializer` is a factory for stream execution engines, it is the "
"thing that makes streams run—you don’t need to worry about any of the "
"details just now apart from that you need one for calling any of the ``run``"
" methods on a :class:`Source`."
msgstr ""

# add6309f81ea4c52a44566a1121d972e
#: ../../java/stream/stream-quickstart.rst:51
msgid ""
"The nice thing about Akka Streams is that the :class:`Source` is just a "
"description of what you want to run, and like an architect’s blueprint it "
"can be reused, incorporated into a larger design. We may choose to transform"
" the source of integers and write it to a file instead:"
msgstr ""

# ee9f1a8dcace4b23bf4fba104317cb46
#: ../../java/stream/stream-quickstart.rst:58
msgid ""
"First we use the ``scan`` combinator to run a computation over the whole "
"stream: starting with the number 1 (``BigInteger.ONE``) we multiple by each "
"of the incoming numbers, one after the other; the scan operationemits the "
"initial value and then every calculation result. This yields the series of "
"factorial numbers which we stash away as a :class:`Source` for later "
"reuse—it is important to keep in mind that nothing is actually computed yet,"
" this is just a description of what we want to have computed once we run the"
" stream. Then we convert the resulting series of numbers into a stream of "
":class:`ByteString` objects describing lines in a text file. This stream is "
"then run by attaching a file as the receiver of the data. In the terminology"
" of Akka Streams this is called a :class:`Sink`. :class:`IOResult` is a type"
" that IO operations return in Akka Streams in order to tell you how many "
"bytes or elements were consumed and whether the stream terminated normally "
"or exceptionally."
msgstr ""

# 7bfa3d6f46af43da8ea72741666e0c2a
#: ../../java/stream/stream-quickstart.rst:73
msgid "Reusable Pieces"
msgstr ""

# 6f4d81cf41e24247863b31d4116b5cd5
#: ../../java/stream/stream-quickstart.rst:75
msgid ""
"One of the nice parts of Akka Streams—and something that other stream "
"libraries do not offer—is that not only sources can be reused like "
"blueprints, all other elements can be as well. We can take the file-writing "
":class:`Sink`, prepend the processing steps necessary to get the "
":class:`ByteString` elements from incoming strings and package that up as a "
"reusable piece as well. Since the language for writing these streams always "
"flows from left to right (just like plain English), we need a starting point"
" that is like a source but with an “open” input. In Akka Streams this is "
"called a :class:`Flow`:"
msgstr ""

# 14fc369c7b98472b81d850406210e6bb
#: ../../java/stream/stream-quickstart.rst:86
msgid ""
"Starting from a flow of strings we convert each to :class:`ByteString` and "
"then feed to the already known file-writing :class:`Sink`. The resulting "
"blueprint is a :class:`Sink<String, CompletionStage<IOResult>>`, which means"
" that it accepts strings as its input and when materialized it will create "
"auxiliary information of type ``CompletionStage<IOResult>`` (when chaining "
"operations on a :class:`Source` or :class:`Flow` the type of the auxiliary "
"information—called the “materialized value”—is given by the leftmost "
"starting point; since we want to retain what the ``FileIO.toPath`` sink has "
"to offer, we need to say ``Keep.right()``)."
msgstr ""

# 2396ed8573a8468388dbd55eb9eb8afe
#: ../../java/stream/stream-quickstart.rst:96
msgid ""
"We can use the new and shiny :class:`Sink` we just created by attaching it "
"to our ``factorials`` source—after a small adaptation to turn the numbers "
"into strings:"
msgstr ""

# aa5879d2d06e4b7fa3aa394e1d92d0f1
#: ../../java/stream/stream-quickstart.rst:103
msgid "Time-Based Processing"
msgstr ""

# 0171663702ad4ab3b72c9ebb7bb3f073
#: ../../java/stream/stream-quickstart.rst:105
msgid ""
"Before we start looking at a more involved example we explore the streaming "
"nature of what Akka Streams can do. Starting from the ``factorials`` source "
"we transform the stream by zipping it together with another stream, "
"represented by a :class:`Source` that emits the number 0 to 100: the first "
"number emitted by the ``factorials`` source is the factorial of zero, the "
"second is the factorial of one, and so on. We combine these two by forming "
"strings like ``\"3! = 6\"``."
msgstr ""

# 52a2826ee4cb4432a93b31e4418cf2dc
#: ../../java/stream/stream-quickstart.rst:115
msgid ""
"All operations so far have been time-independent and could have been "
"performed in the same fashion on strict collections of elements. The next "
"line demonstrates that we are in fact dealing with streams that can flow at "
"a certain speed: we use the ``throttle`` combinator to slow down the stream "
"to 1 element per second (the second ``1`` in the argument list is the "
"maximum size of a burst that we want to allow—passing ``1`` means that the "
"first element gets through immediately and the second then has to wait for "
"one second and so on)."
msgstr ""

# 3977210214dd47d2bd16da4b233f933e
#: ../../java/stream/stream-quickstart.rst:124
msgid ""
"If you run this program you will see one line printed per second. One aspect"
" that is not immediately visible deserves mention, though: if you try and "
"set the streams to produce a billion numbers each then you will notice that "
"your JVM does not crash with an OutOfMemoryError, even though you will also "
"notice that running the streams happens in the background, asynchronously "
"(this is the reason for the auxiliary information to be provided as a "
":class:`CompletionStage`, in the future). The secret that makes this work is"
" that Akka Streams implicitly implement pervasive flow control, all "
"combinators respect back-pressure. This allows the throttle combinator to "
"signal to all its upstream sources of data that it can only accept elements "
"at a certain rate—when the incoming rate is higher than one per second the "
"throttle combinator will assert *back-pressure* upstream."
msgstr ""

# e7a6a6175e694a088f7babefa358f655
#: ../../java/stream/stream-quickstart.rst:137
msgid ""
"This is basically all there is to Akka Streams in a nutshell—glossing over "
"the fact that there are dozens of sources and sinks and many more stream "
"transformation combinators to choose from, see also :ref:`stages-"
"overview_java`."
msgstr ""

# fb1dd24993e64118afcbfa587134d26e
#: ../../java/stream/stream-quickstart.rst:142
msgid "Reactive Tweets"
msgstr ""

# b3fc0a14853446d4926d396e737a3556
#: ../../java/stream/stream-quickstart.rst:144
msgid ""
"A typical use case for stream processing is consuming a live stream of data "
"that we want to extract or aggregate some other data from. In this example "
"we'll consider consuming a stream of tweets and extracting information "
"concerning Akka from them."
msgstr ""

# f39b63fba8544f7c9b4ed7c01fe30bef
#: ../../java/stream/stream-quickstart.rst:147
msgid ""
"We will also consider the problem inherent to all non-blocking streaming "
"solutions: *\"What if the subscriber is too slow to consume the live stream "
"of data?\"*. Traditionally the solution is often to buffer the elements, but"
" this can—and usually will—cause eventual buffer overflows and instability "
"of such systems. Instead Akka Streams depend on internal backpressure "
"signals that allow to control what should happen in such scenarios."
msgstr ""

# c8f191c909014c33b056bd3cbd794aa7
#: ../../java/stream/stream-quickstart.rst:154
msgid ""
"Here's the data model we'll be working with throughout the quickstart "
"examples:"
msgstr ""

# 57c3f4233cb948c9af2123021c17e574
#: ../../java/stream/stream-quickstart.rst:160
msgid ""
"If you would like to get an overview of the used vocabulary first instead of"
" diving head-first into an actual example you can have a look at the :ref"
":`core-concepts-java` and :ref:`defining-and-running-streams-java` sections "
"of the docs, and then come back to this quickstart to see it all pieced "
"together into a simple example application."
msgstr ""

# 7e4203bc2262486693bcf1b6b35c9115
#: ../../java/stream/stream-quickstart.rst:165
msgid "Transforming and consuming simple streams"
msgstr ""

# ce4efbb311244db5ae4e1f51a1c27b7a
#: ../../java/stream/stream-quickstart.rst:166
msgid ""
"The example application we will be looking at is a simple Twitter feed "
"stream from which we'll want to extract certain information, like for "
"example finding all twitter handles of users who tweet about ``#akka``."
msgstr ""

# fd56871ffcdc4abb91ecc8893e197180
#: ../../java/stream/stream-quickstart.rst:169
msgid ""
"In order to prepare our environment by creating an :class:`ActorSystem` and "
":class:`ActorMaterializer`, which will be responsible for materializing and "
"running the streams we are about to create:"
msgstr ""

# 187766170d7f4e01965628256c01a5af
#: ../../java/stream/stream-quickstart.rst:174
msgid ""
"The :class:`ActorMaterializer` can optionally take "
":class:`ActorMaterializerSettings` which can be used to define "
"materialization properties, such as default buffer sizes (see also :ref"
":`async-stream-buffers-java`), the dispatcher to be used by the pipeline "
"etc. These can be overridden with ``withAttributes`` on :class:`Flow`, "
":class:`Source`, :class:`Sink` and :class:`Graph`."
msgstr ""

# 1ff59a954a974023a4a9fc3e2bfb1463
#: ../../java/stream/stream-quickstart.rst:178
msgid ""
"Let's assume we have a stream of tweets readily available. In Akka this is "
"expressed as a :class:`Source<Out, M>`:"
msgstr ""

# 7eb8201d201e41c9a251d1dc04e6a997
#: ../../java/stream/stream-quickstart.rst:182
msgid ""
"Streams always start flowing from a ``Source<Out,M1>`` then can continue "
"through ``Flow<In,Out,M2>`` elements or more advanced graph elements to "
"finally be consumed by a ``Sink<In,M3>``."
msgstr ""

# 318e47a31f2f4b52a19c6ad9d56e407b
#: ../../java/stream/stream-quickstart.rst:185
msgid ""
"The first type parameter—:class:`Tweet` in this case—designates the kind of "
"elements produced by the source while the ``M`` type parameters describe the"
" object that is created during materialization (:ref:`see below "
"<materialized-values-quick-java>`)—:class:`BoxedUnit` (from the "
"``scala.runtime`` package) means that no value is produced, it is the "
"generic equivalent of ``void``."
msgstr ""

# 23ffaa322aa84b66a3d4bbdb0d8a82f9
#: ../../java/stream/stream-quickstart.rst:190
msgid ""
"The operations should look familiar to anyone who has used the Scala "
"Collections library, however they operate on streams and not collections of "
"data (which is a very important distinction, as some operations only make "
"sense in streaming and vice versa):"
msgstr ""

# f8d213c8c0024d37ba53fd1dda3ab349
#: ../../java/stream/stream-quickstart.rst:196
msgid ""
"Finally in order to :ref:`materialize <stream-materialization-java>` and run"
" the stream computation we need to attach the Flow to a ``Sink<T, M>`` that "
"will get the Flow running. The simplest way to do this is to call "
"``runWith(sink)`` on a ``Source<Out, M>``. For convenience a number of "
"common Sinks are predefined and collected as static methods on the `Sink "
"class <http://doc.akka.io/japi/akka-stream-and-http-"
"experimental/@version@/akka/stream/javadsl/Sink.html>`_. For now let's "
"simply print each author:"
msgstr ""

# 47a9ec47df8849d2ab801c5ee0816a5e
#: ../../java/stream/stream-quickstart.rst:204
msgid ""
"or by using the shorthand version (which are defined only for the most "
"popular Sinks such as :class:`Sink.fold` and :class:`Sink.foreach`):"
msgstr ""

# be6f6f040fc24cdc8915446d62d0390e
#: ../../java/stream/stream-quickstart.rst:208
msgid ""
"Materializing and running a stream always requires a :class:`Materializer` "
"to be passed in explicitly, like this: ``.run(mat)``."
msgstr ""

# 823b226cbf8b4123bf10f7943a5b763a
#: ../../java/stream/stream-quickstart.rst:211
msgid "The complete snippet looks like this:"
msgstr ""

# f152c2cf885e4b57a1d7eafdd8cfaa3d
#: ../../java/stream/stream-quickstart.rst:216
msgid "Flattening sequences in streams"
msgstr ""

# b9f259ea4ca249d78a0c804079b74f6f
#: ../../java/stream/stream-quickstart.rst:217
msgid ""
"In the previous section we were working on 1:1 relationships of elements "
"which is the most common case, but sometimes we might want to map from one "
"element to a number of elements and receive a \"flattened\" stream, "
"similarly like ``flatMap`` works on Scala Collections. In order to get a "
"flattened stream of hashtags from our stream of tweets we can use the "
"``mapConcat`` combinator:"
msgstr ""

# 2cc3a34cb65a42c49e83471c23546cba
#: ../../java/stream/stream-quickstart.rst:225
msgid ""
"The name ``flatMap`` was consciously avoided due to its proximity with for-"
"comprehensions and monadic composition. It is problematic for two reasons: "
"firstly, flattening by concatenation is often undesirable in bounded stream "
"processing due to the risk of deadlock (with merge being the preferred "
"strategy), and secondly, the monad laws would not hold for our "
"implementation of flatMap (due to the liveness issues)."
msgstr ""

# 99a187f2c55e43129c074f02fe5917fa
#: ../../java/stream/stream-quickstart.rst:230
msgid ""
"Please note that the ``mapConcat`` requires the supplied function to return "
"a strict collection (``Out f -> java.util.List<T>``), whereas ``flatMap`` "
"would have to operate on streams all the way through."
msgstr ""

# 2f18a4126ee54d8f8a5566971de4d3b2
#: ../../java/stream/stream-quickstart.rst:235
msgid "Broadcasting a stream"
msgstr ""

# 8cd050f1940e41f49676a494a295009a
#: ../../java/stream/stream-quickstart.rst:236
msgid ""
"Now let's say we want to persist all hashtags, as well as all author names "
"from this one live stream. For example we'd like to write all author handles"
" into one file, and all hashtags into another file on disk. This means we "
"have to split the source stream into two streams which will handle the "
"writing to these different files."
msgstr ""

# 7e97e19e7f4a43dca3a59f7c1145044a
#: ../../java/stream/stream-quickstart.rst:240
msgid ""
"Elements that can be used to form such \"fan-out\" (or \"fan-in\") "
"structures are referred to as \"junctions\" in Akka Streams. One of these "
"that we'll be using in this example is called :class:`Broadcast`, and it "
"simply emits elements from its input port to all of its output ports."
msgstr ""

# 78276e5faabc4348922b9a196cba0e9f
#: ../../java/stream/stream-quickstart.rst:244
msgid ""
"Akka Streams intentionally separate the linear stream structures (Flows) "
"from the non-linear, branching ones (Graphs) in order to offer the most "
"convenient API for both of these cases. Graphs can express arbitrarily "
"complex stream setups at the expense of not reading as familiarly as "
"collection transformations."
msgstr ""

# 9dd75c3b55394acfbc47a1b9d3526778
#: ../../java/stream/stream-quickstart.rst:248
msgid "Graphs are constructed using :class:`GraphDSL` like this:"
msgstr ""

# 7f2c575c2edd45049e5db13d472c0efc
#: ../../java/stream/stream-quickstart.rst:252
msgid ""
"As you can see, we use graph builder ``b`` to construct the graph using "
"``UniformFanOutShape`` and ``Flow`` s."
msgstr ""

# aa28970e9d5e435fa0b567bfb82052bf
#: ../../java/stream/stream-quickstart.rst:254
msgid ""
"``GraphDSL.create`` returns a :class:`Graph`, in this example a "
"``Graph<ClosedShape,Unit>`` where :class:`ClosedShape` means that it is *a "
"fully connected graph* or \"closed\" - there are no unconnected inputs or "
"outputs. Since it is closed it is possible to transform the graph into a "
":class:`RunnableGraph` using ``RunnableGraph.fromGraph``. The runnable graph"
" can then be ``run()`` to materialize a stream out of it."
msgstr ""

# 686dccff1ee34e00a3a70b18b06c719d
#: ../../java/stream/stream-quickstart.rst:259
msgid ""
"Both :class:`Graph` and :class:`RunnableGraph` are *immutable, thread-safe, "
"and freely shareable*."
msgstr ""

# f912d9b9dcf94a84b0662dfe41f89cdc
#: ../../java/stream/stream-quickstart.rst:261
msgid ""
"A graph can also have one of several other shapes, with one or more "
"unconnected ports. Having unconnected ports expresses a graph that is a "
"*partial graph*. Concepts around composing and nesting graphs in large "
"structures are explained in detail in :ref:`composition-java`. It is also "
"possible to wrap complex computation graphs as Flows, Sinks or Sources, "
"which will be explained in detail in :ref:`partial-graph-dsl-java`."
msgstr ""

# 43087e16f0db4050aee83ff5da90bf21
#: ../../java/stream/stream-quickstart.rst:268
msgid "Back-pressure in action"
msgstr ""

# 4857fb2280974fb089f83f3957b250fb
#: ../../java/stream/stream-quickstart.rst:270
msgid ""
"One of the main advantages of Akka Streams is that they *always* propagate "
"back-pressure information from stream Sinks (Subscribers) to their Sources "
"(Publishers). It is not an optional feature, and is enabled at all times. To"
" learn more about the back-pressure protocol used by Akka Streams and all "
"other Reactive Streams compatible implementations read :ref:`back-pressure-"
"explained-java`."
msgstr ""

# 164ddb4787804a63a24c854ce3266ccd
#: ../../java/stream/stream-quickstart.rst:275
msgid ""
"A typical problem applications (not using Akka Streams) like this often face"
" is that they are unable to process the incoming data fast enough, either "
"temporarily or by design, and will start buffering incoming data until "
"there's no more space to buffer, resulting in either ``OutOfMemoryError`` s "
"or other severe degradations of service responsiveness. With Akka Streams "
"buffering can and must be handled explicitly. For example, if we are only "
"interested in the \"*most recent tweets, with a buffer of 10 elements*\" "
"this can be expressed using the ``buffer`` element:"
msgstr ""

# f87f016aeb0c4cc1b59952cf4f5f51d4
#: ../../java/stream/stream-quickstart.rst:283
msgid ""
"The ``buffer`` element takes an explicit and required ``OverflowStrategy``, "
"which defines how the buffer should react when it receives another element "
"while it is full. Strategies provided include dropping the oldest element "
"(``dropHead``), dropping the entire buffer, signalling failures etc. Be sure"
" to pick and choose the strategy that fits your use case best."
msgstr ""

# 705e43485a9b4cbcb62426271698e718
#: ../../java/stream/stream-quickstart.rst:291
msgid ""
"So far we've been only processing data using Flows and consuming it into "
"some kind of external Sink - be it by printing values or storing them in "
"some external system. However sometimes we may be interested in some value "
"that can be obtained from the materialized processing pipeline. For example,"
" we want to know how many tweets we have processed. While this question is "
"not as obvious to give an answer to in case of an infinite stream of tweets "
"(one way to answer this question in a streaming setting would be to create a"
" stream of counts described as \"*up until now*, we've processed N "
"tweets\"), but in general it is possible to deal with finite streams and "
"come up with a nice result such as a total count of elements."
msgstr ""

# 12c8eb51126c429486295e388ade1d70
#: ../../java/stream/stream-quickstart.rst:298
msgid ""
"First, let's write such an element counter using ``Flow.of(Class)`` and "
"``Sink.fold`` to see how the types look like:"
msgstr ""

# 64b495bdc0d84acba0a2011712134937
#: ../../java/stream/stream-quickstart.rst:302
msgid ""
"First we prepare a reusable ``Flow`` that will change each incoming tweet "
"into an integer of value ``1``. We'll use this in order to combine those "
"with a ``Sink.fold`` that will sum all ``Integer`` elements of the stream "
"and make its result available as a ``CompletionStage<Integer>``. Next we "
"connect the ``tweets`` stream to ``count`` with ``via``. Finally we connect "
"the Flow to the previously prepared Sink using ``toMat``."
msgstr ""

# c7021fd698ab483e9d1550c79c3e0164
#: ../../java/stream/stream-quickstart.rst:307
msgid ""
"Remember those mysterious ``Mat`` type parameters on ``Source<Out, Mat>``, "
"``Flow<In, Out, Mat>`` and ``Sink<In, Mat>``? They represent the type of "
"values these processing parts return when materialized. When you chain these"
" together, you can explicitly combine their materialized values: in our "
"example we used the ``Keep.right`` predefined function, which tells the "
"implementation to only care about the materialized type of the stage "
"currently appended to the right. The materialized type of ``sumSink`` is "
"``CompletionStage<Integer>`` and because of using ``Keep.right``, the "
"resulting :class:`RunnableGraph` has also a type parameter of "
"``CompletionStage<Integer>``."
msgstr ""

# 3550baad95594225a2eafc5870f9339f
#: ../../java/stream/stream-quickstart.rst:314
msgid ""
"This step does *not* yet materialize the processing pipeline, it merely "
"prepares the description of the Flow, which is now connected to a Sink, and "
"therefore can be ``run()``, as indicated by its type: "
"``RunnableGraph<CompletionStage<Integer>>``. Next we call ``run()`` which "
"uses the :class:`ActorMaterializer` to materialize and run the Flow. The "
"value returned by calling ``run()`` on a ``RunnableGraph<T>`` is of type "
"``T``. In our case this type is ``CompletionStage<Integer>`` which, when "
"completed, will contain the total length of our tweets stream. In case of "
"the stream failing, this future would complete with a Failure."
msgstr ""

# 2c2725536070493b86c64ceef2a502d8
#: ../../java/stream/stream-quickstart.rst:321
msgid ""
"A :class:`RunnableGraph` may be reused and materialized multiple times, "
"because it is just the \"blueprint\" of the stream. This means that if we "
"materialize a stream, for example one that consumes a live stream of tweets "
"within a minute, the materialized values for those two materializations will"
" be different, as illustrated by this example:"
msgstr ""

# 0a72878cb99f4d2381125769a154990f
#: ../../java/stream/stream-quickstart.rst:328
msgid ""
"Many elements in Akka Streams provide materialized values which can be used "
"for obtaining either results of computation or steering these elements which"
" will be discussed in detail in :ref:`stream-materialization-java`. Summing "
"up this section, now we know what happens behind the scenes when we run this"
" one-liner, which is equivalent to the multi line version above:"
msgstr ""

# 20ba5835d2f243148a9a5d5d1b7be672
#: ../../java/stream/stream-quickstart.rst:335
msgid ""
"``runWith()`` is a convenience method that automatically ignores the "
"materialized value of any other stages except those appended by the "
"``runWith()`` itself. In the above example it translates to using "
"``Keep.right`` as the combiner for materialized values."
msgstr ""

# 813551c0c3a0481590f3e69914b17ff9
#: ../../java/stream/stream-rate.rst:5
msgid "Buffers and working with rate"
msgstr ""

# 7f078399017f442a8ba9f344f550bfb3
#: ../../java/stream/stream-rate.rst:7
msgid ""
"When upstream and downstream rates differ, especially when the throughput "
"has spikes, it can be useful to introduce buffers in a stream. In this "
"chapter we cover how buffers are used in Akka Streams."
msgstr ""

# 5160b1a1aabf42ed9b245985eae80b8e
#: ../../java/stream/stream-rate.rst:14
msgid "Buffers for asynchronous stages"
msgstr ""

# c64c95cc25974e588213f77fc0397ab7
#: ../../java/stream/stream-rate.rst:16
msgid ""
"In this section we will discuss internal buffers that are introduced as an "
"optimization when using asynchronous stages."
msgstr ""

# 40f8fa3ef0cc42bab476fdb904a91c9e
#: ../../java/stream/stream-rate.rst:18
msgid ""
"To run a stage asynchronously it has to be marked explicitly as such using "
"the ``.async()`` method. Being run asynchronously means that a stage, after "
"handing out an element to its downstream consumer is able to immediately "
"process the next message. To demonstrate what we mean by this, let's take a "
"look at the following example:"
msgstr ""

# a67017d6900c4196b7cf9939b7b13e51
#: ../../java/stream/stream-rate.rst:24
msgid ""
"Running the above example, one of the possible outputs looks like this:"
msgstr ""

# 6dc677f7c86541199f1943175c57a4b2
#: ../../java/stream/stream-rate.rst:38
msgid ""
"Note that the order is *not* ``A:1, B:1, C:1, A:2, B:2, C:2,`` which would "
"correspond to the normal fused synchronous execution model of flows where an"
" element completely passes through the processing pipeline before the next "
"element enters the flow. The next element is processed by an asynchronous "
"stage as soon as it is emitted the previous one."
msgstr ""

# bfeaf10f3ac7470d840bc9eccad94bf8
#: ../../java/stream/stream-rate.rst:42
msgid ""
"While pipelining in general increases throughput, in practice there is a "
"cost of passing an element through the asynchronous (and therefore thread "
"crossing) boundary which is significant. To amortize this cost Akka Streams "
"uses a *windowed*, *batching* backpressure strategy internally. It is "
"windowed because as opposed to a `Stop-And-Wait`_ protocol multiple elements"
" might be \"in-flight\" concurrently with requests for elements. It is also "
"batching because a new element is not immediately requested once an element "
"has been drained from the window-buffer but multiple elements are requested "
"after multiple elements have been drained. This batching strategy reduces "
"the communication cost of propagating the backpressure signal through the "
"asynchronous boundary."
msgstr ""

# a1c3754f29b64fb18895c19b2128ba24
#: ../../java/stream/stream-rate.rst:50
msgid ""
"While this internal protocol is mostly invisible to the user (apart form its"
" throughput increasing effects) there are situations when these details get "
"exposed. In all of our previous examples we always assumed that the rate of "
"the processing chain is strictly coordinated through the backpressure signal"
" causing all stages to process no faster than the throughput of the "
"connected chain. There are tools in Akka Streams however that enable the "
"rates of different segments of a processing chain to be \"detached\" or to "
"define the maximum throughput of the stream through external timing sources."
" These situations are exactly those where the internal batching buffering "
"strategy suddenly becomes non-transparent."
msgstr ""

# 62d5db5c9d144776970563eab5a12f98
#: ../../java/stream/stream-rate.rst:60
msgid "Internal buffers and their effect"
msgstr ""

# 110f05d27320405cac80c5fb2f75817b
#: ../../java/stream/stream-rate.rst:62
msgid ""
"As we have explained, for performance reasons Akka Streams introduces a "
"buffer for every asynchronous processing stage. The purpose of these buffers"
" is solely optimization, in fact the size of 1 would be the most natural "
"choice if there would be no need for throughput improvements. Therefore it "
"is recommended to keep these buffer sizes small, and increase them only to a"
" level suitable for the throughput requirements of the application. Default "
"buffer sizes can be set through configuration:"
msgstr ""

# 97c02256c8b747d5863375516d1595ae
#: ../../java/stream/stream-rate.rst:72
msgid ""
"Alternatively they can be set by passing a "
":class:`ActorMaterializerSettings` to the materializer:"
msgstr ""

# fcd34cb4a09c4554970a2714bd90f0fc
#: ../../java/stream/stream-rate.rst:76
msgid ""
"If the buffer size needs to be set for segments of a :class:`Flow` only, it "
"is possible by defining a separate :class:`Flow` with these attributes:"
msgstr ""

# 605aab7399d94372a5bae0fcddf5a599
#: ../../java/stream/stream-rate.rst:81
msgid ""
"Here is an example of a code that demonstrate some of the issues caused by "
"internal buffers:"
msgstr ""

# 765fefe4fa5f475ca8f89d0c2d942661
#: ../../java/stream/stream-rate.rst:85
msgid ""
"Running the above example one would expect the number *3* to be printed in "
"every 3 seconds (the ``conflateWithSeed`` step here is configured so that it"
" counts the number of elements received before the downstream ``ZipWith`` "
"consumes them). What is being printed is different though, we will see the "
"number *1*. The reason for this is the internal buffer which is by default "
"16 elements large, and prefetches elements before the ``ZipWith`` starts "
"consuming them. It is possible to fix this issue by changing the buffer size"
" of ``ZipWith`` (or the whole graph) to 1. We will still see a leading 1 "
"though which is caused by an initial prefetch of the ``ZipWith`` element."
msgstr ""

# 30b8a567c51044fe8029d718da924ce9
#: ../../java/stream/stream-rate.rst:93
msgid ""
"In general, when time or rate driven processing stages exhibit strange "
"behavior, one of the first solutions to try should be to decrease the input "
"buffer of the affected elements to 1."
msgstr ""

# b32f0cdacc9a475daa5d06d2cccc8125
#: ../../java/stream/stream-rate.rst:98
msgid "Buffers in Akka Streams"
msgstr ""

# 2d7e8a3ab33a4b8e836b0884ca61d7bb
#: ../../java/stream/stream-rate.rst:100
msgid ""
"In this section we will discuss *explicit* user defined buffers that are "
"part of the domain logic of the stream processing pipeline of an "
"application."
msgstr ""

# 77cc0fdcd8fd4d29b3a751e450f10049
#: ../../java/stream/stream-rate.rst:103
msgid ""
"The example below will ensure that 1000 jobs (but not more) are dequeued "
"from an external (imaginary) system and stored locally in memory - relieving"
" the external system:"
msgstr ""

# aca2b3de256a4286b8e5055488cc3f14
#: ../../java/stream/stream-rate.rst:108
msgid ""
"The next example will also queue up 1000 jobs locally, but if there are more"
" jobs waiting in the imaginary external systems, it makes space for the new "
"element by dropping one element from the *tail* of the buffer. Dropping from"
" the tail is a very common strategy but it must be noted that this will drop"
" the *youngest* waiting job. If some \"fairness\" is desired in the sense "
"that we want to be nice to jobs that has been waiting for long, then this "
"option can be useful."
msgstr ""

# aeed2eab04964f318d24ee75aaee718b
#: ../../java/stream/stream-rate.rst:116
msgid ""
"Instead of dropping the youngest element from the tail of the buffer a new "
"element can be dropped without enqueueing it to the buffer at all."
msgstr ""

# 6b56af53db27437a8875206c156e06f3
#: ../../java/stream/stream-rate.rst:121
msgid ""
"Here is another example with a queue of 1000 jobs, but it makes space for "
"the new element by dropping one element from the *head* of the buffer. This "
"is the *oldest* waiting job. This is the preferred strategy if jobs are "
"expected to be resent if not processed in a certain period. The oldest "
"element will be retransmitted soon, (in fact a retransmitted duplicate might"
" be already in the queue!) so it makes sense to drop it first."
msgstr ""

# 664079586262435d8982c81b4965d446
#: ../../java/stream/stream-rate.rst:130
msgid ""
"Compared to the dropping strategies above, dropBuffer drops all the 1000 "
"jobs it has enqueued once the buffer gets full. This aggressive strategy is "
"useful when dropping jobs is preferred to delaying jobs."
msgstr ""

# a381166716d540d0854a8a2f24d9259e
#: ../../java/stream/stream-rate.rst:136
msgid ""
"If our imaginary external job provider is a client using our API, we might "
"want to enforce that the client cannot have more than 1000 queued jobs "
"otherwise we consider it flooding and terminate the connection. This is "
"easily achievable by the error strategy which simply fails the stream once "
"the buffer gets full."
msgstr ""

# 67e0c077a3ef4a48804966f200034beb
#: ../../java/stream/stream-rate.rst:145
msgid "Rate transformation"
msgstr ""

# c97ba049511441c8b1b2be0471eae2ad
#: ../../java/stream/stream-rate.rst:148
msgid "Understanding conflate"
msgstr ""

# edbc58232aef47ba8139ce540fcfafa0
#: ../../java/stream/stream-rate.rst:150
msgid ""
"When a fast producer can not be informed to slow down by backpressure or "
"some other signal, ``conflate`` might be useful to combine elements from a "
"producer until a demand signal comes from a consumer."
msgstr ""

# 83ed7f04e7eb40f7ac2765e0a10026b0
#: ../../java/stream/stream-rate.rst:153
msgid ""
"Below is an example snippet that summarizes fast stream of elements to a "
"standard deviation, mean and count of elements that have arrived  while the "
"stats have been calculated."
msgstr ""

# f90bd3561dc74a4da668c5b4a573a39a
#: ../../java/stream/stream-rate.rst:158
msgid ""
"This example demonstrates that such flow's rate is decoupled. The element "
"rate at the start of the flow can be much higher that the element rate at "
"the end of the flow."
msgstr ""

# 0a89d6b9ded94255a46124a8c74edc02
#: ../../java/stream/stream-rate.rst:161
msgid ""
"Another possible use of ``conflate`` is to not consider all elements for "
"summary when producer starts getting too fast. Example below demonstrates "
"how ``conflate`` can be used to implement random drop of elements when "
"consumer is not able to keep up with the producer."
msgstr ""

# 08b6536b4c794312ba2493e174918afc
#: ../../java/stream/stream-rate.rst:168
msgid "Understanding expand"
msgstr ""

# 360a988b46714091a7c54c6d182dbeaf
#: ../../java/stream/stream-rate.rst:170
msgid ""
"Expand helps to deal with slow producers which are unable to keep up with "
"the demand coming from consumers. Expand allows to extrapolate a value to be"
" sent as an element to a consumer."
msgstr ""

# 69772ccbfa8f4393a63fc590b1ec3ec4
#: ../../java/stream/stream-rate.rst:173
msgid ""
"As a simple use of ``expand`` here is a flow that sends the same element to "
"consumer when producer does not send any new elements."
msgstr ""

# a550c51b188749dca548e7eade73fdb2
#: ../../java/stream/stream-rate.rst:178
msgid ""
"Expand also allows to keep some state between demand requests from the "
"downstream. Leveraging this, here is a flow that tracks and reports a drift "
"between fast consumer and slow producer."
msgstr ""

# 23511a43bb79466b80ba73c1f38a9117
#: ../../java/stream/stream-rate.rst:183
msgid ""
"Note that all of the elements coming from upstream will go through "
"``expand`` at least once. This means that the output of this flow is going "
"to report a drift of zero if producer is fast enough, or a larger drift "
"otherwise."
msgstr ""

# c7c53bc574bb4c94bfb597afe19089f4
#: ../../java/stream/stream-testkit.rst:5
msgid "Testing streams"
msgstr ""

# e2846ffe74a24e149fe4cbca5fec0606
#: ../../java/stream/stream-testkit.rst:7
msgid ""
"Verifying behaviour of Akka Stream sources, flows and sinks can be done "
"using various code patterns and libraries. Here we will discuss testing "
"these elements using:"
msgstr ""

# 5eb69b04f24b4d68bbcb7614236d1473
#: ../../java/stream/stream-testkit.rst:11
msgid "simple sources, sinks and flows;"
msgstr ""

# e68d36c3ecea457b8661f39e1590d46b
#: ../../java/stream/stream-testkit.rst:12
msgid ""
"sources and sinks in combination with :class:`TestProbe` from the :mod"
":`akka-testkit` module;"
msgstr ""

# be6c4b21997c46369194be9f09b3833b
#: ../../java/stream/stream-testkit.rst:13
msgid ""
"sources and sinks specifically crafted for writing tests from the :mod"
":`akka-stream-testkit` module."
msgstr ""

# 09f1907c31f54786bbff6a0e9aa44224
#: ../../java/stream/stream-testkit.rst:15
msgid ""
"It is important to keep your data processing pipeline as separate sources, "
"flows and sinks. This makes them easily testable by wiring them up to other "
"sources or sinks, or some test harnesses that :mod:`akka-testkit` or :mod"
":`akka-stream-testkit` provide."
msgstr ""

# c8ef2ba571c544bb9674a44fb3330a98
#: ../../java/stream/stream-testkit.rst:21
msgid "Built in sources, sinks and combinators"
msgstr ""

# bca53c21d77a46dea8abfa26e3bc41f3
#: ../../java/stream/stream-testkit.rst:23
msgid ""
"Testing a custom sink can be as simple as attaching a source that emits "
"elements from a predefined collection, running a constructed test flow and "
"asserting on the results that sink produced. Here is an example of a test "
"for a sink:"
msgstr ""

# 50df9b8dcae84951b2dfa092adac6d17
#: ../../java/stream/stream-testkit.rst:30
msgid ""
"The same strategy can be applied for sources as well. In the next example we"
" have a source that produces an infinite stream of elements. Such source can"
" be tested by asserting that first arbitrary number of elements hold some "
"condition. Here the ``grouped`` combinator and ``Sink.head`` are very "
"useful."
msgstr ""

# fde8dbf49fc1428281e52cd13e9c2068
#: ../../java/stream/stream-testkit.rst:37
msgid ""
"When testing a flow we need to attach a source and a sink. As both stream "
"ends are under our control, we can choose sources that tests various edge "
"cases of the flow and sinks that ease assertions."
msgstr ""

# c5eb7e164025432f959a3041444b1a15
#: ../../java/stream/stream-testkit.rst:44
msgid "TestKit"
msgstr ""

# f322db9b98ee4aaa883df34c570b3428
#: ../../java/stream/stream-testkit.rst:46
msgid ""
"Akka Stream offers integration with Actors out of the box. This support can "
"be used for writing stream tests that use familiar :class:`TestProbe` from "
"the :mod:`akka-testkit` API."
msgstr ""

# c521374537444858804320166024adde
#: ../../java/stream/stream-testkit.rst:50
msgid ""
"One of the more straightforward tests would be to materialize stream to a "
":class:`CompletionStage` and then use ``PatternsCS.pipe`` pattern to pipe "
"the result of that future to the probe."
msgstr ""

# a7a4acfd135c4d028bc415128e49a7c7
#: ../../java/stream/stream-testkit.rst:56
msgid ""
"Instead of materializing to a future, we can use a :class:`Sink.actorRef` "
"that sends all incoming elements to the given :class:`ActorRef`. Now we can "
"use assertion methods on :class:`TestProbe` and expect elements one by one "
"as they arrive. We can also assert stream completion by expecting for "
"``onCompleteMessage`` which was given to :class:`Sink.actorRef`."
msgstr ""

# bd3c8b900cfb4f31accd1fc754d36294
#: ../../java/stream/stream-testkit.rst:64
msgid ""
"Similarly to :class:`Sink.actorRef` that provides control over received "
"elements, we can use :class:`Source.actorRef` and have full control over "
"elements to be sent."
msgstr ""

# 69d02eacfd644c1c92aa2a507187c912
#: ../../java/stream/stream-testkit.rst:71
msgid "Streams TestKit"
msgstr ""

# 6d8ee47ac6ad4940ad3ac131164b460c
#: ../../java/stream/stream-testkit.rst:73
msgid ""
"You may have noticed various code patterns that emerge when testing stream "
"pipelines. Akka Stream has a separate :mod:`akka-stream-testkit` module that"
" provides tools specifically for writing stream tests. This module comes "
"with two main components that are :class:`TestSource` and :class:`TestSink` "
"which provide sources and sinks that materialize to probes that allow fluent"
" API."
msgstr ""

# c3bf92e8b7814b7bb45e5dc67786807a
#: ../../java/stream/stream-testkit.rst:81
msgid ""
"Be sure to add the module :mod:`akka-stream-testkit` to your dependencies."
msgstr ""

# aaf08007586b4b978789a9eac3e47337
#: ../../java/stream/stream-testkit.rst:83
msgid ""
"A sink returned by ``TestSink.probe`` allows manual control over demand and "
"assertions over elements coming downstream."
msgstr ""

# 7ed60453d82641bbb969cac8e5b5b77d
#: ../../java/stream/stream-testkit.rst:88
msgid ""
"A source returned by ``TestSource.probe`` can be used for asserting demand "
"or controlling when stream is completed or ended with an error."
msgstr ""

# 3ba2c77c1c414e279054257fb0c5783e
#: ../../java/stream/stream-testkit.rst:93
msgid ""
"You can also inject exceptions and test sink behaviour on error conditions."
msgstr ""

# 260039b45d0d4bef89214c8d0cda126a
#: ../../java/stream/stream-testkit.rst:97
msgid ""
"Test source and sink can be used together in combination when testing flows."
msgstr ""

# 7d202d02c8384a3e9301af610d0c2944
#: ../../java/testing.rst:5
msgid "Testing Actor Systems"
msgstr ""

# 99cf8a1d992b4ab7be5a80e3eb0f1c55
#: ../../java/testing.rst:7
msgid ""
"As with any piece of software, automated tests are a very important part of "
"the development cycle. The actor model presents a different view on how "
"units of code are delimited and how they interact, which has an influence on"
" how to perform tests."
msgstr ""

# a9575b6059f6451d904dee8d6a6e9f4f
#: ../../java/testing.rst:12
msgid ""
"Akka comes with a dedicated module :mod:`akka-testkit` for supporting tests "
"at different levels, which fall into two clearly distinct categories:"
msgstr ""

# c8621ff7ba5a42a2b54c8d2f81f11982
#: ../../java/testing.rst:15
msgid ""
"Testing isolated pieces of code without involving the actor model, meaning "
"without multiple threads; this implies completely deterministic behavior "
"concerning the ordering of events and no concurrency concerns and will be "
"called **Unit Testing** in the following."
msgstr ""

# e61a487e065f453ba7bf242b747c785d
#: ../../java/testing.rst:19
msgid ""
"Testing (multiple) encapsulated actors including multi-threaded scheduling; "
"this implies non-deterministic order of events but shielding from "
"concurrency concerns by the actor model and will be called **Integration "
"Testing** in the following."
msgstr ""

# fb411e16c6734f0a954316425b118ff2
#: ../../java/testing.rst:24
msgid ""
"There are of course variations on the granularity of tests in both "
"categories, where unit testing reaches down to white-box tests and "
"integration testing can encompass functional tests of complete actor "
"networks. The important distinction lies in whether concurrency concerns are"
" part of the test or not. The tools offered are described in detail in the "
"following sections."
msgstr ""

# 7dd5385d38f3460bb3a1225738b3d544
#: ../../java/testing.rst:32
msgid "Be sure to add the module :mod:`akka-testkit` to your dependencies."
msgstr ""

# 02ff9ea4411846c8bde9397ada0337bc
#: ../../java/testing.rst:35
msgid "Synchronous Unit Testing with :class:`TestActorRef`"
msgstr ""

# a4456cb137d54c54b878c1a83e14ca8b
#: ../../java/testing.rst:37
msgid ""
"Testing the business logic inside :class:`Actor` classes can be divided into"
" two parts: first, each atomic operation must work in isolation, then "
"sequences of incoming events must be processed correctly, even in the "
"presence of some possible variability in the ordering of events. The former "
"is the primary use case for single-threaded unit testing, while the latter "
"can only be verified in integration tests."
msgstr ""

# 13a2c7025af94e51b64d55987a377ab0
#: ../../java/testing.rst:44
msgid ""
"Normally, the :class:`ActorRef` shields the underlying :class:`Actor` "
"instance from the outside, the only communications channel is the actor's "
"mailbox. This restriction is an impediment to unit testing, which led to the"
" inception of the :class:`TestActorRef`. This special type of reference is "
"designed specifically for test purposes and allows access to the actor in "
"two ways: either by obtaining a reference to the underlying actor instance, "
"or by invoking or querying the actor's behaviour (:meth:`receive`). Each one"
" warrants its own section below."
msgstr ""

# 5371b87a01764b82be38c53ee30c3e84
#: ../../java/testing.rst:54
msgid ""
"It is highly recommended to stick to traditional behavioural testing (using "
"messaging to ask the Actor to reply with the state you want to run "
"assertions against), instead of using ``TestActorRef`` whenever possible."
msgstr ""

# b64863ba1d624fc38f425cb27728a641
#: ../../java/testing.rst:59
msgid ""
"Due to the synchronous nature of ``TestActorRef`` it will **not** work with "
"some support traits that Akka provides as they require asynchronous "
"behaviours to function properly. Examples of traits that do not mix well "
"with test actor refs are :ref:`PersistentActor <event-sourcing-java>` and "
":ref:`AtLeastOnceDelivery <at-least-once-delivery-java>` provided by "
":ref:`Akka Persistence <persistence-java>`."
msgstr ""

# 23239117ca004cd19e7b208287114c62
#: ../../java/testing.rst:65
msgid "Obtaining a Reference to an :class:`Actor`"
msgstr ""

# 305af8cc522a4510aea884d3786febc1
#: ../../java/testing.rst:67
msgid ""
"Having access to the actual :class:`Actor` object allows application of all "
"traditional unit testing techniques on the contained methods. Obtaining a "
"reference is done like this:"
msgstr ""

# 8a86d4d0b8fe42a1a7ae7a46d8dd4d10
#: ../../java/testing.rst:73
msgid ""
"Since :class:`TestActorRef` is generic in the actor type it returns the "
"underlying actor with its proper static type. From this point on you may "
"bring any unit testing tool to bear on your actor as usual."
msgstr ""

# 270bf9b0f1574797b79bed2e3b2e47d3
#: ../../java/testing.rst:78
msgid "Testing the Actor's Behavior"
msgstr ""

# dcd5d427bf594ca288b069daa2fdd9a2
#: ../../java/testing.rst:80
msgid ""
"When the dispatcher invokes the processing behavior of an actor on a "
"message, it actually calls :meth:`apply` on the current behavior registered "
"for the actor. This starts out with the return value of the declared "
":meth:`receive` method, but it may also be changed using :meth:`become` and "
":meth:`unbecome` in response to external messages. All of this contributes "
"to the overall actor behavior and it does not lend itself to easy testing on"
" the :class:`Actor` itself. Therefore the :class:`TestActorRef` offers a "
"different mode of operation to complement the :class:`Actor` testing: it "
"supports all operations also valid on normal :class:`ActorRef`. Messages "
"sent to the actor are processed synchronously on the current thread and "
"answers may be sent back as usual. This trick is made possible by the "
":class:`CallingThreadDispatcher` described below (see "
"`CallingThreadDispatcher`_); this dispatcher is set implicitly for any actor"
" instantiated into a :class:`TestActorRef`."
msgstr ""

# cf33a38dc32f4ba0b3386eb48841529e
#: ../../java/testing.rst:96
msgid ""
"As the :class:`TestActorRef` is a subclass of :class:`LocalActorRef` with a "
"few special extras, also aspects like supervision and restarting work "
"properly, but beware that execution is only strictly synchronous as long as "
"all actors involved use the :class:`CallingThreadDispatcher`. As soon as you"
" add elements which include more sophisticated scheduling you leave the "
"realm of unit testing as you then need to think about asynchronicity again "
"(in most cases the problem will be to wait until the desired effect had a "
"chance to happen)."
msgstr ""

# 70854384760447d3bc8d8aa04a191dba
#: ../../java/testing.rst:104
msgid ""
"One more special aspect which is overridden for single-threaded tests is the"
" :meth:`receiveTimeout`, as including that would entail asynchronous queuing"
" of :obj:`ReceiveTimeout` messages, violating the synchronous contract."
msgstr ""

# 9af4cfb4c33b425faf6ef79f66e0994e
#: ../../java/testing.rst:110
msgid ""
"To summarize: :class:`TestActorRef` overwrites two fields: it sets the "
"dispatcher to :obj:`CallingThreadDispatcher.global` and it sets the "
":obj:`receiveTimeout` to None."
msgstr ""

# 175d610c75a0400b9634157210a7e798
#: ../../java/testing.rst:115
msgid "The Way In-Between: Expecting Exceptions"
msgstr ""

# d8a7890008554bac9a8d22b142d192e2
#: ../../java/testing.rst:117
msgid ""
"If you want to test the actor behavior, including hotswapping, but without "
"involving a dispatcher and without having the :class:`TestActorRef` swallow "
"any thrown exceptions, then there is another mode available for you: just "
"use the :meth:`receive` method on :class:`TestActorRef`, which will be "
"forwarded to the underlying actor:"
msgstr ""

# 4b31e6c822884d668fabeec5a88da56d
#: ../../java/testing.rst:126
msgid "Use Cases"
msgstr ""

# b9b3bd58d358499aac7420fd4ae19929
#: ../../java/testing.rst:128
msgid ""
"You may of course mix and match both modi operandi of :class:`TestActorRef` "
"as suits your test needs:"
msgstr ""

# 1ad4ea03532842019ad38405f0488e05
#: ../../java/testing.rst:131
msgid ""
"one common use case is setting up the actor into a specific internal state "
"before sending the test message"
msgstr ""

# 21e5757b189343569cc67b0fcfa9c578
#: ../../java/testing.rst:133
msgid ""
"another is to verify correct internal state transitions after having sent "
"the test message"
msgstr ""

# dd4870a3e4ae4e158b6a253ad129d81f
#: ../../java/testing.rst:136
msgid ""
"Feel free to experiment with the possibilities, and if you find useful "
"patterns, don't hesitate to let the Akka forums know about them! Who knows, "
"common operations might even be worked into nice DSLs."
msgstr ""

# c2458b0adc3449319fd862b897a4a55c
#: ../../java/testing.rst:143
msgid "Asynchronous Integration Testing with :class:`JavaTestKit`"
msgstr ""

# ad9b7be9a97d47598ada439b351e0481
#: ../../java/testing.rst:145
msgid ""
"When you are reasonably sure that your actor's business logic is correct, "
"the next step is verifying that it works correctly within its intended "
"environment. The definition of the environment depends of course very much "
"on the problem at hand and the level at which you intend to test, ranging "
"for functional/integration tests to full system tests. The minimal setup "
"consists of the test procedure, which provides the desired stimuli, the "
"actor under test, and an actor receiving replies.  Bigger systems replace "
"the actor under test with a network of actors, apply stimuli at varying "
"injection points and arrange results to be sent from different emission "
"points, but the basic principle stays the same in that a single procedure "
"drives the test."
msgstr ""

# d567758e19c547e8982591c5abd24fd5
#: ../../java/testing.rst:156
msgid ""
"The :class:`JavaTestKit` class contains a collection of tools which makes "
"this common task easy."
msgstr ""

# 1b895b5f2e6147afbdbb3df61ac57340
#: ../../java/testing.rst:161
msgid ""
"The :class:`JavaTestKit` contains an actor named :obj:`testActor` which is "
"the entry point for messages to be examined with the various "
"``expectMsg...`` assertions detailed below. The test actor’s reference is "
"obtained using the :meth:`getRef()` method as demonstrated above.  The "
":obj:`testActor` may also be passed to other actors as usual, usually "
"subscribing it as notification listener. There is a whole set of examination"
" methods, e.g. receiving all consecutive messages matching certain criteria,"
" receiving a whole sequence of fixed messages or classes, receiving nothing "
"for some time, etc."
msgstr ""

# 01dfe71cdcaa4f37b63fee370f98da07
#: ../../java/testing.rst:170
msgid ""
"The ActorSystem passed in to the constructor of JavaTestKit is accessible "
"via the :meth:`getSystem()` method."
msgstr ""

# 7be254df075b4e1482b5af011cefa0a9
#: ../../java/testing.rst:175
msgid ""
"Remember to shut down the actor system after the test is finished (also in "
"case of failure) so that all actors—including the test actor—are stopped."
msgstr ""

# 10670a30895d4d069c3c1f89e8ecafeb
#: ../../java/testing.rst:179
msgid "Built-In Assertions"
msgstr ""

# 4d5468b828ea4082aec3b746e7f3a4dd
#: ../../java/testing.rst:181
msgid ""
"The above mentioned :meth:`expectMsgEquals` is not the only method for "
"formulating assertions concerning received messages, the full set is this:"
msgstr ""

# 9c6adb298e864811bdb8583202f330f0
#: ../../java/testing.rst:186
msgid ""
"In these examples, the maximum durations you will find mentioned below are "
"left out, in which case they use the default value from configuration item "
"``akka.test.single-expect-default`` which itself defaults to 3 seconds (or "
"they obey the innermost enclosing :class:`Within` as detailed :ref:`below "
"<JavaTestKit.within>`). The full signatures are:"
msgstr ""

# 18753864bf5c48d6820d4cf07eede139
#: ../../java/testing.rst:192
msgid ":meth:`public <T> T expectMsgEquals(Duration max, T msg)`"
msgstr ""

# 139a7ae2c0d24dc6a33eba48de3166a9
#: ../../java/testing.rst:194
msgid ""
"The given message object must be received within the specified time; the "
"object will be returned."
msgstr ""

# 5b4e7f7250844c5abc5ca7b021dbe632
#: ../../java/testing.rst:197
msgid ":meth:`public Object expectMsgAnyOf(Duration max, Object... msg)`"
msgstr ""

# 43192b5ec8c14c9989990e59bf101043
#: ../../java/testing.rst:199
msgid ""
"An object must be received within the given time, and it must be equal "
"(compared with ``equals()``) to at least one of the passed reference "
"objects; the received object will be returned."
msgstr ""

# cc99d0e4284d4a4d869098cc39bd68e9
#: ../../java/testing.rst:203
msgid ":meth:`public Object[] expectMsgAllOf(Duration max, Object... msg)`"
msgstr ""

# 9076b27f8c954d2aa9a40e7b0fb753a3
#: ../../java/testing.rst:205
msgid ""
"A number of objects matching the size of the supplied object array must be "
"received within the given time, and for each of the given objects there must"
" exist at least one among the received ones which equals it (compared with "
"``equals()``). The full sequence of received objects is returned in the "
"order received."
msgstr ""

# 4a3e9b3294df43c09a64d23ee5a2d1a8
#: ../../java/testing.rst:211
msgid ":meth:`public <T> T expectMsgClass(Duration max, Class<T> c)`"
msgstr ""

# ad30809ca0c44783bcd852c19b0b1e6c
#: ../../java/testing.rst:213
msgid ""
"An object which is an instance of the given :class:`Class` must be received "
"within the allotted time frame; the object will be returned. Note that this "
"does a conformance check, if you need the class to be equal you need to "
"verify that afterwards."
msgstr ""

# f51c8032817543f794f6b201adb2d14f
#: ../../java/testing.rst:218
msgid ""
":meth:`public <T> T expectMsgAnyClassOf(Duration max, Class<? extends T>... "
"c)`"
msgstr ""

# d892a7fdb6b745b0ab3d77a817a79e0d
#: ../../java/testing.rst:220
msgid ""
"An object must be received within the given time, and it must be an instance"
" of at least one of the supplied :class:`Class` objects; the received object"
" will be returned. Note that this does a conformance check, if you need the "
"class to be equal you need to verify that afterwards."
msgstr ""

# 297ba208cbfc4bef9c5d14322562fecd
#: ../../java/testing.rst:227
msgid ""
"Because of a limitation in Java’s type system it may be necessary to add "
"``@SuppressWarnings(\"unchecked\")`` when using this method."
msgstr ""

# 6d83b1dec8ab4580a2456bc4aee28184
#: ../../java/testing.rst:230
msgid ":meth:`public void expectNoMsg(Duration max)`"
msgstr ""

# f761f872f7ec4a989c8068186bd3171a
#: ../../java/testing.rst:232
msgid ""
"No message must be received within the given time. This also fails if a "
"message has been received before calling this method which has not been "
"removed from the queue using one of the other methods."
msgstr ""

# d9cecd091cc042e98d32ccee8a8c8c0c
#: ../../java/testing.rst:236
msgid ":meth:`Object[] receiveN(int n, Duration max)`"
msgstr ""

# 195e72ef89bb4bfcaf6afc91c4d1ce53
#: ../../java/testing.rst:238
msgid ""
"``n`` messages must be received within the given time; the received messages"
" are returned."
msgstr ""

# b983fc160f0343c2a53c70e06114e7c0
#: ../../java/testing.rst:241
msgid ""
"For cases which require more refined conditions there are constructs which "
"take code blocks:"
msgstr ""

# fc1624208c48405eaa3cb333c13053a0
#: ../../java/testing.rst:244
msgid "**ExpectMsg<T>**"
msgstr ""

# 63f4ebc375684b8691eb80ea7d5f62c6
#: ../../java/testing.rst:248
msgid ""
"The :meth:`match(Object in)` method will be evaluated once a message has "
"been received within the allotted time (which may be given as constructor "
"argument). If it throws ``noMatch()`` (where it is sufficient to call that "
"method; the ``throw`` keyword is only needed in cases where the compiler "
"would otherwise complain about wrong return types—Java is lacking Scala’s "
"notion of a type which signifies “will not ever return normally”), then the "
"expectation fails with an :class:`AssertionError`, otherwise the matched and"
" possibly transformed object is stored for retrieval using the :meth:`get()`"
" method."
msgstr ""

# c802be3d5b9a490ab7fdbadb325fdc39
#: ../../java/testing.rst:258
msgid "**ReceiveWhile<T>**"
msgstr ""

# 628d70060d2048a49c4c3f701d12ba17
#: ../../java/testing.rst:262
msgid ""
"This construct works like ExpectMsg, but it continually collects messages as"
" long as they match the criteria, and it does not fail when a non-matching "
"one is encountered. Collecting messages also ends when the time is up, when "
"too much time passes between messages or when enough messages have been "
"received."
msgstr ""

# 643b79bce2554144acd8a6bf7cc2b5c6
#: ../../java/testing.rst:271
msgid ""
"The need to specify the ``String`` result type twice results from the need "
"to create a correctly typed array and Java’s inability to infer the class’s "
"type argument."
msgstr ""

# b2387cdd343e40e4a1654b5806ca19b8
#: ../../java/testing.rst:275
msgid "**AwaitCond**"
msgstr ""

# 86f616285e734e0cb046fd457382ef11
#: ../../java/testing.rst:279
msgid ""
"This general construct is not connected with the test kit’s message "
"reception, the embedded condition can compute the boolean result from "
"anything in scope."
msgstr ""

# 0ad6e271fcf04864956976bbae26034c
#: ../../java/testing.rst:283
msgid "**AwaitAssert**"
msgstr ""

# 08e340699de64338a83016cae364c52b
#: ../../java/testing.rst:287
msgid ""
"This general construct is not connected with the test kit’s message "
"reception, the embedded assert can check anything in scope."
msgstr ""

# 7cb67d3b206046c597c87008b40380ec
#: ../../java/testing.rst:290
msgid ""
"There are also cases where not all messages sent to the test kit are "
"actually relevant to the test, but removing them would mean altering the "
"actors under test. For this purpose it is possible to ignore certain "
"messages:"
msgstr ""

# 898dd399d01949c6ae7eda6556ec59e2
#: ../../java/testing.rst:294
msgid "**IgnoreMsg**"
msgstr ""

# 0663d17712244c0891f6fb37a917facd
#: ../../java/testing.rst:299
msgid "Expecting Log Messages"
msgstr ""

# d53bfbee40d341c0beee2f3835c31320
#: ../../java/testing.rst:301
msgid ""
"Since an integration test does not allow to the internal processing of the "
"participating actors, verifying expected exceptions cannot be done directly."
" Instead, use the logging system for this purpose: replacing the normal "
"event handler with the :class:`TestEventListener` and using an "
":class:`EventFilter` allows assertions on log messages, including those "
"which are generated by exceptions:"
msgstr ""

# 602462da55254b168c96c715bef9e2d0
#: ../../java/testing.rst:310
msgid ""
"If a number of occurrences is specific—as demonstrated above—then ``exec()``"
" will block until that number of matching messages have been received or the"
" timeout configured in ``akka.test.filter-leeway`` is used up (time starts "
"counting after the ``run()`` method returns). In case of a timeout the test "
"fails."
msgstr ""

# 58e32b56309b4032adfb8614ee44d8ab
#: ../../java/testing.rst:318
msgid ""
"Be sure to exchange the default logger with the :class:`TestEventListener` "
"in your ``application.conf`` to enable this function::"
msgstr ""

# 6a3f9f638d0b4f40b702fc609f949321
#: ../../java/testing.rst:327
msgid "Timing Assertions"
msgstr ""

# 0dd48cd0ec39482b9167b2375ff118b9
#: ../../java/testing.rst:329
msgid ""
"Another important part of functional testing concerns timing: certain events"
" must not happen immediately (like a timer), others need to happen before a "
"deadline. Therefore, all examination methods accept an upper time limit "
"within the positive or negative result must be obtained. Lower time limits "
"need to be checked external to the examination, which is facilitated by a "
"new construct for managing time constraints:"
msgstr ""

# 206f5d644d784f8fb20c0cb43a247c59
#: ../../java/testing.rst:338
msgid ""
"The block in :meth:`Within.run()` must complete after a :ref:`Duration` "
"which is between :obj:`min` and :obj:`max`, where the former defaults to "
"zero. The deadline calculated by adding the :obj:`max` parameter to the "
"block's start time is implicitly available within the block to all "
"examination methods, if you do not specify it, it is inherited from the "
"innermost enclosing :meth:`within` block."
msgstr ""

# 8c7bc72f62bb486e911e3df5e3317576
#: ../../java/testing.rst:345
msgid ""
"It should be noted that if the last message-receiving assertion of the block"
" is :meth:`expectNoMsg` or :meth:`receiveWhile`, the final check of the "
":meth:`within` is skipped in order to avoid false positives due to wake-up "
"latencies. This means that while individual contained assertions still use "
"the maximum time bound, the overall block may take arbitrarily longer in "
"this case."
msgstr ""

# ac6b325d03b548a6a43199dcf2ca2fb1
#: ../../java/testing.rst:353
msgid ""
"All times are measured using ``System.nanoTime``, meaning that they describe"
" wall time, not CPU time or system time."
msgstr ""

# 1c0a26e4f6ef4744bda3d145ec006262
#: ../../java/testing.rst:357
msgid "Accounting for Slow Test Systems"
msgstr ""

# 2c15ecb6d24c4087ae3bef53cc6dc7d7
#: ../../java/testing.rst:359
msgid ""
"The tight timeouts you use during testing on your lightning-fast notebook "
"will invariably lead to spurious test failures on the heavily loaded Jenkins"
" server (or similar). To account for this situation, all maximum durations "
"are internally scaled by a factor taken from the :ref:`configuration`, "
"``akka.test.timefactor``, which defaults to 1."
msgstr ""

# fc09ad336a344d41aaaefeb7fdf1b57d
#: ../../java/testing.rst:365
msgid ""
"You can scale other durations with the same factor by using ``dilated`` "
"method in :class:`JavaTestKit`."
msgstr ""

# f94ce12f76594089a45153762a94ec15
#: ../../java/testing.rst:371
msgid "Using Multiple Probe Actors"
msgstr ""

# 64d68b216a7e400690475ebb56041a93
#: ../../java/testing.rst:373
msgid ""
"When the actors under test are supposed to send various messages to "
"different destinations, it may be difficult distinguishing the message "
"streams arriving at the :obj:`testActor` when using the :class:`JavaTestKit`"
" as shown until now. Another approach is to use it for creation of simple "
"probe actors to be inserted in the message flows. The functionality is best "
"explained using a small example:"
msgstr ""

# 89ebd38a98cf42ac927d6c175f85ca1c
#: ../../java/testing.rst:382
msgid ""
"This simple test verifies an equally simple Forwarder actor by injecting a "
"probe as the forwarder’s target.  Another example would be two actors A and "
"B which collaborate by A sending messages to B. In order to verify this "
"message flow, a :class:`TestProbe` could be inserted as target of A, using "
"the forwarding capabilities or auto-pilot described below to include a real "
"B in the test setup."
msgstr ""

# 7c09cd589db6410ca11509d05702639c
#: ../../java/testing.rst:389
msgid ""
"If you have many test probes, you can name them to get meaningful actor "
"names in test logs and assertions:"
msgstr ""

# 8b31c14ba047465bb2d3331ca954ebf3
#: ../../java/testing.rst:394
msgid ""
"Probes may also be equipped with custom assertions to make your test code "
"even more concise and clear:"
msgstr ""

# 0713e6a0dc004131b8a43a809b0f49e1
#: ../../java/testing.rst:400
msgid ""
"You have complete flexibility here in mixing and matching the "
":class:`JavaTestKit` facilities with your own checks and choosing an "
"intuitive name for it. In real life your code will probably be a bit more "
"complicated than the example given above; just use the power!"
msgstr ""

# 3698c7fd00b94e81b6b6e356f0c1c822
#: ../../java/testing.rst:407
msgid ""
"Any message send from a ``TestProbe`` to another actor which runs on the "
"CallingThreadDispatcher runs the risk of dead-lock, if that other actor "
"might also send to this probe. The implementation of :meth:`TestProbe.watch`"
" and :meth:`TestProbe.unwatch` will also send a message to the watchee, "
"which means that it is dangerous to try watching e.g. :class:`TestActorRef` "
"from a :meth:`TestProbe`."
msgstr ""

# b4be07ba790f416aab5fe91a49d5514d
#: ../../java/testing.rst:415
msgid "Watching Other Actors from Probes"
msgstr ""

# c68f35f63b3a4885bb92a175d4370b46
#: ../../java/testing.rst:417
msgid ""
"A :class:`JavaTestKit` can register itself for DeathWatch of any other "
"actor:"
msgstr ""

# 29756a93c1c64c1683d09a71fbfb64bf
#: ../../java/testing.rst:423
msgid "Replying to Messages Received by Probes"
msgstr ""

# 9f4c4361c72442179be43237465ff6fb
#: ../../java/testing.rst:425
msgid ""
"The probe stores the sender of the last dequeued message (i.e. after its "
"``expectMsg*`` reception), which may be retrieved using the "
":meth:`getLastSender()` method. This information can also implicitly be used"
" for having the probe reply to the last received message:"
msgstr ""

# 39e43de837314029b270afa30ad7cd65
#: ../../java/testing.rst:433
msgid "Forwarding Messages Received by Probes"
msgstr ""

# 4dd7f2cf34b247b09a00df52d65aaf7e
#: ../../java/testing.rst:435
msgid ""
"The probe can also forward a received message (i.e. after its ``expectMsg*``"
" reception), retaining the original sender:"
msgstr ""

# a8e55c953ae84ad2902f2147cc9c1d20
#: ../../java/testing.rst:441
msgid "Auto-Pilot"
msgstr ""

# 43bee24766b54ed8815192f2cd4edb59
#: ../../java/testing.rst:443
msgid ""
"Receiving messages in a queue for later inspection is nice, but in order to "
"keep a test running and verify traces later you can also install an "
":class:`AutoPilot` in the participating test probes (actually in any "
":class:`TestKit`) which is invoked before enqueueing to the inspection "
"queue. This code can be used to forward messages, e.g. in a chain ``A --> "
"Probe --> B``, as long as a certain protocol is obeyed."
msgstr ""

# 9e5c80442d4048b5a6ebccf048b01fa6
#: ../../java/testing.rst:452
msgid ""
"The :meth:`run` method must return the auto-pilot for the next message, "
"wrapped in an :class:`Option`; setting it to :obj:`None` terminates the "
"auto-pilot."
msgstr ""

# 9697c5aa41344976b34861bdd6820901
#: ../../java/testing.rst:456
msgid "Caution about Timing Assertions"
msgstr ""

# bb8147d2c6e8440d82438c34eec016f0
#: ../../java/testing.rst:458
msgid ""
"The behavior of :meth:`within` blocks when using test probes might be "
"perceived as counter-intuitive: you need to remember that the nicely scoped "
"deadline as described :ref:`above <JavaTestKit.within>` is local to each "
"probe. Hence, probes do not react to each other's deadlines or to the "
"deadline set in an enclosing :class:`JavaTestKit` instance:"
msgstr ""

# 1e53c90107074f5699e4ab7bccec81f5
#: ../../java/testing.rst:466
msgid "Here, the ``expectMsgEquals`` call will use the default timeout."
msgstr ""

# cee009b5488a495b9a6cf7e856b1e8d2
#: ../../java/testing.rst:469
msgid "Testing parent-child relationships"
msgstr ""

# 1e44b0e58b5a4b4ab8a662173d507bca
#: ../../java/testing.rst:471
msgid ""
"The parent of an actor is always the actor that created it. At times this "
"leads to a coupling between the two that may not be straightforward to test."
" Broadly, there are three approaches to improve testability of parent-child "
"relationships:"
msgstr ""

# 5e4492a5da6246e5ab4848c2d1e7548e
#: ../../java/testing.rst:476
msgid "when creating a child, pass an explicit reference to its parent"
msgstr ""

# 07ec249d2e804e449b98d190d16654f1
#: ../../java/testing.rst:477
msgid "when creating a parent, tell the parent how to create its child"
msgstr ""

# 07d565040e3b4bef887efe47e960118f
#: ../../java/testing.rst:478
msgid "create a fabricated parent when testing"
msgstr ""

# 455520257f0b4f74886e1fe20a7e1d96
#: ../../java/testing.rst:480
msgid ""
"For example, the structure of the code you want to test may follow this "
"pattern:"
msgstr ""

# 59657b10004b4164bddd4b664b15720f
#: ../../java/testing.rst:485
msgid "Using dependency-injection"
msgstr ""

# 8d896bf808f0477db7adbbf402b2f145
#: ../../java/testing.rst:487
msgid ""
"The first option is to avoid use of the :meth:`context.parent` function and "
"create a child with a custom parent by passing an explicit reference to its "
"parent instead."
msgstr ""

# e62cc47c843941c3ad70e1a2650931fe
#: ../../java/testing.rst:492
msgid ""
"Alternatively, you can tell the parent how to create its child. There are "
"two ways to do this: by giving it a :class:`Props` object or by giving it a "
"function which takes care of creating the child actor:"
msgstr ""

# 220e1d25ec9b4503a720807f52104664
#: ../../java/testing.rst:498
msgid ""
"Creating the :class:`Actor` is straightforward and the function may look "
"like this in your test code:"
msgstr ""

# 4bfecda3f5c748418a93c804a942b153
#: ../../java/testing.rst:502
msgid "And like this in your application code:"
msgstr ""

# 52070a2ec4ff41fe835a9317fda74888
#: ../../java/testing.rst:507
msgid "Using a fabricated parent"
msgstr ""

# cafe02971a8948919f511ebf9281acc1
#: ../../java/testing.rst:509
msgid ""
"If you prefer to avoid modifying the parent or child constructor you can "
"create a fabricated parent in your test. This, however, does not enable you "
"to test the parent actor in isolation."
msgstr ""

# ea9d3849f8de4936a41c985b68f738dd
#: ../../java/testing.rst:516
msgid ""
"Which of these methods is the best depends on what is most important to "
"test. The most generic option is to create the parent actor by passing it a "
"function that is responsible for the Actor creation, but the fabricated "
"parent is often sufficient."
msgstr ""

# bb328ea44af448baa04fb4ee4135b600
#: ../../java/testing.rst:525
msgid ""
"The :class:`CallingThreadDispatcher` serves good purposes in unit testing, "
"as described above, but originally it was conceived in order to allow "
"contiguous stack traces to be generated in case of an error. As this special"
" dispatcher runs everything which would normally be queued directly on the "
"current thread, the full history of a message's processing chain is recorded"
" on the call stack, so long as all intervening actors run on this "
"dispatcher."
msgstr ""

# e2d528cde51d4d23a42dcecf25ce0727
#: ../../java/testing.rst:533
msgid "How to use it"
msgstr ""

# e71c817f903146eb8512a91e778d0070
#: ../../java/testing.rst:535
msgid "Just set the dispatcher as you normally would:"
msgstr ""

# 79bdee8fc5f943b6abeda10a6817b020
#: ../../java/testing.rst:542
msgid ""
"When receiving an invocation, the :class:`CallingThreadDispatcher` checks "
"whether the receiving actor is already active on the current thread. The "
"simplest example for this situation is an actor which sends a message to "
"itself. In this case, processing cannot continue immediately as that would "
"violate the actor model, so the invocation is queued and will be processed "
"when the active invocation on that actor finishes its processing; thus, it "
"will be processed on the calling thread, but simply after the actor finishes"
" its previous work. In the other case, the invocation is simply processed "
"immediately on the current thread. Futures scheduled via this dispatcher are"
" also executed immediately."
msgstr ""

# ce6d68320af84567ba3765d37988f23d
#: ../../java/testing.rst:553
msgid ""
"This scheme makes the :class:`CallingThreadDispatcher` work like a general "
"purpose dispatcher for any actors which never block on external events."
msgstr ""

# 450767e47d54474abac6530d9e849739
#: ../../java/testing.rst:556
msgid ""
"In the presence of multiple threads it may happen that two invocations of an"
" actor running on this dispatcher happen on two different threads at the "
"same time. In this case, both will be processed directly on their respective"
" threads, where both compete for the actor's lock and the loser has to wait."
" Thus, the actor model is left intact, but the price is loss of concurrency "
"due to limited scheduling. In a sense this is equivalent to traditional "
"mutex style concurrency."
msgstr ""

# 584250fd76f74109ab551d7a96dd1220
#: ../../java/testing.rst:564
msgid ""
"The other remaining difficulty is correct handling of suspend and resume: "
"when an actor is suspended, subsequent invocations will be queued in thread-"
"local queues (the same ones used for queuing in the normal case). The call "
"to :meth:`resume`, however, is done by one specific thread, and all other "
"threads in the system will probably not be executing this specific actor, "
"which leads to the problem that the thread-local queues cannot be emptied by"
" their native threads. Hence, the thread calling :meth:`resume` will collect"
" all currently queued invocations from all threads into its own queue and "
"process them."
msgstr ""

# 063d41379eb24d91af810c085cc38a70
#: ../../java/testing.rst:578
msgid ""
"In case the CallingThreadDispatcher is used for top-level actors, but "
"without going through TestActorRef, then there is a time window during which"
" the actor is awaiting construction by the user guardian actor. Sending "
"messages to the actor during this time period will result in them being "
"enqueued and then executed on the guardian’s thread instead of the caller’s "
"thread. To avoid this, use TestActorRef."
msgstr ""

# 81414a2efc104e7d99575c7d007cb031
#: ../../java/testing.rst:585
msgid ""
"If an actor's behavior blocks on a something which would normally be "
"affected by the calling actor after having sent the message, this will "
"obviously dead-lock when using this dispatcher. This is a common scenario in"
" actor tests based on :class:`CountDownLatch` for synchronization:"
msgstr ""

# 35806fab559e4633bb1c3a59d13385f5
#: ../../java/testing.rst:597
msgid ""
"The example would hang indefinitely within the message processing initiated "
"on the second line and never reach the fourth line, which would unblock it "
"on a normal dispatcher."
msgstr ""

# 6560bbfb2fa243bf9386fc800bc1b796
#: ../../java/testing.rst:601
msgid ""
"Thus, keep in mind that the :class:`CallingThreadDispatcher` is not a "
"general-purpose replacement for the normal dispatchers. On the other hand it"
" may be quite useful to run your actor network on it for testing, because if"
" it runs without dead-locking chances are very high that it will not dead-"
"lock in production."
msgstr ""

# 0ecbc8e7ac0d4ca69d726f151e0702c6
#: ../../java/testing.rst:609
msgid ""
"The above sentence is unfortunately not a strong guarantee, because your "
"code might directly or indirectly change its behavior when running on a "
"different dispatcher. If you are looking for a tool to help you debug dead-"
"locks, the :class:`CallingThreadDispatcher` may help with certain error "
"scenarios, but keep in mind that it has may give false negatives as well as "
"false positives."
msgstr ""

# 242e6a8ae4404279ad1cab5dbad944a4
#: ../../java/testing.rst:617
msgid "Thread Interruptions"
msgstr ""

# 283bbac1f66d4995b8d1251dbe43c639
#: ../../java/testing.rst:619
msgid ""
"If the CallingThreadDispatcher sees that the current thread has its "
"``isInterrupted()`` flag set when message processing returns, it will throw "
"an :class:`InterruptedException` after finishing all its processing (i.e. "
"all messages which need processing as described above are processed before "
"this happens). As :meth:`tell` cannot throw exceptions due to its contract, "
"this exception will then be caught and logged, and the thread’s interrupted "
"status will be set again."
msgstr ""

# 8f4eaa4204a1428d86d19439c777e23c
#: ../../java/testing.rst:627
msgid ""
"If during message processing an :class:`InterruptedException` is thrown then"
" it will be caught inside the CallingThreadDispatcher’s message handling "
"loop, the thread’s interrupted flag will be set and processing continues "
"normally."
msgstr ""

# b87d814adc4d41ce90fa2c8474bd27dc
#: ../../java/testing.rst:633
msgid ""
"The summary of these two paragraphs is that if the current thread is "
"interrupted while doing work under the CallingThreadDispatcher, then that "
"will result in the ``isInterrupted`` flag to be ``true`` when the message "
"send returns and no :class:`InterruptedException` will be thrown."
msgstr ""

# 63c912175074467fabb289aba3125a51
#: ../../java/testing.rst:639
msgid "Benefits"
msgstr ""

# f0bb449c40bc4a789461c91be782c92e
#: ../../java/testing.rst:641
msgid ""
"To summarize, these are the features with the "
":class:`CallingThreadDispatcher` has to offer:"
msgstr ""

# 13237589a995466f8bf2c899a890eb3c
#: ../../java/testing.rst:644
msgid ""
"Deterministic execution of single-threaded tests while retaining nearly full"
" actor semantics"
msgstr ""

# d758c62bb52b427aabff850542bf16f4
#: ../../java/testing.rst:646
msgid ""
"Full message processing history leading up to the point of failure in "
"exception stack traces"
msgstr ""

# 4fff48951e7c40cf95366a129d9b65a3
#: ../../java/testing.rst:648
msgid "Exclusion of certain classes of dead-lock scenarios"
msgstr ""

# a39371515e3d4b2abb2713409b8748c1
#: ../../java/testing.rst:653
msgid "Tracing Actor Invocations"
msgstr ""

# 2a40f38558734e73abec5ce469324969
#: ../../java/testing.rst:655
msgid ""
"The testing facilities described up to this point were aiming at formulating"
" assertions about a system’s behavior. If a test fails, it is usually your "
"job to find the cause, fix it and verify the test again. This process is "
"supported by debuggers as well as logging, where the Akka toolkit offers the"
" following options:"
msgstr ""

# 96632762ba4b48f181e9271486ca8dfa
#: ../../java/testing.rst:661
msgid "*Logging of exceptions thrown within Actor instances*"
msgstr ""

# 7ef6bf5ec3454f1d850e901f6c9f7aeb
#: ../../java/testing.rst:663
msgid ""
"This is always on; in contrast to the other logging mechanisms, this logs at"
" ``ERROR`` level."
msgstr ""

# afb36b3b71d44b01a0cc0d565e8aa218
#: ../../java/testing.rst:666
msgid "*Logging of special messages*"
msgstr ""

# 923669f44a96465fbc87865733d5da51
#: ../../java/testing.rst:668
msgid ""
"Actors handle certain special messages automatically, e.g. :obj:`Kill`, "
":obj:`PoisonPill`, etc. Tracing of these message invocations is enabled by "
"the setting ``akka.actor.debug.autoreceive``, which enables this on all "
"actors."
msgstr ""

# c07b0c5fa2c9415082bf7765e1f1efce
#: ../../java/testing.rst:673
msgid "*Logging of the actor lifecycle*"
msgstr ""

# ad36956fb381457c95861d4bde03a1a3
#: ../../java/testing.rst:675
msgid ""
"Actor creation, start, restart, monitor start, monitor stop and stop may be "
"traced by enabling the setting ``akka.actor.debug.lifecycle``; this, too, is"
" enabled uniformly on all actors."
msgstr ""

# ba6907503d464e55b0317045057e4e63
#: ../../java/testing.rst:679
msgid ""
"All these messages are logged at ``DEBUG`` level. To summarize, you can "
"enable full logging of actor activities using this configuration fragment::"
msgstr ""

# 6415a0b0c761484da684512509b47371
#: ../../java/testing.rst:695
msgid ""
"There are several configuration properties for the TestKit module, please "
"refer to the :ref:`reference configuration <config-akka-testkit>`."
msgstr ""

# 6655e19e369e46d7a4d09eb769988cfb
#: ../../java/typed-actors.rst:2
msgid "Typed Actors"
msgstr ""

# 596ce6e37f4d42fcace482bc946d69f9
#: ../../java/typed-actors.rst:4
msgid ""
"Akka Typed Actors is an implementation of the `Active Objects "
"<http://en.wikipedia.org/wiki/Active_object>`_ pattern. Essentially turning "
"method invocations into asynchronous dispatch instead of synchronous that "
"has been the default way since Smalltalk came out."
msgstr ""

# 8bc309050e4942158d80a2b95129fb76
#: ../../java/typed-actors.rst:7
msgid ""
"Typed Actors consist of 2 \"parts\", a public interface and an "
"implementation, and if you've done any work in \"enterprise\" Java, this "
"will be very familiar to you. As with normal Actors you have an external API"
" (the public interface instance) that will delegate method calls "
"asynchronously to a private instance of the implementation."
msgstr ""

# f7010a6e2f08445c84133757b6671700
#: ../../java/typed-actors.rst:10
msgid ""
"The advantage of Typed Actors vs. Actors is that with TypedActors you have a"
" static contract, and don't need to define your own messages, the downside "
"is that it places some limitations on what you can do and what you can't, "
"i.e. you can't use become/unbecome."
msgstr ""

# 7328ff519fcd4951bdb50a82dfe57a8f
#: ../../java/typed-actors.rst:12
msgid ""
"Typed Actors are implemented using `JDK Proxies "
"<http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Proxy.html>`_ "
"which provide a pretty easy-worked API to intercept method calls."
msgstr ""

# 186ce6bb53084feb9a2551470d506ae5
#: ../../java/typed-actors.rst:16
msgid ""
"Just as with regular Akka Untyped Actors, Typed Actors process one call at a"
" time."
msgstr ""

# 79deb3b69669479491dccaa914015d72
#: ../../java/typed-actors.rst:19
msgid "When to use Typed Actors"
msgstr ""

# 49fe8ac0177a46b3b4c16cc8368c0a72
#: ../../java/typed-actors.rst:21
msgid ""
"Typed actors are nice for bridging between actor systems (the “inside”) and "
"non-actor code (the “outside”), because they allow you to write normal OO-"
"looking code on the outside. Think of them like doors: their practicality "
"lies in interfacing between private sphere and the public, but you don’t "
"want that many doors inside your house, do you? For a longer discussion see "
"`this blog post <http://letitcrash.com/post/19074284309/when-to-use-"
"typedactors>`_."
msgstr ""

# b1c94f0a3a8f400c884530857e937123
#: ../../java/typed-actors.rst:28
msgid ""
"A bit more background: TypedActors can easily be abused as RPC, and that is "
"an abstraction which is `well-known "
"<http://doc.akka.io/docs/misc/smli_tr-94-29.pdf>`_ to be leaky. Hence "
"TypedActors are not what we think of first when we talk about making highly "
"scalable concurrent software easier to write correctly. They have their "
"niche, use them sparingly."
msgstr ""

# 4089109a3f0e44bbbdac1fad32486227
#: ../../java/typed-actors.rst:36
msgid "The tools of the trade"
msgstr ""

# 70c90442831c40c2a4ab2670bc60833c
#: ../../java/typed-actors.rst:38
msgid ""
"Before we create our first Typed Actor we should first go through the tools "
"that we have at our disposal, it's located in ``akka.actor.TypedActor``."
msgstr ""

# 801a416b22dd42ce8943847d575729c5
#: ../../java/typed-actors.rst:46
msgid ""
"Same as not exposing ``this`` of an Akka Actor, it's important not to expose"
" ``this`` of a Typed Actor, instead you should pass the external proxy "
"reference, which is obtained from within your Typed Actor as "
"``TypedActor.self()``, this is your external identity, as the ``ActorRef`` "
"is the external identity of an Akka Actor."
msgstr ""

# fa6f0846ac254c5a905101ed2fb74085
#: ../../java/typed-actors.rst:52
msgid "Creating Typed Actors"
msgstr ""

# b69e4b94c30e414188fe0a666ac90cd1
#: ../../java/typed-actors.rst:54
msgid ""
"To create a Typed Actor you need to have one or more interfaces, and one "
"implementation."
msgstr ""

# 5bbe2d1e49864a90b114724392496230
#: ../../java/typed-actors.rst:56
msgid "The following imports are assumed:"
msgstr ""

# b4357a31d5544651a3a3b4a4a6993dda
#: ../../java/typed-actors.rst:61
msgid "Our example interface:"
msgstr ""

# c116845770d543dd98c315908f8af71b
#: ../../java/typed-actors.rst:67
msgid "Our example implementation of that interface:"
msgstr ""

# 7f03d15d60d346ebb8682a589d3e31c0
#: ../../java/typed-actors.rst:73
msgid ""
"The most trivial way of creating a Typed Actor instance of our ``Squarer``:"
msgstr ""

# 782beb4c75024a0191360624f08dc14d
#: ../../java/typed-actors.rst:79
msgid ""
"First type is the type of the proxy, the second type is the type of the "
"implementation. If you need to call a specific constructor you do it like "
"this:"
msgstr ""

# 1d5614f90eee41fea9b75d1b3c46bd4c
#: ../../java/typed-actors.rst:85
msgid ""
"Since you supply a ``Props``, you can specify which dispatcher to use, what "
"the default timeout should be used and more. Now, our ``Squarer`` doesn't "
"have any methods, so we'd better add those."
msgstr ""

# a024812d6b204bb4aa939ec668b9c2d4
#: ../../java/typed-actors.rst:91
msgid ""
"Alright, now we've got some methods we can call, but we need to implement "
"those in ``SquarerImpl``."
msgstr ""

# d2d384fda6b04cbc9df693c23be9bcc4
#: ../../java/typed-actors.rst:96
msgid ""
"Excellent, now we have an interface and an implementation of that interface,"
" and we know how to create a Typed Actor from that, so let's look at calling"
" these methods."
msgstr ""

# eb7067b8d5664de19919c78a20c8599d
#: ../../java/typed-actors.rst:100
msgid "Method dispatch semantics"
msgstr ""

# 071d5020dfed4a9ab53c8e71689ed103
#: ../../java/typed-actors.rst:102
msgid "Methods returning:"
msgstr ""

# 39c771ec108541ce9a9be6ccc3f19984
#: ../../java/typed-actors.rst:104
msgid ""
"``void`` will be dispatched with ``fire-and-forget`` semantics, exactly like"
" ``ActorRef.tell``"
msgstr ""

# 8fa22d27ce7a45a7b22f268642966d46
#: ../../java/typed-actors.rst:105
msgid ""
"``scala.concurrent.Future<?>`` will use ``send-request-reply`` semantics, "
"exactly like ``ActorRef.ask``"
msgstr ""

# 647153926a9d40b3aac0df2231221f20
#: ../../java/typed-actors.rst:106
msgid ""
"``akka.japi.Option<?>`` will use ``send-request-reply`` semantics, but "
"*will* block to wait for an answer, and return ``akka.japi.Option.None`` if "
"no answer was produced within the timeout, or ``akka.japi.Option.Some<?>`` "
"containing the result otherwise. Any exception that was thrown during this "
"call will be rethrown."
msgstr ""

# 82ece5effd60418cb2d463f2af55acd0
#: ../../java/typed-actors.rst:109
msgid ""
"Any other type of value will use ``send-request-reply`` semantics, but "
"*will* block to wait for an answer, throwing "
"``java.util.concurrent.TimeoutException`` if there was a timeout or rethrow "
"any exception that was thrown during this call. Note that due to the Java "
"exception and reflection mechanisms, such a ``TimeoutException`` will be "
"wrapped in a ``java.lang.reflect.UndeclaredThrowableException`` unless the "
"interface method explicitly declares the ``TimeoutException`` as a thrown "
"checked exception."
msgstr ""

# f3190d8335774ffe80ebe03f56d565f8
#: ../../java/typed-actors.rst:117
msgid ""
"While Akka cannot enforce that the parameters to the methods of your Typed "
"Actors are immutable, we *strongly* recommend that parameters passed are "
"immutable."
msgstr ""

# a8270bf31ee94e6db4c748d6a17ecaa4
#: ../../java/typed-actors.rst:121
msgid "One-way message send"
msgstr ""

# 84ff4c7a572a48808bb5f5313303fc98
#: ../../java/typed-actors.rst:126
msgid ""
"As simple as that! The method will be executed on another thread; "
"asynchronously."
msgstr ""

# 414e0d5c6f6a4940a4345b1ef8e8853c
#: ../../java/typed-actors.rst:129
msgid "Request-reply message send"
msgstr ""

# 142bf08be749471cb55cede350a13118
#: ../../java/typed-actors.rst:134
msgid ""
"This will block for as long as the timeout that was set in the ``Props`` of "
"the Typed Actor, if needed. It will return ``None`` if a timeout occurs."
msgstr ""

# 0acffee680324041b07777e19aa140b0
#: ../../java/typed-actors.rst:140
msgid ""
"This will block for as long as the timeout that was set in the ``Props`` of "
"the Typed Actor, if needed. It will throw a "
"``java.util.concurrent.TimeoutException`` if a timeout occurs. Note that "
"here, such a ``TimeoutException`` will be wrapped in a "
"``java.lang.reflect.UndeclaredThrowableException`` by the Java reflection "
"mechanism, because the interface method does not explicitly declare the "
"``TimeoutException`` as a thrown checked exception. To get the "
"``TimeoutException`` directly, declare ``throws "
"java.util.concurrent.TimeoutException`` at the interface method."
msgstr ""

# 1ca5f1a75b304e92a8895762d1a17646
#: ../../java/typed-actors.rst:149
msgid "Request-reply-with-future message send"
msgstr ""

# 288b05c9b402465c96fd3353b35c4614
#: ../../java/typed-actors.rst:154
msgid ""
"This call is asynchronous, and the Future returned can be used for "
"asynchronous composition."
msgstr ""

# 7146cdb165fa4a67bcf4c445b5ce28d7
#: ../../java/typed-actors.rst:157
msgid "Stopping Typed Actors"
msgstr ""

# 31846c1d04d742ceb075658454ae3e7c
#: ../../java/typed-actors.rst:159
msgid ""
"Since Akka's Typed Actors are backed by Akka Actors they must be stopped "
"when they aren't needed anymore."
msgstr ""

# 929c56f11fd548de881b7c54ebdd4a25
#: ../../java/typed-actors.rst:164
msgid ""
"This asynchronously stops the Typed Actor associated with the specified "
"proxy ASAP."
msgstr ""

# 728a9245dedb45c1b4b6bd11d1215c46
#: ../../java/typed-actors.rst:169
msgid ""
"This asynchronously stops the Typed Actor associated with the specified "
"proxy after it's done with all calls that were made prior to this call."
msgstr ""

# a67f6a918c4e4fde9f3efa494a2136d3
#: ../../java/typed-actors.rst:173
msgid "Typed Actor Hierarchies"
msgstr ""

# 77f0c2a2dffe4a8d97760f82a9c3ddf5
#: ../../java/typed-actors.rst:175
msgid ""
"Since you can obtain a contextual Typed Actor Extension by passing in an "
"``ActorContext`` you can create child Typed Actors by invoking "
"``typedActorOf(..)`` on that."
msgstr ""

# 5f6ee24036194bba8a5d8baba1f82964
#: ../../java/typed-actors.rst:181
msgid ""
"You can also create a child Typed Actor in regular Akka Actors by giving the"
" ``UntypedActorContext`` as an input parameter to TypedActor.get(…)."
msgstr ""

# eedb0c2faf604169af6512c0e1cee380
#: ../../java/typed-actors.rst:185
msgid "Supervisor Strategy"
msgstr ""

# 25b1209a9f7e42d985496228a2c2c750
#: ../../java/typed-actors.rst:187
msgid ""
"By having your Typed Actor implementation class implement "
"``TypedActor.Supervisor`` you can define the strategy to use for supervising"
" child actors, as described in :ref:`supervision` and :ref:`fault-tolerance-"
"java`."
msgstr ""

# fa0008239d88470ea8ab923eb6193a2c
#: ../../java/typed-actors.rst:192
msgid "Receive arbitrary messages"
msgstr ""

# e7e4ca4c33444ada89fbafc23287a7f5
#: ../../java/typed-actors.rst:194
msgid ""
"If your implementation class of your TypedActor extends "
"``akka.actor.TypedActor.Receiver``, all messages that are not ``MethodCall``"
" instances will be passed into the ``onReceive``-method."
msgstr ""

# 60dc29de6bc4481dafba340d1ab06b81
#: ../../java/typed-actors.rst:197
msgid ""
"This allows you to react to DeathWatch ``Terminated``-messages and other "
"types of messages, e.g. when interfacing with untyped actors."
msgstr ""

# b35ea2b237c7475cbe950c5975c495bb
#: ../../java/typed-actors.rst:201
msgid "Lifecycle callbacks"
msgstr ""

# f90966e63f424356831fcf044a4830d2
#: ../../java/typed-actors.rst:203
msgid ""
"By having your Typed Actor implementation class implement any and all of the"
" following:"
msgstr ""

# cebf41699f7d48b8ba72dc7226db1ed3
#: ../../java/typed-actors.rst:205
msgid "``TypedActor.PreStart``"
msgstr ""

# d2f68f35707b4a71842863d0b54295fd
#: ../../java/typed-actors.rst:206
msgid "``TypedActor.PostStop``"
msgstr ""

# 9fede67709e34239b81781f53f4b3982
#: ../../java/typed-actors.rst:207
msgid "``TypedActor.PreRestart``"
msgstr ""

# a3351621e48340f88023eb49ec5e39b7
#: ../../java/typed-actors.rst:208
msgid "``TypedActor.PostRestart``"
msgstr ""

# 6b6c1088fb0146f698398c68cd2acccc
#: ../../java/typed-actors.rst:210
msgid "You can hook into the lifecycle of your Typed Actor."
msgstr ""

# 9d1298cd587443e6b8e09907ca9425ed
#: ../../java/typed-actors.rst:213
msgid "Proxying"
msgstr ""

# 0de818d335c944318a811c919dd22737
#: ../../java/typed-actors.rst:215
msgid ""
"You can use the ``typedActorOf`` that takes a TypedProps and an ActorRef to "
"proxy the given ActorRef as a TypedActor. This is usable if you want to "
"communicate remotely with TypedActors on other machines, just pass the "
"``ActorRef`` to ``typedActorOf``."
msgstr ""

# ad7899fbc16649a982ed4907b27b0575
#: ../../java/typed-actors.rst:219
msgid "Lookup & Remoting"
msgstr ""

# f25038a2b1574d40aa61326b02d921da
#: ../../java/typed-actors.rst:221
msgid ""
"Since ``TypedActors`` are backed by ``Akka Actors``, you can use "
"``typedActorOf`` to proxy ``ActorRefs`` potentially residing on remote "
"nodes."
msgstr ""

# 2354b211b6b0420b8f6673972ef8ba1e
#: ../../java/typed-actors.rst:226
msgid "Typed Router pattern"
msgstr ""

# adab38686a174711b2a1c274b7bea378
#: ../../java/typed-actors.rst:228
msgid ""
"Sometimes you want to spread messages between multiple actors. The easiest "
"way to achieve this in Akka is to use a :ref:`Router <routing-java>`, which "
"can implement a specific routing logic, such as ``smallest-mailbox`` or "
"``consistent-hashing`` etc."
msgstr ""

# 9b3c1b57740b480a8465f908b9d67d29
#: ../../java/typed-actors.rst:231
msgid ""
"Routers are not provided directly for typed actors, but it is really easy to"
" leverage an untyped router and use a typed proxy in front of it. To "
"showcase this let's create typed actors that assign themselves some random "
"``id``, so we know that in fact, the router has sent the message to "
"different actors:"
msgstr ""

# 66d8869f0e544d2c81634047998badaa
#: ../../java/typed-actors.rst:236
msgid ""
"In order to round robin among a few instances of such actors, you can simply"
" create a plain untyped router, and then facade it with a ``TypedActor`` "
"like shown in the example below. This works because typed actors of course "
"communicate using the same mechanisms as normal actors, and methods calls on"
" them get transformed into message sends of ``MethodCall`` messages."
msgstr ""

# a66f29b377094a0aabd69c1890fde42f
#: ../../java/untyped-actors.rst:35
msgid ""
"Actors in Java are implemented by extending the ``UntypedActor`` class and "
"implementing the :meth:`onReceive` method. This method takes the message as "
"a parameter."
msgstr ""

# 076d2a3c5cd3464ca115e48c5f26c540
#: ../../java/untyped-actors.rst:54
msgid ""
"The second line shows how to pass constructor arguments to the "
":class:`Actor` being created. The presence of a matching constructor is "
"verified during construction of the :class:`Props` object, resulting in an "
":class:`IllegalArgumentException` if no or multiple matching constructors "
"are found."
msgstr ""

# fd31cf18a7374462ad2acb07704af4e5
#: ../../java/untyped-actors.rst:60
msgid ""
"The third line demonstrates the use of a :class:`Creator<T extends Actor>`. "
"The creator class must be static, which is verified during :class:`Props` "
"construction. The type parameter’s upper bound is used to determine the "
"produced actor class, falling back to :class:`Actor` if fully erased. An "
"example of a parametric factory could be:"
msgstr ""

# 7344e245a169488583070f4a8b7db051
#: ../../java/untyped-actors.rst:70
msgid ""
"In order for mailbox requirements—like using a deque-based mailbox for "
"actors using the stash—to be picked up, the actor type needs to be known "
"before creating it, which is what the :class:`Creator` type argument allows."
" Therefore make sure to use the specific type for your actors wherever "
"possible."
msgstr ""

# c7efb5e8daec44ab87e5058535c200ba
#: ../../java/untyped-actors.rst:79
msgid ""
"It is a good idea to provide static factory methods on the "
":class:`UntypedActor` which help keeping the creation of suitable "
":class:`Props` as close to the actor definition as possible. This also "
"allows usage of the :class:`Creator`-based methods which statically verify "
"that the used constructor actually exists instead relying only on a runtime "
"check."
msgstr ""

# 723e5320bb4b4be2869ac656eb911776
#: ../../java/untyped-actors.rst:182
msgid "UntypedActor API"
msgstr ""

# b694cc87aa6942498288f9459f1741c8
#: ../../java/untyped-actors.rst:184
msgid ""
"The :class:`UntypedActor` class defines only one abstract method, the above "
"mentioned :meth:`onReceive(Object message)`, which implements the behavior "
"of the actor."
msgstr ""

# 92c296ac23e440f3930fb32e5e3a41f2
#: ../../java/untyped-actors.rst:187
msgid ""
"If the current actor behavior does not match a received message, it's "
"recommended that you call the :meth:`unhandled` method, which by default "
"publishes a ``new akka.actor.UnhandledMessage(message, sender, recipient)`` "
"on the actor system’s event stream (set configuration item "
"``akka.actor.debug.unhandled`` to ``on`` to have them converted into actual "
"Debug messages)."
msgstr ""

# c1b52d0e39df4f6f8083f5867c6bdbb9
#: ../../java/untyped-actors.rst:195
msgid ":meth:`getSelf()` reference to the :class:`ActorRef` of the actor"
msgstr ""

# 4eb6a1fe2f464b3aa7c34961eb2ee2b1
#: ../../java/untyped-actors.rst:197
msgid ""
":meth:`getSender()` reference sender Actor of the last received message, "
"typically used as described in :ref:`UntypedActor.Reply`"
msgstr ""

# d60f7c026a034ff7be7e4ca92b2f8e44
#: ../../java/untyped-actors.rst:201
msgid ""
"This strategy is typically declared inside the actor in order to have access"
" to the actor’s internal state within the decider function: since failure is"
" communicated as a message sent to the supervisor and processed like other "
"messages (albeit outside of the normal behavior), all values and variables "
"within the actor are available, as is the ``getSender()`` reference (which "
"will be the immediate child reporting the failure; if the original failure "
"occurred within a distant descendant it is still reported one level up at a "
"time)."
msgstr ""

# 1d3899e8b7a74785a1b584eace30b912
#: ../../java/untyped-actors.rst:210
msgid ""
":meth:`getContext()` exposes contextual information for the actor and the "
"current message, such as:"
msgstr ""

# 6d2dbafeafd54dee9c5ff64b8e93186b
#: ../../java/untyped-actors.rst:217
msgid "hotswap behavior stack as described in :ref:`UntypedActor.HotSwap`"
msgstr ""

# ab70e5d169bf4489804d455282dec28d
#: ../../java/untyped-actors.rst:224
msgid ""
"The implementations shown above are the defaults provided by the "
":class:`UntypedActor` class."
msgstr ""

# 0c1571037c404a42a86c5c630306ca1b
#: ../../java/untyped-actors.rst:244
msgid ""
"The lifecycle of an incarnation ends when the actor is stopped. At that "
"point the appropriate lifecycle events are called and watching actors are "
"notified of the termination. After the incarnation is stopped, the path can "
"be reused again by creating an actor with ``actorOf()``. In this case the "
"name of the new incarnation will be the same as the previous one but the "
"UIDs will differ. An actor can be stopped by the actor itself, another actor"
" or the ``ActorSystem`` (see :ref:`stopping-actors-java`)."
msgstr ""

# 6bb2613f535d46e5a4bea99654461671
#: ../../java/untyped-actors.rst:264
msgid ""
"``ActorSelection`` on the other hand points to the path (or multiple paths "
"if wildcards are used) and is completely oblivious to which incarnation is "
"currently occupying it. ``ActorSelection`` cannot be watched for this "
"reason. It is possible to resolve the current incarnation's ``ActorRef`` "
"living under the path by sending an ``Identify`` message to the "
"``ActorSelection`` which will be replied to with an ``ActorIdentity`` "
"containing the correct reference (see :ref:`actorSelection-java`). This can "
"also be done with the ``resolveOne`` method of the :class:`ActorSelection`, "
"which returns a ``Future`` of the matching :class:`ActorRef`."
msgstr ""

# 72b2f3632e5e4617943fcebef06d5a5b
#: ../../java/untyped-actors.rst:285
msgid ""
"Registering a monitor is easy (see fourth line, the rest is for "
"demonstrating the whole functionality):"
msgstr ""

# 9509d16bf4ca4915a0e999a24c6f632a
#: ../../java/untyped-actors.rst:304
msgid ""
"It is also possible to deregister from watching another actor’s liveliness "
"using ``getContext().unwatch(target)``. This works even if the "
":class:`Terminated` message has already been enqueued in the mailbox; after "
"calling :meth:`unwatch` no :class:`Terminated` message for that actor will "
"be processed anymore."
msgstr ""

# a4c3b9fe59e248969c361237cc27a7cd
#: ../../java/untyped-actors.rst:333
msgid ""
"The old actor is informed by calling :meth:`preRestart` with the exception "
"which caused the restart and the message which triggered that exception; the"
" latter may be ``None`` if the restart was not caused by processing a "
"message, e.g. when a supervisor does not trap the exception and is restarted"
" in turn by its supervisor, or if an actor is restarted due to a sibling’s "
"failure. If the message is available, then that message’s sender is also "
"accessible in the usual way (i.e. by calling ``getSender()``)."
msgstr ""

# 9f2628c51b0541fdaa2390599ce0aaa6
#: ../../java/untyped-actors.rst:399
msgid "sending messages using the :ref:`at-least-once-delivery-java` facility"
msgstr ""

# 57c6ead59286483e884d23cc715b2e86
#: ../../java/untyped-actors.rst:424
msgid ""
"To acquire an :class:`ActorRef` for an :class:`ActorSelection` you need to "
"send a message to the selection and use the ``getSender`` reference of the "
"reply from the actor. There is a built-in ``Identify`` message that all "
"Actors will understand and automatically reply to with a ``ActorIdentity`` "
"message containing the :class:`ActorRef`. This message is handled specially "
"by the actors which are traversed in the sense that if a concrete name "
"lookup fails (i.e. a non-wildcard path element does not correspond to a live"
" actor) then a negative result is generated. Please note that this does not "
"mean that delivery of that reply is guaranteed, it still is a normal "
"message."
msgstr ""

# b42274f9570044fe9f8b6e54fe36dcb1
#: ../../java/untyped-actors.rst:437
msgid ""
"You can also acquire an :class:`ActorRef` for an :class:`ActorSelection` "
"with the ``resolveOne`` method of the :class:`ActorSelection`. It returns a "
"``Future`` of the matching :class:`ActorRef` if such an actor exists. It is "
"completed with failure [[akka.actor.ActorNotFound]] if no such actor exists "
"or the identification didn't complete within the supplied `timeout`."
msgstr ""

# fdfc39568e8e4d74bb3cbfbe320bca3b
#: ../../java/untyped-actors.rst:447
msgid ""
"An example demonstrating remote actor look-up is given in :ref:`remote-"
"sample-java`."
msgstr ""

# d2847022aeec4a4cbf4fa64ab2c8ea40
#: ../../java/untyped-actors.rst:494
msgid ""
"The sender reference is passed along with the message and available within "
"the receiving actor via its :meth:`getSender()` method while processing this"
" message. Inside of an actor it is usually :meth:`getSelf` who shall be the "
"sender, but there can be cases where replies shall be routed to some other "
"actor—e.g. the parent—in which the second argument to :meth:`tell` would be "
"a different one. Outside of an actor and if no reply is needed the second "
"argument can be ``null``; if a reply is needed outside of an actor you can "
"use the ask-pattern described next.."
msgstr ""

# fe883ff3ee434fd1a9f4b487e1df259b
#: ../../java/untyped-actors.rst:522
msgid ""
"Using ``ask`` will send a message to the receiving Actor as with ``tell``, "
"and the receiving actor must reply with ``getSender().tell(reply, "
"getSelf())`` in order to complete the returned :class:`Future` with a value."
" The ``ask`` operation involves creating an internal actor for handling this"
" reply, which needs to have a timeout after which it is destroyed in order "
"not to leak resources; see more below."
msgstr ""

# 2c07f94af2f14340923bf083c9f4d0c7
#: ../../java/untyped-actors.rst:530
msgid ""
"A Java 8 variant of the ``ask`` pattern that returns a ``CompletionStage`` "
"instead of a Scala ``Future`` is available in the "
"``akka.pattern.PatternsCS`` object."
msgstr ""

# d3458557f5ae4cb689a70c350a3914f7
#: ../../java/untyped-actors.rst:564
msgid ""
"You can forward a message from one actor to another. This means that the "
"original sender address/reference is maintained even though the message is "
"going through a 'mediator'. This can be useful when writing actors that work"
" as routers, load-balancers, replicators etc. You need to pass along your "
"context variable as well."
msgstr ""

# ed0503e9fedd46ef9f86919131131925
#: ../../java/untyped-actors.rst:575
msgid ""
"When an actor receives a message it is passed into the ``onReceive`` method,"
" this is an abstract method on the ``UntypedActor`` base class that needs to"
" be defined."
msgstr ""

# f280972dc4874f0aa0981444302a0f46
#: ../../java/untyped-actors.rst:582
msgid ""
"An alternative to using if-instanceof checks is to use `Apache Commons "
"MethodUtils "
"<http://commons.apache.org/beanutils/api/org/apache/commons/beanutils/MethodUtils.html#invokeMethod(java.lang.Object,%20java.lang.String,%20java.lang.Object)>`_"
" to invoke a named method whose parameter type matches the message type."
msgstr ""

# 33f33bf7afa64c72935bf1021592055e
#: ../../java/untyped-actors.rst:591
msgid ""
"If you want to have a handle for replying to a message, you can use "
"``getSender()``, which gives you an ActorRef. You can reply by sending to "
"that ActorRef with ``getSender().tell(replyMsg, getSelf())``. You can also "
"store the ActorRef for replying later, or passing on to other actors. If "
"there is no sender (a message was sent without an actor or future context) "
"then the sender defaults to a 'dead-letter' actor ref."
msgstr ""

# 107c1cce723540d1bb09a0398e885922
#: ../../java/untyped-actors.rst:604
msgid ""
"The `UntypedActorContext` :meth:`setReceiveTimeout` defines the inactivity "
"timeout after which the sending of a `ReceiveTimeout` message is triggered. "
"When specified, the receive function should be able to handle an "
"`akka.actor.ReceiveTimeout` message. 1 millisecond is the minimum supported "
"timeout."
msgstr ""

# bd123f21d6e54cdb8656b208ead9aeb2
#: ../../java/untyped-actors.rst:627
msgid ""
"Actors are stopped by invoking the :meth:`stop` method of a "
"``ActorRefFactory``, i.e. ``ActorContext`` or ``ActorSystem``. Typically the"
" context is used for stopping the actor itself or child actors and the "
"system for stopping top level actors. The actual termination of the actor is"
" performed asynchronously, i.e. :meth:`stop` may return before the actor is "
"stopped."
msgstr ""

# bf51c3e206b046f6b7920b9983a6c47e
#: ../../java/untyped-actors.rst:640
msgid ""
"Termination of an actor proceeds in two steps: first the actor suspends its "
"mailbox processing and sends a stop command to all its children, then it "
"keeps processing the internal termination notifications from its children "
"until the last one is gone, finally terminating itself (invoking "
":meth:`postStop`, dumping mailbox, publishing :class:`Terminated` on the "
":ref:`DeathWatch <deathwatch-java>`, telling its supervisor). This procedure"
" ensures that actor system sub-trees terminate in an orderly fashion, "
"propagating the stop command to the leaves and collecting their confirmation"
" back to the stopped supervisor. If one of the actors does not respond (i.e."
" processing a message for extended periods of time and therefore not "
"receiving the stop command), this whole process will be stuck."
msgstr ""

# 85407ad91eef491a89b1128139fb223d
#: ../../java/untyped-actors.rst:680
msgid "Use it like this:"
msgstr ""

# 3a10141aa2a04f6194f99c2aae101874
#: ../../java/untyped-actors.rst:704
msgid ""
"In the above example a custom ``Manager.SHUTDOWN`` message is sent to the "
"target actor to initiate the process of stopping the actor. You can use "
"``PoisonPill`` for this, but then you have limited possibilities to perform "
"interactions with other actors before stopping the target actor. Simple "
"cleanup tasks can be handled in ``postStop``."
msgstr ""

# 68686b742eb943d5932df5d190702dc8
#: ../../java/untyped-actors.rst:721
msgid "HotSwap"
msgstr ""

# 9bedf7de9b7944cfa06f3fab325c71c3
#: ../../java/untyped-actors.rst:726
msgid ""
"Akka supports hotswapping the Actor’s message loop (e.g. its implementation)"
" at runtime. Use the ``getContext().become`` method from within the Actor. "
"The hotswapped code is kept in a Stack which can be pushed (replacing or "
"adding at the top) and popped."
msgstr ""

# e21be493cfcd425ab250cb33e2a4a200
#: ../../java/untyped-actors.rst:735
msgid "To hotswap the Actor using ``getContext().become``:"
msgstr ""

# 23c93e5dd8ca49d494bdf1db1052c064
#: ../../java/untyped-actors.rst:743
msgid ""
"This variant of the :meth:`become` method is useful for many different "
"things, such as to implement a Finite State Machine (FSM). It will replace "
"the current behavior (i.e. the top of the behavior stack), which means that "
"you do not use :meth:`unbecome`, instead always the next behavior is "
"explicitly installed."
msgstr ""

# 8a9b24fedf5a42a292a818e2710c13d1
#: ../../java/untyped-actors.rst:761
msgid ""
"The ``UntypedActorWithStash`` class enables an actor to temporarily stash "
"away messages that can not or should not be handled using the actor's "
"current behavior. Upon changing the actor's message handler, i.e., right "
"before invoking ``getContext().become()`` or ``getContext().unbecome()``, "
"all stashed messages can be \"unstashed\", thereby prepending them to the "
"actor's mailbox. This way, the stashed messages can be processed in the same"
" order as they have been received originally. An actor that extends "
"``UntypedActorWithStash`` will automatically get a deque-based mailbox."
msgstr ""

# 92db51b346174c0d8cb2a8b55cca8b65
#: ../../java/untyped-actors.rst:772
msgid ""
"The abstract class ``UntypedActorWithStash`` implements the marker interface"
" ``RequiresMessageQueue<DequeBasedMessageQueueSemantics>`` which requests "
"the system to automatically choose a deque based mailbox implementation for "
"the actor. If you want more control over the mailbox, see the documentation "
"on mailboxes: :ref:`mailboxes-java`."
msgstr ""

# 12a79854190142a6b0d6cbce09c52064
#: ../../java/untyped-actors.rst:778
msgid "Here is an example of the ``UntypedActorWithStash`` class in action:"
msgstr ""

# a7835d70311441eea5b1482bce8996f7
#: ../../java/untyped-actors.rst:805
msgid ""
"Note that the stash is part of the ephemeral actor state, unlike the "
"mailbox. Therefore, it should be managed like other parts of the actor's "
"state which have the same property. The :class:`UntypedActorWithStash` "
"implementation of :meth:`preRestart` will call ``unstashAll()``, which is "
"usually the desired behavior."
msgstr ""

# d20f85726814411a8a9a92578d40c82f
#: ../../java/untyped-actors.rst:813
msgid ""
"If you want to enforce that your actor can only work with an unbounded "
"stash, then you should use the ``UntypedActorWithUnboundedStash`` class "
"instead."
msgstr ""
